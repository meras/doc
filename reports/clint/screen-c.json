["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows to be redrawn later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows that are editing the current buffer to be updated later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Changed something in the current window, at buffer line \"lnum\", that"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* must_redraw is reset here, so that when we run into some weird", "    * reason to redraw while busy redrawing (e.g., asynchronous"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Postpone the redrawing when it's not needed and when being called", "   * recursively. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Only start redrawing if there is really something to do."], "readability/old_style_comment"]
["src/nvim/screen.c", ["               && curwin->w_old_curswant == curwin->w_curswant)", "           )) {", "    curwin->w_redr_type = type;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  /*", "   * Correct stored syntax highlighting info for changes in each displayed"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Go from top to bottom through the windows, redrawing the ones that need"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset b_mod_set flags.  Going through all windows is probably faster", "   * than going through all buffers (there could be many buffers). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Clear or redraw the command line.  Done last, because scrolling may", "   * mess up the command line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Update a single window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  } else {", "    /*", "     * Set mod_top to the first line that needs displaying because of"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        mod_top = buf->b_mod_top;", "        /* Need to redraw lines above the change that may be included", "         * in a pattern match. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * A change in a line can cause lines above it to become folded or"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to", "       * the line below it.  If there is no valid entry, use w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i) {", "        if (wp->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["", "    /* When a change starts above w_topline and the end is below", "     * w_topline, start redrawing at w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* When line numbers are displayed need to redraw all lines below", "     * inserted/deleted lines. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * When only displaying the lines at the top, set top_end.  Used when"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    j = 0;", "    for (i = 0; i < wp->w_lines_valid; ++i) {", "      j += wp->w_lines[i].wl_size;"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * If there are no changes on the screen that require a complete redraw,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                       && wp->w_topfill > wp->w_old_topfill)", "                   )) {", "      /*"], "whitespace/parens"]
["src/nvim/screen.c", ["                   )) {", "      /*", "       * New topline is above old topline: May scroll down."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* count the number of lines we are off, counting a sequence", "         * of folded lines as one */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    } else {", "      /*", "       * New topline is at or below old topline: May scroll up."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (j == -1) {", "        /* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all", "         * lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Try to delete the correct number of lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["         */", "        /* If the topline didn't change, delete old filler lines,", "         * otherwise delete filler lines of the new topline... */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {", "          /*", "           * Skip the lines (below the deleted lines) that are still"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            wp->w_lines[idx] = wp->w_lines[j];", "            /* stop at line that didn't fit, unless it is still", "             * valid (no lines deleted) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Find the line numbers that need to be updated: The lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * If in block mode and changed column or curwin->w_curswant:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * There is no need to update lines above the top of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * If we know the value of w_botline, use it to restrict the update to"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Find the minimal part to be updated."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * Update all the window rows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  for (;;) {", "    /* stop updating when reached the end of the window (check for _past_", "     * the end of the window is at the end of the loop) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Remember the starting row of the line that is going to be dealt", "     * with.  It is used further down when the line doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * When at start of changed lines: May scroll following lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Count the old number of window rows, using w_lines[], which", "         * should still contain the sizes for the lines as they are"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * currently displayed. */", "        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid"], "readability/increment"]
["src/nvim/screen.c", ["        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid", "           * lines are part of the changed area. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {", "            /* Must have found the last valid entry above mod_bot.", "             * Add following invalid entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             * Add following invalid entries. */", "            ++i;", "            while (i < wp->w_lines_valid"], "readability/increment"]
["src/nvim/screen.c", ["        if (i >= wp->w_lines_valid) {", "          /* We can't find a valid line below the changed lines,", "           * need to redraw until the end of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        } else {", "          /* Able to count old number of rows: Count new window", "           * rows, and may insert/delete lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (xtra_rows < 0) {", "            /* May scroll text up.  If there is not enough", "             * remaining text or scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          } else if (xtra_rows > 0) {", "            /* May scroll text down.  If there is not enough", "             * remaining text of scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "          /* When not updating the rest, may need to move w_lines[]", "           * entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                x += wp->w_lines[j++].wl_size;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/screen.c", ["", "              /* The w_lines[] entries for inserted lines are", "               * now invalid, but wl_size may be used above."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[i].wl_size = 0;", "                wp->w_lines[i--].wl_valid = FALSE;", "              }"], "readability/bool"]
["src/nvim/screen.c", ["", "      /*", "       * When lines are folded, display one line for all of them."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  /*", "   * End of loop over all window lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Let the syntax stuff know we stop parsing here."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * If we didn't hit the end of the file, and we didn't finish the last"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum == wp->w_topline) {", "      /*", "       * Single line that does not fit!"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (dollar_vcol == -1) {", "    /*", "     * There is a trick with w_botline.  If we invalidate it on each"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  while (**color_cols >= 0 && vcol > **color_cols) {", "    ++*color_cols;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  // attributes desired by syntax", "  int has_syntax = FALSE;               // this buffer has syntax highl.", "  int save_did_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  // column where nextline[] starts", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  // column where nextline[] starts", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     // line number for \"checked_col\"", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     // line number for \"checked_col\"", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* To be able to spell-check over line boundaries copy the end of the", "     * current line into nextline[].  Above the start of the next line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (v < SPWORDLEN) {", "        /* Short line, use it completely and append the start of the", "         * next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Handle a character that's not completely on the screen: Put ptr at", "     * that character but skip the first few screen characters. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Adjust for when the inverted text is before the screen,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {", "        /* no bad word found at line start, don't check until end of a", "         * word */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Correct highlighting for cursor that can't be disabled."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if ((colnr_T)fromcol == wp->w_virtcol) {", "        /* highlighting starts at cursor, let it start just after the", "         * cursor */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_SIGN;", "        /* Show the sign column when there are any signs in this", "         * buffer or when using Netbeans. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_NR;", "        /* Display the absolute or relative line number. After the", "         * first fill with blanks when the 'n' flag isn't in 'cpo' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      // (area_attr may be 0 when \"noinvcur\" is set).", "      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)", "                                  || vcol < fromcol || vcol_prev < fromcol_prev"], "whitespace/newline"]
["src/nvim/screen.c", ["", "        /* Get syntax attribute, unless still at the start of the line", "         * (double-wide char that doesn't fit). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (has_syntax && v > 0) {", "          /* Get the syntax attribute for the character.  If there", "           * is an error, disable syntax highlighting. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          save_did_emsg = did_emsg;", "          did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          if (did_emsg) {", "            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;", "          } else {"], "readability/bool"]
["src/nvim/screen.c", ["", "        /* Check spelling (unless at the end of the line).", "         * Only do this when there is no syntax highlighting, the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Use nextline[] if possible, it has the start of the", "             * next line concatenated. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* In Insert mode only highlight a word that", "             * doesn't touch the cursor. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                && (p - nextline) + len > nextline_idx) {", "              /* Remember that the good word continues at the", "               * start of the next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                  && (p - nextline) + cap_col >= nextline_idx) {", "                /* Remember that the word in the next line", "                 * must start with a capital. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          char_u *p = ptr - (mb_off + 1);", "          // TODO: is passing p for start of the line OK?", "          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;"], "readability/todo"]
["src/nvim/screen.c", ["", "      /*", "       * Handling of non-printable characters."], "readability/old_style_comment"]
["src/nvim/screen.c", ["            memset(p, ' ', n_extra);", "            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);", "            p[n_extra] = NUL;"], "runtime/printf"]
["src/nvim/screen.c", ["", "    /* In the cursor line and we may be concealing characters: correct", "     * the cursor column when we reach its position. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (n != 0) {", "          /* At the window boundary, highlight the last character", "           * instead (better than nothing). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --col;", "          --off;"], "readability/increment"]
["src/nvim/screen.c", ["          --col;", "          --off;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++col;", "          ++off;"], "readability/increment"]
["src/nvim/screen.c", ["          ++col;", "          ++off;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["        }", "        ++vcol;", "        eol_hl_off = 1;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /*", "       * Update w_cline_height and w_cline_folded if the cursor line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          // now it's time to backup one cell", "          --off;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --off;", "          --col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_rl) {", "        --off;", "        --col;"], "readability/increment"]
["src/nvim/screen.c", ["        --off;", "        --col;", "      } else {"], "readability/increment"]
["src/nvim/screen.c", ["      } else {", "        ++off;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["    } else if (wp->w_p_cole > 0 && is_concealing) {", "      --n_skip;", "      ++vcol_off;"], "readability/increment"]
["src/nvim/screen.c", ["      --n_skip;", "      ++vcol_off;", "      if (n_extra > 0) {"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_wrap) {", "        /*", "         * Special voodoo required if 'wrap' is on."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (wp->w_p_rl) {", "            --boguscols;", "            --col;"], "readability/increment"]
["src/nvim/screen.c", ["            --boguscols;", "            --col;", "          } else {"], "readability/increment"]
["src/nvim/screen.c", ["          } else {", "            ++boguscols;", "            ++col;"], "readability/increment"]
["src/nvim/screen.c", ["            ++boguscols;", "            ++col;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --boguscols;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --boguscols;", "          --col;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++boguscols;", "          ++col;"], "readability/increment"]
["src/nvim/screen.c", ["          ++boguscols;", "          ++col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["    } else {", "      --n_skip;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "    /* Only advance the \"vcol\" when after the 'number' or 'relativenumber'", "     * column. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        && filler_todo <= 0) {", "      ++vcol;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "    /*", "     * At end of screen line and there is more to come: Display the line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* When not wrapping and finished diff lines, or when displayed", "       * '$' and highlighting until last column, break here. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           && filler_todo <= 0", "           ) || lcs_eol_one == -1) {", "        break;"], "whitespace/parens"]
["src/nvim/screen.c", ["      if (row == endrow) {", "        ++row;", "        break;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Mirror text \"str\" for right-left displaying."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2) {", "    t = *p1;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines that need to be redrawn."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines at the bottom of frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the number of characters that should be skipped in a status match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    // check if match fits on the screen", "    for (i = first_match; i < match; ++i) {", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      clen = 2;", "      for (i = match; i < num_matches; ++i) {", "        clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["    } else {", "      for (; *s != NUL; ++s) {", "        s += skip_status_match_char(xp, s);"], "readability/increment"]
["src/nvim/screen.c", ["    *(buf + len++) = '>';", "    ++clen;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["        *p = '<';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * May need to draw the character below the vertical separator."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  busy = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line according to 'statusline' and take care of any"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When called recursively return.  This can happen when the statusline", "   * contains an expression that triggers a redraw. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* There is a tiny chance that this gets called recursively: When", "   * redrawing a status line triggers redrawing the ruler or tabline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Temporarily reset 'cursorbind', we don't want a side effect from moving", "   * the cursor away and back. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  p_crb_save = ewp->w_p_crb;", "  ewp->w_p_crb = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Make a copy, because the statusline may include a function call that", "   * might change the option value and free the memory. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Draw each snippet with the specified highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Prepare for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Clean up for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Note that the window sizes are updated before reallocating the arrays,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * Do not apply autocommands more than 3 times to avoid an endless loop"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Set cursor to its position in the current window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * The rest of the routines in this file perform screen manipulations. The"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          case 0:", "            p = N_(\" VISUAL\"); break;", "          case 1:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 1:", "            p = N_(\" VISUAL LINE\"); break;", "          case 2:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 2:", "            p = N_(\" VISUAL BLOCK\"); break;", "          case 4:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 4:", "            p = N_(\" SELECT\"); break;", "          case 5:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 5:", "            p = N_(\" SELECT LINE\"); break;", "          default:"], "whitespace/newline"]
["src/nvim/screen.c", ["          default:", "            p = N_(\" SELECT BLOCK\"); break;", "          }"], "whitespace/newline"]
["src/nvim/screen.c", ["", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Position for a mode message."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the tab pages line at the top of the Vim window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int use_sep_chars = (t_colors < 8", "                       );", ""], "whitespace/parens"]
["src/nvim/screen.c", ["    FOR_ALL_TABS(tp) {", "      ++tabcount;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Get buffer name for \"buf\" into NameBuff[]."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a status line.  Get its attributes in \"*attr\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if redrawing should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if printing messages should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Check if cursor.lnum is valid, since win_redr_ruler() may be called"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Only draw the ruler when something changed."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Some sprintfs return the length, some return a pointer."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                 (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                          : (int64_t)wp->w_cursor.lnum);", "    size_t len = STRLEN(buffer);"], "whitespace/alignment"]
["src/nvim/screen.c", ["", "    /*", "     * Add a \"50%\" if there is room for it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the width of the 'number' and 'relativenumber' column."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    lnum /= 10;", "    ++n;", "  } while (lnum > 0);"], "readability/increment"]
["src/nvim/screen.c", ["", "  /* curwin->w_buffer can be NULL when we are closing a window and the", "   * buffer has already been closed and removing a scrollbar causes a resize"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * We only redraw when it's needed:"], "readability/old_style_comment"]

["src/nvim/regexp.c", ["", "/*", " * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Magic characters have a special meaning, they don't match literally."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * We should define ftpr as a pointer to a function returning a pointer to"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * REGEXP_INRANGE contains all characters which are always special in a []"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Translate '\\x' to its control character, except \"\\n\", which is Magic."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a character class name \"[:name:]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  static const char *(class_names[]) =", "  {", "    \"alnum:]\","], "whitespace/braces"]
["src/nvim/regexp.c", ["", "/*", " * Specific version of character class functions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static short class_tab[256];", ""], "runtime/int"]
["src/nvim/regexp.c", ["", "/*", " * META contains all characters that may be magic, except '^' and '$'."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a collating element \"[.a.]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip over a \"[]\" range."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip past regular expression."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Start parsing at \"str\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Save the current parse state, so that it can be restored and parsing"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Restore a previously saved parse state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character without advancing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (vim_strchr(REGEXP_ABBR, c)) {", "      /*", "       * Handle abbreviations, like \"\\t\" for TAB -- webb"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Eat one lexed character.  Do this in a way that we can undo it."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip a character while keeping the value of prev_at_start for at_start."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character from the pattern. We know about magic and such, so"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * put character back.  Works only once!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the hex string at the current position."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < maxinputlen; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the decimal string immediately after the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0;; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * get and return the value of the octal string immediately after the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * read_limits - Read two integers to be taken as a minimum and maximum."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Reverse the range if there was a '-', or make sure it is in the right"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * vim_regexec and friends"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Global work variables for vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Create a new extmatch and mark it as referenced once."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Add a reference to an extmatch."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Remove a reference to an extmatch.  If there are no references left, free"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check the regexp program for its magic number."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Cleanup the subexpressions, if this wasn't done yet."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check whether a backreference matches."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    assert(*n >= 0);", "    result = mb_strnicmp(s1, s2, (size_t)*n);", "  }"], "whitespace/operators"]
["src/nvim/regexp.c", ["", "      /* decompose the character if necessary, into 'base' characters", "       * because I don't care about Arabic, I will hard-code the Hebrew"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regtilde(): Replace tildes in the pattern by the old pattern."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (p = newsub; *p; ++p) {", "    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {"], "readability/increment"]
["src/nvim/regexp.c", ["            s++;", "            /* Change NL to CR here too, so that this works:", "             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          case 'r':", "            c = CAR;        ++src;  break;", "          case 'n':"], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 'n':", "            c = NL;         ++src;  break;", "          case 't':"], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 't':", "            c = TAB;        ++src;  break;", "          // Oh no!  \\e already has meaning in subst pat :-("], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 'b':", "            c = Ctrl_H;     ++src;  break;", ""], "whitespace/newline"]
["src/nvim/regexp.c", ["", "              ++s;", "              --len;"], "readability/increment"]
["src/nvim/regexp.c", ["              ++s;", "              --len;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Call reg_getline() with the line numbers from the submatch.  If a"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Used for the submatch() function: get the string from the n'th submatch in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * First round: compute the length and allocate memory."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (round == 2) {", "          STRNCPY(retval + len, reg_getline_submatch(lnum),", "                  rsm.sm_mmatch->endpos[no].col);"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/*", " * Compile a regular expression into internal code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by vim_regcomp()."], "readability/old_style_comment"]

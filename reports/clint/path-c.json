["src/nvim/path.c", ["  while (vim_ispathsep(*retval)) {", "    ++retval;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if 'c' is a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Like vim_ispathsep(c), but exclude the colon for MS-Windows."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * return TRUE if 'c' is a path list separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if the directory of \"fname\" exists, FALSE otherwise."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Unix style wildcard expansion code."], "readability/old_style_comment"]
["src/nvim/path.c", ["  while (*path_end != NUL) {", "    /* May ignore a wildcard that has a backslash before it; it will", "     * be removed by rem_backslash() or file_pat_to_reg_pat() below. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "                   )) {", "      e = p;"], "whitespace/parens"]
["src/nvim/path.c", ["  // Now we have one wildcard component between \"s\" and \"e\".", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard", "   * component. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p) {", "    if (rem_backslash(p)) {"], "readability/increment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);", "      --e;", "      --s;"], "readability/increment"]
["src/nvim/path.c", ["      --e;", "      --s;", "    }"], "readability/increment"]
["src/nvim/path.c", ["  // Check for \"**\" between \"s\" and \"e\".", "  for (p = s; p < e; ++p) {", "    if (p[0] == '*' && p[1] == '*') {"], "readability/increment"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD)) {", "    ++emsg_silent;", "  }"], "readability/increment"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD)) {", "    --emsg_silent;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "  /* If \"**\" is by itself, this is the first time we encounter it and more", "   * is following then find matches without any directory. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (starstar && stardepth < 100) {", "          /* For \"**\" in the pattern first go deeper in the tree to", "           * find matches. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["           * find matches. */", "          STRCPY(buf + len, \"/**\");", "          STRCPY(buf + len + 3, path_end);"], "readability/old_style_comment"]
["src/nvim/path.c", ["          STRCPY(buf + len + 3, path_end);", "          ++stardepth;", "          (void)do_path_expand(gap, buf, len + 1, flags, true);"], "readability/increment"]
["src/nvim/path.c", ["          (void)do_path_expand(gap, buf, len + 1, flags, true);", "          --stardepth;", "        }"], "readability/increment"]
["src/nvim/path.c", ["          if ((flags & EW_ALLLINKS) ? os_fileinfo_link((char *)buf, &file_info)", "                                    : os_path_exists(buf)) {", "            addfile(gap, buf, flags);"], "whitespace/alignment"]
["src/nvim/path.c", ["", "/*", " * Moves \"*psep\" back to the previous path separator in \"path\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (*psep > path && vim_ispathsep(**psep)) {", "    --*psep;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Split the 'path' option into an array of strings in garray_T.  Relative"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1]))) {", "      /* Relative to current buffer:", "       * \"/path/file\" + \".\" -> \"/path/\""], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Returns a pointer to the file or directory name in \"fname\" that matches the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    /* If the {filename} is not unique, change it to ./{filename}.", "     * Else reduce it to {filename} */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" contains what looks like an environment variable."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * expand_env() is called to expand things like \"~user\".  If this fails,"], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (recursive)", "#ifdef SPECIAL_WILDCHAR"], "readability/braces"]
["src/nvim/path.c", ["#ifdef SPECIAL_WILDCHAR", "  /*", "   * If there are any special wildcard characters which we cannot handle"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * The matching file names are stored in a growarray.  Init it empty."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  for (int i = 0; i < num_pat; ++i) {", "    add_pat = -1;"], "readability/increment"]
["src/nvim/path.c", ["#ifdef UNIX", "        /*", "         * On Unix, if expand_env() can't expand an environment"], "readability/old_style_comment"]
["src/nvim/path.c", ["         */", "        else if (has_env_var(p) || *p == '~') {", "          xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "      /*", "       * If there are wildcards: Expand file names and add each match to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                         && vim_ispathsep(p[2]))))) {", "          /* :find completion where 'path' is used.", "           * Recursiveness is OK here. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* When EW_NOTFOUND is used, always add files and dirs.  Makes", "       * \"vim c:/\" work. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if we can expand this backtick thing here."], "readability/old_style_comment"]
["src/nvim/path.c", ["    while (*p != NUL && *p != '\\r' && *p != '\\n') {  // skip over entry", "      ++p;", "    }"], "readability/increment"]
["src/nvim/path.c", ["      *p = i;", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/path.c", ["    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n')) {", "      ++cmd;", "    }"], "readability/increment"]
["src/nvim/path.c", ["#endif", "  /*", "   * Append a slash or backslash after directory names if none is present."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Converts a file name into a canonical form. It simplifies a file name into"], "readability/old_style_comment"]
["src/nvim/path.c", ["  do {", "    /* At this point \"p\" is pointing to the char following a single \"/\"", "     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      } else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name", "         * and there is no trailing path separator, either strip \"/.\" if"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!stripping_disabled) {", "          /* If the preceding component does not exist in the file", "           * system, we strip it.  On Unix, we don't accept a symbolic"], "readability/old_style_comment"]
["src/nvim/path.c", ["          if (!do_strip) {", "            /* If the component exists in the file system, check", "             * that stripping it won't change the meaning of the"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (do_strip) {", "              /* The check for the unstripped file name", "               * above works also for a symbolic link pointing to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                do_strip = false;", "                /* We don't disable stripping of later", "                 * components since the unstripped path name is"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!do_strip) {", "          /* Skip the \"..\" or \"../\" and reset the counter for the", "           * components that might be stripped later on. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        } else {", "          /* Strip previous component.  If the result would get empty", "           * and there is no trailing path separator, leave a single"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (p > start && tail[-1] == '.') {", "              --p;", "            }"], "readability/increment"]
["src/nvim/path.c", ["", "          --components;", "        }"], "readability/increment"]
["src/nvim/path.c", ["", "    /*", "     * If the file could not be found in a normal way, try applying"], "readability/old_style_comment"]
["src/nvim/path.c", ["        file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                      TRUE, rel_fname);", "      }"], "readability/bool"]
["src/nvim/path.c", ["", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      xfree(file_name);", "      file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);", "    }"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"name\" is a full (absolute) path name or URL."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" points to just after a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if file names \"f1\" and \"f2\" are in the same directory."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  (void)vim_FullName((char *)f1, (char *)ffname, MAXPATHL, FALSE);", "  t1 = path_tail_with_sep(ffname);"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Compare path \"p[]\" to \"q[]\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<') {", "    ++emsg_off;", "    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,"], "readability/increment"]
["src/nvim/path.c", ["                         NULL, &ignored_msg, NULL);", "    --emsg_off;", "    if (eval_pat != NULL) {"], "readability/increment"]
["src/nvim/path.c", ["", "  /*", "   * Remove names that match 'wildignore'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"fname\" matches with an entry in 'suffixes'."], "readability/old_style_comment"]

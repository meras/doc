["src/nvim/if_cscope.c", ["", "/*", " * CSCOPE support for Vim added by Andy Kahn <kahn@zk3.dec.com>"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the cscope command"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    const char *query_type[] =", "    {", "      \"a\", \"c\", \"d\", \"e\", \"f\", \"g\", \"i\", \"s\", \"t\", NULL"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["", "/*", " * Handle command line completion for :cscope command."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  int ret = FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * PRIVATE functions"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  if ((fname = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Add);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL) {", "    flags = strtok((char *)NULL, (const char *)\" \");"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL) {", "    flags = strtok((char *)NULL, (const char *)\" \");", "  }"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    if (fname[0] == '\\0') {", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    } else {", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    }", "    if ((stok = strtok(buf, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  char *cmd;", "  short search;", "  char *pat;"], "runtime/int"]
["src/nvim/if_cscope.c", ["    while (ascii_iswhite(*pat)) {", "      ++pat;", "    }"], "readability/increment"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(cmd, \"%d%s\", search, pat);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "  /*", "   * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["  sa.nLength = sizeof(SECURITY_ATTRIBUTES);", "  sa.bInheritHandle = TRUE;", "  sa.lpSecurityDescriptor = NULL;"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].ppath != NULL) {", "      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].flags != NULL) {", "      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    si.hStdInput  = stdin_rd;", "    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "                            NULL, NULL, &si, &pi);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((opt = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Find);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Let's replace the NULs written by strtok() with spaces - we need the"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i) {", "    if (NUL == eap->arg[i]) {"], "readability/increment"]
["src/nvim/if_cscope.c", ["        if (use_ll) {", "          /*", "           * In the location list window, use the displayed location"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["      csinfo_size *= 2;", "      csinfo = xrealloc(csinfo, sizeof(csinfo_T)*csinfo_size);", "    }"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["", "  (void)strcpy(csinfo[i].fname, (const char *)fname);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].ppath = xmalloc(strlen(ppath) + 1);", "    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].flags = xmalloc(strlen(flags) + 1);", "    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Kill);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  cs_release_csp(i, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\\t%s\", tagstr, fname, slno, search);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\", tagstr, fname, slno);", "  }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  /*", "   * cscope output is in the following format:"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["#if defined(UNIX) && defined(SIGALRM)", "/*", " * Used to catch and ignore SIGALRM below."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    sleep(0);", "    for (waited = 0; waited < 40; ++waited) {", "      pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);"], "readability/increment"]
["src/nvim/if_cscope.c", ["# endif", "    /*", "     * If the cscope process is still running: kill it."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      if (waitpid_errno == ECHILD) {", "        /*", "         * When using 'vim -g', vim is forked and cscope process is"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      }", "      if (alive)", "# endif"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].fname != NULL) {", "      cs_release_csp(i, FALSE);", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Ppath is freed when we destroy the cscope connection."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    fullname = xmalloc(len);", "    (void)sprintf(fullname, \"%s/%s\", csinfo[i].ppath, name);", "  } else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL) {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]

["src/nvim/memline.c", ["", "/*", " * memline.c: Contains the functions for appending, deleting and changing the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * pointer to a block, used in a pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A pointer block contains a list of branches in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A data block is a leaf in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The low bits of db_index hold the actual index. The topmost bit is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_HNAME_SIZE           40", "/*", " * Restrict the numbers to 32 bits, otherwise most compilers will complain."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Block zero holds all info about the swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             // check for byte order of int", "  short b0_magic_short;         // check for byte order of short", "  char_u b0_magic_char;         // check for last char"], "runtime/int"]
["src/nvim/memline.c", ["", "/*", " * Note: b0_dirty and b0_flags are put at the end of the file name.  For very"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The b0_flags field is new in Vim 7.0."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The line number where the first mark may be is remembered."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * arguments for ml_find_line()"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * When 'updatecount' is non-zero swap file may be opened later."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * fill block0 struct and write page 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  b0p->b0_magic_int = (int)B0_MAGIC_INT;", "  b0p->b0_magic_short = (short)B0_MAGIC_SHORT;", "  b0p->b0_magic_char = B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "  /*", "   * Always sync block number 0 to disk, so we can check the file name in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Fill in root pointer block and write page 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate first data block and create an empty line 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp->mf_fd < 0) {             // there is no swap file yet", "    /*", "     * When 'updatecount' is 0 and 'noswapfile' there is no swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in the 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          // close all not-modified buffers", "    }"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * For a file under the home directory of the current user, we try to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "                 B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = TRUE;", "  called_from_main = (curbuf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/memline.c", ["    // count the number of matching swap files", "    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 // no swap files found"], "readability/bool"]
["src/nvim/memline.c", ["      // list the names of the swap files", "      (void)recover_names(fname, TRUE, 0, NULL);", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/memline.c", ["      msg_puts(_(\"Enter number of swap file to use (0 to quit): \"));", "      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len) {"], "readability/bool"]
["src/nvim/memline.c", ["    // get the swap file name that will be used", "    (void)recover_names(fname, FALSE, i, &fname_used);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate a buffer structure for the swap file that is used for recovery."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * open the memfile from the old swap file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * The page size set in mf_open() might be different from the page size"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * try to read block 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If we guessed the wrong page size, we have to recalculate the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If .swp file name given directly, use name from swap file for buffer."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Using swap file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * check date of swap file and original file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Now that we are sure that the file is going to be recovered, clear the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try reading the original file to obtain the values of 'fileformat',"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    /*", "     * get block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i) {", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["          if (pp->pb_pointer[idx].pe_bnum < 0) {", "            /*", "             * Data block with negative block number."], "readability/old_style_comment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  // get same block again for next index", "            continue;"], "readability/increment"]
["src/nvim/memline.c", ["", "          /*", "           * going one block deeper in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          /*", "           * check number of lines in block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          for (i = 0; i < dp->db_line_count; ++i) {", "            txt_start = (dp->db_index[i] & DB_INDEX_MASK);"], "readability/increment"]
["src/nvim/memline.c", ["              p = (char_u *)\"???\";", "              ++error;", "            } else {"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * go one block up in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Compare the buffer contents with the original file.  When they differ"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    for (idx = 1; idx <= lnum; ++idx) {", "      // Need to copy one line, fetching the other one may flush it."], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Delete the lines from the original file and the dummy line from the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  recoverymode = FALSE;", "  if (got_int) {"], "readability/bool"]
["src/nvim/memline.c", ["  } else if (error) {", "    ++no_wait_return;", "    msg(\">>>>>>>>>>>>>\");"], "readability/increment"]
["src/nvim/memline.c", ["    emsg(_(\"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;", "    msg(_(\"See \\\":help E312\\\" for more information.\"));"], "readability/increment"]
["src/nvim/memline.c", ["  xfree(fname_used);", "  recoverymode = FALSE;", "  if (mfp != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  if (buf != NULL) {  //may be NULL if swap file not found.", "    xfree(buf->b_ml.ml_stack);"], "whitespace/comments"]
["src/nvim/memline.c", ["  if (serious_error && called_from_main) {", "    ml_close(curbuf, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/memline.c", ["      fname_res = fname_buf;", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["      } else {", "        num_names = recov_file_names(names, fname_res, TRUE);", "      }"], "readability/bool"]
["src/nvim/memline.c", ["        }", "        num_names = recov_file_names(names, tail, FALSE);", "        xfree(tail);"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * When no swap file found, wildcard expansion might have failed (e.g."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * remove swapfile name of the current buffer, it must be ignored"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          } else {", "            for (; i < num_files; ++i) {", "              files[i] = files[i + 1];"], "readability/increment"]
["src/nvim/memline.c", ["      if (num_files) {", "        for (int i = 0; i < num_files; ++i) {", "          // print the swap file name"], "readability/increment"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i) {", "      xfree(names[i]);"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    d = concat_fnames(dir, s, TRUE);", "    xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["      msg_puts(_(\"   dated: \"));", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * print the original file name"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  // Form the normal swap file name pattern by appending \".sw?\".", "  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     // check if we have the same name twice"], "readability/bool"]
["src/nvim/memline.c", ["    if (STRCMP(p, names[num_names]) != 0) {", "      ++num_names;", "    } else {"], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    ++num_names;", "  }"], "readability/increment"]
["src/nvim/memline.c", ["        && buf->b_ffname != NULL) {", "      /*", "       * If the original file does not exist anymore or has been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Some of the data blocks may have been changed from negative to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * NOTE: The pointer returned by the ml_get_*() functions only remains valid"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * See if it is the same line as requested last time."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  // When starting up, we might still need to create the memfile", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL) {", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  return ml_append_int(buf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the previous line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      && lnum < buf->b_ml.ml_line_count) {", "    /*", "     * Now that the line is not going to be inserted in the block that we"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  ++buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["  if ((int)dp->db_free >= space_needed) {       // enough room in data block", "    /*", "     * Insert new line in existing data block, or in data block allocated above."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    dp->db_free -= space_needed;", "    ++(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * move the text of the lines that follow to the front"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (line_count > db_idx + 1) {          // if there are following lines", "      /*", "       * Offset is the start of the previous line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i) {", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * copy the text into the block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Mark the block dirty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {        // not enough space in data block", "    /*", "     * If there is not enough room we have to create a new data block and copy some"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * We are going to allocate a new data block. Depending on the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the right/new block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              line, (size_t)len);", "      ++line_count_right;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    /*", "     * may move lines from the left/old block to the right/new one."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lines_moved) {", "      /*", "       */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /*", "       * update indexes in the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to) {", "        dp_right->db_index[to] = dp->db_index[from] + offset;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the left (old or new) block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              line, (size_t)len);", "      ++line_count_left;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * release the two data blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * flush the old data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update pointer blocks for the new data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/increment"]
["src/nvim/memline.c", ["      }", "      /*", "       * TODO: If the pointer block is full and we are adding at the end"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "        ++pp->pb_count;", "        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;"], "readability/increment"]
["src/nvim/memline.c", ["        if (lineadd) {", "          --(buf->b_ml.ml_stack_top);", "          // fix line count for rest of blocks in the stack"], "readability/increment"]
["src/nvim/memline.c", ["            lineadd;", "          ++(buf->b_ml.ml_stack_top);", "        }"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * We are finished, break the loop here."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Safety check: fallen out of for loop?"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If the file becomes empty the last line is replaced by an empty line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  --buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * special case: If there is only one line in the data block it becomes empty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           // stack is invalid when failing"], "readability/increment"]
["src/nvim/memline.c", ["        }", "        ++(buf->b_ml.ml_stack_top);", ""], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    /*", "     * delete the text by moving the next lines forwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * delete the index by moving the next indexes backwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i) {", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/increment"]
["src/nvim/memline.c", ["    dp->db_txt_start += line_size;", "    --(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * mark the block dirty and make sure it is in the file (for recovery)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with lowest_marked line. This is the last line where"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count;) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum) {", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with line lowest_marked."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count;) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum) {", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "      /*", "       * if new line fits in data block, replace directly"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          // adjust pointers of this and following lines", "          for (i = idx + 1; i < count; ++i) {", "            dp->db_index[i] -= extra;"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * If there is a locked block check if the wanted line is in it."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (action == ML_INSERT) {", "        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);", "      } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["      } else if (action == ML_DELETE) {", "        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);", "      }"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * If lines have been added or deleted in the locked block, need to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (action == ML_FIND) {      // first try stack entries", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {", "      ip = &(buf->b_ml.ml_stack[top]);"], "readability/increment"]
["src/nvim/memline.c", ["  }", "  /*", "   * search downwards in the tree until a data block is found"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update high for insert/delete"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (action == ML_INSERT) {", "      ++high;", "    } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["    } else if (action == ML_DELETE) {", "      --high;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {"], "readability/bool"]
["src/nvim/memline.c", ["    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {", "      t = pp->pb_pointer[idx].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * a negative block number may have been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            pp->pb_pointer[idx].pe_bnum = bnum;", "            dirty = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count--;", "      dirty = TRUE;", "    } else if (action == ML_INSERT) {"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count++;", "      dirty = TRUE;", "    }"], "readability/bool"]
["src/nvim/memline.c", ["error_noblock:", "  /*", "   * If action is ML_DELETE or ML_INSERT we have to correct the tree for"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  for (idx = buf->b_ml.ml_stack_top - 1; idx >= 0; --idx) {", "    ip = &(buf->b_ml.ml_stack[idx]);"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Try to resolve the full name of the file so that the swapfile name will"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["    if (tail == fname) {            // no path before file name", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    } else {"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = NUL;", "      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);", "      *tail = save_char;"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = save_char;", "      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);", "      xfree(t);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  ++no_wait_return;", "  (void)emsg(_(\"E325: ATTENTION\"));"], "readability/increment"]
["src/nvim/memline.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Isolate a directory name from *dirp and put it in dir_name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * we try different names until we find one that does not exist yet"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        struct block0 b0;", "        int differ = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["                                 char_to_long(b0.b0_ino))) {", "                  differ = TRUE;", "                }"], "readability/bool"]
["src/nvim/memline.c", ["                               char_to_long(b0.b0_ino))) {", "                differ = TRUE;", "              }"], "readability/bool"]
["src/nvim/memline.c", ["            case 1:", "              buf->b_p_ro = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              swap_exists_action = SEA_QUIT;", "              got_int = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * Change the \".swp\" extension to find another file that can be used."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   // \".svz\", \".suz\", etc.", "      fname[n - 1] = 'z' + 1;"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     // \".swo\", \".swn\", etc.", "  }"], "readability/increment"]
["src/nvim/memline.c", ["         || b0p->b0_magic_int != (int)B0_MAGIC_INT", "         || b0p->b0_magic_short != (short)B0_MAGIC_SHORT", "         || b0p->b0_magic_char != B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "  /*", "   * First we try to get the inode from the file name, because the inode in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * One of the inode numbers is unknown, try a forced vim_FullName() and"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK) {"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * Can't compare inodes or file names, guess that the files are different,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (updtype == ML_CHNK_UPDLINE && buf->b_ml.ml_line_count == 1) {", "    /*", "     * First line in empty buffer from ml_flush_line() -- reset"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Find chunk that our line belongs to, curline will be at start of the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {", "        /*", "         * Line is just prior to last, move count for last"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  /*", "   * Find the last chunk before the one containing our line. Last chunk is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]

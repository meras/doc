["src/nvim/mbyte.c", ["", "/*", " * Canonical encoding names and their properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name;   int prop;              int codepage; }", "enc_canon_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Aliases for encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name; int canon; }", "enc_alias_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Find encoding \"name\" in the list of canonical encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Find canonical encoding \"name\" in the list and return its properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the size of the BOM for the current buffer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Remove all BOM from \"s\" by moving remaining text."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of pointer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is in \"table\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte sequence to a wide character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Check if the character pointed to by \"p2\" is a composing character when it"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return length of UTF-8 character, obtained from the first byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  }", "  for (i = 1; i < m; ++i) {", "    if ((p[i] & 0xc0) != 0x80) {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /*", "   * Check for composing characters.  We can handle only the first six, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    /*", "     * Next character length should not go beyond size to ensure that"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is a composing UTF-8 character.  This means it will be"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true for characters that can be displayed in a normal way."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  static struct interval nonprint[] =", "  {", "    { 0x070f, 0x070f }, { 0x180b, 0x180e }, { 0x200b, 0x200f }, { 0x202a, 0x202e },"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of a Unicode character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Generic conversion function for case operations."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Version of strnicmp() that handles multi-byte characters."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  clen = 0;", "  for (i = 0; i < len; ++i) {", "    if (clen == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "            (line[i] == NL) ? NUL : line[i]);          // NUL is stored as NL"], "runtime/printf"]
["src/nvim/mbyte.c", ["            (line[i] == NL) ? NUL : line[i]);          // NUL is stored as NL", "    --clen;", "    rlen += (int)STRLEN(IObuff + rlen);"], "readability/increment"]
["src/nvim/mbyte.c", ["  const char_u *q;", "  for (q = p;; --q) {", "    // Move s to the last byte of this char."], "readability/increment"]
["src/nvim/mbyte.c", ["    const char_u *s;", "    for (s = q; (s[1] & 0xc0) == 0x80; ++s) {}", ""], "readability/increment"]
["src/nvim/mbyte.c", ["    while (q > base && (*q & 0xc0) == 0x80) {", "      --q;", "    }"], "readability/increment"]
["src/nvim/mbyte.c", ["      const char_u *j = q;", "      --j;", "      // Move j to the first byte of this char."], "readability/increment"]
["src/nvim/mbyte.c", ["      while (j > base && (*j & 0xc0) == 0x80) {", "        --j;", "      }"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Find the next illegal byte sequence."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    }", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * If the cursor moves on an trail byte, set the cursor on the lead byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Skip the Vim specific head of a 'encoding' name."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Find the canonical name for encoding \"enc\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  p = r;", "  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_') {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i) {", "    if (STRCMP(name, enc_alias_table[i].name) == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the canonicalized encoding of the current locale."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#ifdef HAVE_NL_LANGINFO_CODESET", "  if (!(s = nl_langinfo(CODESET)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(HAVE_LOCALE_H)", "    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Call iconv_open() with a check if iconv() works properly (there are broken"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (fd != (iconv_t)-1 && iconv_working == kUnknown) {", "    /*", "     * Do a dummy iconv() call to check if it actually works.  There is a"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert the string \"str[slen]\" with iconv()."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Setup \"vcp\" for conversion from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert text \"ptr[*lenp]\" according to \"vcp\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["      case 0xa4:", "        c = 0x20ac; break;                 // euro", "      case 0xa6:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xa6:", "        c = 0x0160; break;                 // S hat", "      case 0xa8:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xa8:", "        c = 0x0161; break;                 // S -hat", "      case 0xb4:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xb4:", "        c = 0x017d; break;                 // Z hat", "      case 0xb8:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xb8:", "        c = 0x017e; break;                 // Z -hat", "      case 0xbc:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbc:", "        c = 0x0152; break;                 // OE", "      case 0xbd:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbd:", "        c = 0x0153; break;                 // oe", "      case 0xbe:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbe:", "        c = 0x0178; break;                 // Y", "      }"], "whitespace/newline"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      l = utf_ptr2len_len(ptr + i, len - i);"], "readability/increment"]
["src/nvim/mbyte.c", ["          case 0x20ac:", "            c = 0xa4; break;                     // euro", "          case 0x0160:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0160:", "            c = 0xa6; break;                     // S hat", "          case 0x0161:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0161:", "            c = 0xa8; break;                     // S -hat", "          case 0x017d:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x017d:", "            c = 0xb4; break;                     // Z hat", "          case 0x017e:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x017e:", "            c = 0xb8; break;                     // Z -hat", "          case 0x0152:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0152:", "            c = 0xbc; break;                     // OE", "          case 0x0153:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0153:", "            c = 0xbd; break;                     // oe", "          case 0x0178:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0178:", "            c = 0xbe; break;                     // Y", "          case 0xa4:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0xbe:", "            c = 0x100; break;                   // not in latin9", "          }"], "whitespace/newline"]

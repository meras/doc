["src/nvim/ex_getln.c", ["", "/*", " * ex_getln.c: Functions for entering and editing an Ex command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Variables shared between getcmdline(), redrawcmdline() and others."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Type used by call_user_expand_func"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      case K_RIGHT:", "        s->c = K_LEFT; break;", "      case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_S_RIGHT:", "        s->c = K_S_LEFT; break;", "      case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_C_RIGHT:", "        s->c = K_C_LEFT; break;", "      case K_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_LEFT:", "        s->c = K_RIGHT; break;", "      case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_S_LEFT:", "        s->c = K_S_RIGHT; break;", "      case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_C_LEFT:", "        s->c = K_C_RIGHT; break;", "      }"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["    if (s->wim_index < 3) {", "      ++s->wim_index;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (s->c == K_DEL && ccline.cmdpos != ccline.cmdlen) {", "      ++ccline.cmdpos;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["                }", "                ++len;", "              }"], "readability/increment"]
["src/nvim/ex_getln.c", ["            }", "            ++len;", "          }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE when the text must not be changed and we can't switch to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (cmdwin_type != 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Give an error message for a command that isn't allowed while the cmdline"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Allocate a new command line buffer."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /*", "   * give some extra space to avoid having to allocate all the time"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Re-allocate the command line to length len + something extra."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    const varnumber_T start = (", "                               tv_get_number_chk(TV_LIST_ITEM_TV(tv_list_first(l)), &error));", "    if (error) {"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["", "/*", " * Draw part of the cmdline at the current cursor position.  But draw stars"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a character on the command line.  Shifts the following text to the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put the given string, of the given length, onto the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        msg_col += Columns;", "        --msg_row;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (redraw && !cmd_silent) {", "    msg_no_more = TRUE;", "    i = cmdline_row;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    }", "    msg_no_more = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a string on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (literally) {", "    put_on_cmdline(s, -1, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Redraw what is currently on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  // Don't use more prompt, truncate the cmdline if it doesn't fit.", "  msg_no_more = TRUE;", "  draw_cmdline(0, ccline.cmdlen);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  msg_clr_eos();", "  msg_no_more = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * An emsg() before may have set msg_scroll. This is used in normal mode,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           // next message overwrites cmdline", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Check the word in front of the cursor for an abbreviation."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    const int use_options = (", "                             options", "                             | WILD_HOME_REPLACE"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             options", "                             | WILD_HOME_REPLACE", "                             | WILD_ADD_SLASH"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_HOME_REPLACE", "                             | WILD_ADD_SLASH", "                             | WILD_SILENT"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_ADD_SLASH", "                             | WILD_SILENT", "                             | (escape ? WILD_ESCAPE : 0)"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_SILENT", "                             | (escape ? WILD_ESCAPE : 0)", "                             | (p_wic ? WILD_ICASE : 0));"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | (escape ? WILD_ESCAPE : 0)", "                             | (p_wic ? WILD_ICASE : 0));", "    p2 = ExpandOne(xp, p1, vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["", "  /* When expanding a \":map\" command and no matches are found, assume that", "   * the key is supposed to be inserted literally */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static char_u *orig_save = NULL;      // kept value of orig", "  int orig_saved = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * first handle the case of using an old match"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        }", "        --findex;", "      } else {  // mode == WILD_NEXT"], "readability/increment"]
["src/nvim/ex_getln.c", ["      } else {  // mode == WILD_NEXT", "        ++findex;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * When wrapping around, return the original string, set findex to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    orig_save = orig;", "    orig_saved = TRUE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Do the expansion."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["#ifdef FNAME_ILLEGAL", "      /* Illegal file name has been silently skipped.  But when there", "       * are wildcards, the real problem is that there was no match,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * Check for matching suffixes in file names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["            && xp->xp_numfiles > 1) {", "          /*", "           * More than one match; check suffix."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (non_suf_match != 1) {", "          /* Can we ever get here unless it's while expanding", "           * interactively?  If not, we can get rid of this all"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/increment"]
["src/nvim/ex_getln.c", ["    *ss = NUL;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      STRCAT(ss, xp->xp_files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Prepare an expand structure for use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Cleanup an expand structure after use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * May change home directory back to \"~\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_DIRECTORIES) {", "      /*", "       * Insert a backslash into a file name before a space, \\, %, #"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        // for \":set path=\" we need to escape spaces twice"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "        /* If 'str' starts with \"\\~\", replace \"~\" at start of", "         * files[i] with \"\\~\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /* If the first file starts with a '+' escape it.  Otherwise it", "       * could be seen as \"+cmd\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_context == EXPAND_TAGS) {", "      /*", "       * Insert a backslash before characters in a tag name that"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        p = vim_strsave_escaped(files[i], (char_u *)\"\\\\|\\\"\");"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a backslash before the file name in \"pp\", which is in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * For each file name in files[num_files]:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1])) {", "    for (i = 0; i < num_files; ++i) {", "      p = home_replace_save(NULL, files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Show all matches for completion on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    maxlen = 0;", "    for (i = 0; i < num_files; ++i) {", "      if (!showtail && (xp->xp_context == EXPAND_FILES"], "readability/increment"]
["src/nvim/ex_getln.c", ["                        || xp->xp_context == EXPAND_BUFFERS)) {", "        home_replace(NULL, files_found[i], NameBuff, MAXPATHL, TRUE);", "        j = vim_strsize(NameBuff);"], "readability/bool"]
["src/nvim/ex_getln.c", ["    // list the files line by line", "    for (i = 0; i < lines; ++i) {", "      lastlen = 999;"], "readability/increment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                         TRUE);", "            p = NameBuff;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        } else {", "          j = FALSE;", "          p = L_SHOWFILE(k);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (got_int) {", "        got_int = FALSE;", "        break;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * we redraw the command below the lines that we have just listed"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Private path_tail for showmatches() (and win_redr_status_matches()):"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u *t = s;", "  int had_sep = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      t = p;", "      had_sep = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE if we only need to show the tail of completion matches."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      && xp->xp_context != EXPAND_DIRECTORIES) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["      && context != EXPAND_DIRECTORIES) {", "    /*", "     * Matching will be done internally (on something other than files)."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~') {", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~') {", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        }", "        /* Custom expansion takes care of special things, match", "         * backslashes literally (perhaps also for other types?) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        for (i = 0; i < len; i++, j++) {", "          /* Skip backslash.  But why?  At least keep it for custom", "           * expansion. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Don't add a star to *, ~, ~user, $var or `cmd`."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (len > 0 && retval[len - 1] == '$') {", "      --len;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Must parse the command line so far to work out what context we are in."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Avoid a UMR warning from Purify, only save the character if it has been"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Store the string here so that call_user_expand_func() can get to them", "   * easily. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      || xp->xp_context == EXPAND_FILES_IN_PATH) {", "    /*", "     * Expand file or directory names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    int free_pat = FALSE;", "    int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (xp->xp_backslash != XP_BS_NONE) {", "      free_pat = TRUE;", "      pat = vim_strsave(pat);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i) {", "        if (pat[i] == '\\\\') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_HELP) {", "    /* With an empty argument we would get all the help tags, which is", "     * very slow.  Get matches for \"help\" instead. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Find a context in the table and call the ExpandGeneric() with the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i) {", "      if (xp->xp_context == tab[i].context) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (tab[i].ic) {", "          regmatch.rm_ic = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (vim_regexec(regmatch, str, (colnr_T)0)) {", "      ++count;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["      // <SNR> functions should be sorted to the end.", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "            sort_func_compare);"], "whitespace/operators"]
["src/nvim/ex_getln.c", ["", "  /* Reset the variables used for special highlight names expansion, so that", "   * they don't show up when getting normal highlight names by ID. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i) {", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Go over all directories in $PATH.  Expand matches in that directory and"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (*e != NUL) {", "      ++e;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a list returned by a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Sort and remove duplicates which can happen when specifying multiple", "   * directories in dirnames. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*********************************", "*  Command line history stuff    *"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Table of history names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible first"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (hisidx[type] < 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (history[type][i].hisstr == NULL) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* For search history, check that the separator character matches as", "     * well. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (!move_to_front) {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Searches inside the same mapping overwrite each other, so that only"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      hist_free_entry(hisptr);", "      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get identifier of newest history entry."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line position, counted in bytes."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Set the command line byte position to \"pos\".  Zero is the first position."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command-line type."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Calculate history index from a number:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *hist;", "  int wrapped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["        i += hislen;", "        wrapped = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Get a history entry by its index."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove all entries matching {str} from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       // always match case", "  if (hislen != 0"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove an indexed entry from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (i < 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* When deleting the last added search string in a mapping, reset", "   * last_maptick, so that the last added search string isn't deleted again."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  hisidx[histype] = i;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * :history command - print a history"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  for (; !got_int && histype1 <= histype2; ++histype1) {", "    STRCPY(IObuff, \"\\n      #  \");"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (idx >= 0 && j <= k) {", "      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Call the main loop until <CR> or CTRL-C is typed."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *const hlast = (", "                              &(history[history_type][hisidx[history_type]]));", "  const histentry_T *const hend = &(history[history_type][hislen - 1]);"], "whitespace/indent"]

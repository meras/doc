["src/nvim/spell.c", ["typedef struct {", "  short sft_score;              // lowest score used", "  char_u sft_word[1];           // soundfolded word, actually longer"], "runtime/int"]
["src/nvim/spell.c", ["  // language.", "  for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi) {", "    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      endidx[endidxcnt++] = arridx++;", "      --len;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++wlen;", "        --flen;"], "readability/increment"]
["src/nvim/spell.c", ["        ++wlen;", "        --flen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (endidxcnt > 0) {", "    --endidxcnt;", "    arridx = endidx[endidxcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    for (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;", "         --len, ++arridx) {", "      uint32_t flags = idxs[arridx];"], "readability/increment"]
["src/nvim/spell.c", ["      // mip->mi_prefarridx that find_prefix() filled.", "      else if (mode == FIND_PREFIX && !prefix_found) {", "        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,"], "whitespace/newline"]
["src/nvim/spell.c", ["        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags", "                : slang->sl_compallflags,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                ? slang->sl_compstartflags", "                : slang->sl_compallflags,", "                         ((unsigned)flags >> 24))) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // Check NEEDCOMPOUND: can't use word without compounding.", "      else if (flags & WF_NEEDCOMP) {", "        continue;"], "whitespace/newline"]
["src/nvim/spell.c", ["#endif", "        ++mip->mi_complen;", "        if (flags & WF_COMPROOT) {"], "readability/increment"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT) {", "          ++mip->mi_compextra;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["        // to find the \".add\" file(s).", "        for (int lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi) {", "          if (slang->sl_nobreak) {"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        --mip->mi_complen;", "        if (flags & WF_COMPROOT) {"], "readability/increment"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT) {", "          --mip->mi_compextra;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag)) {", "    return false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // loop over all the COMPOUNDRULE entries", "  for (p = slang->sl_comprules; *p != NUL; ++p) {", "    // loop over the flags in the compound word we have made, match"], "readability/increment"]
["src/nvim/spell.c", ["    // them against the current rule entry", "    for (i = 0;; ++i) {", "      c = compflags[i];"], "readability/increment"]
["src/nvim/spell.c", ["        // compare against all the flags in []", "        ++p;", "        while (*p != ']' && *p != NUL) {"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  prefid = (unsigned)flags >> 24;", "  for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt) {", "    pidx = slang->sl_pidxs[arridx + prefcnt];"], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                               FALSE, &can_spell, FALSE);", "              if (!can_spell) {"], "readability/bool"]
["src/nvim/spell.c", ["      if (lnum < wp->w_buffer->b_ml.ml_line_count) {", "        ++lnum;", "      } else if (!p_ws) {"], "readability/increment"]
["src/nvim/spell.c", ["      // Capcol skips over the inserted space.", "      --capcol;", ""], "readability/increment"]
["src/nvim/spell.c", ["  // autocommand may load it then.", "  for (round = 1; round <= 2; ++round) {", "    // Find the first spell file for \"lang\" in 'runtimepath' and load it."], "readability/increment"]
["src/nvim/spell.c", ["", "  for (int i = 0; i < lp->sl_prefixcnt; ++i) {", "    vim_regfree(lp->sl_prefprog[i]);"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p) {", "    if (*p == n) {"], "readability/increment"]
["src/nvim/spell.c", ["    len = 0;", "    for (int i = 0; i < slang->sl_syl_items.ga_len; ++i) {", "      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;"], "readability/increment"]
["src/nvim/spell.c", ["    if (len != 0) {     // found a match, count syllable", "      ++cnt;", "      skip = false;"], "readability/increment"]
["src/nvim/spell.c", ["      } else if (!skip) {", "        ++cnt;                      // Yes, count it", "        skip = true;                // don't count following syllable chars"], "readability/increment"]
["src/nvim/spell.c", ["  spf = curwin->w_s->b_p_spf;", "  for (round = 0; round == 0 || *spf != NUL; ++round) {", "    if (round == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["      // If it was already found above then skip it.", "      for (c = 0; c < ga.ga_len; ++c) {", "        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;"], "readability/increment"]
["src/nvim/spell.c", ["  // with the same name.  E.g. for \"en-math\" use \"en\".", "  for (int i = 0; i < ga.ga_len; ++i) {", "    lp = LANGP_ENTRY(ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["      // find first similar language that does sound folding", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["      // find first similar language that has REP items", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["      if (SPELL_ISUPPER(c)) {", "        ++u;", "        if (p == word) {"], "readability/increment"]
["src/nvim/spell.c", ["      } else {", "        ++l;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  if (buf != NULL) {", "    ml_close(buf, TRUE);", "    xfree(buf);"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (i = 0; i < 256; ++i) {", "    sp->st_fold[i] = i;"], "readability/increment"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'A'; i <= 'Z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'a'; i <= 'z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["    end_visual_mode();", "  } else", "  // Find the start of the badly spelled word."], "readability/braces"]
["src/nvim/spell.c", ["", "    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {"], "readability/bool"]
["src/nvim/spell.c", ["    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "      stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["", "    cmdmsg_rl = FALSE;", "    msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["    regmatch.regprog = curwin->w_s->b_cap_prog;", "    regmatch.rm_ic = FALSE;", "    p = line + endcol;"], "readability/bool"]
["src/nvim/spell.c", ["  frompat = xmalloc(STRLEN(repl_from) + 7);", "  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);", "  p_ws = false;"], "runtime/printf"]
["src/nvim/spell.c", ["      if (curwin->w_cursor.lnum != prev_lnum) {", "        ++sub_nlines;", "        prev_lnum = curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++sub_nsubs;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  ga_grow(gap, sug.su_ga.ga_len);", "  for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "    stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // languages (e.g., \"pl,en\").", "  for (int i = 0; i < curbuf->b_s.b_langp.ga_len; ++i) {", "    lp = LANGP_ENTRY(curbuf->b_s.b_langp, i);"], "readability/increment"]
["src/nvim/spell.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"prefix\");", "#endif"], "runtime/printf"]
["src/nvim/spell.c", ["          go_deeper(stack, depth, 0);", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["      // End of word in tree.", "      ++sp->ts_curi;                    // eat one NUL byte", ""], "readability/increment"]
["src/nvim/spell.c", ["", "      // TODO: how about splitting in the soundfold tree?", "      if (fword_ends"], "readability/todo"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j) {", "            smsg(\"%s\", changename[j]);"], "readability/increment"]
["src/nvim/spell.c", ["        // different.  It's done like a split.", "        // TODO: word split for soundfold words", "        try_split = (sp->ts_fidx - repextra < su->su_badlen)"], "readability/todo"]
["src/nvim/spell.c", ["          sp->ts_flags |= TSF_DIDSPLIT;", "          --sp->ts_curi;                    // do the same NUL again", "          compflags[sp->ts_complen] = NUL;"], "readability/increment"]
["src/nvim/spell.c", ["            if (!try_compound && !fword_ends) {", "              sprintf(changename[depth], \"%.*s-%s: split\",", "                      sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["            } else {", "              sprintf(changename[depth], \"%.*s-%s: compound\",", "                      sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["", "            ++depth;", "            sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["            if (try_compound) {", "              ++sp->ts_complen;", "            } else {"], "readability/increment"]
["src/nvim/spell.c", ["          if (newscore > 0) {", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                    sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          } else {", "            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                    sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          sp = &stack[depth];", "          ++sp->ts_fidx;", "          tword[sp->ts_twordlen++] = c;"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++sp->ts_curi;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", "        sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3L;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3R;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          // Change the \"from\" to the \"to\" string.", "          ++depth;", "          fl = (int)STRLEN(ftp->ft_from);"], "readability/increment"]
["src/nvim/spell.c", ["      // Did all possible states at this level, go up one level.", "      --depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // kword is getting too long, continue one level up", "      --depth;", "    } else if (++round[depth] > 2) {"], "readability/increment"]
["src/nvim/spell.c", ["      // level up", "      --depth;", "    } else {"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (tryidx = arridx[depth]; l > 0; --l) {", "        // Perform a binary search in the list of accepted bytes."], "readability/increment"]
["src/nvim/spell.c", ["        if (round[depth] == 1) {", "          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "                  flen);"], "runtime/printf"]
["src/nvim/spell.c", ["        } else {", "          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "                  ulen);"], "runtime/printf"]
["src/nvim/spell.c", ["", "        ++depth;", "        arridx[depth] = tryidx;"], "readability/increment"]
["src/nvim/spell.c", ["  // Use the sound-folding of the first language that supports it.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["          sstp->st_orglen = stp->st_orglen;", "          ++su->su_sga.ga_len;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_ga.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (int i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_sga.", "  for (int i = 0; i < su->su_sga.ga_len; ++i) {", "    stp = &SUG(su->su_sga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  stp = &SUG(ga, 0);", "  for (int i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i) {", "    // round 1: get a suggestion from su_ga"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: get a suggestion from su_sga", "    for (round = 1; round <= 2; ++round) {", "      gap = round == 1 ? &su->su_ga : &su->su_sga;"], "readability/increment"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j) {", "          if (STRCMP(stp[j].st_word, p) == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["  if (ga.ga_len > su->su_maxcount) {", "    for (int i = su->su_maxcount; i < ga.ga_len; ++i) {", "      xfree(stp[i].st_word);"], "readability/increment"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      // try all kinds of inserts/deletes/swaps/etc.", "      // TODO: also soundfold the next words, so that we can try joining", "      // and splitting"], "readability/todo"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spell.c", ["          xfree(HI2SFT(hi));", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["    wordcount = 0;", "    for (wlen = 0; wlen < MAXWLEN - 3; ++wlen) {", "      i = 1;"], "readability/increment"]
["src/nvim/spell.c", ["      if (byts[n + 1] == NUL) {", "        ++wordcount;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i) {", "        if (i > byts[n]) {              // safety check"], "readability/increment"]
["src/nvim/spell.c", ["      // One of the siblings must have the word.", "      for (; i < byts[n]; ++i) {", "        wc = idxs[idxs[n + i]];         // nr of words under this byte"], "readability/increment"]
["src/nvim/spell.c", ["    // Go over the possible flags and regions.", "    for (; i <= byts[n] && byts[n + i] == NUL; ++i) {", "      char_u cword[MAXWLEN];"], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == NUL) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++wordnr;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      wordnr += idxs[idxs[arridx]];", "      ++arridx;", "      if (--len == 0) {         // end of the bytes, didn't find it"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[arridx];", "    ++wlen;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (ptr[wlen] == ' ' || ptr[wlen] == TAB) {", "        ++wlen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  stp = &SUG(*gap, 0);", "  for (int i = gap->ga_len - 1; i >= 0; --i) {", "    // Need to append what follows to check for \"the the\"."], "readability/increment"]
["src/nvim/spell.c", ["      xfree(stp[i].st_word);", "      --gap->ga_len;", "      if (i < gap->ga_len) {"], "readability/increment"]
["src/nvim/spell.c", ["  if (su->su_sallang != NULL) {", "    for (int i = 0; i < su->su_ga.ga_len; ++i) {", "      rescore_one(su, &SUG(su->su_ga, i));"], "readability/increment"]
["src/nvim/spell.c", ["      for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)", "           && ws[0] != NUL; ++n) {", "        // Quickly skip entries that don't match the word.  Most"], "readability/increment"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j) {", "              if (word[i + j] != ws[j]) {"], "readability/increment"]
["src/nvim/spell.c", ["          while (*pf != NUL && *pf != word[i + k]) {", "            ++pf;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["          }", "          ++k;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["            for (; ((ws = smp[n0].sm_lead_w)[0] & 0xff)", "                 == (c0 & 0xff); ++n0) {", "              // Quickly skip entries that don't match the word."], "readability/increment"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j) {", "                    if (*pf++ != ws[j]) {"], "readability/increment"]
["src/nvim/spell.c", ["                while (*pf != NUL && *pf != word[i + k0]) {", "                  ++pf;", "                }"], "readability/increment"]
["src/nvim/spell.c", ["                }", "                ++k0;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["      if (*badsound == '*') {", "        ++badsound;", "      } else {"], "readability/increment"]
["src/nvim/spell.c", ["      } else {", "        ++goodsound;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (*pl == *ps && *pl != NUL) {", "    ++pl;", "    ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["    ++pl;", "    ++ps;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["    // Must delete two characters from \"pl\".", "    ++pl;               // first delete", "    while (*pl == *ps) {"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl == *ps) {", "      ++pl;", "      ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl;", "      ++ps;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j) {", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (i = 1; i <= badlen; ++i) {", "    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++bi;", "      ++gi;"], "readability/increment"]
["src/nvim/spell.c", ["      ++bi;", "      ++gi;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      // round 1: try inserting a char in badword", "      for (round = 0; round <= 1; ++round) {", "        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              ++bi2;", "              ++gi2;"], "readability/increment"]
["src/nvim/spell.c", ["              ++bi2;", "              ++gi2;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["            stack[stackidx].score = score_off;", "            ++stackidx;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["        // Do the substitution.", "        ++gi;", "        ++bi;"], "readability/increment"]
["src/nvim/spell.c", ["        ++gi;", "        ++bi;", "        continue;"], "readability/increment"]
["src/nvim/spell.c", ["    // pop an item from the stack", "    --stackidx;", "    gi = stack[stackidx].goodi;"], "readability/increment"]
["src/nvim/spell.c", ["  // regions or none at all.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["  // Loop over all files loaded for the entries in 'spelllang'.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: keep-case tree", "    for (round = 1; round <= 2; ++round) {", "      if (round == 1) {"], "readability/increment"]
["src/nvim/spell.c", ["          // Done all bytes at this node, go up one level.", "          --depth;", "          line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["          n = arridx[depth] + curi[depth];", "          ++curi[depth];", "          c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["                if (pat == NULL) {", "                  ++lnum;", "                }"], "readability/increment"]
["src/nvim/spell.c", ["                && mb_strnicmp(word, pat, (size_t)depth) != 0) {", "              --depth;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["        // Done all bytes at this node, go up one level.", "        --depth;", "        line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["        n += curi[depth];", "        ++curi[depth];", "        c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i) {", "            if (byts[n + i] != 0) {"], "readability/increment"]
["src/nvim/spell.c", ["                      (c & WF_RAREPFX) ? (flags | WF_RARE)", "                                       : flags, lnum);", "            if (lnum != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["            if (lnum != 0) {", "              ++lnum;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["                        (c & WF_RAREPFX) ? (flags | WF_RARE)", "                                         : flags, lnum);", "              if (lnum != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["              if (lnum != 0) {", "                ++lnum;", "              }"], "readability/increment"]

["src/nvim/file_search.c", ["", "/*", " * type for the directory search stack"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the fix part (no wildcards) and the part containing the wildcards", "   * of the search path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* files/dirs found in the above directory, matched by the first wildcard", "   * of wc_part"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* to store status of partly handled directories", "   * 0: we work on this directory for the first time"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* How deep are we in the directory tree?", "   * Counts backward from value of level parameter to vim_findfile_init"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for already visited directories or files."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Visited directories are different if the wildcard string are", "   * different. So we have to save it."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  FileID file_id;", "  /* The memory for this struct is allocated according to the length of", "   * ffv_fname."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * We might have to manage several visited lists during a search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * '**' can be expanded to several directory levels."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * The search context:"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* If a search context is given by the caller, reuse it, else allocate a", "   * new one."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  // clear visited list if wanted", "  if (free_visited == TRUE) {", "    vim_findfile_free_visited(search_ctx);"], "readability/bool"]
["src/nvim/file_search.c", ["  } else {", "    /* Reuse old visited lists. Get the visited list for the given", "     * filename. If no list for the current filename exists, creates a new"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Store information on starting dir now if path is relative.", "   * If path is absolute, we do that later.  */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/file_search.c", ["    if (*++path != NUL) {", "      ++path;", "    }"], "readability/increment"]
["src/nvim/file_search.c", ["      path += 2;", "    } else", "#endif"], "readability/braces"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* A path that starts with \"/dir\" is relative to the drive, not to the", "     * directory (but not for \"//machine/dir\").  Only use the drive name. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * If stopdirs are given, split them into an array of pointers."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      } else {", "        /* this might be \"\", which means ascent till top", "         * of directory tree."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* split into:", "   *  -fix path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /*", "     * copy wc_path and add restricts to the '**' wildcard."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          semsg(_(", "                 \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "                PATHSEPSTR);"], "whitespace/indent"]
["src/nvim/file_search.c", ["  if (search_ctx->ffsc_start_dir == NULL) {", "    /* store the fix part as startdir.", "     * This is needed if the parameter path is fully qualified."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["error_return:", "  /*", "   * We clear the search context now!"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (r_ptr[0] == '\\\\' && r_ptr[1] == ';') {", "      /* Overwrite the escape char,", "       * use STRLEN(r_ptr) to move the trailing '\\0'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * filepath is used as buffer for various actions and as the storage to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    path_end = &search_ctx->ffsc_start_dir[", "                                           STRLEN(search_ctx->ffsc_start_dir)];", "  }"], "whitespace/indent"]
["src/nvim/file_search.c", ["", "      /*", "       * TODO: decide if we leave this test in"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                              stackp->ffs_wc_path", "                              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/parens"]
["src/nvim/file_search.c", ["#ifdef FF_VERBOSE", "      else if (p_verbose >= 5) {", "        verbose_enter_scroll();"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /*", "       * If no filearray till now expand wildcards"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* we use filepath to build the path expand_wildcards() should", "         * expand."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "          /*", "           * Here we copy until the next path separator or the end of"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /*", "         * Expand wildcards like \"*\" and \"$VAR\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        } else {", "          /* Add EW_NOTWILD because the expanded path may contain", "           * wildcard characters that are to be taken literally."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        rest_of_wildcards = &stackp->ffs_wc_path[", "                                                 STRLEN(stackp->ffs_wc_path)];", "      }"], "whitespace/indent"]
["src/nvim/file_search.c", ["        if (*rest_of_wildcards == NUL) {", "          /*", "           * We don't have further wildcards to expand, so we have to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])"], "readability/increment"]
["src/nvim/file_search.c", ["", "            /*", "             * Try without extra suffix and then with suffixes"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                                       (char_u *)\"\"", "                                       ) == OK)", "#endif"], "whitespace/parens"]
["src/nvim/file_search.c", ["                                     (char_u *)\"\"", "                                     ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/parens"]
["src/nvim/file_search.c", ["        } else {", "          /*", "           * still wildcards left, push the directories for further"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i])) {"], "readability/increment"]
["src/nvim/file_search.c", ["", "      /*", "       * if wildcards contains '**' we have to descent till we reach the"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /* If we reached this, we didn't find anything downwards.", "     * Let's check if we should do an upward search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                              (int)(path_end - search_ctx->ffsc_start_dir),", "                              search_ctx->ffsc_stopdirs_v) == TRUE) {", "        break;"], "readability/bool"]
["src/nvim/file_search.c", ["", "  /*", "   * if we reach this we didn't find a list and we have to allocate new list"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * New file/dir.  Add it to the list of visited files/dirs."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  /* check for NULL pointer, not to return an error to the user, but", "   * to prevent a crash */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  if (path_len == 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/file_search.c", ["    if ((int)STRLEN(stopdirs_v[i]) > path_len) {", "      /* match for parent directory. So '/home' also matches", "       * '/home/rks'. Check for PATHSEP in stopdirs_v[i], else"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          && vim_ispathsep(stopdirs_v[i][path_len])) {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/file_search.c", ["{", "  return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,", "                                  FINDFILE_DIR, rel_fname, (char_u *)\"\");"], "readability/bool"]
["src/nvim/file_search.c", ["  static char_u *dir;", "  static int did_findfile_init = FALSE;", "  char_u save_char;"], "readability/bool"]
["src/nvim/file_search.c", ["      // Change all \"\\ \" to \" \".", "      for (ptr = ff_file_to_find; *ptr != NUL; ++ptr) {", "        if (ptr[0] == '\\\\' && ptr[1] == ' ') {"], "readability/increment"]
["src/nvim/file_search.c", ["      ) {", "    /*", "     * Absolute path, no need to use \"path_option\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      if (path_with_url((char *)ff_file_to_find)) {"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* When FNAME_REL flag given first use the directory of the file.", "       * Otherwise or when this fails use the current directory. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       * Otherwise or when this fails use the current directory. */", "      for (int run = 1; run <= 2; ++run) {", "        size_t l = STRLEN(ff_file_to_find);"], "readability/increment"]
["src/nvim/file_search.c", ["", "        /* When the file doesn't exist, try adding parts of", "         * 'suffixesadd'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  } else {", "    /*", "     * Loop over all paths in the 'path' or 'cdpath' option."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      // vim_findfile_free_visited can handle a possible NULL pointer"], "readability/bool"]
["src/nvim/file_search.c", ["      dir = path_option;", "      did_findfile_init = FALSE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["", "        did_findfile_init = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (dir == NULL || *dir == NUL) {", "          /* We searched all paths of the option, now we can", "           * free the search context. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "                                            r_ptr, 100, FALSE, find_what,", "                                            fdip_search_ctx, FALSE, rel_fname);"], "readability/bool"]
["src/nvim/file_search.c", ["                                            r_ptr, 100, FALSE, find_what,", "                                            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL) {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (fdip_search_ctx != NULL) {", "          did_findfile_init = TRUE;", "        }"], "readability/bool"]
["src/nvim/file_search.c", ["  if (file_name == NULL && (options & FNAME_MESS)) {", "    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR) {"], "readability/bool"]

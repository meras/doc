["src/nvim/api/vim.c", ["    case 'n':", "      remap = false; break;", "    case 'm':"], "whitespace/newline"]
["src/nvim/api/vim.c", ["    case 'm':", "      remap = true; break;", "    case 't':"], "whitespace/newline"]
["src/nvim/api/vim.c", ["    case 't':", "      typed = true; break;", "    case 'i':"], "whitespace/newline"]
["src/nvim/api/vim.c", ["    case 'i':", "      insert = true; break;", "    case 'x':"], "whitespace/newline"]
["src/nvim/api/vim.c", ["    case 'x':", "      execute = true; break;", "    case '!':"], "whitespace/newline"]
["src/nvim/api/vim.c", ["    case '!':", "      dangerous = true; break;", "    }"], "whitespace/newline"]
["src/nvim/api/vimscript.c", ["    case 'm':", "      pflags |= kExprFlagsMulti; break;", "    case 'E':"], "whitespace/newline"]
["src/nvim/api/vimscript.c", ["    case 'E':", "      pflags |= kExprFlagsDisallowEOC; break;", "    case 'l':"], "whitespace/newline"]
["src/nvim/api/vimscript.c", ["    case 'l':", "      pflags |= kExprFlagsParseLet; break;", "    case NUL:"], "whitespace/newline"]
["src/nvim/assert.h", ["// _Static_assert but we need to suppress warnings, this is pretty ugly.", "#elif (!defined(__clang__) && !defined(__INTEL_COMPILER)) && \\", "  (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6))"], "whitespace/parens"]
["src/nvim/buffer.c", ["  case DOBUF_FIRST:", "    buf = firstbuf; break;", "  case DOBUF_LAST:"], "whitespace/newline"]
["src/nvim/buffer.c", ["  case DOBUF_LAST:", "    buf = lastbuf;  break;", "  default:"], "whitespace/newline"]
["src/nvim/buffer.c", ["  default:", "    buf = curbuf;   break;", "  }"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 1:", "        buf_p = strappend(buf_p, \" +\"); break;", "      case 2:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 2:", "        buf_p = strappend(buf_p, \" =\"); break;", "      case 3:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 3:", "        buf_p = strappend(buf_p, \" =+\"); break;", "      case 4:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 6:", "        buf_p = strappend(buf_p, \" -\"); break;", "      case 5:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 7:", "        buf_p = strappend(buf_p, \" -+\"); break;", "      default:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 2:", "        str = \"[+]\"; break;", "      case 3:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 3:", "        str = \",+\"; break;", "      case 4:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 4:", "        str = \"[-]\"; break;", "      case 5:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 5:", "        str = \",-\"; break;", "      case 6:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 6:", "        str = \"[+-]\"; break;", "      case 7:"], "whitespace/newline"]
["src/nvim/buffer.c", ["      case 7:", "        str = \",+-\"; break;", "      }"], "whitespace/newline"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "build/header_guard"]
["src/nvim/buffer_defs.h", ["", "/*", " * Flags for w_valid."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * The taggy struct is used to store the information about a :tag command."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * structure used to store one block of the stuff/redo/recording buffers"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * header used for the stuff buffer and the redo buffer"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure that contains all options that are local to a window."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Window info stored with a buffer."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Argument list: Array of file names."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Used for the typeahead buffer: typebuf."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure used for mappings and abbreviations."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Used for :syntime: timing of executing a syntax pattern."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * These are items normally related to a buffer.  But when using \":ownsyntax\""], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * buffer: structure that holds information about one file"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_saving;                /* Set to true if we are in the middle of", "                                   saving the buffer. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  bool b_saving;                /* Set to true if we are in the middle of", "                                   saving the buffer. */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Changes to a buffer require updating of the display.  To minimize the"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_mod_set;               /* true when there are changes since the last", "                                   time the display was updated */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  bool b_mod_set;               /* true when there are changes since the last", "                                   time the display was updated */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the changelist contains old change positions"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Character table, only used in charset.c for 'iskeyword'"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  garray_T b_ucmds;", "  /*", "   * start and end of an operator, also used for '[ and ']"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * The following only used in undo.c."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * variables for \"U\" command in undo.c"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Options local to a buffer."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary", "                                 * write should not have an end-of-line */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T b_no_eol_lnum;       /* non-zero lnum when last line of next binary", "                                 * write should not have an end-of-line */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /* When a buffer is created, it starts without a swap file.  b_may_swap is", "   * then set to indicate that a swap file may be opened later.  It is reset"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  bool b_may_swap;", "  bool b_did_warn;              /* Set to true if user has been warned on first", "                                   change of a read-only file */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  bool b_may_swap;", "  bool b_did_warn;              /* Set to true if user has been warned on first", "                                   change of a read-only file */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /* Two special kinds of buffers:", "   * help buffer  - used for help files, won't use a swap file."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Stuff for diff mode."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Each diffblock defines where a block of lines starts in each of the buffers"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Structure to cache info for displayed lines in w_lines[]."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Windows are kept in a tree of frames.  Each frame has a column (FR_COL)"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * Struct used for highlighting 'hlsearch' matches, matches defined by"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "/*", " * matchitem_T provides a linked list for storing match items for \":match\" and"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * \"w_topline\", \"w_leftcol\" and \"w_skipcol\" specify the offsets for"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  linenr_T w_topline;               /* buffer line number of the line at the", "                                       top of the window */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["   */", "  linenr_T w_topline;               /* buffer line number of the line at the", "                                       top of the window */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["                                       top of the window */", "  char w_topline_was_set;           /* flag set to TRUE when topline is set,", "                                       e.g. by winrestview() */"], "readability/bool"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * === start of cached values ===="], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["   */", "  /*", "   * Recomputing is minimized by storing the result of computations."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["  int w_valid;", "  pos_T w_valid_cursor;             /* last known position of w_cursor, used", "                                       to adjust w_valid */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["  int w_valid;", "  pos_T w_valid_cursor;             /* last known position of w_cursor, used", "                                       to adjust w_valid */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_cline_height is the number of physical lines taken by the buffer line"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_wrow and w_wcol specify the cursor position in the window."], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * Info about the lines currently in the window is remembered to avoid"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * === end of cached values ==="], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * The w_prev_pcmark field is used to check whether we really did jump to"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the jumplist contains old cursor positions"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * the tagstack grows from 0 upwards:"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  /*", "   * w_fraction is the fractional row of the cursor within the window, from"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width", "                                         * was computed. */"], "readability/multiline_comment"]
["src/nvim/buffer_defs.h", ["", "  linenr_T w_nrwidth_line_count;        /* line count when ml_nrwidth_width", "                                         * was computed. */"], "readability/old_style_comment"]
["src/nvim/buffer_defs.h", ["", "#endif // NVIM_BUFFER_DEFS_H", ""], "whitespace/comments"]
["src/nvim/cursor_shape.c", ["      case SHAPE_BLOCK:", "        shape_str = cstr_to_string(\"block\"); break;", "      case SHAPE_VER:"], "whitespace/newline"]
["src/nvim/cursor_shape.c", ["      case SHAPE_VER:", "        shape_str = cstr_to_string(\"vertical\"); break;", "      case SHAPE_HOR:"], "whitespace/newline"]
["src/nvim/cursor_shape.c", ["      case SHAPE_HOR:", "        shape_str = cstr_to_string(\"horizontal\"); break;", "      default:"], "whitespace/newline"]
["src/nvim/decoration.h", ["", "typedef kvec_t(struct virt_line { VirtText line; bool left_col; }) VirtLines;", ""], "whitespace/newline"]
["src/nvim/edit.c", ["", "/*", " * edit.c: functions for Insert mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Structure used to store one match for insert completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * All the current matches are stored in a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* After using a cursor key <Enter> selects a match in the popup menu,", " * otherwise it inserts a line break. */"], "readability/old_style_comment"]
["src/nvim/edit.c", [" * otherwise it inserts a line break. */", "static int compl_enter_selects = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/* When \"compl_leader\" is not NULL only matches that start with this string", " * are used. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert"], "readability/bool"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/bool"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u *compl_orig_text = NULL;  /* text as it was before", "                                         * completion started */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u *compl_orig_text = NULL;  /* text as it was before", "                                         * completion started */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else if (hasFolding(curwin->w_topline, NULL, &s->old_topline)) {"], "readability/increment"]
["src/nvim/edit.c", ["    case K_LEFT:", "      s->c = K_RIGHT; break;", "    case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_S_LEFT:", "      s->c = K_S_RIGHT; break;", "    case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_C_LEFT:", "      s->c = K_C_RIGHT; break;", "    case K_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_RIGHT:", "      s->c = K_LEFT; break;", "    case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_S_RIGHT:", "      s->c = K_S_LEFT; break;", "    case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_C_RIGHT:", "      s->c = K_C_LEFT; break;", "    }"], "whitespace/newline"]
["src/nvim/edit.c", ["", "/*", " * Handle a CTRL-V or CTRL-Q typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character directly onto the screen.  It's not stored in a buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Undo the previous edit_putchar()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when p_dollar is set: display a '$' at the end of the changed text"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Call this function before moving the cursor from the normal insert position"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  save_p_list = curwin->w_p_list;", "  curwin->w_p_list = FALSE;", "  vc = getvcol_nolist(&curwin->w_cursor);"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * For Replace mode we need to fix the replace stack later, which is only"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the cursor is in the indent, compute how many screen columns the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Set the new indent.  The cursor will be put on the first non-blank."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Try to put cursor on same character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (new_cursor_col >= 0) {", "    /*", "     * When changing the indent while the cursor is touching it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else {", "    /*", "     * Compute the screen column where the cursor should be."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Advance the cursor until we reach the right screen column."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * May need to insert spaces to be able to position the cursor on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * When changing the indent while the cursor is in it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  }", "  curwin->w_set_curswant = TRUE;", "  changed_cline_bef_curs();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May have to adjust the start of the insert."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      ++start_col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-X pressed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* \"actual_len\" may be smaller than \"actual_compl_length\" when using", "     * thesaurus, only use the minimum when comparing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Rule 2: No lower case, 2nd consecutive letter converted to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the same match is already present, don't add it."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Allocate a new match structure."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Link the new match structure in the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find the longest common string if still doing that."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Reduce the longest common string for match \"match\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    ins_bytes(compl_leader + ins_compl_len());", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    /* When the match isn't there (to avoid matching itself) remove it", "     * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      ins_bytes(compl_leader + ins_compl_len());", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      /* When the match isn't there (to avoid matching itself) remove it", "       * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add an array of matches to the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* Make the completion list cyclic.", " * Return the number of matches (excluding the original)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_first_match != NULL) {", "    /*", "     * Find the end of the list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      match = match->cp_next;", "      ++count;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Start completion for the complete() function."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* \"compl_match_array\" points the currently displayed list of entries in the", " * popup menu.  It is NULL when there is no popup menu. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Remove any popup menu."], "readability/old_style_comment"]
["src/nvim/edit.c", ["          if (compl == compl_shown_match || did_find_shown_match) {", "            /* This item is the shown match or this is the", "             * first displayed item after the shown match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        /* When the original text is the shown match don't set", "         * compl_shown_match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (!shown_match_ok && shown_compl != NULL) {", "          /* The shown match isn't displayed, set it to the", "           * previously displayed match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (*dict == NUL) {", "    /* When 'dictionary' is empty and spell checking is enabled use", "     * \"spell\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (curbuf->b_p_inf) {", "    p_scs = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /* When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern", "   * to only match at the start of a line.  Otherwise just match the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /* Expand wildcards in the dictionary name, but do not allow", "       * backticks (for security, the 'dict' option may have been set in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    if (count == -1) {", "      /* Complete from active spelling.  Skip \"\\<\" in the pattern, we", "       * don't use it as a RE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * Read dictionary file line by line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "          /*", "           * Add the other matches on the line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          while (!got_int) {", "            /* Find start of the next word.  Skip white", "             * space and punctuation. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the start of the next word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the word.  Assumes it starts inside a word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the line, omitting CR and NL at the end."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  while (s > ptr && (s[-1] == CAR || s[-1] == NL)) {", "    --s;", "  }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Free the list of completions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Delete one character before the cursor and show the subset of the matches"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Deleted more than what was used to find matches or didn't finish", "   * finding all matches: need to look for matches all over again. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called after changing \"compl_leader\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Don't let Enter select the original text when there is no popup menu.", "   * Don't let Enter select when use user function and refresh_always is set */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_match_array == NULL || ins_compl_need_restart()) {", "    compl_enter_selects = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Return the length of the completion, from the completion start column to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Setup for finding completions again without leaving CTRL-X mode.  Used when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* update screen before restart.", "   * so if complete is blocked,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Set the first match, the original text."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Forget any previous 'special' messages if this is actually", "   * a ^X mode key - bar ^R, in which case we wait to see what it gives us."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET) {", "    /*", "     * We have just typed CTRL-X and aren't quite sure which CTRL-X mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case Ctrl_N:", "      /* ^X^P means LOCAL expansion if nothing interrupted (eg we", "       * just started ^X mode, or there were enough ^X's to cancel"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    default:", "      /* If we have typed at least 2 ^X's... for modes != 0, we set", "       * compl_cont_status = 0 (eg, as if we had just started ^X"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {", "    /* Show error message from attempted keyword completion (probably", "     * 'Pattern not found') until another key is hit, then go back to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        || ctrl_x_mode == CTRL_X_FINISHED) {", "      /* Get here when we have finished typing a sequence of ^N and", "       * ^P or other completion characters in CTRL-X mode.  Free up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {", "        /*", "         * If any of the original typed text has been changed, eg when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /*", "       * Indent now if a key was typed that is in 'cinkeys'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {", "    /* Trigger the CompleteDone event to give scripts a chance to act", "     * upon the (possibly failed) completion. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* reset continue_* if we left expansion-mode, if we stay they'll be", "   * (re)set properly in ins_complete() */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Fix the redo buffer for the completion leader replacing some of the typed"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Loops through the list of windows, loaded-buffers or non-loaded-buffers"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else {", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'", "     * (unlisted buffers)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a dict."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      find_pattern_in_path(compl_pattern, compl_direction,", "                           STRLEN(compl_pattern), FALSE, FALSE,", "                           ((type == CTRL_X_PATH_DEFINES"], "readability/bool"]
["src/nvim/edit.c", ["      if (ins_buf->b_p_inf) {", "        p_scs = FALSE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["              // compl_length, so the next STRNCPY always works -- Acevedo", "              STRNCPY(IObuff, ptr, len);", "              ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);"], "runtime/printf"]
["src/nvim/edit.c", ["", "  /* When user complete function return -1 for findstart which is next", "   * time of 'always', compl_shown_match become NULL. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If we didn't find it searching forward, and compl_shows_dir is", "     * backward, find the last match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap", "   * around. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (compl_shows_dir == BACKWARD) {", "          --compl_pending;", "        } else {"], "readability/increment"]
["src/nvim/edit.c", ["        } else {", "          ++compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_next;", "          --compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_prev;", "          ++compl_pending;", "        } else {"], "readability/increment"]
["src/nvim/edit.c", ["", "  /* Enter will select a match when the match wasn't inserted and the popup", "   * menu is visible. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_no_insert && !started) {", "    compl_enter_selects = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * Show the file name for the match (if any)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()", "   * can't do its work correctly. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /* Need to get the character to have KeyTyped set.  We'll put it", "       * back with vungetc() below.  But skip K_IGNORE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c != K_IGNORE) {", "        /* Don't interrupt completion when the character wasn't typed,", "         * e.g., when doing @q to replay keys. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (c != Ctrl_R && KeyTyped) {", "          compl_interrupted = TRUE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Decide the direction of Insert mode complete from the key typed."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Decide the number of completions to move forward."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Do Insert mode completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If this same ctrl_x_mode has been interrupted use the text from", "     * \"compl_startpos\" to the cursor as a pattern to add a new word"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && compl_cont_mode == ctrl_x_mode) {", "      /*", "       * it is a continued search"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          /* S_IPOS was set when we inserted a word that was at the", "           * beginning of the line, which means that we'll go to SOL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        compl_length = curwin->w_cursor.col - (int)compl_col;", "        /* IObuff is used to add a \"word from the next line\" would we", "         * have enough space?  just being paranoid */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/parens"]
["src/nvim/edit.c", ["        if (compl_length == 1) {", "          /* Only match word with at least two chars -- webb", "           * there's no need to call quote_meta,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Return value -2 means the user complete function wants to", "       * cancel the complete without an error."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Setup variables for completion.  Need to obtain \"line\" again,", "       * it may have become invalid. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If any of the original typed text has been changed we need to fix", "     * the redo buffer. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* showmode might reset the internal line pointers, so it must", "     * be called before line = ml_get(), or when this address is no"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find next match (and following matches)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert", "   * mode. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    edit_submode_highl = HLF_E;", "    /* remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,", "     * because we couldn't expand anything at first place, but if we used"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* The match should always have a sequence number now, this is", "       * just a safety check. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match->cp_number != -1) {", "        /* Space for 10 text chars. + 2x10-digit no.s = 31.", "         * Translations may need more than twice that. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  compl_was_interrupted = compl_interrupted;", "  compl_interrupted = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Looks in the first \"len\" chars. of \"src\" for search-metachars."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      ++i;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "  --no_mapping;", "  if (nc) {"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Special characters in this context are those that need processing other"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Need to remove existing (middle) comment leader and insert end"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * When 'ai' is off we don't want a space under the cursor to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Repeat breaking lines, until the current line is not too long."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Find position to break at."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * adjust startcol for spaces that will be deleted and"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Split the line just before the margin."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /*", "       * Check if cursor is not past the NUL off the line, cindent"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * May start formatting in a previous line, so that after \"x\" a word is"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (prev_line && !paragraph_start(curwin->w_cursor.lnum)) {", "    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL) {"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * Do the formatting and restore the cursor position.  \"saved_cursor\" will"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character in the redo buffer, for when just after a CTRL-V."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If we skipped highlighting word at cursor, do it now."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * stop_arrow() is called before a change is made in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Save the inserted text for later redo with ^@ and CTRL-A."], "readability/old_style_comment"]
["src/nvim/edit.c", ["        }", "        /* If the cursor is still at the same character, also keep", "         * the \"coladd\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0) {", "          --curwin->w_cursor.col;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["        if (cc != NUL && gchar_pos(&tpos) == NUL) {", "          ++curwin->w_cursor.col;         // put cursor back on the NUL", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Set the last inserted text to a single character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * move cursor to start of line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr) {", "        ++curwin->w_cursor.col;"], "readability/increment"]
["src/nvim/edit.c", ["           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr) {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["    }", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * oneright oneleft cursor_down cursor_up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "    curwin->w_set_curswant = TRUE;", "    return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/edit.c", ["  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/edit.c", ["    } else if (hasAnyFolding(curwin)) {", "      /*", "       * Count each sequence of folded lines as one logical line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Get last inserted string, and remove trailing <Esc>."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * replace-stack functions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  *p = (char_u)c;", "  ++replace_stack_nr;", "}"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Push a character onto the replace stack.  Handles a multi-byte character in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j) {", "    replace_push(p[j]);"], "readability/increment"]
["src/nvim/edit.c", ["    if (replace_stack[i] == NUL && off-- <= 0) {", "      --replace_stack_nr;", "      memmove(replace_stack + i, replace_stack + i + 1,"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * make the replace stack empty"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle doing a BS for one character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Re-indent the current line, based on the current contents of it and the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  while (*look) {", "    /*", "     * Find out if we want to try a match with this key, depending on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case '*':", "      try_match = (*look == '*'); break;", "    case '!':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case '!':", "      try_match = (*look == '!'); break;", "    default:"], "whitespace/newline"]
["src/nvim/edit.c", ["    default:", "      try_match = (*look != '*'); break;", "    }"], "whitespace/newline"]
["src/nvim/edit.c", ["    }", "    /*", "     * Is it a word: \"=word\"?"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;"], "whitespace/newline"]
["src/nvim/edit.c", ["    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;", "      if (*look == '~') {"], "readability/increment"]
["src/nvim/edit.c", ["", "          /* Just completed a word, check if it starts with \"look\".", "           * search back for the start of a word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (match && try_match_word && !try_match) {", "          /* \"0=word\": Check if there are only blanks before the", "           * word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Skip over \", \"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Map Hebrew keyboard when in hkmap mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case ',':", "      c = '{'; break;", "    case '.':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case '.':", "      c = 'v'; break;", "    case ';':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case ';':", "      c = 't'; break;", "    default: {"], "whitespace/newline"]
["src/nvim/edit.c", ["", "  /*", "   * If we are going to wait for a character, show a '\"'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  regname = plain_vgetc();", "  LANGMAP_ADJUST(regname, TRUE);", "  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {"], "readability/bool"]
["src/nvim/edit.c", ["    regname = plain_vgetc();", "    LANGMAP_ADJUST(regname, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * CTRL-G commands in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-^ in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Repeating insert may take a long time.  Check for"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    stop_insert(&curwin->w_cursor, TRUE, nomove);", "    undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * The cursor should end up on the last inserted character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              && !VIsual_active", "              ))", "      && !revins_on) {"], "whitespace/parens"]
["src/nvim/edit.c", ["", "/*", " * Toggle language: hkmap and revins_on."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (gchar_cursor() != NUL && revins_chars--) {", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * <Insert> key in Insert mode: toggle insert/replace mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Pressed CTRL-O in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If the cursor is on an indent, ^T/^D insert/delete one"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * 0^D and ^^D: remove all indent."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["  } else {", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Delete one character for ins_bs()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * In replace mode:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL) {"], "readability/bool"]
["src/nvim/edit.c", ["", "    /*", "     * Handle deleting one 'shiftwidth' or 'softtabstop'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol) {"], "readability/bool"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol) {"], "readability/bool"]
["src/nvim/edit.c", ["      && !(", "           p_sta", "           && ind"], "whitespace/indent"]
["src/nvim/edit.c", ["           p_sta", "           && ind", "           // These five lines mean 'tabstop' != 'shiftwidth'"], "whitespace/indent"]
["src/nvim/edit.c", ["           // These five lines mean 'tabstop' != 'shiftwidth'", "           && ((tabstop_count(curbuf->b_p_vts_array) > 1)", "               || (tabstop_count(curbuf->b_p_vts_array) == 1"], "whitespace/indent"]
["src/nvim/edit.c", ["      && !(", "           p_sta", "           && ind"], "whitespace/indent"]
["src/nvim/edit.c", ["           p_sta", "           && ind", "           // These five lines mean 'tabstop' != 'shiftwidth'"], "whitespace/indent"]
["src/nvim/edit.c", ["           // These five lines mean 'tabstop' != 'shiftwidth'", "           && ((tabstop_count(curbuf->b_p_vts_array) > 1)", "               || (tabstop_count(curbuf->b_p_vts_array) == 1"], "whitespace/indent"]
["src/nvim/edit.c", ["", "  /*", "   * When 'expandtab' not set: Replace spaces by TABs where possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (fpos.col > 0 && ascii_iswhite(ptr[-1])) {", "      --fpos.col;", "      --ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      --fpos.col;", "      --ptr;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["      }", "      ++fpos.col;", "      ++ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      ++fpos.col;", "      ++ptr;", "      vcol += i;"], "readability/increment"]
["src/nvim/edit.c", ["        vcol += lbr_chartabsize(line, ptr, vcol);", "        ++ptr;", "        ++repl_off;"], "readability/increment"]
["src/nvim/edit.c", ["        ++ptr;", "        ++repl_off;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * Strange Vi behaviour: In Replace mode, typing a NL will not delete the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle digraph in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    clear_showcmd();", "    insert_special(c, TRUE, FALSE);", "    return NUL;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-Y or CTRL-E typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      curbuf->b_p_tw = -1;", "      insert_special(c, TRUE, FALSE);", "      curbuf->b_p_tw = tw_save;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Try to do some very smart auto-indenting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * do some very smart indenting when entering '{' or '}'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      old_pos = curwin->w_cursor;", "      /*", "       * If the matching '{' has a ')' immediately before it (ignoring"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (State & VREPLACE_FLAG) {", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/edit.c", ["      if (temp) {", "        shift_line(TRUE, FALSE, 1, TRUE);", "      }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * set indent of '#' always to 0"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Get the value that w_virtcol would have when 'list' is off."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle the InsertCharPre autocommand."], "readability/old_style_comment"]
["src/nvim/edit.h", ["", "/*", " * Array indexes used for cptext argument of ins_compl_add()."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * eval.c: Expression evaluation."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Old Vim variables such as \"v:version\" are also available without the \"v:\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Array to hold the hashtab with variables local to each sourced script."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Info used by a \":for\" loop."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /* Script-local variables. First clear all the variables and in a second", "   * loop free the scriptvar_T, because a variable in one script might hold"], "readability/old_style_comment"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    vars_clear(&SCRIPT_VARS(i));"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    xfree(SCRIPT_SV(i));"], "readability/increment"]
["src/nvim/eval.c", ["", "  /* check if we can write to the variable: set it to or append an empty", "   * string */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  save_emsg = did_emsg;", "  did_emsg = FALSE;", "  tv.v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["", "  ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  if (p_verbose == 0) {", "    ++emsg_off;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (p_verbose == 0) {", "    --emsg_off;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", "  if (use_sandbox) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (use_sandbox) {", "    ++sandbox;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  ++textlock;", "  *cp = NUL;"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", "  if (use_sandbox) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (use_sandbox) {", "    --sandbox;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --textlock;", ""], "readability/increment"]
["src/nvim/eval.c", ["    if (eap->skip) {", "      ++emsg_skip;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["  if (*arg != '[') {", "    /*", "     * \":let var = expr\" or \":for var in list\""], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*arg == ';') {", "      /* Put the rest of the list (may be empty) in the var after ';'.", "       * Create a new list for this. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++*var_count;", ""], "readability/increment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && !got_int; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/eval.c", ["      if (len <= 0) {", "        /* This is mainly to keep test 49 working: when expanding", "         * curly braces fails overrule the exception error message. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        }", "        error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["              case 'g':", "                list_glob_vars(first); break;", "              case 'b':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'b':", "                list_buf_vars(first); break;", "              case 'w':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'w':", "                list_win_vars(first); break;", "              case 't':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 't':", "                list_tab_vars(first); break;", "              case 'v':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'v':", "                list_vim_vars(first); break;", "              case 's':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 's':", "                list_script_vars(first); break;", "              case 'l':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'l':", "                list_func_vars(first); break;", "              default:"], "whitespace/newline"]
["src/nvim/eval.c", ["", "  /*", "   * \":let $VAR = expr\": Set environment variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["            case '+':", "              n = numval + n; break;", "            case '-':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '-':", "              n = numval - n; break;", "            case '*':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '*':", "              n = numval * n; break;", "            case '/':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '/':", "              n = num_divide(numval, n); break;", "            case '%':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '%':", "              n = num_modulus(numval, n); break;", "            }"], "whitespace/newline"]
["src/nvim/eval.c", ["  }", "  /*", "   * \":let var = expr\": Set internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  else if (eval_isnamec1(*arg) || *arg == '{') {", "    lval_T lv;"], "whitespace/newline"]
["src/nvim/eval.c", ["  typval_T var2;", "  int empty1 = FALSE;", "  listitem_T *ni;"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Assign the List values to the list items."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["{", "  int got_eq = FALSE;", "  int c;"], "readability/bool"]
["src/nvim/eval.c", ["      if (c == '&') {", "        ++xp->xp_pattern;", "        xp->xp_context = cmdidx != CMD_let || got_eq"], "readability/increment"]
["src/nvim/eval.c", ["    } else if (c == '=') {", "      got_eq = TRUE;", "      xp->xp_context = EXPAND_EXPRESSION;"], "readability/bool"]
["src/nvim/eval.c", ["        if (xp->xp_pattern[1] == '|') {", "          ++xp->xp_pattern;", "          xp->xp_context = EXPAND_EXPRESSION;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Local string buffer for the next two functions to store a variable name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * The \"evaluate\" argument: When FALSE, the argument is only parsed but not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if ((*arg)[0] == '?') {", "    result = FALSE;", "    if (evaluate) {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Check for the \":\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the third variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"||\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = FALSE;", "  while ((*arg)[0] == '|' && (*arg)[1] == '|') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"&&\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = TRUE;", "  while ((*arg)[0] == '&' && (*arg)[1] == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * If there is a comparative operator, use it."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL) {", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '+', '-' or '.' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (evaluate) {", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '*', '/' or '%' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      if (*p == 'e' || *p == 'E') {", "        ++p;", "        if (*p == '-' || *p == '+') {"], "readability/increment"]
["src/nvim/eval.c", ["        if (*p == '-' || *p == '+') {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["  case '@':", "    ++*arg;", "    if (evaluate) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg != NUL) {", "      ++*arg;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg == ')') {", "      ++*arg;", "    } else if (ret == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (**arg == '.') {", "    /*", "     * dict.name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  } else {", "    /*", "     * something[idx]"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable from inside the [:]."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping backslashed characters."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling backslashed"], "readability/old_style_comment"]
["src/nvim/eval.c", ["      case 'b':", "        *name++ = BS; ++p; break;", "      case 'e':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'e':", "        *name++ = ESC; ++p; break;", "      case 'f':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'f':", "        *name++ = FF; ++p; break;", "      case 'n':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'n':", "        *name++ = NL; ++p; break;", "      case 'r':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'r':", "        *name++ = CAR; ++p; break;", "      case 't':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 't':", "        *name++ = TAB; ++p; break;", ""], "whitespace/newline"]
["src/nvim/eval.c", ["          while (--n >= 0 && ascii_isxdigit(p[1])) {", "            ++p;", "            nr = (nr << 4) + hex2nr(*p);"], "readability/increment"]
["src/nvim/eval.c", ["        }", "        ++name;", "        break;"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping ''."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++reduce;", "      ++p;"], "readability/increment"]
["src/nvim/eval.c", ["      ++reduce;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling '' to ' reduction."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Garbage collection for lists and dictionaries."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  // script-local variables", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    ABORTING(set_ref_in_ht)(&SCRIPT_VARS(i), copyID, NULL);"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * First check if it's not a curly-braces thing: {expr}."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++*arg;", "  name = *arg;"], "readability/increment"]
["src/nvim/eval.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      todo = (int)ht->ht_used;", "      for (hi = ht->ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * \"setwinvar()\" and \"settabwinvar()\" functions"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    char *d = res;", "    for (char *s = res; *s; ++s) {", "      if (s[0] == CAR && s[1] == NL) {"], "readability/increment"]
["src/nvim/eval.c", ["      if (s[0] == CAR && s[1] == NL) {", "        ++s;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["", "    /*", "     * Include any <SID> etc in the expanded string:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (*p == '\\\\' && p[1] != NUL) {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["      if (*p == '[') {", "        ++br_nest;", "      } else if (*p == ']') {"], "readability/increment"]
["src/nvim/eval.c", ["      } else if (*p == ']') {", "        --br_nest;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["        if (selfdict != NULL) {", "          ++selfdict->dv_refcount;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["  {", "    /* Re-allocating ga_data means that an ht_array pointing to", "     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is"], "readability/old_style_comment"]
["src/nvim/eval.c", ["     * at its init value.  Also reset \"v_dict\", it's always the same. */", "    for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "      ht = &SCRIPT_VARS(i);"], "readability/increment"]
["src/nvim/eval.c", ["      init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);", "      ++ga_scripts.ga_len;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["{", "  /* Now the dict needs to be freed if no one else is using it, go back to", "   * normal reference counting. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  vars_clear_ext(ht, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["    if (*string == '[') {", "      ++string;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (*string == '{') {", "      ++string;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    msg_clr_eos();", "    *first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  ++recurse;", ""], "readability/increment"]
["src/nvim/eval.c", ["      to->vval.v_dict = from->vval.v_dict->dv_copydict;", "      ++to->vval.v_dict->dv_refcount;", "    } else {"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --recurse;", "  return ret;"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["", "  ++p;", "  if (*p == 'g' && p[1] == ':') {"], "readability/increment"]
["src/nvim/eval.c", ["", "  fp->uf_profiling = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "  for (hi = func_hashtab.ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval.c", ["", "        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL) {"], "readability/increment"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "                         &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "readability/bool"]
["src/nvim/eval.c", ["          prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);", "    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),"], "readability/bool"]
["src/nvim/eval.c", ["          prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  fprintf(fd, \"count  total (s)   self (s)  function\\n\");", "  for (i = 0; i < 20 && i < st_len; ++i) {", "    fp = sorttab[i];"], "readability/increment"]
["src/nvim/eval.c", ["  if (fp->uf_profiling && fp->uf_tml_idx >= 0) {", "    fp->uf_tml_execed = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    if (fp->uf_tml_execed) {", "      ++fp->uf_tml_count[fp->uf_tml_idx];", "      fp->uf_tml_start = profile_end(fp->uf_tml_start);"], "readability/increment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["         && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {", "    /* find a '.' in the tail:", "     * - for second :e: before the current fname"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          *bufp = s;", "          didit = TRUE;", "          xfree(sub);"], "readability/bool"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = f1 == f2; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = f1 != f2; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = f1 > f2; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = f1 >= f2; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = f1 < f2; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = f1 <= f2; break;", "    case EXPR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = n1 == n2; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = n1 != n2; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = n1 > n2; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = n1 >= n2; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = n1 < n2; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = n1 <= n2; break;", "    case EXPR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = i == 0; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = i != 0; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = i > 0; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = i >= 0; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = i < 0; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = i <= 0; break;", ""], "whitespace/newline"]
["src/nvim/eval.h", ["", "/*", " * Structure returned by get_lval() and used by set_var_lval()."], "readability/old_style_comment"]
["src/nvim/eval/decode.c", ["                          ((typval_T){", "        .v_type = VAR_LIST,", "        .v_lock = VAR_UNLOCKED,"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .v_type = VAR_LIST,", "        .v_lock = VAR_UNLOCKED,", "        .vval = { .v_list = list },"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .v_lock = VAR_UNLOCKED,", "        .vval = { .v_list = list },", "      }));"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .vval = { .v_list = list },", "      }));", "      const int elw_ret = encode_list_write((void *)list, s, len);"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["                          ((typval_T){", "        .v_type = VAR_LIST,", "        .v_lock = VAR_UNLOCKED,"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .v_type = VAR_LIST,", "        .v_lock = VAR_UNLOCKED,", "        .vval = { .v_list = list },"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .v_lock = VAR_UNLOCKED,", "        .vval = { .v_list = list },", "      }));"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .vval = { .v_list = list },", "      }));", "      const int elw_ret = encode_list_write((void *)list, s, len);"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["    } else {", "      uint8_t p_byte = (uint8_t)*p;", "      // unescaped = %x20-21 / %x23-5B / %x5D-10FFFF"], "whitespace/operators"]
["src/nvim/eval/decode.c", ["        };", "        *str_end++ = escapes[(int)*t];", "        break;"], "whitespace/operators"]
["src/nvim/eval/decode.c", ["          .special_val = NULL,", "        }));", "      kv_push(stack, OBJ(tv, false, didcomma, didcolon));"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["          .special_val = val_list,", "        }));", "      kv_push(stack, OBJ(tv, false, didcomma, didcolon));"], "whitespace/indent"]
["src/nvim/eval/decode.c", ["        .vval = { .v_list = list },", "      }));", "    if (encode_list_write((void *)ext_val_list, mobj.via.ext.ptr,"], "whitespace/indent"]
["src/nvim/eval/encode.c", ["      const int idx = (v.data.l.li == tv_list_first(v.data.l.list)", "                         ? 0", "                         : (v.data.l.li == NULL"], "whitespace/alignment"]
["src/nvim/eval/encode.c", ["                         ? 0", "                         : (v.data.l.li == NULL", "                            ? tv_list_len(v.data.l.list) - 1"], "whitespace/alignment"]
["src/nvim/eval/encode.c", ["      const listitem_T *const li = (v.data.l.li == NULL", "                                      ? tv_list_last(v.data.l.list)", "                                      : TV_LIST_ITEM_PREV(v.data.l.list,"], "whitespace/alignment"]
["src/nvim/eval/encode.c", ["                                      ? tv_list_last(v.data.l.list)", "                                      : TV_LIST_ITEM_PREV(v.data.l.list,", "                                                          v.data.l.li));"], "whitespace/alignment"]
["src/nvim/eval/executor.c", ["          case '+':", "            f += tv2->vval.v_float; break;", "          case '-':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '-':", "            f -= tv2->vval.v_float; break;", "          case '*':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '*':", "            f *= tv2->vval.v_float; break;", "          case '/':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '/':", "            f /= tv2->vval.v_float; break;", "          }"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '+':", "            n += tv_get_number(tv2); break;", "          case '-':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '-':", "            n -= tv_get_number(tv2); break;", "          case '*':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '*':", "            n *= tv_get_number(tv2); break;", "          case '/':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '/':", "            n = num_divide(n, tv_get_number(tv2)); break;", "          case '%':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["          case '%':", "            n = num_modulus(n, tv_get_number(tv2)); break;", "          }"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["      const float_T f = (tv2->v_type == VAR_FLOAT", "                           ? tv2->vval.v_float", "                           : (float_T)tv_get_number(tv2));"], "whitespace/alignment"]
["src/nvim/eval/executor.c", ["                           ? tv2->vval.v_float", "                           : (float_T)tv_get_number(tv2));", "      switch (*op) {"], "whitespace/alignment"]
["src/nvim/eval/executor.c", ["      case '+':", "        tv1->vval.v_float += f; break;", "      case '-':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["      case '-':", "        tv1->vval.v_float -= f; break;", "      case '*':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["      case '*':", "        tv1->vval.v_float *= f; break;", "      case '/':"], "whitespace/newline"]
["src/nvim/eval/executor.c", ["      case '/':", "        tv1->vval.v_float /= f; break;", "      }"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["    if (buf == NULL) {", "      /* No full path name match, try a match with a URL or a \"nofile\"", "       * buffer, these don't use the full path. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  save_magic = p_magic;", "  p_magic = TRUE;", "  save_cpo = p_cpo;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["          case 'E':", "            type = VIM_ERROR; break;", "          case 'Q':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'Q':", "            type = VIM_QUESTION; break;", "          case 'I':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'I':", "            type = VIM_INFO; break;", "          case 'W':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'W':", "            type = VIM_WARNING; break;", "          case 'G':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'G':", "            type = VIM_GENERIC; break;", "          }"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      todo = error ? 0 : (int)d->dv_hashtab.ht_used;", "      for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["                + STRLEN(s));     // concatenated", "    sprintf((char *)r, txt, dashes, count);", "    len = (int)STRLEN(r);"], "runtime/printf"]
["src/nvim/eval/funcs.c", ["        for (wp = firstwin; wp != win; wp = wp->w_next) {", "          ++winnr;", "        }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "  /* When the optional second argument is non-zero, don't remove matches", "  * for 'wildignore' and don't put matches for 'suffixes' at the end. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, FALSE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, TRUE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int mode;", "  int abbr = FALSE;", "  int get_dict = FALSE;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int abbr = FALSE;", "  int get_dict = FALSE;", "  mapblock_T *mp;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        TV_LIST_ITEM_TV(li3)->vval.v_number = (varnumber_T)(", "                                                            regmatch.startp[0] - expr);", "        TV_LIST_ITEM_TV(li4)->vval.v_number = (varnumber_T)("], "whitespace/indent"]
["src/nvim/eval/funcs.c", ["        TV_LIST_ITEM_TV(li4)->vval.v_number = (varnumber_T)(", "                                                            regmatch.endp[0] - expr);", "        if (l != NULL) {"], "whitespace/indent"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        } else {", "          /* Change \"prev\" buffer to be the right size.  This way", "           * the bytes are only copied once, and very long lines are"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["      if (p - start + prevlen >= prevsize) {", "        /* A common use case is ordinary text files and \"prev\" gets a", "         * fragment of a line, so the first allocation is made"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'b':", "        dir = BACKWARD; break;", "      case 'w':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'w':", "        p_ws = true; break;", "      case 'W':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'W':", "        p_ws = false; break;", "      default:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'c':", "            mask = SP_START; break;", "          case 'e':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'e':", "            mask = SP_END; break;", "          case 'm':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'm':", "            mask = SP_RETCOUNT; break;", "          case 'n':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'n':", "            mask = SP_NOMOVE; break;", "          case 'p':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'p':", "            mask = SP_SUBPAT; break;", "          case 'r':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'r':", "            mask = SP_REPEAT; break;", "          case 's':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 's':", "            mask = SP_SETPCMARK; break;", "          case 'z':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'z':", "            mask = SP_COLUMN; break;", "          }"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["", "  /*", "   * This function does not accept SP_REPEAT and SP_RETCOUNT flags."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["                        (attr == HLF_SPB ? \"bad\"", "                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr =="], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr ==", "                         HLF_SPC ? \"caps\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                         HLF_SPC ? \"caps\"", "                                 :", "                         NULL), -1);"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                        (attr == HLF_SPB ? \"bad\"", "                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr =="], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr ==", "                         HLF_SPC ? \"caps\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                         HLF_SPC ? \"caps\"", "                                 :", "                         NULL), -1);"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["      }", "      ++nr;", "    }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["  case VAR_NUMBER:", "    n = VAR_TYPE_NUMBER; break;", "  case VAR_STRING:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_STRING:", "    n = VAR_TYPE_STRING; break;", "  case VAR_PARTIAL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_FUNC:", "    n = VAR_TYPE_FUNC; break;", "  case VAR_LIST:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_LIST:", "    n = VAR_TYPE_LIST; break;", "  case VAR_DICT:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_DICT:", "    n = VAR_TYPE_DICT; break;", "  case VAR_FLOAT:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_FLOAT:", "    n = VAR_TYPE_FLOAT; break;", "  case VAR_BOOL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_BOOL:", "    n = VAR_TYPE_BOOL; break;", "  case VAR_SPECIAL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_SPECIAL:", "    n = VAR_TYPE_SPECIAL; break;", "  case VAR_BLOB:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_BLOB:", "    n = VAR_TYPE_BLOB; break;", "  case VAR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["    getvvcol(curwin, fp, NULL, NULL, &vcol);", "    ++vcol;", "  }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["      case 'b':", "        binary = true; break;", "      case 'a':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'a':", "        append = true; break;", "      case 's':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 's':", "        do_fsync = true; break;", "      case 'S':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'S':", "        do_fsync = false; break;", "      default:"], "whitespace/newline"]
["src/nvim/eval/typval.h", ["    uint8_t di_flags;  /* Flags. */ \\", "    char_u di_key[__VA_ARGS__];  /* Key value. */ \\", "  }"], "runtime/arrays"]
["src/nvim/eval/typval.h", ["#define TV_LIST_ITER(l, li, code) \\", "  _TV_LIST_ITER_MOD( , l, li, code)", ""], "whitespace/parens"]
["src/nvim/eval/typval_encode.c.h", ["                                                      const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT", "  REAL_FATTR_ALWAYS_INLINE;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(", "                                                      TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                                      void *const val, int *const val_copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                      TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                                      void *const val, int *const val_copyID,", "                                                      const MPConvStack *const mpstack, const int copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                      void *const val, int *const val_copyID,", "                                                      const MPConvStack *const mpstack, const int copyID,", "                                                      const MPConvStackValType conv_type,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                      const MPConvStack *const mpstack, const int copyID,", "                                                      const MPConvStackValType conv_type,", "                                                      const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                      const MPConvStackValType conv_type,", "                                                      const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3, 4, 7) REAL_FATTR_WARN_UNUSED_RESULT"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["static inline int _TYPVAL_ENCODE_CHECK_SELF_REFERENCE(", "                                                     TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, void *const val, int *const val_copyID,", "                                                     const MPConvStack *const mpstack, const int copyID, const MPConvStackValType conv_type,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                     TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, void *const val, int *const val_copyID,", "                                                     const MPConvStack *const mpstack, const int copyID, const MPConvStackValType conv_type,", "                                                     const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                                     const MPConvStack *const mpstack, const int copyID, const MPConvStackValType conv_type,", "                                                     const char *const objname)", "{"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                            const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;", ""], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(", "                                            TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                            MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                            TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                            MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,", "                                            typval_T *const tv, const int copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                            MPConvStack *const mpstack, MPConvStackVal *const cur_mpsv,", "                                            typval_T *const tv, const int copyID,", "                                            const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                            typval_T *const tv, const int copyID,", "                                            const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 4, 6) REAL_FATTR_WARN_UNUSED_RESULT;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["static int _TYPVAL_ENCODE_CONVERT_ONE_VALUE(", "                                           TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, MPConvStack *const mpstack,", "                                           MPConvStackVal *const cur_mpsv, typval_T *const tv, const int copyID, const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                           TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, MPConvStack *const mpstack,", "                                           MPConvStackVal *const cur_mpsv, typval_T *const tv, const int copyID, const char *const objname)", "{"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    TYPVAL_ENCODE_CONV_REAL_LIST_AFTER_START(tv, _mp_last(*mpstack));"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        const listitem_T *const highest_bits_li = (", "                                                   TV_LIST_ITEM_NEXT(val_list, sign_li));", "        if (TV_LIST_ITEM_TV(highest_bits_li)->v_type != VAR_NUMBER"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["            || ((highest_bits", "                   = TV_LIST_ITEM_TV(highest_bits_li)->vval.v_number)", "                < 0)) {"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["            || ((highest_bits", "                   = TV_LIST_ITEM_TV(highest_bits_li)->vval.v_number)", "                < 0)) {"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["        const listitem_T *const high_bits_li =  (", "                                                 TV_LIST_ITEM_NEXT(val_list, highest_bits_li));", "        if (TV_LIST_ITEM_TV(high_bits_li)->v_type != VAR_NUMBER"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        _mp_push(*mpstack, ((MPConvStackVal) {", "              .tv = tv,", "              .type = kMPConvList,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .tv = tv,", "              .type = kMPConvList,", "              .saved_copyID = saved_copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .type = kMPConvList,", "              .saved_copyID = saved_copyID,", "              .data = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .saved_copyID = saved_copyID,", "              .data = {", "                .l = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["          TYPVAL_ENCODE_CONV_EMPTY_DICT(  // -V501", "                                          tv, TYPVAL_ENCODE_NODICT_VAR);", "          break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        _mp_push(*mpstack, ((MPConvStackVal) {", "              .tv = tv,", "              .type = kMPConvPairs,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .tv = tv,", "              .type = kMPConvPairs,", "              .saved_copyID = saved_copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .type = kMPConvPairs,", "              .saved_copyID = saved_copyID,", "              .data = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              .saved_copyID = saved_copyID,", "              .data = {", "                .l = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        break;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["            || ((type", "                   = TV_LIST_ITEM_TV(tv_list_first(val_list))->vval.v_number)", "                > INT8_MAX)"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["            || ((type", "                   = TV_LIST_ITEM_TV(tv_list_first(val_list))->vval.v_number)", "                > INT8_MAX)"], "whitespace/alignment"]
["src/nvim/eval/typval_encode.c.h", ["        if (!(", "              encode_vim_list_to_buf(TV_LIST_ITEM_TV(tv_list_last(val_list))->vval.v_list, &len,", "                                     &buf))) {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["        },", "      }));", "    TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(tv, tv->vval.v_dict,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                              typval_T *const tv, const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;", ""], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(", "                                              TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                              typval_T *const tv, const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                              TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME,", "                                              typval_T *const tv, const char *const objname)", "REAL_FATTR_NONNULL_ARG(2, 3) REAL_FATTR_WARN_UNUSED_RESULT;"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["TYPVAL_ENCODE_SCOPE int _TYPVAL_ENCODE_ENCODE(", "                                             TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, typval_T *const top_tv,", "                                             const char *const objname)"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                                             TYPVAL_ENCODE_FIRST_ARG_TYPE TYPVAL_ENCODE_FIRST_ARG_NAME, typval_T *const top_tv,", "                                             const char *const objname)", "{"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["      const list_T *const kv_pair = (", "                                     TV_LIST_ITEM_TV(cur_mpsv->data.l.li)->vval.v_list);", "      TYPVAL_ENCODE_SPECIAL_DICT_KEY_CHECK(encode_vim_to__error_ret,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["              },", "            }));", "        }"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["          _mp_push(mpstack, ((MPConvStackVal) {", "                .type = kMPConvDict,", "                .tv = NULL,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                .type = kMPConvDict,", "                .tv = NULL,", "                .saved_copyID = saved_copyID,"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                .tv = NULL,", "                .saved_copyID = saved_copyID,", "                .data = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                .saved_copyID = saved_copyID,", "                .data = {", "                  .d = {"], "whitespace/indent"]
["src/nvim/eval/typval_encode.c.h", ["                },", "              }));", "          TYPVAL_ENCODE_CONV_REAL_DICT_AFTER_START(NULL, pt->pt_dict,"], "whitespace/indent"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Get the arguments."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    }", "    ++argcount;", "    if (*argp != ',') {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (*argp == ')') {", "    ++argp;", "  } else {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++depth;", "  // Save search patterns and redo buffer."], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++fp->uf_calls;", "  // check for CTRL-C hit"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    v->di_tv.vval.v_dict = selfdict;", "    ++selfdict->dv_refcount;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (p_verbose >= 12) {", "      ++no_wait_return;", "      verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      verbose_leave_scroll();", "      --no_wait_return;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (func_or_func_caller_profiling) {", "    ++fp->uf_tm_count;", "    call_start = profile_start();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  save_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12 && sourcing_name != NULL) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    }", "    /*", "     * The function call (or \"FuncUndefined\" autocommand sequence) might"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range))) {", "    /*", "     * Report an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function\" without argument: list functions."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      todo = (int)func_hashtab.ht_used;", "      for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", "          fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function /pat\": list functions matching pattern."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["        todo = (int)func_hashtab.ht_used;", "        for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "          if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["          if (!HASHITEM_EMPTY(hi)) {", "            --todo;", "            fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (*p == '/') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip) {", "    /*", "     * Return on an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    } else {", "      eap->skip = TRUE;", "    }"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  saved_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function name(arg1, arg2)\" Define function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])", "                                      : eval_isnamec(arg[j]))) {", "        ++j;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["                                      : eval_isnamec(arg[j]))) {", "        ++j;", "      }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        emsg_funcname(N_", "                        (\"E932: Closure function should not be at top level: %s\"),", "                      name == NULL ? (char_u *)\"\" : name);"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Read the body of the function, until \":endfunction\" is found."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * If there are no errors, add the function"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    xfree(name);", "    sprintf(numbuf, \"%d\", ++func_nr);", "    name = vim_strsave((char_u *)numbuf);"], "runtime/printf"]
["src/nvim/eval/userfunc.c", ["    if (done++ > 0) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  typval_T rettv;", "  int returning = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  } else {", "    current_funccal->returned = TRUE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  if (fcp->dbg_tick != debug_tick) {", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "                                          sourcing_lnum);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "/*", " * ex_cmds.c: some functions for command line commands"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["  } else {", "    /*", "     * if 'textwidth' set, use it"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  for (curwin->w_cursor.lnum = eap->line1;", "       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left) {              // left align"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    } else {", "      has_tab = FALSE;          // avoid uninit warnings", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      len = linelen(eap->cmdidx == CMD_right ? &has_tab", "                                             : NULL) - get_indent();", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Make sure that embedded TABs don't make the text go too far"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (linelen(NULL) <= width) {", "              /*", "               * Now try to move the line as much as possible to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            }", "            --new_indent;", "          }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  if (got_int) {", "    sort_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (i == count) {", "    for (i = 0; i < count; ++i) {", "      ml_delete(eap->line1, false);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * First we copy the old text to its new location -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we must be careful adjusting our marks so that we don't overlap our"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we delete the original text -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Leave the cursor on the last of the moved lines."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * there are three situations:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    ++line1;", "    if (curwin->w_cursor.lnum < line1) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line1) {", "      ++line1;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line2) {", "      ++line2;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                // :!", "    msg_scroll = FALSE;             // don't scroll here", "    autowrite_all();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Try to find an embedded bang, like in :!<cmd> ! [args]"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Scan the rest of the argument for '!', which is replaced by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * Add quotes around the command, for shells that need them."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * When using temp files:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * The writing and reading of temp files will not be shown."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  os_breakcheck();", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Put cursor on first filtered line for \":range!cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /*", "       * Put cursor on last new line for \":r !cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    beginline(BL_WHITE | BL_FIX);           // cursor on first non-blank", "    --no_wait_return;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor = cursor_save;", "    --no_wait_return;", "    wait_return(FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * For autocommands we want to get the output on the current screen, to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  msg_start();", "  silent_mode = FALSE;", "  info_message = true;  // use mch_msg(), not mch_errmsg()"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * The name of the current buffer will be changed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    other = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we have a new file, put its name in the list of alternate file names."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (!alt_buf->b_p_bl) {", "        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (retval == OK) {", "        curbuf->b_p_ro = FALSE;", "        redraw_tabline = true;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * write to other file or b_flags set or not writing the whole file:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          }", "          eap->forceit = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * Check if there is a reason the buffer cannot be written:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (not_writing()) {", "      ++error;", "      break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        // Set forceit, to force the writing of a readonly file", "        *forceit = TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        *forceit = TRUE;", "        return FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      } else {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (other) {", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * End Visual mode before switching to another buffer, so the text can be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we are starting to edit another file, open a (new) buffer."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Make the (new) buffer the one used by the current window."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          curbuf = buf;", "          ++curbuf->b_nwindows;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["          if (!oldbuf && eap != NULL) {", "            set_file_options(TRUE, eap);", "            set_forced_fenc(eap);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    // CTRL-O to go back to a help file.", "    set_buflisted(TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * other_file oldbuf"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we get here we are sure to start editing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if we are editing the w_arg_idx file in the argument list."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!auto_buf) {", "    /*", "     * Set cursor and init window before reading the file and executing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Careful: open_buffer() and apply_autocmds() may change the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open the buffer and read the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "                            &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.coladd = 0;", "        curwin->w_set_curswant = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Did not read the file, need to show some info about the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0) {", "      msg_scroll = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append) {", "    --lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ') {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      if (*p == ' ') {", "        ++vcol;", "      } else if (*p == TAB) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    xfree(theline);", "    ++lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY) {         // nothing to delete"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      || *kind == '^' || *kind == '.') {", "    ++x;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  while (*x == '-' || *x == '+') {", "    ++x;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    } else if (eap->addr_count == 0) {", "      ++start;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (joined_lines_count > 1) {", "      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);", "      sub_nsubs = joined_lines_count - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Small incompatibility: vi sees '\\n' as end of the command, but in"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * check for trailing command or garbage"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * The new text is build up step by step, to avoid too much"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Loop until nothing more to replace in this line."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.lnum = lnum;", "        do_again = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * 1. Match empty string does not count, except for first"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                                    + len_change;", "              highlight_match = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);", "              msg_no_more = FALSE;", "              msg_scroll = i;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace the line in the buffer when needed.  This is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (new_start != NULL) {", "            /*", "             * Copy the rest of the line, that didn't match."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (nmatch_tl > 0) {", "              /*", "               * Matched lines have now been substituted and are"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               */", "              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * 5. break if there isn't another match in this line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * Only report substitutions when:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * If there is already a preview window open, use that one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (!found_win) {", "      /*", "       * There is no preview window open yet.  Create one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap != NULL) {", "    /*", "     * A \":help\" command ends at the first LF, or at a '|' that is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if there is a match for the argument."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    // Find first item with the requested language.", "    for (i = 0; i < num_matches; ++i) {", "      len = (int)STRLEN(matches[i]);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Re-use an existing help window or open a new one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open help file (do_ecmd() will set b_help flag, readfile() will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                    NULL                  // buffer is still open, don't store info", "                    );", "      if (!cmdmod.keepalt) {"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Multiply the number of letters by 100 to give it a much bigger"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        /*", "         * Insert a backslash before a backslash after a slash, for search"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        else if (s[0] == '\\\\' && s[1] != '\\\\'", "                 && *arg == '/' && s == arg + 1) {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["    check_buf_options(curbuf);", "    (void)buf_init_chartab(curbuf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ts = 8;         // 'tabstop' is 8.", "  curwin->w_p_list = FALSE;   // No list mode.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.", "  curwin->w_p_nu = 0;         // No line numbers."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  RESET_BINDING(curwin);      // No scroll or cursor binding.", "  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  set_buflisted(FALSE);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * In the \"help.txt\" and \"help.abx\" file, add the locally added help"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!add_pathsep((char *)NameBuff)", "              || STRLCAT(NameBuff, \"doc/*.??[tx]\",", "                         sizeof(NameBuff)) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                  }", "                  ++s;", "                }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["          mix = !got_int;", "          got_int = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        }", "        ++p1;", "        ++p2;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++p1;", "        ++p2;", "      }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Loop over the found languages to generate a tags file for each one."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Structure used to store info for line position in a while or for loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Declare cmdnames[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;", "  dsp->vv_exception   = v_exception(NULL);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\".", "  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;", "}"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["        msg_col = 0;", "        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);", "        msg_clr_eos();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        // line number count", "  int did_inc = FALSE;                  // incremented RedrawingDisabled", "  int retval = OK;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (getline_is_func && ex_nesting_level == func_level(real_cookie)) {", "    ++ex_nesting_level;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Continue executing command lines:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 1. If repeating a line in a loop, get a line from lines_ga."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (next_cmdline == NULL) {", "      /*", "       * Need to set msg_didout for the first line after an \":if\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * Keep the first typed line.  Clear it when more lines are typed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Save the current line when inside a \":while\" or \":for\", and when"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (count++ == 0) {", "      /*", "       * All output from the commands is put below each other, without"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          // put messages below each other", "        ++no_wait_return;           // don't wait for return until finished"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          // put messages below each other", "        ++no_wait_return;           // don't wait for return until finished", "        ++RedrawingDisabled;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++no_wait_return;           // don't wait for return until finished", "        ++RedrawingDisabled;", "        did_inc = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++RedrawingDisabled;", "        did_inc = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 2. Execute one '|' separated command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        && !func_has_abort(real_cookie)) {", "      did_emsg = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      ++current_line;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * An \":endwhile\", \":endfor\" and \":continue\" is handled here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /*", "       * For a \":while\" or \":for\" we need to remember the line number."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       */", "      else if (cstack.cs_lflags & CSL_HAD_LOOP) {", "        cstack.cs_lflags &= ~CSL_HAD_LOOP;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When not inside any \":while\" loop, clear remembered lines."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * A \":finally\" makes did_emsg, got_int and current_exception pending for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Continue executing command lines when:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  while (!((got_int || (did_emsg && force_abort) || current_exception)", "           && cstack.cs_trylevel == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (cstack.cs_idx >= 0) {", "    /*", "     * If a sourced file or executed function ran to its end, report the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    do {", "      int idx = cleanup_conditionals(&cstack, 0, TRUE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0) {", "        --idx;              // remove try block not in its finally clause", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * If the uncaught exception is a user exception, report it as an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (getline_equal(fgetline, cookie, get_func_line)) {", "      --ex_nesting_level;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Go to debug mode when returning from a function in which we are"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      do_debug(getline_equal(fgetline, cookie, getsourceline)", "          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));", "    }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Restore the exception environment (done after returning from the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If there was too much output to fit on the command line, ask the user to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (did_inc) {", "    --RedrawingDisabled;", "    --no_wait_return;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --RedrawingDisabled;", "    --no_wait_return;", "    msg_scroll = FALSE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --no_wait_return;", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When just finished an \":if\"-\":else\" which was typed, no need to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (need_wait_return) {", "      /*", "       * The msg_start() above clears msg_didout. The wait_return we do"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      msg_didout |= msg_didout_before_start;", "      wait_return(FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      store_loop_line(cp->lines_gap, line);", "      ++cp->current_line;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++nr;", "    if (wp == win) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_TABS(tp) {", "    ++nr;", "    if (tp == tab) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["                        getnextac)) {", "    --quitmore;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Reset browse, confirm, etc..  They are restored when returning, for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (!ea.skip && got_int) {", "    ea.skip = TRUE;", "    (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. Parse the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip ':' and any white space"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If we got a line, but no command, then go to the line."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALNUM(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't complain about the range if it is not used"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip to start of argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"++opt=val\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) {  // :w !filter", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      // :r! filter if ea.forceit", "      ea.forceit = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.usefilter = TRUE;                      // :r! filter if ea.forceit", "      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              // :r !filter"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!') {              // :r !filter", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"+command\" argument, before checking for next command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for flags: 'l', 'p' and '#'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip the command when it's not going to be executed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Accept buffer name.  Cannot be used at the same time with a buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && !IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * :bdelete, :bwipeout and :bunload take several arguments, separated"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * Execute a user-defined command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /*", "     * Call the function to execute the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the command just executed called do_cmdline(), any throw or \":return\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (source_finished(fgetline, cookie)) {", "      do_finish(&ea, TRUE);", "    } else if (getline_equal(fgetline, cookie, get_func_line)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["               && current_func_returned()) {", "      do_return(&ea, TRUE, FALSE, NULL);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  need_rethrow = check_cstack = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  --ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_k;", "    ++p;", "  } else if (p[0] == 's'"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_substitute;", "    ++p;", "  } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALPHA(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p)) {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (i == len - 1) {", "        --len;", "        if (p[-1] == 'l') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL) {", "          *full = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p)) {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (k == len || (*np == NUL && ascii_isdigit(eap->cmd[k]))) {", "        /* If finding a second match, the command is ambiguous.  But", "         * not if a buffer-local command wasn't a full match and a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (!found || (k == len && *np == NUL)) {", "          /* If we matched up to a digit, then there could", "           * be another command including the digit that we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          }", "          /* Do not search for further abbreviations", "           * if this is an exact match. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["            if (full != NULL) {", "              *full = TRUE;", "            }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* The match we found may be followed immediately by a number.  Move \"p\"", "   * back to point to it. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 3. parse a range specifier of the form: addr [,addr] [;addr] .."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 4. parse command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. parse arguments"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Allow spaces within back-quotes to count as part of the argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /* An argument can contain just about everything, except", "       * characters that end the command and white space. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * characters that end the command and white space. */", "      else if (c == '|'", "               || c == '\\n'"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * If we are still inside the quotes, and we passed a space, just"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifndef BACKSLASH_IN_FILENAME", "      xp->xp_shell = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        xp->xp_context = EXPAND_USER;", "        ++xp->xp_pattern;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 6. switch on command name"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Command modifiers: return the argument.", "   * Also for commands with an argument that is a command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * All completion for the +cmdline_compl feature goes here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (*cmd++ == '\\\\' && *cmd != NUL) {", "          ++cmd;", "        }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*cmd != NUL) {", "      ++cmd;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '.':                               // '.' - Cursor position", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '$':                               // '$' - last line", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (skip) {", "        ++cmd;", "      } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        fp = getmark(*cmd, to_other_file && cmd[1] == NUL);", "        ++cmd;", "        if (fp == (pos_T *)-1) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        if (*cmd == c) {", "          ++cmd;", "        }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '\\\\':                      // \"\\?\", \"\\/\" or \"\\&\", repeat search", "      ++cmd;", "      if (addr_type != ADDR_LINES) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      }", "      ++cmd;", "      break;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't do it when \":vimgrep\" is used for \":grep\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Decide to expand wildcards *before* replacing '%', '#', etc.  If"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (*p == '`') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Quick check if this cannot be the start of a special string."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Try to find a match at this position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * One file argument: Expand wildcards."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (has_wildcards) {", "      /*", "       * May expand environment variables.  This"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Halve the number of backslashes (this is Vi compatible)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "    if (!has_wildcards)", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * The new command line is build in new_cmdline[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Copy the stuff before the expanded part."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["               // :redir @\" doesn't either.", "               (*p == '\"'", "                && !(eap->argt & EX_NOTRLCOM)"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["  if (*arg == '+') {        // +[command]", "    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      command = arg;", "      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (!unaccept_arg0 && relative == -1) {", "        --tab_number;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          // almost the same as mapping", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * If we are sourcing .exrc or .vimrc in current directory we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  // Search for the command in the already defined commands.", "  for (i = 0; i < gap->ga_len; ++i) {", "    size_t len;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    ++gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * List of names for completion for \":command\" with the EXPAND_ flag."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  --gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* When specified there is a single argument don't split it.", "     * Works for \":Cmd %\" when % is \"a b c\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    sprintf(num_buf, \"%\" PRId64, (int64_t)num);", "    num_len = STRLEN(num_buf);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Replace <> in the command by the arguments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      // Include the '>'", "      ++end;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  // Look for any argument part - which is the part after any ','", "  for (i = 0; i < vallen; ++i) {", "    if (value[i] == ',') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  close_others(TRUE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* Don't use 'suffixes' here.  This should work like the shell did the", "   * expansion.  Also, the vimrc file isn't read yet, thus the user"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i) {", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "              TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {", "    for (i = 0; i < count; ++i) {", "      if (got_int) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (got_int) {", "        /* When adding many buffers this can take a long time.  Allow", "         * interrupting here. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* May set buffer name of a buffer previously used for the", "       * argument list, so that it's re-used by alist_add. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  ++al->al_ga.ga_len;", "}"], "readability/increment"]
["src/nvim/ex_docmd.c", ["{", "  for (int i = 0; i < GARGCOUNT; ++i) {", "    if (GARGLIST[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (wp->w_alist != &global_alist) {", "      for (int i = 0; i < WARGCOUNT(wp); ++i) {", "        if (WARGLIST(wp)[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Either open new tab page or split the window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  msg_start();", "  msg_scroll = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * \":vi\" command ends Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * if \":split file\" worked, set alternate file name in old window to new"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * determine max topline"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Set all scrollbind windows to the same topline."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (y > 0) {", "        scrollup(y, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        scrolldown(-y, TRUE);", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      cursor_correct();", "      curwin->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ex_pwd(NULL);", "  } else", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  case NUL:", "    len *= 1000L; break;", "  default:"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  default:", "    semsg(_(e_invarg2), eap->arg); return;", "  }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    }", "    op_shift(&oa, FALSE, eap->amount);", "    break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    eap->line2 = 1;", "    eap->forceit = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    ++eap->line2;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Execute from the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case 's':", "      ++p; sec = true; break;", "    case 'm':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 's':", "      ++p; sec = true; break;", "    case 'm':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'm':", "      ++p; sec = true; count *= 60; break;", "    case 'h':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'm':", "      ++p; sec = true; count *= 60; break;", "    case 'h':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'h':", "      ++p; sec = true; count *= 60 * 60; break;", "    case 'd':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'h':", "      ++p; sec = true; count *= 60 * 60; break;", "    case 'd':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'd':", "      ++p; sec = true; count *= 24 * 60 * 60; break;", "    case 'f':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'd':", "      ++p; sec = true; count *= 24 * 60 * 60; break;", "    case 'f':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'f':", "      ++p; file = true; break;", "    }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'f':", "      ++p; file = true; break;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*arg == '>') {", "      ++arg;", "      if (*arg == '>') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        mode = \"a\";"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      close_redir();", "      ++arg;", "      if (valid_yank_reg(*arg, true) && *arg != '_') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        append = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++arg;", "        append = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        append = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  validate_cursor();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  update_screen(eap->forceit ? NOT_VALID", "                             : VIsual_active ? INVERTED : 0);", "  if (need_maketitle) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  if (eap->forceit) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  for (size_t i = 0; i < ARRAY_SIZE(spec_str); ++i) {", "    len = STRLEN(spec_str[i]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (escaped != NULL) {", "    *escaped = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check if there is something to do."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip when preceded with a backslash \"\\%\" and \"\\#\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * word or WORD under cursor"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                                        spec_idx == SPEC_CWORD", "        ? (FIND_IDENT | FIND_STRING)", "        : (spec_idx == SPEC_CEXPR"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        ? (FIND_IDENT | FIND_STRING)", "        : (spec_idx == SPEC_CEXPR", "           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        if (escaped != NULL) {", "          *escaped = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Do this loop two times:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        }", "        ++len;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(p, \"<sfile>\", 7) != 0) {", "      ++p;", "    } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  // First set the marks for all lines closed/open.", "  for (linenr_T lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed)) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 0:", "      arg[0] = '0'; break;", "    case (EX_EXTRA):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA):", "      arg[0] = '*'; break;", "    case (EX_EXTRA | EX_NOSPC):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NOSPC):", "      arg[0] = '?'; break;", "    case (EX_EXTRA | EX_NEEDARG):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NEEDARG):", "      arg[0] = '+'; break;", "    case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):", "      arg[0] = '1'; break;", "    }"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["", "/*", " * When several errors appear in a row, setting \"force_abort\" is delayed until"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", [" */", "static int cause_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Do nothing when displaying the interrupt message or reporting an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If emsg() has not been called previously, temporarily reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    cause_abort = force_abort;", "    force_abort = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If no try conditional is active and no exception is being thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ignore an interrupt message when inside a try conditional or when an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  cause_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When an exception is being thrown, some commands (like conditionals) are"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (!THROW_ON_ERROR) {", "    /*", "     * Print error message immediately without searching for a matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  {", "    /*", "     * Prepare the throw of an error exception, so that everything will"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    cause_abort = FALSE;", "    force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = FALSE;", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    } else {", "      need_rethrow = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Disallow faking Interrupt or error exceptions as user exceptions.  They"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    --no_wait_return;", "    if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    smsg(was_finished ? _(\"Exception finished: %s\")", "                      : _(\"Exception discarded: %s\"),", "         excp->value);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    --no_wait_return;", "    if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * Flags specifying the message displayed by report_pending."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0) {", "    msg_silent = FALSE;         // display messages", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  ++no_wait_return;", "  msg_scroll = TRUE;            // always scroll up, don't overwrite"], "readability/increment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            // always scroll up, don't overwrite", "  smsg(mesg, s);"], "readability/bool"]
["src/nvim/ex_eval.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "  if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["  } else {", "    ++cstack->cs_idx;", "    cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "    --eap->cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["  } else {", "    /*", "     * The loop flag is set when we have jumped back from the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if ((cstack->cs_lflags & CSL_HAD_LOOP) == 0) {", "      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;", "      cstack->cs_line[cstack->cs_idx] = -1;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (eap->cmdidx == CMD_while) {", "      /*", "       * \":while bool-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":for var in list-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        fi = cstack->cs_forinfo[cstack->cs_idx];", "        error = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      } else {", "        result = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If this cstack entry was just initialised and is active, set the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_CONT, so do_cmdline() will jump back to the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      // Try to find the matching \":while\" and report what's missing.", "      for (idx = cstack->cs_idx; idx > 0; --idx) {", "        fl =  cstack->cs_flags[idx];"], "readability/increment"]
["src/nvim/ex_eval.c", ["      // Cleanup and rewind all contained (and unclosed) conditionals.", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "      rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Set loop flag, so do_cmdline() will jump back to the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int inactivate_try = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (did_emsg && !THROW_ON_ERROR) {", "    inactivate_try = TRUE;", "    did_emsg = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (got_int && !THROW_ON_INTERRUPT) {", "    inactivate_try = TRUE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (idx >= 0) {", "    /*", "     * If this try conditional is active and we are before its first"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  } else {", "    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;", "    cstack->cs_flags[cstack->cs_idx] = CSF_TRY;"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":silent!\", even when used in a try conditional, disables"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx) {", "      if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["  if (!give_up) {", "    /*", "     * Don't do something when no exception has been thrown or when the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Check for a match only if an exception is thrown but not caught by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int idx;", "  int skip = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx) {", "        if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Don't do something when the corresponding try block never got active"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, FALSE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Make did_emsg, got_int, current_exception pending.  If set, they"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If an exception is being thrown, discard it to prevent it from"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If we stopped with the exception currently being thrown at this"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If a \":return\" is pending, we need to resume it after closing the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Discard anything pending on an error, interrupt, or throw in the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_RETURN:", "        do_return(eap, FALSE, FALSE, rettv);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_FINISH:", "        do_finish(eap, FALSE);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * enter_cleanup() and leave_cleanup()"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Postpone did_emsg, got_int, current_exception.  The pending values will be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        force_abort |= cause_abort;", "        cause_abort = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  /*", "   * If there was no new error, interrupt, or throw between the calls"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * If there was an exception being thrown when enter_cleanup() was"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cause_abort = force_abort;", "      force_abort = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int idx;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  for (idx = cstack->cs_idx; idx >= 0; --idx) {", "    if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_TRY) {", "      /*", "       * Discard anything pending in a finally clause and continue the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Stop at a try conditional not in its finally clause.  If this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          }", "          stop = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_eval.c", ["      }", "      stop = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * When leaving a try conditional that reset \"emsg_silent\" on its"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[cstack->cs_idx] & cond_type) {", "      --*cond_level;", "    }"], "readability/increment"]
["src/nvim/ex_eval.c", ["    }", "    --cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["    while (*p == ' ' || *p == '\\t' || *p == ':') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_eval.c", ["      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r')) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_eval.h", ["", "/* There is no CSF_IF, the lack of CSF_WHILE, CSF_FOR and CSF_TRY means \":if\"", " * was used. */"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * What's pending for being reactivated at the \":endtry\" of this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * A list of error messages that can be converted to an exception.  \"throw_msg\""], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * Structure describing an exception."], "readability/old_style_comment"]
["src/nvim/ex_eval.h", ["", "/*", " * Structure to save the error/interrupt/exception state between calls to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * ex_getln.c: Functions for entering and editing an Ex command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Variables shared between getcmdline(), redrawcmdline() and others."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Type used by call_user_expand_func"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      case K_RIGHT:", "        s->c = K_LEFT; break;", "      case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_S_RIGHT:", "        s->c = K_S_LEFT; break;", "      case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_C_RIGHT:", "        s->c = K_C_LEFT; break;", "      case K_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_LEFT:", "        s->c = K_RIGHT; break;", "      case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_S_LEFT:", "        s->c = K_S_RIGHT; break;", "      case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["      case K_C_LEFT:", "        s->c = K_C_RIGHT; break;", "      }"], "whitespace/newline"]
["src/nvim/ex_getln.c", ["    if (s->wim_index < 3) {", "      ++s->wim_index;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (s->c == K_DEL && ccline.cmdpos != ccline.cmdlen) {", "      ++ccline.cmdpos;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["                }", "                ++len;", "              }"], "readability/increment"]
["src/nvim/ex_getln.c", ["            }", "            ++len;", "          }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE when the text must not be changed and we can't switch to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (cmdwin_type != 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Give an error message for a command that isn't allowed while the cmdline"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Allocate a new command line buffer."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["{", "  /*", "   * give some extra space to avoid having to allocate all the time"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Re-allocate the command line to length len + something extra."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    const varnumber_T start = (", "                               tv_get_number_chk(TV_LIST_ITEM_TV(tv_list_first(l)), &error));", "    if (error) {"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["", "/*", " * Draw part of the cmdline at the current cursor position.  But draw stars"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a character on the command line.  Shifts the following text to the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put the given string, of the given length, onto the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        msg_col += Columns;", "        --msg_row;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (redraw && !cmd_silent) {", "    msg_no_more = TRUE;", "    i = cmdline_row;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    }", "    msg_no_more = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a string on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (literally) {", "    put_on_cmdline(s, -1, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Redraw what is currently on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  // Don't use more prompt, truncate the cmdline if it doesn't fit.", "  msg_no_more = TRUE;", "  draw_cmdline(0, ccline.cmdlen);"], "readability/bool"]
["src/nvim/ex_getln.c", ["  msg_clr_eos();", "  msg_no_more = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * An emsg() before may have set msg_scroll. This is used in normal mode,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["   */", "  msg_scroll = FALSE;           // next message overwrites cmdline", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Check the word in front of the cursor for an abbreviation."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    const int use_options = (", "                             options", "                             | WILD_HOME_REPLACE"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             options", "                             | WILD_HOME_REPLACE", "                             | WILD_ADD_SLASH"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_HOME_REPLACE", "                             | WILD_ADD_SLASH", "                             | WILD_SILENT"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_ADD_SLASH", "                             | WILD_SILENT", "                             | (escape ? WILD_ESCAPE : 0)"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | WILD_SILENT", "                             | (escape ? WILD_ESCAPE : 0)", "                             | (p_wic ? WILD_ICASE : 0));"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["                             | (escape ? WILD_ESCAPE : 0)", "                             | (p_wic ? WILD_ICASE : 0));", "    p2 = ExpandOne(xp, p1, vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),"], "whitespace/indent"]
["src/nvim/ex_getln.c", ["", "  /* When expanding a \":map\" command and no matches are found, assume that", "   * the key is supposed to be inserted literally */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  static char_u *orig_save = NULL;      // kept value of orig", "  int orig_saved = FALSE;", "  int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * first handle the case of using an old match"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        }", "        --findex;", "      } else {  // mode == WILD_NEXT"], "readability/increment"]
["src/nvim/ex_getln.c", ["      } else {  // mode == WILD_NEXT", "        ++findex;", "      }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * When wrapping around, return the original string, set findex to"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    orig_save = orig;", "    orig_saved = TRUE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Do the expansion."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["#ifdef FNAME_ILLEGAL", "      /* Illegal file name has been silently skipped.  But when there", "       * are wildcards, the real problem is that there was no match,"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /*", "       * Check for matching suffixes in file names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["            && xp->xp_numfiles > 1) {", "          /*", "           * More than one match; check suffix."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (non_suf_match != 1) {", "          /* Can we ever get here unless it's while expanding", "           * interactively?  If not, we can get rid of this all"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    size_t len = 0;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      len += STRLEN(xp->xp_files[i]) + 1;"], "readability/increment"]
["src/nvim/ex_getln.c", ["    *ss = NUL;", "    for (i = 0; i < xp->xp_numfiles; ++i) {", "      STRCAT(ss, xp->xp_files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Prepare an expand structure for use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Cleanup an expand structure after use."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * May change home directory back to \"~\""], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        || xp->xp_context == EXPAND_DIRECTORIES) {", "      /*", "       * Insert a backslash into a file name before a space, \\, %, #"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        // for \":set path=\" we need to escape spaces twice"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "        /* If 'str' starts with \"\\~\", replace \"~\" at start of", "         * files[i] with \"\\~\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "      /* If the first file starts with a '+' escape it.  Otherwise it", "       * could be seen as \"+cmd\". */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (xp->xp_context == EXPAND_TAGS) {", "      /*", "       * Insert a backslash before characters in a tag name that"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["       */", "      for (i = 0; i < numfiles; ++i) {", "        p = vim_strsave_escaped(files[i], (char_u *)\"\\\\|\\\"\");"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Put a backslash before the file name in \"pp\", which is in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * For each file name in files[num_files]:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (orig_pat[0] == '~' && vim_ispathsep(orig_pat[1])) {", "    for (i = 0; i < num_files; ++i) {", "      p = home_replace_save(NULL, files[i]);"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Show all matches for completion on the command line."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    maxlen = 0;", "    for (i = 0; i < num_files; ++i) {", "      if (!showtail && (xp->xp_context == EXPAND_FILES"], "readability/increment"]
["src/nvim/ex_getln.c", ["                        || xp->xp_context == EXPAND_BUFFERS)) {", "        home_replace(NULL, files_found[i], NameBuff, MAXPATHL, TRUE);", "        j = vim_strsize(NameBuff);"], "readability/bool"]
["src/nvim/ex_getln.c", ["    // list the files line by line", "    for (i = 0; i < lines; ++i) {", "      lastlen = 999;"], "readability/increment"]
["src/nvim/ex_getln.c", ["            home_replace(NULL, files_found[k], NameBuff, MAXPATHL,", "                         TRUE);", "            p = NameBuff;"], "readability/bool"]
["src/nvim/ex_getln.c", ["        } else {", "          j = FALSE;", "          p = L_SHOWFILE(k);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      if (got_int) {", "        got_int = FALSE;", "        break;"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /*", "     * we redraw the command below the lines that we have just listed"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Private path_tail for showmatches() (and win_redr_status_matches()):"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  char_u *t = s;", "  int had_sep = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["      t = p;", "      had_sep = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Return TRUE if we only need to show the tail of completion matches."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      && xp->xp_context != EXPAND_DIRECTORIES) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["  }", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["      && context != EXPAND_DIRECTORIES) {", "    /*", "     * Matching will be done internally (on something other than files)."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~') {", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/multiline_comment"]
["src/nvim/ex_getln.c", ["        if (fname[i] == '*' || fname[i] == '~') {", "          new_len++;                    /* '*' needs to be replaced by \".*\"", "                                           '~' needs to be replaced by \"\\~\" */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        }", "        /* Custom expansion takes care of special things, match", "         * backslashes literally (perhaps also for other types?) */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["        for (i = 0; i < len; i++, j++) {", "          /* Skip backslash.  But why?  At least keep it for custom", "           * expansion. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Don't add a star to *, ~, ~user, $var or `cmd`."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    } else if (len > 0 && retval[len - 1] == '$') {", "      --len;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Must parse the command line so far to work out what context we are in."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Avoid a UMR warning from Purify, only save the character if it has been"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Store the string here so that call_user_expand_func() can get to them", "   * easily. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      || xp->xp_context == EXPAND_FILES_IN_PATH) {", "    /*", "     * Expand file or directory names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["     */", "    int free_pat = FALSE;", "    int i;"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (xp->xp_backslash != XP_BS_NONE) {", "      free_pat = TRUE;", "      pat = vim_strsave(pat);"], "readability/bool"]
["src/nvim/ex_getln.c", ["      pat = vim_strsave(pat);", "      for (i = 0; pat[i]; ++i) {", "        if (pat[i] == '\\\\') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["  if (xp->xp_context == EXPAND_HELP) {", "    /* With an empty argument we would get all the help tags, which is", "     * very slow.  Get matches for \"help\" instead. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "    /*", "     * Find a context in the table and call the ExpandGeneric() with the"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    ret = FAIL;", "    for (i = 0; i < (int)ARRAY_SIZE(tab); ++i) {", "      if (xp->xp_context == tab[i].context) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["        if (tab[i].ic) {", "          regmatch.rm_ic = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (vim_regexec(regmatch, str, (colnr_T)0)) {", "      ++count;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["      // <SNR> functions should be sorted to the end.", "      qsort((void *)*file, (size_t)*num_file, sizeof(char_u *),", "            sort_func_compare);"], "whitespace/operators"]
["src/nvim/ex_getln.c", ["", "  /* Reset the variables used for special highlight names expansion, so that", "   * they don't show up when getting normal highlight names by ID. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  pat = vim_strsave(filepat);", "  for (i = 0; pat[i]; ++i) {", "    if (pat[i] == '\\\\' && pat[i + 1] == ' ') {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Go over all directories in $PATH.  Expand matches in that directory and"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["    if (*e != NUL) {", "      ++e;", "    }"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Expand names with a list returned by a function defined by the user."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  /* Sort and remove duplicates which can happen when specifying multiple", "   * directories in dirnames. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*********************************", "*  Command line history stuff    *"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Table of history names."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible first"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (hisidx[type] < 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["    if (history[type][i].hisstr == NULL) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "    /* For search history, check that the separator character matches as", "     * well. */"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      if (!move_to_front) {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Searches inside the same mapping overwrite each other, so that only"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["      hist_free_entry(hisptr);", "      --hisnum[histype];", "      if (--hisidx[HIST_SEARCH] < 0) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get identifier of newest history entry."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line in allocated memory."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command line position, counted in bytes."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Set the command line byte position to \"pos\".  Zero is the first position."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Get the current command-line type."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Calculate history index from a number:"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *hist;", "  int wrapped = FALSE;", ""], "readability/bool"]
["src/nvim/ex_getln.c", ["        i += hislen;", "        wrapped = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Get a history entry by its index."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove all entries matching {str} from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  regmatch.regprog = NULL;", "  regmatch.rm_ic = FALSE;       // always match case", "  if (hislen != 0"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * Remove an indexed entry from a history."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  if (i < 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "  /* When deleting the last added search string in a mapping, reset", "   * last_maptick, so that the last added search string isn't deleted again."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  hisidx[histype] = i;", "  return TRUE;", "}"], "readability/bool"]
["src/nvim/ex_getln.c", ["", "/*", " * :history command - print a history"], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["", "  for (; !got_int && histype1 <= histype2; ++histype1) {", "    STRCPY(IObuff, \"\\n      #  \");"], "readability/increment"]
["src/nvim/ex_getln.c", ["    if (idx >= 0 && j <= k) {", "      for (i = idx + 1; !got_int; ++i) {", "        if (i == hislen) {"], "readability/increment"]
["src/nvim/ex_getln.c", ["", "  /*", "   * Call the main loop until <CR> or CTRL-C is typed."], "readability/old_style_comment"]
["src/nvim/ex_getln.c", ["  histentry_T *const hlast = (", "                              &(history[history_type][hisidx[history_type]]));", "  const histentry_T *const hend = &(history[history_type][hislen - 1]);"], "whitespace/indent"]
["src/nvim/extmark.c", ["  static Map(uint64_t, ssize_t) delete_set = MAP_INIT;", "  typedef struct { int row1; } DecorItem;", "  static kvec_t(DecorItem) decors;"], "whitespace/newline"]
["src/nvim/file_search.c", ["", "/*", " * type for the directory search stack"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* the fix part (no wildcards) and the part containing the wildcards", "   * of the search path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* files/dirs found in the above directory, matched by the first wildcard", "   * of wc_part"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* to store status of partly handled directories", "   * 0: we work on this directory for the first time"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* How deep are we in the directory tree?", "   * Counts backward from value of level parameter to vim_findfile_init"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * type for already visited directories or files."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Visited directories are different if the wildcard string are", "   * different. So we have to save it."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  FileID file_id;", "  /* The memory for this struct is allocated according to the length of", "   * ffv_fname."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * We might have to manage several visited lists during a search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * '**' can be expanded to several directory levels."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "/*", " * The search context:"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* If a search context is given by the caller, reuse it, else allocate a", "   * new one."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  // clear visited list if wanted", "  if (free_visited == TRUE) {", "    vim_findfile_free_visited(search_ctx);"], "readability/bool"]
["src/nvim/file_search.c", ["  } else {", "    /* Reuse old visited lists. Get the visited list for the given", "     * filename. If no list for the current filename exists, creates a new"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* Store information on starting dir now if path is relative.", "   * If path is absolute, we do that later.  */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      STRLCPY(ff_expand_buffer, rel_fname, len + 1);", "      search_ctx->ffsc_start_dir = (char_u *)FullName_save((char *)ff_expand_buffer, FALSE);", "    } else {"], "readability/bool"]
["src/nvim/file_search.c", ["    if (*++path != NUL) {", "      ++path;", "    }"], "readability/increment"]
["src/nvim/file_search.c", ["      path += 2;", "    } else", "#endif"], "readability/braces"]
["src/nvim/file_search.c", ["#ifdef BACKSLASH_IN_FILENAME", "    /* A path that starts with \"/dir\" is relative to the drive, not to the", "     * directory (but not for \"//machine/dir\").  Only use the drive name. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * If stopdirs are given, split them into an array of pointers."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["      } else {", "        /* this might be \"\", which means ascent till top", "         * of directory tree."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /* split into:", "   *  -fix path"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /*", "     * copy wc_path and add restricts to the '**' wildcard."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          semsg(_(", "                 \"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"),", "                PATHSEPSTR);"], "whitespace/indent"]
["src/nvim/file_search.c", ["  if (search_ctx->ffsc_start_dir == NULL) {", "    /* store the fix part as startdir.", "     * This is needed if the parameter path is fully qualified."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["error_return:", "  /*", "   * We clear the search context now!"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    if (r_ptr[0] == '\\\\' && r_ptr[1] == ';') {", "      /* Overwrite the escape char,", "       * use STRLEN(r_ptr) to move the trailing '\\0'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * filepath is used as buffer for various actions and as the storage to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["    path_end = &search_ctx->ffsc_start_dir[", "                                           STRLEN(search_ctx->ffsc_start_dir)];", "  }"], "whitespace/indent"]
["src/nvim/file_search.c", ["", "      /*", "       * TODO: decide if we leave this test in"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                              stackp->ffs_wc_path", "                              ) == FAIL) {", "#ifdef FF_VERBOSE"], "whitespace/parens"]
["src/nvim/file_search.c", ["#ifdef FF_VERBOSE", "      else if (p_verbose >= 5) {", "        verbose_enter_scroll();"], "readability/braces"]
["src/nvim/file_search.c", ["", "      /*", "       * If no filearray till now expand wildcards"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /* we use filepath to build the path expand_wildcards() should", "         * expand."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "          /*", "           * Here we copy until the next path separator or the end of"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "        /*", "         * Expand wildcards like \"*\" and \"$VAR\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        } else {", "          /* Add EW_NOTWILD because the expanded path may contain", "           * wildcard characters that are to be taken literally."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        rest_of_wildcards = &stackp->ffs_wc_path[", "                                                 STRLEN(stackp->ffs_wc_path)];", "      }"], "whitespace/indent"]
["src/nvim/file_search.c", ["        if (*rest_of_wildcards == NUL) {", "          /*", "           * We don't have further wildcards to expand, so we have to"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!path_with_url((char *)stackp->ffs_filearray[i])"], "readability/increment"]
["src/nvim/file_search.c", ["", "            /*", "             * Try without extra suffix and then with suffixes"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                                       (char_u *)\"\"", "                                       ) == OK)", "#endif"], "whitespace/parens"]
["src/nvim/file_search.c", ["                                     (char_u *)\"\"", "                                     ) == FAIL) {", "                  if (p_verbose >= 5) {"], "whitespace/parens"]
["src/nvim/file_search.c", ["        } else {", "          /*", "           * still wildcards left, push the directories for further"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          for (int i = stackp->ffs_filearray_cur;", "               i < stackp->ffs_filearray_size; ++i) {", "            if (!os_isdir(stackp->ffs_filearray[i])) {"], "readability/increment"]
["src/nvim/file_search.c", ["", "      /*", "       * if wildcards contains '**' we have to descent till we reach the"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "    /* If we reached this, we didn't find anything downwards.", "     * Let's check if we should do an upward search."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["                              (int)(path_end - search_ctx->ffsc_start_dir),", "                              search_ctx->ffsc_stopdirs_v) == TRUE) {", "        break;"], "readability/bool"]
["src/nvim/file_search.c", ["", "  /*", "   * if we reach this we didn't find a list and we have to allocate new list"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["", "  /*", "   * New file/dir.  Add it to the list of visited files/dirs."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["{", "  /* check for NULL pointer, not to return an error to the user, but", "   * to prevent a crash */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  if (path_len == 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/file_search.c", ["    if ((int)STRLEN(stopdirs_v[i]) > path_len) {", "      /* match for parent directory. So '/home' also matches", "       * '/home/rks'. Check for PATHSEP in stopdirs_v[i], else"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["          && vim_ispathsep(stopdirs_v[i][path_len])) {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/file_search.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/file_search.c", ["{", "  return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,", "                                  FINDFILE_DIR, rel_fname, (char_u *)\"\");"], "readability/bool"]
["src/nvim/file_search.c", ["  static char_u *dir;", "  static int did_findfile_init = FALSE;", "  char_u save_char;"], "readability/bool"]
["src/nvim/file_search.c", ["      // Change all \"\\ \" to \" \".", "      for (ptr = ff_file_to_find; *ptr != NUL; ++ptr) {", "        if (ptr[0] == '\\\\' && ptr[1] == ' ') {"], "readability/increment"]
["src/nvim/file_search.c", ["      ) {", "    /*", "     * Absolute path, no need to use \"path_option\"."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      if (path_with_url((char *)ff_file_to_find)) {"], "readability/bool"]
["src/nvim/file_search.c", ["", "      /* When FNAME_REL flag given first use the directory of the file.", "       * Otherwise or when this fails use the current directory. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["       * Otherwise or when this fails use the current directory. */", "      for (int run = 1; run <= 2; ++run) {", "        size_t l = STRLEN(ff_file_to_find);"], "readability/increment"]
["src/nvim/file_search.c", ["", "        /* When the file doesn't exist, try adding parts of", "         * 'suffixesadd'. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["  } else {", "    /*", "     * Loop over all paths in the 'path' or 'cdpath' option."], "readability/old_style_comment"]
["src/nvim/file_search.c", ["     */", "    if (first == TRUE) {", "      // vim_findfile_free_visited can handle a possible NULL pointer"], "readability/bool"]
["src/nvim/file_search.c", ["      dir = path_option;", "      did_findfile_init = FALSE;", "    }"], "readability/bool"]
["src/nvim/file_search.c", ["", "        did_findfile_init = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (dir == NULL || *dir == NUL) {", "          /* We searched all paths of the option, now we can", "           * free the search context. */"], "readability/old_style_comment"]
["src/nvim/file_search.c", ["        fdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,", "                                            r_ptr, 100, FALSE, find_what,", "                                            fdip_search_ctx, FALSE, rel_fname);"], "readability/bool"]
["src/nvim/file_search.c", ["                                            r_ptr, 100, FALSE, find_what,", "                                            fdip_search_ctx, FALSE, rel_fname);", "        if (fdip_search_ctx != NULL) {"], "readability/bool"]
["src/nvim/file_search.c", ["        if (fdip_search_ctx != NULL) {", "          did_findfile_init = TRUE;", "        }"], "readability/bool"]
["src/nvim/file_search.c", ["  if (file_name == NULL && (options & FNAME_MESS)) {", "    if (first == TRUE) {", "      if (find_what == FINDFILE_DIR) {"], "readability/bool"]
["src/nvim/fileio.c", ["", "/* When converting, a read() or write() may leave some bytes to be converted", " * for the next call.  The value is guessed... */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* We have to guess how much a sequence of bytes may expand when converting", " * with iconv() to be able to allocate a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Structure to pass arguments from buf_write() to buf_write_bytes()."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0) {", "    msg_scroll = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  // may truncate the message to avoid a hit-return prompt", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the read file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0) {", "    msg_scroll = FALSE;         // overwrite previous file message", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    msg_scroll = TRUE;          // don't overwrite previous file message", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file we take the readonly flag from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (check_readonly && !readonlymode) {", "    curbuf->b_p_ro = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef UNIX", "      /*", "       * Use the protection bits of the original file for the swap file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Only set the 'ro' flag for readonly files the first time they are"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((check_readonly && file_readonly) || curbuf->b_help) {", "    curbuf->b_p_ro = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (!read_buffer) {", "      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         // don't wait for return yet", ""], "readability/increment"]
["src/nvim/fileio.c", ["    if (aborting()) {       // autocmds may abort script processing", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            // must use \"w!\" now", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /*", "     * Don't allow the autocommands to change the current buffer."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      curbuf->b_p_ro = TRUE;            // must use \"w!\" now", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   // overwrite the file message", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Set linecnt now, before the \"retry\" caused by a wrong guess for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Decide which 'encoding' to use or use first."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Jump back here to retry reading the file in different ways."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When retrying with another \"fenc\" and the first time \"fileformat\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat_force(curbuf, eap);", "      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin) {"], "readability/bool"]
["src/nvim/fileio.c", ["  if (advance_fenc) {", "    /*", "     * Try the next entry in 'fileencodings'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Conversion may be required when the encoding of the file is different"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Use the 'charconvert' expression when conversion is required"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  while (!error && !got_int) {", "    /*", "     * We allocate as much space for the file as we can get, plus"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (read_buffer) {", "          /*", "           * Read bytes from curbuf.  Used for converting text read"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                n = (int)(size - tlen);", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL) {"], "readability/increment"]
["src/nvim/fileio.c", ["        } else {", "          /*", "           * Read bytes from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          } else if (conv_restlen > 0) {", "            /*", "             * Reached end-of-file but some trailing bytes could"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            // Remember the first linenr with an illegal byte", "            else if (illegal_byte == 0) {", "              illegal_byte = curbuf->b_ml.ml_line_count"], "whitespace/newline"]
["src/nvim/fileio.c", ["#endif", "                                                    )) {", "                while (conv_restlen > 0) {"], "whitespace/parens"]
["src/nvim/fileio.c", ["                  *(--ptr) = bad_char_behavior;", "                  --conv_restlen;", "                }"], "readability/increment"]
["src/nvim/fileio.c", ["", "      /*", "       * At start of file: Check for BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (set_options) {", "            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["      conv_restlen = 0;", "      /*", "       * Break here for a read error or end-of-file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (iconv_fd != (iconv_t)-1) {", "        /*", "         * Attempt conversion of the read bytes to 'encoding' using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * If there is conversion error or not enough room try using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          // Deal with a bad byte and continue with the next.", "          ++fromp;", "          --from_size;"], "readability/increment"]
["src/nvim/fileio.c", ["          ++fromp;", "          --from_size;", "          if (bad_char_behavior == BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = *(fromp - 1);", "            --to_size;", "          } else if (bad_char_behavior != BAD_DROP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = bad_char_behavior;", "            --to_size;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["            while (tail > ptr && (*tail & 0xc0) == 0x80) {", "              --tail;", "            }"], "readability/increment"]
["src/nvim/fileio.c", ["                memmove(p, p + 1, todo - 1);", "                --p;", "                --size;"], "readability/increment"]
["src/nvim/fileio.c", ["                --p;", "                --size;", "              } else if (bad_char_behavior != BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["", "      /*", "       * when reading the first part of a file: guess EOL type"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * This loop is executed once for every character read."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (fileformat == EOL_MAC) {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            }", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["          } else {", "            --skip_count;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["    } else {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            }", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["          } else {", "            --skip_count;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we get EOF in the middle of a line, note the fact and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_eol = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     // may wait for return now", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * In recovery mode everything but autocommands is skipped."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * If we were reading from the same terminal as where messages go,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (newfile) {", "          curbuf->b_p_ro = TRUE;                // must use \"w!\" now", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[character special]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        msg_add_eol();", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[CR missing]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[NOT converted]\"));", "        c = TRUE;", "      } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[converted]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (conv_error != 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);"], "runtime/printf"]
["src/nvim/fileio.c", ["                _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;", "      } else if (illegal_byte > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else if (illegal_byte > 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);"], "runtime/printf"]
["src/nvim/fileio.c", ["                _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;", "      } else if (error) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[READ ERRORS]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (msg_add_fileformat(fileformat)) {", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)", "                    )) {", "      curbuf->b_p_ro = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["                    )) {", "      curbuf->b_p_ro = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * In Ex mode: cursor at last new line."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Get the marks before executing autocommands, so they can be used there."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * We remember if the last line of the read didn't have"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file locate undo info and read it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * The output from the autocommands should not overwrite anything and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s) {", "    if (*s == '\\n') {"], "readability/increment"]
["src/nvim/fileio.c", ["    if (*s == '\\n') {", "      ++lnum;", "    }"], "readability/increment"]
["src/nvim/fileio.c", ["  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;", "  eap->read_edit = FALSE;", "  eap->forceit = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  eap->read_edit = FALSE;", "  eap->forceit = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Always set b_marks_read; needed when 'shada' is changed to include", "   * the ' parameter after opening a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                // 'w' bit has been set", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#endif", "  int write_undo_file = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (buf->b_ml.ml_mfp == NULL) {", "    /* This can happen during startup when there is a stray \"w\" in the", "     * vimrc file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Disallow writing from .exrc and .vimrc in current directory for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  write_info.bw_conv_buf = NULL;", "  write_info.bw_conv_error = FALSE;", "  write_info.bw_conv_error_lnum = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* After writing a file changedtick changes but we don't want to display", "   * the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the written file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  } else {", "    overwriting = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 // don't wait for return yet", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ and '] marks to the lines to be written."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    aco_save_T aco;", "    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;", "    int nofile_err = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int did_cmd = FALSE;", "    int nofile_err = FALSE;", "    int empty_memline = (buf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply PRE autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                                           sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf)) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "                           NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole) {"], "readability/bool"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "                                     sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (was_changed && !curbufIsChanged()) {", "          /* Written everything correctly and BufWriteCmd has reset", "           * 'modified': Correct the undo information so that an"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                                           sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf)) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["          || aborting()) {", "        /* An aborting error, interrupt or exception in the", "         * autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (buf == NULL) {", "          /* The buffer was deleted.  We assume it was written", "           * (can't retry anyway). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the number of lines in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (end < start) {", "          --no_wait_return;", "          msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the name of the buffer, which may"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting) {", "    msg_scroll = FALSE;             // overwrite previous file message", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    msg_scroll = TRUE;              // don't overwrite previous file message", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  msg_scroll = FALSE;               // always overwrite the file message now", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Get information about original file (if there is one)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      /* It's a device of some kind (or a fifo) which we can write to", "       * but for which we can't make a backup. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * but for which we can't make a backup. */", "      device = TRUE;", "      newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      device = TRUE;", "      newfile = TRUE;", "      perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (c == NODE_WRITABLE) {", "    device = TRUE;", "    newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    device = TRUE;", "    newfile = TRUE;", "    perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (!device && !newfile) {", "    /*", "     * Check if the file is really writable (when renaming the file to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Check if the timestamp hasn't changed since reading the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  /*", "   * For systems that support ACL: get the ACL from the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If 'backupskip' is not empty, don't make a backup for some files."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Save the value of got_int and reset it.  We don't want a previous"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  prev_got_int = got_int;", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If we are not appending or filtering, the file exists, and the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if ((bkc & BKC_YES) || append) {       // \"yes\"", "      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          // \"auto\""], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * Don't rename the file when:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else {", "        /*", "         * Check if we can create a file and set the owner/group to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (fd < 0) {           // can't write in directory", "          backup_copy = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["              || (long)file_info.stat.st_mode != perm) {", "            backup_copy = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "          /* Close the file before removing it, on MS-Windows we", "           * can't delete an open file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Break symlinks and/or hardlinks if we've been asked to."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["              || os_fileinfo_id_equal(&file_info, &file_info_old))) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * Try to make the backup in each directory in the 'bdir' option."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name, using an entry in 'bdir'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                // out of memory", "          goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          // out of memory", "            goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["", "          /*", "           * Check if backup file already exists."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * Try to create the backup file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Make a backup by renaming the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      /*", "       * If 'cpoptions' includes the \"W\" flag, we don't want to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       *"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name and make the backup file name."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /*", "           * If we are not going to keep the backup file, don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      write_info.bw_first = TRUE;", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      write_info.bw_first = TRUE;", "    } else", "#endif"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * When the file needs to be converted with 'charconvert' after"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    notconverted = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)", "                                     : (O_CREAT | O_TRUNC)),", "                           perm < 0 ? 0666 : (perm & 0777))) < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)", "                                     : (O_CREAT | O_TRUNC)),", "                           perm < 0 ? 0666 : (perm & 0777))) < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          SET_ERRMSG(xmalloc(300));", "          vim_snprintf(errmsg, 300,", "                       _(\"E513: write error, conversion failed in line %\" PRIdLINENR"], "runtime/printf"]
["src/nvim/fileio.c", ["  lnum -= start;            // compute number of written lines", "  --no_wait_return;         // may wait for return now", ""], "readability/increment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\" CONVERSION ERROR\"));", "      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[NOT converted]\"));", "      c = TRUE;", "    } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[converted]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[Device]\"));", "      c = TRUE;", "    } else if (newfile) {"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_eol();", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (msg_add_fileformat(fileformat)) {", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* When written everything correctly: reset 'modified'.  Unless not", "   * writing to the original file and '+' is not in 'cpoptions'. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If written to the current file, update the timestamp of the swap file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we kept a backup until now, and we are in patch mode, then we make"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (backup != NULL) {", "      /*", "       * If the original file does not exist yet"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    /*", "     * If there is no backup file, remember that a (new) file was"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "whitespace/newline"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Remove the backup unless 'backup' option is set"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Finish up.  We get here either after failure or success."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             // may wait for return now", "nofail:"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * When writing the whole file and 'undofile' is set, also write the undo"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply POST autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    } else if (filtering) {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "                           FALSE, curbuf, eap);", "    } else if (reset_changed && whole) {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (aborting()) {       // autocmds may abort script processing", "      retval = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Skip conversion when writing the BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (flags & FIO_UTF8) {", "      /*", "       * Convert latin1 in the buffer to UTF-8 in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    } else if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {", "      /*", "       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          /* Use remainder of previous call.  Append the start of", "           * buf[] to get a full sequence.  Might still be too"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (n > ip->bw_restlen + len) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (n > len - wlen) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {", "          ip->bw_conv_error = TRUE;", "          ip->bw_conv_error_lnum = ip->bw_start_lnum;"], "readability/bool"]
["src/nvim/fileio.c", ["        if (c == NL) {", "          ++ip->bw_start_lnum;", "        }"], "readability/increment"]
["src/nvim/fileio.c", ["", "        /* Need to concatenate the remainder of the previous call and", "         * the bytes of the current call.  Use the end of the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* There is a bug in iconv() on Linux (which appears to be", "         * wide-spread) which sets \"to\" to NULL and messes up \"tolen\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        ip->bw_first = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * If iconv() has an error or there is not enough room, fail."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || fromlen > CONV_RESTLEN) {", "        ip->bw_conv_error = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["      if (flags & FIO_UTF16) {", "        /* Make two words, ten bits of the character in each.  First", "         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {", "    same_encoding = TRUE;", "    fenc_flags = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["    fnamelen = strlen(retval);", "    prepend_dot = FALSE;  // nothing to prepend a dot to", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    retval = xmalloc(fnamelen + extlen + 3);", "    strcpy(retval, fname);", "  }"], "runtime/printf"]
["src/nvim/fileio.c", ["  // ext can start with '.' and cannot exceed 3 more characters.", "  strcpy(s, ext);", ""], "runtime/printf"]
["src/nvim/fileio.c", ["", "  /*", "   * When the names are identical, there is nothing to do.  When they refer"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Find a name that doesn't exist and is in the same directory."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Delete the \"to\" file, this is required on some systems to make the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * First try a normal rename, return if it works."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Rename() failed, try copying the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "static int already_warned = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (no_check_timestamps > 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (focus && did_check_timestamps) {", "    need_check_timestamps = TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    --no_wait_return;", "    need_check_timestamps = FALSE;"], "readability/increment"]
["src/nvim/fileio.c", ["    --no_wait_return;", "    need_check_timestamps = FALSE;", "    if (need_wait_return && didit == 2) {"], "readability/bool"]
["src/nvim/fileio.c", ["            mesg = _(", "                    \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");", "            mesg2 = _(\"See \\\":help W12\\\" for more info.\");"], "whitespace/indent"]
["src/nvim/fileio.c", ["      }", "      already_warned = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Try for a match with the pattern with:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (allow_dirs != NULL) {", "    *allow_dirs = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["      while (p[1] == '*') {  // \"**\" matches like \"*\"", "        ++p;", "      }"], "readability/increment"]
["src/nvim/fileio.c", ["          if (allow_dirs != NULL) {", "            *allow_dirs = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["            ) {", "          *allow_dirs = TRUE;", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (allow_dirs != NULL) {", "        *allow_dirs = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ')';", "      --nested;", "      break;"], "readability/increment"]
["src/nvim/fold.c", ["", "/*", " * fold.c: code for folding"], "readability/old_style_comment"]
["src/nvim/fold.c", ["// typedef fold_T {{{2", "/*", " * The toplevel folds for each window are stored in the w_folds growarray."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * While updating the folds lines between invalid_top and invalid_bot have an"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * When using 'foldexpr' we sometimes get the level of the next line, which"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (cache) {", "    /*", "     * First look in cached info for displayed lines.  This is probably"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (first == 0) {", "    /*", "     * Recursively search for a fold that contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_rel -= fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "    /*", "     * Set the same foldlevel in other windows in diff mode."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i) {", "      fp[i].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["  fold_T *fp;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    // Only manually opened folds may need to be closed."], "readability/increment"]
["src/nvim/fold.c", ["        fp[i].fd_flags = FD_LEVEL;", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fold.c", ["  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin)) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  int cont;", "  int use_level = FALSE;", "  int closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int closed = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (found_ga == NULL) {", "      ++lnum;", "    } else {"], "readability/increment"]
["src/nvim/fold.c", ["    // reset got_int here, otherwise it won't work", "    got_int = FALSE;", "    foldUpdateIEMS(wp, top, bot);"], "readability/bool"]
["src/nvim/fold.c", ["          }", "          --fp;", "        } else {"], "readability/increment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i) {", "    if (win->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/fold.c", ["    cloneFoldGrowArray(&from_p->fd_nested, &to_p->fd_nested);", "    ++to->ga_len;", "    ++from_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++to->ga_len;", "    ++from_p;", "    ++to_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++from_p;", "    ++to_p;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * Perform a binary search."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_rel -= fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "  for (n = 0; n < count; ++n) {", "    done = DONE_NOTHING;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /*", "     * Do the same operation in other windows in diff mode.  Calculate the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int found_fold = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int found_fold = FALSE;", "  garray_T *gap;"], "readability/bool"]
["src/nvim/fold.c", ["", "  /*", "   * Find the fold, open or close it."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    // lnum is inside this fold", "    found_fold = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    if (use_level || fp->fd_flags == FD_LEVEL) {", "      use_level = TRUE;", "      if (level >= wp->w_p_fdl) {"], "readability/bool"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j) {", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["    off += fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["  fp = (fold_T *)fpr->fd_nested.ga_data;", "  for (int i = 0; i < fpr->fd_nested.ga_len; ++i) {", "    foldOpenNested(&fp[i]);"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * Adjust all folds below \"line1\" that are affected."], "readability/old_style_comment"]
["src/nvim/fold.c", ["   */", "  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*", "     * Check for these situations:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;"], "readability/increment"]
["src/nvim/fold.c", ["    if (ascii_isdigit(p[len])) {", "      ++len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  // an error occurred when evaluating 'fdt' setting", "  static int got_fdt_error = FALSE;", "  int save_did_emsg = did_emsg;"], "readability/bool"]
["src/nvim/fold.c", ["    // window changed, try evaluating foldtext setting once again", "    got_fdt_error = FALSE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["    // a previous error should not abort evaluating 'foldexpr'", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["      if (text == NULL || did_emsg) {", "        got_fdt_error = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1])) {", "    --cms_slen;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1])) {", "      --cms_slen;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["      if (ascii_isdigit(s[len])) {", "        ++len;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["      while (ascii_iswhite(s[len])) {", "        ++len;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * If folding is defined by the syntax, it is possible that a change in"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      }", "      ++current_fdl;", ""], "readability/increment"]
["src/nvim/fold.c", ["      }", "      ++fline.lnum;", "      fline.lvl = fline.lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * If using the marker method, the start line is not the start of a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Loop over all lines in this fold, or until \"bot\" is hit."], "readability/old_style_comment"]
["src/nvim/fold.c", ["        while (foldFind(&fp2->fd_nested, ll, &fp2)) {", "          ++i;", "          ll -= fp2->fd_top;"], "readability/increment"]
["src/nvim/fold.c", ["            || flp->lnum == linecount)) {", "      /*", "       * Remove or update folds that have lines between startlnum and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (lvl < level || flp->lnum > linecount) {", "      /*", "       * Found a line with a lower foldlevel, this fold ends just above"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * The fold includes the line \"flp->lnum\" and \"flp->lnum_save\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      /*", "       * Get the level of the next line, then continue the loop to check"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Get here when:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    ga_grow(gap1, gap2->ga_len);", "    for (idx = 0; idx < gap2->ga_len; ++idx) {", "      ((fold_T *)gap1->ga_data)[gap1->ga_len]"], "readability/increment"]
["src/nvim/fold.c", ["      ((fold_T *)gap1->ga_data)[gap1->ga_len].fd_top += fp1->fd_len;", "      ++gap1->ga_len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  cstart = *startmarker;", "  ++startmarker;", "  cend = *foldendmarker;"], "readability/increment"]
["src/nvim/fold.c", ["      } else {", "        ++flp->lvl;", "        ++flp->lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl;", "        ++flp->lvl_next;", "        ++flp->start;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl_next;", "        ++flp->start;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.h", ["", "/*", " * Info used to pass info about a fold from the fold-detection code to the"], "readability/old_style_comment"]
["src/nvim/garray.c", ["", "      --gap->ga_len;", "    }"], "readability/increment"]
["src/nvim/garray.c", ["  }", "  strcpy(s, strings[nelem - 1]);", ""], "runtime/printf"]
["src/nvim/getchar.c", ["", "/*", " * getchar.c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * when block_redo is TRUE redo buffer will not be changed"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * List used for abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Variables used by vgetorpeek() and flush_buffers()"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free and clear a buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * Remove the characters that were added the last time, these must be the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * When stopping recording from Insert mode with CTRL-O q, also remove the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Prepare the read buffers for reading (if they contain something)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the stuff buffer is empty."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if readbuf1 is empty.  There may still be redo characters in"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Set a typeahead character that won't be flushed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove the contents of the stuff buffer and the mapped characters in the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * The previous contents of the redo buffer is kept in old_redobuffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Discard the contents of the redo buffer and restore the previous redo"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Initialize typebuf.tb_buf to point to typebuf_init."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Adjust typebuf.tb_noremap[] for the new characters:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  }", "  for (i = 0; i < addlen; ++i) {", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if there are no characters in the typeahead buffer that have"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the number of characters that are mapped (or not typed)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Easy case: Just increase typebuf.tb_off."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  }", "  /*", "   * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "whitespace/newline"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["    i = typebuf.tb_off + offset;", "    /*", "     * Leave some extra room at the end to avoid reallocation."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Write typed characters to script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Sync undo.  Called when typed characters are obtained from the typeahead"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Make \"typebuf\" empty and allocate new buffers."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free the buffers of \"typebuf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * When doing \":so! file\", the current typeahead needs to be saved, and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Save all three kinds of typeahead, so that the user must type at a prompt."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Restore the typeahead to what it was before calling save_typeahead()."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Execute the commands from the file right now when using \":source!\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Close the currently active input script."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (curscript > 0) {", "    --curscript;", "  }"], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE when reading keys from a script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * If a character was put back with vungetc, it was already processed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      case K_KPLUS:", "        c = '+'; break;", "      case K_KMINUS:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KMINUS:", "        c = '-'; break;", "      case K_KDIVIDE:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KDIVIDE:", "        c = '/'; break;", "      case K_KMULTIPLY:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KMULTIPLY:", "        c = '*'; break;", "      case K_KENTER:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KENTER:", "        c = CAR; break;", "      case K_KPOINT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KPOINT:", "        c = '.'; break;", "      case K_KCOMMA:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KCOMMA:", "        c = ','; break;", "      case K_KEQUAL:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KEQUAL:", "        c = '='; break;", "      case K_K0:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K0:", "        c = '0'; break;", "      case K_K1:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K1:", "        c = '1'; break;", "      case K_K2:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K2:", "        c = '2'; break;", "      case K_K3:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K3:", "        c = '3'; break;", "      case K_K4:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K4:", "        c = '4'; break;", "      case K_K5:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K5:", "        c = '5'; break;", "      case K_K6:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K6:", "        c = '6'; break;", "      case K_K7:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K7:", "        c = '7'; break;", "      case K_K8:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K8:", "        c = '8'; break;", "      case K_K9:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K9:", "        c = '9'; break;", ""], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XUP:", "        c = K_UP; break;", "      case K_XDOWN:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XDOWN:", "        c = K_DOWN; break;", "      case K_XLEFT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XLEFT:", "        c = K_LEFT; break;", "      case K_XRIGHT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XRIGHT:", "        c = K_RIGHT; break;", "      }"], "whitespace/newline"]
["src/nvim/getchar.c", ["", "  /*", "   * In the main loop \"may_garbage_collect\" can be set to do garbage"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like vgetc(), but never return a NUL when called recursively, get a key"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like safe_vgetc(), but loop to handle K_IGNORE."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if a character is available, such that vgetc() will not block."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if any character is available, also half an escape sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Call vpeekc() without causing anything to be mapped."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  ++vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["  if (advance) {", "    KeyStuffed = FALSE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["              } else {", "                --curwin->w_wcol;", "                col = curwin->w_cursor.col - 1;"], "readability/increment"]
["src/nvim/getchar.c", ["", "  --vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "  /*", "   * Don't reset these when at the hit-return prompt, otherwise an endless"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Delete one entry from the abbrlist or maphash[]."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Initialize maphash[] for first use."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Get the mapping mode from the command name."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings or abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (hash = 0; hash < 256; ++hash) {", "    if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["        }", "        /*", "         * May need to put this entry into another hash list."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Use FALSE below if we only want things like <Up> to show up as such on", "   * the rhs, and not M-x etc, TRUE gets both -- webb */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Used below when expanding mapping/abbreviation names."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    count = 0;"], "readability/increment"]
["src/nvim/getchar.c", ["        if (round == 1) {", "          ++count;", "        } else {"], "readability/increment"]
["src/nvim/getchar.c", ["", "    for (hash = 0; hash < 256; ++hash) {", "      if (expand_isabbrev) {"], "readability/increment"]
["src/nvim/getchar.c", ["            if (round == 1) {", "              ++count;", "            } else {"], "readability/increment"]
["src/nvim/getchar.c", ["      }", "      ++clen;", "    }"], "readability/increment"]
["src/nvim/getchar.c", ["    if (mp != NULL) {", "      /*", "       * Found a match:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      --str;", "      continue;"], "readability/increment"]
["src/nvim/getchar.c", ["    c = *str;", "    /*", "     * Special key codes have to be translated to be able to make sense"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * A '\\n' in a map command should be written as <NL>."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * Some characters have to be escaped with CTRL-V to"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      for (; mp != NULL; mp = mp->m_next) {", "        /* skip entries with wrong mode, wrong length and not matching", "         * ones */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (; *str; ++str) {", "    int c = *str;"], "readability/increment"]
["src/nvim/globals.h", ["#define FOR_ALL_WINDOWS_IN_TAB(wp, tp) \\", "  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)"], "readability/braces"]
["src/nvim/globals.h", ["  for (win_T *wp = ((tp) == curtab) \\", "              ? firstwin : (tp)->tp_firstwin; wp != NULL; wp = wp->w_next)", ""], "whitespace/alignment"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS(buf) \\", "  for (buf_T *buf = firstbuf; buf != NULL; buf = buf->b_next)", "#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\"], "readability/braces"]
["src/nvim/globals.h", ["#define FOR_ALL_BUFFERS_BACKWARDS(buf) \\", "  for (buf_T *buf = lastbuf; buf != NULL; buf = buf->b_prev)", ""], "readability/braces"]
["src/nvim/globals.h", ["#if MAXPATHL > IOSIZE", "                                            MAXPATHL", "#else"], "whitespace/indent"]
["src/nvim/globals.h", ["#else", "                                            IOSIZE", "#endif"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["", "/*", " * hardcopy.c: printing to paper"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * To implement printing on a platform, the following functions must be"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  =", "  {", "  { \"top\",     TRUE, 0, NULL, 0, FALSE },"], "whitespace/braces"]
["src/nvim/hardcopy.c", ["  {", "  { \"top\",     TRUE, 0, NULL, 0, FALSE },", "  { \"bottom\",  TRUE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"top\",     TRUE, 0, NULL, 0, FALSE },", "  { \"bottom\",  TRUE, 0, NULL, 0, FALSE },", "  { \"left\",    TRUE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"bottom\",  TRUE, 0, NULL, 0, FALSE },", "  { \"left\",    TRUE, 0, NULL, 0, FALSE },", "  { \"right\",   TRUE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"left\",    TRUE, 0, NULL, 0, FALSE },", "  { \"right\",   TRUE, 0, NULL, 0, FALSE },", "  { \"header\",  TRUE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"right\",   TRUE, 0, NULL, 0, FALSE },", "  { \"header\",  TRUE, 0, NULL, 0, FALSE },", "  { \"syntax\",  FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"header\",  TRUE, 0, NULL, 0, FALSE },", "  { \"syntax\",  FALSE, 0, NULL, 0, FALSE },", "  { \"number\",  FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"syntax\",  FALSE, 0, NULL, 0, FALSE },", "  { \"number\",  FALSE, 0, NULL, 0, FALSE },", "  { \"wrap\",    FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"number\",  FALSE, 0, NULL, 0, FALSE },", "  { \"wrap\",    FALSE, 0, NULL, 0, FALSE },", "  { \"duplex\",  FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"wrap\",    FALSE, 0, NULL, 0, FALSE },", "  { \"duplex\",  FALSE, 0, NULL, 0, FALSE },", "  { \"portrait\", FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"duplex\",  FALSE, 0, NULL, 0, FALSE },", "  { \"portrait\", FALSE, 0, NULL, 0, FALSE },", "  { \"paper\",   FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"portrait\", FALSE, 0, NULL, 0, FALSE },", "  { \"paper\",   FALSE, 0, NULL, 0, FALSE },", "  { \"collate\", FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"paper\",   FALSE, 0, NULL, 0, FALSE },", "  { \"collate\", FALSE, 0, NULL, 0, FALSE },", "  { \"jobsplit\", FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"collate\", FALSE, 0, NULL, 0, FALSE },", "  { \"jobsplit\", FALSE, 0, NULL, 0, FALSE },", "  { \"formfeed\", FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"jobsplit\", FALSE, 0, NULL, 0, FALSE },", "  { \"formfeed\", FALSE, 0, NULL, 0, FALSE },", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["{", "  { \"c\",       FALSE, 0, NULL, 0, FALSE },", "  { \"a\",       FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"c\",       FALSE, 0, NULL, 0, FALSE },", "  { \"a\",       FALSE, 0, NULL, 0, FALSE },", "  { \"r\",       FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"a\",       FALSE, 0, NULL, 0, FALSE },", "  { \"r\",       FALSE, 0, NULL, 0, FALSE },", "  { \"b\",       FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"r\",       FALSE, 0, NULL, 0, FALSE },", "  { \"b\",       FALSE, 0, NULL, 0, FALSE },", "  { \"i\",       FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"b\",       FALSE, 0, NULL, 0, FALSE },", "  { \"i\",       FALSE, 0, NULL, 0, FALSE },", "  { \"o\",       FALSE, 0, NULL, 0, FALSE },"], "readability/bool"]
["src/nvim/hardcopy.c", ["  { \"i\",       FALSE, 0, NULL, 0, FALSE },", "  { \"o\",       FALSE, 0, NULL, 0, FALSE },", "};"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "/*", " * These values determine the print position on a page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Structures to map user named encoding and mapping to PS equivalents for", " * building CID font name */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Static buffer to read initial comments in a resource file, some can have a", " * couple of KB of comments! */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse 'printoptions' and set the flags in \"printer_opts\"."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse 'printoptions' and set the flags in \"printer_opts\"."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Parse a list of options in the form"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Repeat for all comma separated parts."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "    for (idx = 0; idx < table_size; ++idx) {", "      if (STRNICMP(stringp, table[idx].name, len) == 0) {"], "readability/increment"]
["src/nvim/hardcopy.c", ["    p = colonp + 1;", "    table[idx].present = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (*stringp == ',') {", "      ++stringp;", "    }"], "readability/increment"]
["src/nvim/hardcopy.c", ["", "/*", " * If using a dark background, the colors will probably be too bright to show"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Get the currently effective header height."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Return TRUE if using a line number for printing."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Return the unit used in a margin item in 'printoptions'."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  if (printer_opts[idx].present) {", "    for (i = 0; i < 4; ++i) {", "      if (STRNICMP(printer_opts[idx].string, units[i], 2) == 0) {"], "readability/increment"]
["src/nvim/hardcopy.c", ["    linenr_T tmp_lnum, tmp_topline, tmp_botline;", "    int use_sandbox = FALSE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Need to (temporarily) set current line number and first/last line"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Display a print status message."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  memset(&settings, 0, sizeof(prt_settings_T));", "  settings.has_color = TRUE;", ""], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Initialise for printing.  Ask the user for settings, unless forceit is"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  if (!syntax_present(curwin)) {", "    settings.do_syntax = FALSE;", "  } else if (printer_opts[OPT_PRINT_SYNTAX].present"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Estimate the total lines to be printed"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Loop over collated copies: 1 2 3, 1 2 3, ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Loop over all pages in the print job: 1 2 3 ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["     */", "    for (page_count = 0; prtpos.file_line <= eap->line2; ++page_count) {", "      /*"], "readability/increment"]
["src/nvim/hardcopy.c", ["    for (page_count = 0; prtpos.file_line <= eap->line2; ++page_count) {", "      /*", "       * Loop over uncollated copies: 1 1 1, 2 2 2, 3 3 3, ..."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "        /*", "         * Do front and rear side of a page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["         */", "        for (side = 0; side <= settings.duplex; ++side) {", "          /*"], "readability/increment"]
["src/nvim/hardcopy.c", ["        for (side = 0; side <= settings.duplex; ++side) {", "          /*", "           * Print one page."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["          assert(prtpos.bytes_printed <= SIZE_MAX / 100);", "          sprintf((char *)IObuff, _(\"Printing page %d (%zu%%)\"),", "                  page_count + 1 + side,"], "runtime/printf"]
["src/nvim/hardcopy.c", ["          if (settings.n_collated_copies > 1) {", "            sprintf((char *)IObuff + STRLEN(IObuff),", "                    _(\" Copy %d of %d\"),"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "          /*", "           * Output header if required"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["          for (page_line = 0; page_line < settings.lines_per_page;", "               ++page_line) {", "            prtpos.column = hardcopy_line(&settings,"], "readability/increment"]
["src/nvim/hardcopy.c", ["", "        /*", "         * Extra blank page for duplexing with odd number of pages and"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      if (settings.duplex && prtpos.file_line <= eap->line2) {", "        ++page_count;", "      }"], "readability/increment"]
["src/nvim/hardcopy.c", ["  if (got_int || settings.user_abort) {", "    sprintf((char *)IObuff, \"%s\", _(\"Printing aborted\"));", "    prt_message(IObuff);"], "runtime/printf"]
["src/nvim/hardcopy.c", ["", "/*", " * Print one page line."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  char_u *line;", "  int need_break = FALSE;", "  int outputlen;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    }", "    ppos->ff = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Loop over the columns until the end of the file line or right margin."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    if (psettings->do_syntax) {", "      id = syn_get_id(curwin, ppos->file_line, col, 1, NULL, FALSE);", "      if (id > 0) {"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "    /*", "     * Appropriately expand any tabs to spaces."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["               == 'y') {", "      ppos->ff = TRUE;", "      need_break = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Start next line of file if we clip lines, or have reached end of the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * PS printer stuff."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* The PS prolog file version number has to match - if the prolog file is", " * updated, increment the number in the file and here.  Version checking was"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* Data for table based DSC comment recognition, easy to extend if VIM needs to", " * read more comments. */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Variables for the output PostScript file."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Various offsets and dimensions in default PostScript user space (points)."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Various control variables used to decide when and how to change the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Variables controlling physical printing."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Buffers used when generating PostScript output"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a string."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write an int and a space."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a boolean and a space."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write PostScript to re-encode and define the font."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define the CID font."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define a duplicate of a CID font"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Convert a real value into an integer and fractional part as integers, with"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a real and a space.  Save bytes if real value has no fractional part!"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Write a line to define a numeric variable."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/* prt_next_dsc() - returns detail on next DSC comment line found.  Returns true", " * if a DSC comment is found, else false */"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    convert_setup(&prt_conv, NULL, NULL);", "    prt_do_conv = FALSE;", "  }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "/*", " * Calculate margins for given width and height from printoptions settings."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "/*", " * Get number of lines of text that fit on a page (excluding the header)."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Calculate offset to lower left corner of background rect based on actual"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["      *pp_mbenc = p_mbenc;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["      *pp_mbchar = p_mbchar;", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up font and encoding."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    prt_use_courier = (", "                       mbfont_opts[OPT_MBFONT_USECOURIER].present", "                       && (TOLOWER_ASC(mbfont_opts[OPT_MBFONT_USECOURIER].string[0]) == 'y'));"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["                       mbfont_opts[OPT_MBFONT_USECOURIER].present", "                       && (TOLOWER_ASC(mbfont_opts[OPT_MBFONT_USECOURIER].string[0]) == 'y'));", "    if (prt_use_courier) {"], "whitespace/indent"]
["src/nvim/hardcopy.c", ["  } else {", "    prt_use_courier = FALSE;", "    prt_ps_font = &prt_ps_courier_font;"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Find the size of the paper and set the margins."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["  }", "  for (i = 0; i < (int)PRT_MEDIASIZE_LEN; ++i) {", "    if (STRLEN(prt_mediasize[i].name) == (unsigned)paper_strlen"], "readability/increment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set PS pagesize based on media dimensions and print orientation."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up the font size."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Return the number of characters per line, and lines per page for the"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Sort out the number of copies to be printed.  PS by default will do"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Set up printer duplex and tumble based on Duplex option setting - default"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["   */", "  prt_duplex = TRUE;", "  prt_tumble = FALSE;"], "readability/bool"]
["src/nvim/hardcopy.c", ["  prt_duplex = TRUE;", "  prt_tumble = FALSE;", "  psettings->duplex = 1;"], "readability/bool"]
["src/nvim/hardcopy.c", ["    if (STRNICMP(printer_opts[OPT_PRINT_DUPLEX].string, \"off\", 3) == 0) {", "      prt_duplex = FALSE;", "      psettings->duplex = 0;"], "readability/bool"]
["src/nvim/hardcopy.c", ["               == 0) {", "      prt_tumble = TRUE;", "    }"], "readability/bool"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS DSC Header comments - no PS code!"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["    prt_dsc_font_resource((prt_use_courier ? NULL", "                                           : \"DocumentNeededResources\"), &prt_ps_mb_font);", "    if (!prt_custom_cmap) {"], "whitespace/alignment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document page defaults"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document prolog inclusion - all required procsets."], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * PS Document setup - must appear after the prolog"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["", "  /*", "   * Output any info we don't know in toto until we finish"], "readability/old_style_comment"]
["src/nvim/hardcopy.c", ["{", "  return mch_print_begin_page(NULL) ? (mch_print_end_page()) : FALSE;", "}"], "readability/bool"]
["src/nvim/hardcopy.c", ["      case BS:", "        ga_append(&prt_ps_buffer, 'b'); break;", "      case TAB:"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case TAB:", "        ga_append(&prt_ps_buffer, 't'); break;", "      case NL:"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case NL:", "        ga_append(&prt_ps_buffer, 'n'); break;", "      case FF:"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case FF:", "        ga_append(&prt_ps_buffer, 'f'); break;", "      case CAR:"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case CAR:", "        ga_append(&prt_ps_buffer, 'r'); break;", "      case '(':"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case '(':", "        ga_append(&prt_ps_buffer, '('); break;", "      case ')':"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case ')':", "        ga_append(&prt_ps_buffer, ')'); break;", "      case '\\\\':"], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      case '\\\\':", "        ga_append(&prt_ps_buffer, '\\\\'); break;", ""], "whitespace/newline"]
["src/nvim/hardcopy.c", ["      default:", "        sprintf((char *)ch_buff, \"%03o\", (unsigned int)ch);", "        ga_append(&prt_ps_buffer, (char)ch_buff[0]);"], "runtime/printf"]
["src/nvim/hardcopy.h", ["", "/*", " * Structure to hold printing color and font attributes."], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["", "/*", " * Structure passed back to the generic printer code."], "readability/old_style_comment"]
["src/nvim/hardcopy.h", ["", "/*", " * Generic option table item, only used for printer at the moment."], "readability/old_style_comment"]
["src/nvim/hashtab.c", ["  size_t todo = ht->ht_used;", "  for (hashitem_T *hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/hashtab.c", ["", "  for (hashitem_T *olditem = oldarray; todo > 0; ++olditem) {", "    if (HASHITEM_EMPTY(olditem)) {"], "readability/increment"]
["src/nvim/highlight_group.c", ["  struct {", "    char **dest; RgbValue val; Object name;", "  } cattrs[] = {"], "whitespace/newline"]
["src/nvim/if_cscope.c", ["", "/*", " * CSCOPE support for Vim added by Andy Kahn <kahn@zk3.dec.com>"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the cscope command"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    const char *query_type[] =", "    {", "      \"a\", \"c\", \"d\", \"e\", \"f\", \"g\", \"i\", \"s\", \"t\", NULL"], "whitespace/braces"]
["src/nvim/if_cscope.c", ["", "/*", " * Handle command line completion for :cscope command."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  do_cscope_general(eap, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["{", "  int ret = FALSE;", ""], "readability/bool"]
["src/nvim/if_cscope.c", ["", "/*", " * \"cscope_connection([{num} , {dbpath} [, {prepend}]])\" function"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "/*", " * PRIVATE functions"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  if ((fname = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Add);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL) {", "    flags = strtok((char *)NULL, (const char *)\" \");"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  if ((ppath = strtok((char *)NULL, (const char *)\" \")) != NULL) {", "    flags = strtok((char *)NULL, (const char *)\" \");", "  }"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["    if (fname[0] == '\\0') {", "      (void)sprintf(fname2, \"/%s\", CSCOPE_DBFILE);", "    } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    } else {", "      (void)sprintf(fname2, \"%s/%s\", fname, CSCOPE_DBFILE);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    }", "    if ((stok = strtok(buf, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "    if ((stok = strtok(NULL, (const char *)\" \")) == NULL) {", "      continue;"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  char *cmd;", "  short search;", "  char *pat;"], "runtime/int"]
["src/nvim/if_cscope.c", ["    while (ascii_iswhite(*pat)) {", "      ++pat;", "    }"], "readability/increment"]
["src/nvim/if_cscope.c", ["", "  (void)sprintf(cmd, \"%d%s\", search, pat);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["#if defined(UNIX)", "  /*", "   * Cscope reads from to_cs[0] and writes to from_cs[1]; vi reads from"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["  sa.nLength = sizeof(SECURITY_ATTRIBUTES);", "  sa.bInheritHandle = TRUE;", "  sa.lpSecurityDescriptor = NULL;"], "readability/bool"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].ppath != NULL) {", "      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" -P\");", "      (void)strcat(cmd, csinfo[i].ppath);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].flags != NULL) {", "      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);"], "runtime/printf"]
["src/nvim/if_cscope.c", ["      (void)strcat(cmd, \" \");", "      (void)strcat(cmd, csinfo[i].flags);", "    }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    si.hStdInput  = stdin_rd;", "    created = CreateProcess(NULL, cmd, NULL, NULL, TRUE, CREATE_NEW_CONSOLE,", "                            NULL, NULL, &si, &pi);"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  if ((opt = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Find);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Let's replace the NULs written by strtok() with spaces - we need the"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["   */", "  for (int i = 0; i < eap_arg_len; ++i) {", "    if (NUL == eap->arg[i]) {"], "readability/increment"]
["src/nvim/if_cscope.c", ["        if (use_ll) {", "          /*", "           * In the location list window, use the displayed location"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/if_cscope.c", ["      csinfo_size *= 2;", "      csinfo = xrealloc(csinfo, sizeof(csinfo_T)*csinfo_size);", "    }"], "whitespace/operators"]
["src/nvim/if_cscope.c", ["", "  (void)strcpy(csinfo[i].fname, (const char *)fname);", ""], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].ppath = xmalloc(strlen(ppath) + 1);", "    (void)strcpy(csinfo[i].ppath, (const char *)ppath);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["    csinfo[i].flags = xmalloc(strlen(flags) + 1);", "    (void)strcpy(csinfo[i].flags, (const char *)flags);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  if ((stok = strtok((char *)NULL, (const char *)\" \")) == NULL) {", "    cs_usage_msg(Kill);"], "runtime/threadsafe_fn"]
["src/nvim/if_cscope.c", ["  }", "  cs_release_csp(i, TRUE);", "}"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\\t%s\", tagstr, fname, slno, search);", "  } else {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "    (void)sprintf(buf, \"%s\\t%s\\t%s;\\\"\", tagstr, fname, slno);", "  }"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  /*", "   * cscope output is in the following format:"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["#if defined(UNIX) && defined(SIGALRM)", "/*", " * Used to catch and ignore SIGALRM below."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    sleep(0);", "    for (waited = 0; waited < 40; ++waited) {", "      pid = waitpid(csinfo[i].pid, &pstat, WNOHANG);"], "readability/increment"]
["src/nvim/if_cscope.c", ["# endif", "    /*", "     * If the cscope process is still running: kill it."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      if (waitpid_errno == ECHILD) {", "        /*", "         * When using 'vim -g', vim is forked and cscope process is"], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["      }", "      if (alive)", "# endif"], "readability/braces"]
["src/nvim/if_cscope.c", ["    if (csinfo[i].fname != NULL) {", "      cs_release_csp(i, FALSE);", "    }"], "readability/bool"]
["src/nvim/if_cscope.c", ["", "  /*", "   * Ppath is freed when we destroy the cscope connection."], "readability/old_style_comment"]
["src/nvim/if_cscope.c", ["    fullname = xmalloc(len);", "    (void)sprintf(fullname, \"%s/%s\", csinfo[i].ppath, name);", "  } else if (csdir != NULL && csinfo[i].fname != NULL && *csdir != NUL) {"], "runtime/printf"]
["src/nvim/if_cscope.c", ["", "  wait_return(TRUE);", "  return CSCOPE_SUCCESS;"], "readability/bool"]
["src/nvim/indent_c.c", ["#endif", "/*", " * Find the start of a comment, not knowing if we are in a comment right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Check if the comment start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the start of a raw string, not knowing if we are in one right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip to the end of a \"string\" and a 'c' character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * We loop, because strings may be concatenated: \"date\"\"time\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Functions for C-indenting."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "/*", " * Below \"XXX\" means that this function may unlock the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return true if the string \"line\" starts with a word from 'cinwords'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip over white space and C comments within the line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* Perl/shell # comment comment continues until eol.  Require a space", "     * before # to avoid recognizing $#array. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if there is no code at *s.  White space and comments are"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check previous lines for a \"//\" line comment, skipping over blank lines."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    quote = *s;", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  while (vim_isIDc(*s)) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  if (*s && *s == quote) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Only accept a label if the previous line is terminated or is a case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If we're in a comment or raw string now, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize structure initialization and enumerations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    for (i = 0; i < (int)ARRAY_SIZE(skip); ++i) {", "      l = (int)strlen(skip[i]);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"case\")) {", "    for (s += 4; *s; ++s) {", "      s = cin_skipcomment(s);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"default\" switch label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return a pointer to the first non-empty non-comment character after a ':'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  for (; *l; ++l) {", "    if (*l == ':') {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Get indent of line \"lnum\", skipping a label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find indent for line \"lnum\", ignoring any case or jump label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first variable name after a type in a declaration."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first non-blank after an equal sign."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a preprocessor statement: Any line that starts with '#'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a C or C++ comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a \"//\" comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      /* ',' at the end: continue looking in the next line.", "       * At the end: check for ',' in the next line, for this style:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check if this is a \"while\" that should have a matching \"do\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if we are at the end of a do-while."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (*s == ';' && cin_nocode(s + 1)) {", "        /* Found \");\" at end of the line, now check there is \"while\"", "         * before the matching '('.  XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Find the position of a C++ base-class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /* Search for a line starting with '#', empty, ending in ';' or containing", "   * '{' or '}' and start below it.  This handles the following situations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (s[1] == ':') {", "        /* skip double colon. It can't be a constructor", "         * initialization any more */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (lookfor_ctor_init || class_or_struct) {", "        /* we have something found, that looks like the start of", "         * cpp-base-class-declaration or constructor-initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == ')') {", "        /* Constructor-initialization is assumed if we come across", "         * something like \"):\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE when \"s\" starts with \"word\" and then a non-ID character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip strings, chars and comments until at or past \"trypos\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the '{' at the start of the block we are in."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return ind_maxparen corrected for the difference in line number between the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Set w_cursor.col to the column number of the last unmatched ')' or '{' in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Parse 'cinoptions' and set the values in \"curbuf\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Set the default values."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  /* Spaces from a block's opening brace the prevailing indent for that", "   * block should be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace that's at the end of a", "   * line is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent for a line that is not preceded by", "   * an opening brace. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent a leftmost open brace should be", "   * located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the matching open brace (real location for one at the left", "   * edge; imaginary location from one that ends a line) the matching close"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace sitting in the leftmost", "   * column is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces jump labels should be shifted to the left if N is non-negative,", "   * otherwise the jump label will be put to column 1. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the class declaration indent a scope declaration label", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a cpp base class declaration or constructor initialization", "   * should be indented. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* additional spaces beyond the prevailing indent a continuation line", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses, which", "   * itself is also unclosed. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* If the opening paren is the last nonwhite character on the line, and", "   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring white space when lining up with the character after", "   * an unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Boolean: if non-zero, use b_ind_in_comment even if there is something", "   * after the comment opener. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle continuation lines containing conditions of if(), for() and", "   * while(). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /* When adding an entry here, also update the default 'cinoptions' in", "     * doc/indent.txt, and add explanation for it! */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the desired indent for C code."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Get a copy of the current contents of the line.", "   * This is required, because only the most recent line obtained with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * In insert mode and the cursor is on a ')' truncate the line at the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * If we are inside a raw string don't change the indent."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a \"//\" comment and there is a \"//\" comment in a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a comment and not looking at the start of the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (what == COM_END) {", "        /* If our line starts with the middle comment string, line it", "         * up with the comment opener per the 'comments' option. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (curwin->w_cursor.lnum > 1) {", "            /* If the start comment string matches in the previous", "             * line, use the indent of that line plus offset.  If"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /* If our line starts with the end comment string, line it up", "         * with the middle comment */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* If our line starts with an asterisk, line up with the", "     * asterisk in the comment opener; otherwise, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (trypos != NULL && tryposBrace != NULL) {", "      /* Both an unmatched '(' and '{' is found.  Use the one which is", "       * closer to the current cursor position, set the other to NULL. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      our_paren_pos = *trypos;", "      /*", "       * If the matching paren is more than one line away, use the indent of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /*", "       * Line up with line where the matching paren is. XXX"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (curbuf->b_ind_if_for_while) {", "          /* Look for the outermost opening parenthesis on this line", "           * and check whether it belongs to an \"if\", \"for\" or \"while\". */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /* Ignore a '(' in front of the line that has a match before", "           * our matching '('. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && ignore_paren_col == 0)) {", "          /*", "           * If we're looking at a close paren, line up right there;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && cin_ends_in(l, (char_u *)\"(\", NULL)) {", "              /* look for opening unmatched paren, indent one level", "               * for each additional level */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              n = 1;", "              for (col = 0; col < our_paren_pos.col; ++col) {", "                switch (l[col]) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Find how indented the paren is, or the character after it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        } else {", "          /* Add b_ind_unclosed2 for each '(' before our matching one,", "           * but ignore (void) before the line (ignore_paren_col). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          while ((int)our_paren_pos.col > ignore_paren_col) {", "            --our_paren_pos.col;", "            switch (*ml_get_pos(&our_paren_pos)) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* Use b_ind_unclosed once, when the first '(' is not inside", "           * braces */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * For a line starting with ')' use the minimum of the two"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /*", "       * Now figure out how indented the line is in general."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (theline[0] == '}') {", "        /*", "         * they may want closing braces to line up with something"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else {", "        /*", "         * If we're looking at an \"else\", try to find an \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * We get here if we are not on an \"while-of-do\" or \"else\" (or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * if the '{' is  _really_ at the left margin, use the imaginary"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "          /*", "           * If we went all the way back to the start of our scope, line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  < ourscope - curbuf->b_ind_maxparen) {", "                /* nothing found (abuse curbuf->b_ind_maxparen as", "                 * limit) assume terminated line (i.e. a variable"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're in a comment or raw string now, skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we are at top level and the line looks like a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0)) {", "                /* if the line is terminated with another ','", "                 * it is a continued variable initialization."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                /* if it is an enum declaration or an assignment,", "                 * we are done."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* it's a variable declaration, add indentation", "               * like in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor_cpp_namespace) {", "                /*", "                 * Looking for C++ namespace, need to look further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                /* If we're in a comment or raw string now, skip", "                 * to the start of it. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * If this is a switch() label, may line up relative to that."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          if (iscase || cin_isscopedecl(l)) {", "            /* we are only looking for cpp base class", "             * declaration/initialization any longer */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /* When looking for a \"do\" we are not interested in", "             * labels. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Try to get the indent of a statement before the switch"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Looking for a switch() label or C++ scope declaration,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore jump labels with nothing after them."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore #defines, #if, etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {", "            /* only look, whether there is a cpp base class", "             * declaration or initialization before the opening brace."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * What happens next depends on the line being terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["            if (trypos != NULL) {", "              /*", "               * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Skip over continuation lines to find the one to get the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If this is just above the line we are indenting, and it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              /*", "               * Only add b_ind_open_extra when the current line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js) {", "                /* have to look back, whether it is a cpp base", "                 * class declaration or initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Check if we are after an \"if\", \"while\", etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If this is just above the line we are indenting, we"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Special trick: when expecting the while () after a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When searching for a terminated line, don't use the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_iselse(l) && whilelevel == 0) {", "                /* If we're looking at \"} else\", let's make sure we", "                 * find the opening brace of the enclosing scope,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If we're below an unterminated line that is not an"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * Found two unterminated lines on a row, line up with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_ENUM_OR_INIT) {", "                /* Found two lines ending in ',', lineup with the", "                 * lowest one, but check for cpp base class"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * Check if we are after a while (cond);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*", "             * Found an unterminated line after a while ();, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            ++whilelevel;", "          }"], "readability/increment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * We are after a \"normal\" statement."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["          else {", "            /*", "             * Skip single break line, if before a switch label. It"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Handle \"do {\" line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above an unterminated line. Add"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above a terminated line or \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * First line above the one we're indenting is terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * position the cursor over the rightmost paren, so"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* When aligning with the case statement, don't align", "               * with a statement after it."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When a terminated line starts with \"else\" skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're at the end of a block, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If the NEXT line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ',', use one level of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /* For a line ending in ',' that is a continuation line go", "       * back to the first line with a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the line looks like a function declaration, and we're"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Finding the closing '}' of a previous function.  Put"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Find a line only has a semicolon that belongs to a previous"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the PREVIOUS line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ';' and the line before the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Doesn't look like anything interesting -- so just"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've gone outside the braces entirely,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if the brace enclosing this is further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if they're enclosed in a *deeper* brace,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was an \"else\" (that's not an \"else if\")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was a \"while\" then we need to go back to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_iswhileofdo(look, curwin->w_cursor.lnum)) {", "      ++whilelevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["    if (cin_isif(look)) {", "      elselevel--;", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      elselevel--;", "      /*", "       * When looking for an \"if\" ignore \"while\"s that"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've used up all the elses, then"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Do C or expression indenting on the current line."], "readability/old_style_comment"]
["src/nvim/lib/kbtree.h", ["// marker so line numbers and indices both start at 1", "/*-", " * Copyright 1997-1999, 2001, John-Mark Gurney."], "readability/old_style_comment"]
["src/nvim/lib/kbtree.h", ["    bool is_internal; \\", "    key_t key[2*T - 1]; \\", "    kbnode_##name##_t *ptr[]; \\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["   x = *--top; \\", "   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\", "   if (__KB_PTR(b, x)[i]) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\", "   if (__KB_PTR(b, x)[i]) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    int tr, *rr, begin = 0, end = x->n; \\", "    if (x->n == 0) return -1; \\", "    rr = r? r : &tr; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      int mid = (begin + end) >> 1; \\", "      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    } \\", "    if (begin == x->n) { *rr = 1; return x->n - 1; } \\", "    if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    if (begin == x->n) { *rr = 1; return x->n - 1; } \\", "    if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin; \\", "    return begin; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = __kb_getp_aux_##name(x, k, &r); \\", "      if (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i]; \\", "      if (x->is_internal == 0) return 0; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i]; \\", "      if (x->is_internal == 0) return 0; \\", "      x = __KB_PTR(b, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      } \\", "      if (i >= 0) *lower = &__KB_KEY(key_t, x)[i]; \\", "      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0) *lower = &__KB_KEY(key_t, x)[i]; \\", "      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\", "      if (x->is_internal == 0) return; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\", "      if (x->is_internal == 0) return; \\", "      x = __KB_PTR(b, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    z = (kbnode_t *)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t)); \\", "    ++b->n_nodes; \\", "    z->is_internal = y->is_internal; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    memcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "    if (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void *) * T); \\", "    y->n = T - 1; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1]; \\", "    ++x->n; \\", "  } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      i = __kb_getp_aux_##name(x, k, 0); \\", "      if (i != x->n - 1) \\", "      memmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      *ret = *k; \\", "      ++x->n; \\", "    } else { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        __kb_split_##name(b, x, i, __KB_PTR(b, x)[i]); \\", "        if (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i; \\", "      } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      b->root = (kbnode_t *)xcalloc(1, ILEN); \\", "      ++b->n_nodes; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    kbnode_t *r, *s; \\", "    ++b->n_keys; \\", "    r = b->root; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    if (r->n == 2 * T - 1) { \\", "      ++b->n_nodes; \\", "      s = (kbnode_t *)xcalloc(1, ILEN); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      s = (kbnode_t *)xcalloc(1, ILEN); \\", "      b->root = s; s->is_internal = 1; s->n = 0; \\", "      __KB_PTR(b, s)[0] = r; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    key_t kp; \\", "    if (x == 0) return *k; \\", "    if (s) {  /* s can only be 0, 1 or 2 */ \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = s == 1? x->n - 1 : -1; \\", "    } else i = __kb_getp_aux_##name(x, k, &r); \\", "    if (x->is_internal == 0) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = s == 1? x->n - 1 : -1; \\", "    } else i = __kb_getp_aux_##name(x, k, &r); \\", "    if (x->is_internal == 0) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    if (x->is_internal == 0) { \\", "      if (s == 2) ++i; \\", "      kp = __KB_KEY(key_t, x)[i]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["              (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "      --x->n; \\", "      return kp; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } else if (yn == T - 1 && zn == T - 1) { \\", "        y = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1]; \\", "        __KB_KEY(key_t, y)[y->n++] = *k; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["        memmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, \\", "                                                                    z), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)(x->n - i - 1) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(z); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    } \\", "    ++i; \\", "    if ((xp = __KB_PTR(b, x)[i])->n == T - 1) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        memmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "        if (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, \\", "                                                                   xp), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        __KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\", "        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\", "      } else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\", "      } else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0]; \\", "        if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "        --y->n; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "        --y->n; \\", "        memmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        memmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, \\", "                                                              y)[1], \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)xp->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, \\", "                                                                    xp), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                                              x)[i + 1], (unsigned int)(x->n - i) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(xp); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)y->n * sizeof(key_t)); \\", "        if (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), \\", "                                     (unsigned int)(y->n + 1) * sizeof(void *)); \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)(x->n - i - 1) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(y); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    ret = __kb_delp_aux_##name(b, b->root, k, 0); \\", "    --b->n_keys; \\", "    if (b->root->n == 0 && b->root->is_internal) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    if (b->root->n == 0 && b->root->is_internal) { \\", "      --b->n_nodes; \\", "      x = b->root; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    itr->p = NULL; \\", "    if (b->n_keys == 0) return; \\", "    itr->p = itr->stack; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    itr->p = itr->stack; \\", "    itr->p->x = b->root; itr->p->i = 0; \\", "    while (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["      kbnode_t *x = itr->p->x; \\", "      ++itr->p; \\", "      itr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      ++itr->p; \\", "      itr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["  { \\", "    if (itr->p == NULL) return 0; \\", "    for (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    for (;;) { \\", "      ++itr->p->i; \\", "      assert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "        ++itr->p; \\", "      } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } \\", "      --itr->p; \\", "      if (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p; \\", "      if (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["  { \\", "    if (itr->p == NULL) return 0; \\", "    for (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        itr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\", "        ++itr->p; \\", "      } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } \\", "      --itr->p; \\", "      --itr->p->i; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p; \\", "      --itr->p->i; \\", "      if (itr->p->x && itr->p->i >= 0) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p->i; \\", "      if (itr->p->x && itr->p->i >= 0) return 1; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      itr->p->i = i; \\", "      if (i >= 0 && r == 0) return 1; \\", "      ++itr->p->i; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0 && r == 0) return 1; \\", "      ++itr->p->i; \\", "      assert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\", "      ++itr->p; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["  KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, \\", "                   (sizeof(kbnode_##name##_t) + (2*T)*sizeof(void *)))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "   Example:"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "   2013-05-02 (0.2.8):"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "   @header"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#else", "typedef unsigned long long khint64_t;", "#endif"], "runtime/int"]
["src/nvim/lib/khash.h", ["", "#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["# define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, \\", "                        ++(x))", "#endif"], "readability/increment"]
["src/nvim/lib/khash.h", ["      mask = h->n_buckets - 1; \\", "      k = __hash_func(key); i = k & mask; \\", "      last = i; \\"], "whitespace/newline"]
["src/nvim/lib/khash.h", ["    if (j) {  /* rehashing is needed */ \\", "      for (j = 0; j != h->n_buckets; ++j) { \\", "        if (__ac_iseither(h->flags, j) == 0) { \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["      __ac_set_isdel_true(h->flags, x); \\", "      --h->size; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_func(key) (khint32_t)(key)", "/*! @function", "   @abstract     Integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_equal(a, b) ((a) == (b))", "/*! @function", "   @abstract     64-bit integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function", "   @abstract     64-bit integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_equal(a, b) ((a) == (b))", "/*! @function", "   @abstract     const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["{", "  khint_t h = (khint_t)*s;", "  if (h) {"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["  if (h) {", "    for (++s; *s; ++s) { h = (h << 5) - h + (uint8_t)*s; }", "  }"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["  if (h) {", "    for (++s; *s; ++s) { h = (h << 5) - h + (uint8_t)*s; }", "  }"], "readability/increment"]
["src/nvim/lib/khash.h", ["}", "/*! @function", "   @abstract     Another interface to const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_str_hash_func(key) __ac_X31_hash_string(key)", "/*! @function", "   @abstract     Const char* comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "   @abstract Type of the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Initiate a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Destroy a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Free memory referenced directly inside a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Reset a hash table without deallocating memory."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Resize a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Insert a key to the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Retrieve a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Remove a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Test whether a bucket contains data."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get key given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get value given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Alias of kh_val()"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the start iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the end iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the number of elements in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the number of buckets in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the entries in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i; \\", "                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\", "                                            (kvar) = kh_key(h, __i); \\"], "readability/braces"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the values in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i; \\", "                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\", "                                            (vvar) = kh_val(h, __i); \\"], "readability/braces"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the keys in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash set containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["typedef const char *kh_cstr_t;", "/*! @function", "   @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Return a literal for an empty hash table."], "readability/old_style_comment"]
["src/nvim/lib/klist.h", ["", "#ifndef _AC_KLIST_H", "#define _AC_KLIST_H"], "build/header_guard"]
["src/nvim/lib/klist.h", ["", "#endif", ""], "build/header_guard"]
["src/nvim/lib/klist.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/klist.h", ["    for (k = 0; k < mp->n; k++) { \\", "      kmpfree_f(mp->buf[k]); XFREE_CLEAR(mp->buf[k]); \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["    } \\", "    XFREE_CLEAR(mp->buf); XFREE_CLEAR(mp); \\", "  } \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["    kl1_##name *q, *p = kmp_alloc(name, kl->mp); \\", "    q = kl->tail; p->next = 0; kl->tail->next = p; kl->tail = p; \\", "    kl->size++; \\"], "whitespace/newline"]
["src/nvim/lib/klist.h", ["#define kl_iter_at(name, kl, p, h) \\", "  for (kl1_##name **p = h ? h : &kl->head; *p != kl->tail; p = &(*p)->next)", ""], "readability/braces"]
["src/nvim/lib/kvec.h", ["  ((v).capacity = ((s) > ARRAY_SIZE((v).init_array) \\", "                     ? (s) \\", "                     : ARRAY_SIZE((v).init_array)), \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                     ? (s) \\", "                     : ARRAY_SIZE((v).init_array)), \\", "   (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["   (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) \\", "                  ? ((v).items == (v).init_array \\", "                     ? (v).items \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                                    (v).size * sizeof((v).items[0]))) \\", "                     : ((v).items == (v).init_array \\", "                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                     : ((v).items == (v).init_array \\", "                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\", "                              (v).items, \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                              (v).size * sizeof((v).items[0])) \\", "                     : xrealloc((v).items, \\", "                                (v).capacity * sizeof((v).items[0])))))"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["   (v).items = ((v).capacity == ARRAY_SIZE((v).init_array) \\", "                  ? ((v).items == (v).init_array \\", "                     ? (v).items \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                                    (v).size * sizeof((v).items[0]))) \\", "                     : ((v).items == (v).init_array \\", "                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                     : ((v).items == (v).init_array \\", "                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\", "                              (v).items, \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                              (v).size * sizeof((v).items[0])) \\", "                     : xrealloc((v).items, \\", "                                (v).capacity * sizeof((v).items[0])))))"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                     : ((v).items == (v).init_array \\", "                     ? memcpy(xmalloc((v).capacity * sizeof((v).items[0])), \\", "                              (v).items, \\"], "whitespace/alignment"]
["src/nvim/lib/kvec.h", ["                              (v).size * sizeof((v).items[0])) \\", "                     : xrealloc((v).items, \\", "                                (v).capacity * sizeof((v).items[0])))))"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["  ((rb)->first == NULL ? 0 \\", "                       : ((rb)->next == (rb)->first) ? (size_t)((rb)->buf_end - (rb)->buf) + 1 \\", "                                                     : ((rb)->next > \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["                       : ((rb)->next == (rb)->first) ? (size_t)((rb)->buf_end - (rb)->buf) + 1 \\", "                                                     : ((rb)->next > \\", "                                                        (rb)->first) ? (size_t)((rb)->next - \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["                                                                                (rb)->first) \\", "                                                                     : (size_t)((rb)-> \\", "                                                                                next - (rb)->buf + \\"], "whitespace/alignment"]
["src/nvim/lib/ringbuf.h", ["  size_t varname##_length_fa_ = _RINGBUF_LENGTH(rb); \\", "  for (RBType *varname = ((rb)->first == NULL ? (rb)->next : (rb)->first); \\", "       varname##_length_fa_; \\"], "readability/braces"]
["src/nvim/lib/ringbuf.h", ["  size_t varname##_length_ib_ = _RINGBUF_LENGTH(rb); \\", "  for (varname = ((rb)->next == (rb)->buf ? (rb)->buf_end : (rb)->next - 1); \\", "       varname##_length_ib_; \\"], "readability/braces"]
["src/nvim/macros.h", ["  do { \\", "    if (*p_langmap \\", "        && (condition) \\"], "readability/braces"]
["src/nvim/macros.h", ["    { \\", "      if ((c) < 256) \\", "      c = langmap_mapchar[c]; \\"], "readability/braces"]
["src/nvim/macros.h", ["      c = langmap_mapchar[c]; \\", "      else \\", "      c = langmap_adjust_mb(c); \\"], "readability/braces"]
["src/nvim/macros.h", ["      c = langmap_mapchar[c]; \\", "      else \\", "      c = langmap_adjust_mb(c); \\"], "whitespace/newline"]
["src/nvim/main.c", ["  if (params.edit_type == EDIT_QF) {", "    qf_jump(NULL, 0, 0, FALSE);", "    TIME_MSG(\"jump to first error\");"], "readability/bool"]
["src/nvim/main.c", ["    FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "      diff_win_options(wp, TRUE);", "    }"], "readability/bool"]
["src/nvim/main.c", ["    // give the user a chance to read the (error) message", "    no_wait_return = FALSE;", "    wait_return(FALSE);"], "readability/bool"]
["src/nvim/main.c", ["    no_wait_return = FALSE;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["              a = SESSION_FILE;", "              ++argc;", "              --argv;"], "readability/increment"]
["src/nvim/main.c", ["              ++argc;", "              --argv;", "            } else {"], "readability/increment"]
["src/nvim/main.c", ["          } else if ((scriptin[0] =", "                        file_open_new(&error, argv[0], kFileReadOnly|kFileNonBlocking,", "                                      0)) == NULL) {"], "whitespace/alignment"]
["src/nvim/main.c", ["", "/*", " * Many variables are in \"params\" so that we can pass them to invoked"], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Decide about window layout for diff mode after reading vimrc."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * \"-q errorfile\": Load the error file now."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Need to jump to the tag before executing the '-c command'."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Create the requested number of windows and edit buffers in them."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * Create the number of windows that was requested."], "readability/old_style_comment"]
["src/nvim/main.c", ["    // Don't execute Win/Buf Enter/Leave autocommands here", "    ++autocmd_no_enter;", "    ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_enter;", "    ++autocmd_no_leave;", "    dorewind = TRUE;"], "readability/increment"]
["src/nvim/main.c", ["    ++autocmd_no_leave;", "    dorewind = TRUE;", "    while (done++ < 1000) {"], "readability/bool"]
["src/nvim/main.c", ["      }", "      dorewind = FALSE;", "      curbuf = curwin->w_buffer;"], "readability/bool"]
["src/nvim/main.c", ["        swap_exists_action = SEA_DIALOG;", "        set_buflisted(TRUE);", ""], "readability/bool"]
["src/nvim/main.c", ["        // create memfile, read file", "        (void)open_buffer(FALSE, NULL, 0);", ""], "readability/bool"]
["src/nvim/main.c", ["            // abort selected or quit and only one window", "            did_emsg = FALSE;               // avoid hit-enter prompt", "            getout(1);"], "readability/bool"]
["src/nvim/main.c", ["        }", "        dorewind = TRUE;                        // start again", "      }"], "readability/bool"]
["src/nvim/main.c", ["    curbuf = curwin->w_buffer;", "    --autocmd_no_enter;", "    --autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["    --autocmd_no_enter;", "    --autocmd_no_leave;", "  }"], "readability/increment"]
["src/nvim/main.c", ["", "  /*", "   * Don't execute Win/Buf Enter/Leave autocommands here"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  ++autocmd_no_enter;", "  ++autocmd_no_leave;"], "readability/increment"]
["src/nvim/main.c", ["  ++autocmd_no_enter;", "  ++autocmd_no_leave;", ""], "readability/increment"]
["src/nvim/main.c", ["  arg_idx = 1;", "  for (i = 1; i < parmp->window_count; ++i) {", "    if (cwd != NULL) {"], "readability/increment"]
["src/nvim/main.c", ["          // abort selected and only one window", "          did_emsg = FALSE;             // avoid hit-enter prompt", "          getout(1);"], "readability/bool"]
["src/nvim/main.c", ["  }", "  --autocmd_no_enter;", ""], "readability/increment"]
["src/nvim/main.c", ["", "  --autocmd_no_leave;", "  TIME_MSG(\"editing files in windows\");"], "readability/increment"]
["src/nvim/main.c", ["", "/*", " * Execute the commands from --cmd arguments \"cmds[cnt]\"."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "/*", " * Execute \"+\", \"-c\" and \"-S\" arguments."], "readability/old_style_comment"]
["src/nvim/main.c", ["", "  /*", "   * We start commands on line 0, make \"vim +/pat file\" match a"], "readability/old_style_comment"]
["src/nvim/main.c", ["   */", "  msg_scroll = TRUE;", "  if (parmp->tagname == NULL && curwin->w_cursor.lnum <= 1) {"], "readability/bool"]
["src/nvim/main.c", ["  if (!exmode_active) {", "    msg_scroll = FALSE;", "  }"], "readability/bool"]
["src/nvim/main.c", ["  if (parmp->edit_type == EDIT_QF) {", "    qf_jump(NULL, 0, 0, FALSE);", "  }"], "readability/bool"]
["src/nvim/main.c", ["      // If vimrc file is not owned by user, set 'secure' mode.", "      if (!file_owned(VIMRC_FILE))", "#endif"], "readability/braces"]
["src/nvim/main.c", ["", "/*", " * Check the result of the ATTENTION dialog:"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * mark.c: functions for setting marks and jumping to them"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * This file contains routines to maintain and manipulate marks."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * If a named file mark's lnum is non-zero, it is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "/*", " * Set named mark \"c\" at current cursor position."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set named mark \"c\" to position \"pos\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Set the previous context mark to the current position and add it to the"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * To change context, call setpcmark(), then move the current position to"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * move \"count\" positions in the jump list (count may be negative)"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "    /*", "     * if first CTRL-O or CTRL-I command after a jump, add cursor position"], "readability/old_style_comment"]
["src/nvim/mark.c", ["      setpcmark();", "      --curwin->w_jumplistidx;          // skip the new entry", "      if (curwin->w_jumplistidx + count < 0) {"], "readability/increment"]
["src/nvim/mark.c", ["      if (buflist_getfile(jmp->fmark.fnum, jmp->fmark.mark.lnum,", "                          0, FALSE) == FAIL) {", "        return (pos_T *)NULL;"], "readability/bool"]
["src/nvim/mark.c", ["", "/*", " * Move \"count\" positions in the changelist (count may be negative)."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Find mark \"c\" in buffer pointed to by \"buf\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["    if (findpar(&oa.inclusive,", "                c == '}' ? FORWARD : BACKWARD, 1L, NUL, FALSE)) {", "      pos_copy = curwin->w_cursor;"], "readability/bool"]
["src/nvim/mark.c", ["        if (buflist_getfile(namedfm[c].fmark.fnum,", "                            (linenr_T)1, GETF_SETMARK, FALSE) == OK) {", "          // Set the lnum now, autocommands could have changed it"], "readability/bool"]
["src/nvim/mark.c", ["", "/*", " * For an xtended filemark: set the fnum from the fname."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  if (fm->fname != NULL) {", "    /*", "     * First expand \"~/\" in the file name to the home directory."], "readability/old_style_comment"]
["src/nvim/mark.c", ["#endif", "                                )) {", "      int len;"], "whitespace/parens"]
["src/nvim/mark.c", ["", "/*", " * Check all file marks for a name that matches the file name in buf."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < NGLOBALMARKS; ++i) {", "    fmarks_check_one(&namedfm[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    for (i = 0; i < wp->w_jumplistlen; ++i) {", "      fmarks_check_one(&wp->w_jumplist[i], name, buf);"], "readability/increment"]
["src/nvim/mark.c", ["", "/*", " * Check a if a position from a mark is valid."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * Get name of file from a filemark."], "readability/old_style_comment"]
["src/nvim/mark.c", ["  }", "  return buflist_nr2name(fmark->fnum, FALSE, TRUE);", "}"], "readability/bool"]
["src/nvim/mark.c", ["", "/*", " * Return the line at mark \"mp\".  Truncate to fit in window."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "/*", " * print the marks"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  show_one_mark('\\'', arg, &curwin->w_pcmark, NULL, true);", "  for (i = 0; i < NMARKS; ++i) {", "    show_one_mark(i + 'a', arg, &curbuf->b_namedm[i].mark, NULL, true);"], "readability/increment"]
["src/nvim/mark.c", ["  }", "  for (i = 0; i < NGLOBALMARKS; ++i) {", "    if (namedfm[i].fmark.fnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["", "/*", " * \":delmarks[!] [marks]\""], "readability/old_style_comment"]
["src/nvim/mark.c", ["          if (!(lower ? ASCII_ISLOWER(p[2])", "                      : (digit ? ascii_isdigit(p[2])", "                               : ASCII_ISUPPER(p[2])))"], "whitespace/alignment"]
["src/nvim/mark.c", ["                      : (digit ? ascii_isdigit(p[2])", "                               : ASCII_ISUPPER(p[2])))", "              || to < from) {"], "whitespace/alignment"]
["src/nvim/mark.c", ["                      : (digit ? ascii_isdigit(p[2])", "                               : ASCII_ISUPPER(p[2])))", "              || to < from) {"], "whitespace/alignment"]
["src/nvim/mark.c", ["", "        for (i = from; i <= to; ++i) {", "          if (lower) {"], "readability/increment"]
["src/nvim/mark.c", ["        case '\"':", "          CLEAR_FMARK(&curbuf->b_last_cursor); break;", "        case '^':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case '^':", "          CLEAR_FMARK(&curbuf->b_last_insert); break;", "        case '.':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case '.':", "          CLEAR_FMARK(&curbuf->b_last_change); break;", "        case '[':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case '[':", "          curbuf->b_op_start.lnum    = 0; break;", "        case ']':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case ']':", "          curbuf->b_op_end.lnum      = 0; break;", "        case '<':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case '<':", "          curbuf->b_visual.vi_start.lnum = 0; break;", "        case '>':"], "whitespace/newline"]
["src/nvim/mark.c", ["        case '>':", "          curbuf->b_visual.vi_end.lnum   = 0; break;", "        case ' ':"], "whitespace/newline"]
["src/nvim/mark.c", ["", "/*", " * print the jumplist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["  msg_puts_title(_(\"\\n jump line  col file/text\"));", "  for (i = 0; i < curwin->w_jumplistlen && !got_int; ++i) {", "    if (curwin->w_jumplist[i].fmark.mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["              i > curwin->w_jumplistidx ? i - curwin->w_jumplistidx", "                                        : curwin->w_jumplistidx - i,", "              curwin->w_jumplist[i].fmark.mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["      }", "      sprintf((char *)IObuff, \"%c %2d %5ld %4d \",", "              i == curwin->w_jumplistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["", "/*", " * print the changelist"], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < curbuf->b_changelistlen && !got_int; ++i) {", "    if (curbuf->b_changelist[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/mark.c", ["              i > curwin->w_changelistidx ? i - curwin->w_changelistidx", "                                          : curwin->w_changelistidx - i,", "              (long)curbuf->b_changelist[i].mark.lnum,"], "whitespace/alignment"]
["src/nvim/mark.c", ["      }", "      sprintf((char *)IObuff, \"%c %3d %5ld %4d \",", "              i == curwin->w_changelistidx ? '>' : ' ',"], "runtime/printf"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "      *lp = 0; \\"], "readability/braces"]
["src/nvim/mark.c", ["      *lp = 0; \\", "      else \\", "      *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["      *lp = 0; \\", "      else \\", "      *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "    *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["    lp = add; \\", "    if (*lp >= line1 && *lp <= line2) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["    { \\", "      if (amount == MAXLNUM) \\", "      *lp = line1; \\"], "readability/braces"]
["src/nvim/mark.c", ["      *lp = line1; \\", "      else \\", "      *lp += amount; \\"], "readability/braces"]
["src/nvim/mark.c", ["      *lp = line1; \\", "      else \\", "      *lp += amount; \\"], "whitespace/newline"]
["src/nvim/mark.c", ["    } \\", "    else if (amount_after && *lp > line2) \\", "    *lp += amount_after; \\"], "readability/braces"]
["src/nvim/mark.c", ["", "/*", " * Adjust marks between line1 and line2 (inclusive) to move 'amount' lines."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["    posp = pp; \\", "    if (posp->lnum == lnum && posp->col >= mincol) \\", "    { \\"], "readability/braces"]
["src/nvim/mark.c", ["", "  /*", "   * Adjust items in all windows related to the current buffer."], "readability/old_style_comment"]
["src/nvim/mark.c", ["    // marks in the jumplist", "    for (i = 0; i < win->w_jumplistlen; ++i) {", "      if (win->w_jumplist[i].fmark.fnum == fnum) {"], "readability/increment"]
["src/nvim/mark.c", ["", "/*", " * Copy the jumplist from window \"from\" to window \"to\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < from->w_jumplistlen; ++i) {", "    to->w_jumplist[i] = from->w_jumplist[i];"], "readability/increment"]
["src/nvim/mark.c", ["    (iter == NULL", "       ? &(win->w_jumplist[0])", "       : (const xfmark_T *const)iter);"], "whitespace/alignment"]
["src/nvim/mark.c", ["       ? &(win->w_jumplist[0])", "       : (const xfmark_T *const)iter);", "  *fm = *iter_mark;"], "whitespace/alignment"]
["src/nvim/mark.c", ["  *name = (char)(iter_off < NMARKS", "                  ? 'A' + (char)iter_off", "                  : '0' + (char)(iter_off - NMARKS));"], "whitespace/alignment"]
["src/nvim/mark.c", ["                  ? 'A' + (char)iter_off", "                  : '0' + (char)(iter_off - NMARKS));", "  *fm = *iter_mark;"], "whitespace/alignment"]
["src/nvim/mark.c", ["  char mark_name = (char)(iter == NULL", "                           ? NUL", "                           : (iter == &(buf->b_last_cursor)"], "whitespace/alignment"]
["src/nvim/mark.c", ["                           ? NUL", "                           : (iter == &(buf->b_last_cursor)", "                              ? '\"'"], "whitespace/alignment"]
["src/nvim/mark.c", ["", "/*", " * Free items in the jumplist of window \"wp\"."], "readability/old_style_comment"]
["src/nvim/mark.c", ["", "  for (i = 0; i < wp->w_jumplistlen; ++i) {", "    free_xfmark(wp->w_jumplist[i]);"], "readability/increment"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "build/header_guard"]
["src/nvim/mark_defs.h", ["", "/*", " * marks: positions in a file"], "readability/old_style_comment"]
["src/nvim/mark_defs.h", ["", "#endif // NVIM_MARK_DEFS_H", ""], "whitespace/comments"]
["src/nvim/marktree.c", ["  if (begin == x->n) {", "    *rr = 1; return x->n - 1;", "  }"], "whitespace/newline"]
["src/nvim/marktree.c", ["    s = (mtnode_t *)xcalloc(1, ILEN);", "    b->root = s; s->level = r->level + 1; s->n = 0;", "    s->ptr[0] = r;"], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Canonical encoding names and their properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name;   int prop;              int codepage; }", "enc_canon_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Aliases for encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["static struct", "{   const char *name; int canon; }", "enc_alias_table[] ="], "whitespace/newline"]
["src/nvim/mbyte.c", ["", "/*", " * Find encoding \"name\" in the list of canonical encoding names."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Find canonical encoding \"name\" in the list and return its properties."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the size of the BOM for the current buffer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Remove all BOM from \"s\" by moving remaining text."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of pointer:"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is in \"table\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte sequence to a wide character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get character at **pp and advance *pp to the next character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Check if the character pointed to by \"p2\" is a composing character when it"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert a UTF-8 byte string to a wide character.  Also get up to MAX_MCO"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return length of UTF-8 character, obtained from the first byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the length of UTF-8 byte sequence \"p[size]\".  Does not include any"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  }", "  for (i = 1; i < m; ++i) {", "    if ((p[i] & 0xc0) != 0x80) {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the number of bytes the UTF-8 encoding of the character at \"p[size]\""], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "  /*", "   * Check for composing characters.  We can handle only the first six, but"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "    /*", "     * Next character length should not go beyond size to ensure that"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true if \"c\" is a composing UTF-8 character.  This means it will be"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return true for characters that can be displayed in a normal way."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  static struct interval nonprint[] =", "  {", "    { 0x070f, 0x070f }, { 0x180b, 0x180e }, { 0x200b, 0x200f }, { 0x202a, 0x202e },"], "whitespace/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Get class of a Unicode character."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Generic conversion function for case operations."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Return the folded-case equivalent of \"a\", which is a UCS-4 character.  Uses"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Version of strnicmp() that handles multi-byte characters."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * \"g8\": show bytes of the UTF-8 char under the cursor.  Doesn't matter what"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  clen = 0;", "  for (i = 0; i < len; ++i) {", "    if (clen == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["    }", "    sprintf((char *)IObuff + rlen, \"%02x \",", "            (line[i] == NL) ? NUL : line[i]);          // NUL is stored as NL"], "runtime/printf"]
["src/nvim/mbyte.c", ["            (line[i] == NL) ? NUL : line[i]);          // NUL is stored as NL", "    --clen;", "    rlen += (int)STRLEN(IObuff + rlen);"], "readability/increment"]
["src/nvim/mbyte.c", ["  const char_u *q;", "  for (q = p;; --q) {", "    // Move s to the last byte of this char."], "readability/increment"]
["src/nvim/mbyte.c", ["    const char_u *s;", "    for (s = q; (s[1] & 0xc0) == 0x80; ++s) {}", ""], "readability/increment"]
["src/nvim/mbyte.c", ["    while (q > base && (*q & 0xc0) == 0x80) {", "      --q;", "    }"], "readability/increment"]
["src/nvim/mbyte.c", ["      const char_u *j = q;", "      --j;", "      // Move j to the first byte of this char."], "readability/increment"]
["src/nvim/mbyte.c", ["      while (j > base && (*j & 0xc0) == 0x80) {", "        --j;", "      }"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Find the next illegal byte sequence."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    }", "    ++curwin->w_cursor.lnum;", "    curwin->w_cursor.col = 0;"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * If the cursor moves on an trail byte, set the cursor on the lead byte."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Skip the Vim specific head of a 'encoding' name."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Find the canonical name for encoding \"enc\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  p = r;", "  for (s = enc; *s != NUL; ++s) {", "    if (*s == '_') {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "  for (i = 0; enc_alias_table[i].name != NULL; ++i) {", "    if (STRCMP(name, enc_alias_table[i].name) == 0) {"], "readability/increment"]
["src/nvim/mbyte.c", ["", "/*", " * Get the canonicalized encoding of the current locale."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["#ifdef HAVE_NL_LANGINFO_CODESET", "  if (!(s = nl_langinfo(CODESET)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["#if defined(HAVE_LOCALE_H)", "    if (!(s = setlocale(LC_CTYPE, NULL)) || *s == NUL)", "#endif"], "readability/braces"]
["src/nvim/mbyte.c", ["", "/*", " * Call iconv_open() with a check if iconv() works properly (there are broken"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["  if (fd != (iconv_t)-1 && iconv_working == kUnknown) {", "    /*", "     * Do a dummy iconv() call to check if it actually works.  There is a"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert the string \"str[slen]\" with iconv()."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Setup \"vcp\" for conversion from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Convert text \"ptr[*lenp]\" according to \"vcp\"."], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["", "/*", " * Like string_convert(), but when \"unconvlenp\" is not NULL and there are is"], "readability/old_style_comment"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      c = ptr[i];"], "readability/increment"]
["src/nvim/mbyte.c", ["      case 0xa4:", "        c = 0x20ac; break;                 // euro", "      case 0xa6:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xa6:", "        c = 0x0160; break;                 // S hat", "      case 0xa8:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xa8:", "        c = 0x0161; break;                 // S -hat", "      case 0xb4:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xb4:", "        c = 0x017d; break;                 // Z hat", "      case 0xb8:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xb8:", "        c = 0x017e; break;                 // Z -hat", "      case 0xbc:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbc:", "        c = 0x0152; break;                 // OE", "      case 0xbd:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbd:", "        c = 0x0153; break;                 // oe", "      case 0xbe:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["      case 0xbe:", "        c = 0x0178; break;                 // Y", "      }"], "whitespace/newline"]
["src/nvim/mbyte.c", ["    d = retval;", "    for (size_t i = 0; i < len; ++i) {", "      l = utf_ptr2len_len(ptr + i, len - i);"], "readability/increment"]
["src/nvim/mbyte.c", ["          case 0x20ac:", "            c = 0xa4; break;                     // euro", "          case 0x0160:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0160:", "            c = 0xa6; break;                     // S hat", "          case 0x0161:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0161:", "            c = 0xa8; break;                     // S -hat", "          case 0x017d:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x017d:", "            c = 0xb4; break;                     // Z hat", "          case 0x017e:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x017e:", "            c = 0xb8; break;                     // Z -hat", "          case 0x0152:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0152:", "            c = 0xbc; break;                     // OE", "          case 0x0153:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0153:", "            c = 0xbd; break;                     // oe", "          case 0x0178:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0x0178:", "            c = 0xbe; break;                     // Y", "          case 0xa4:"], "whitespace/newline"]
["src/nvim/mbyte.c", ["          case 0xbe:", "            c = 0x100; break;                   // not in latin9", "          }"], "whitespace/newline"]
["src/nvim/mbyte.h", ["", "/*", " * Return byte length of character that starts with byte \"b\"."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * memline.c: Contains the functions for appending, deleting and changing the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * pointer to a block, used in a pointer block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A pointer block contains a list of branches in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * A data block is a leaf in the tree."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The low bits of db_index hold the actual index. The topmost bit is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["#define B0_HNAME_SIZE           40", "/*", " * Restrict the numbers to 32 bits, otherwise most compilers will complain."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * Block zero holds all info about the swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  int b0_magic_int;             // check for byte order of int", "  short b0_magic_short;         // check for byte order of short", "  char_u b0_magic_char;         // check for last char"], "runtime/int"]
["src/nvim/memline.c", ["", "/*", " * Note: b0_dirty and b0_flags are put at the end of the file name.  For very"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The b0_flags field is new in Vim 7.0."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * The line number where the first mark may be is remembered."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * arguments for ml_find_line()"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * When 'updatecount' is non-zero swap file may be opened later."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * fill block0 struct and write page 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  b0p->b0_magic_int = (int)B0_MAGIC_INT;", "  b0p->b0_magic_short = (short)B0_MAGIC_SHORT;", "  b0p->b0_magic_char = B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "  /*", "   * Always sync block number 0 to disk, so we can check the file name in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Fill in root pointer block and write page 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate first data block and create an empty line 1."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (mfp->mf_fd < 0) {             // there is no swap file yet", "    /*", "     * When 'updatecount' is 0 and 'noswapfile' there is no swap file."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in the 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try all directories in 'directory' option."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (!bufIsChanged(buf)) {", "      ml_close(buf, TRUE);          // close all not-modified buffers", "    }"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * For a file under the home directory of the current user, we try to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    home_replace(NULL, buf->b_ffname, b0p->b0_fname,", "                 B0_FNAME_SIZE_CRYPT, TRUE);", "    if (b0p->b0_fname[0] == '~') {"], "readability/bool"]
["src/nvim/memline.c", ["", "  recoverymode = TRUE;", "  called_from_main = (curbuf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/memline.c", ["    // count the number of matching swap files", "    len = recover_names(fname, FALSE, 0, NULL);", "    if (len == 0) {                 // no swap files found"], "readability/bool"]
["src/nvim/memline.c", ["      // list the names of the swap files", "      (void)recover_names(fname, TRUE, 0, NULL);", "      msg_putchar('\\n');"], "readability/bool"]
["src/nvim/memline.c", ["      msg_puts(_(\"Enter number of swap file to use (0 to quit): \"));", "      i = get_number(FALSE, NULL);", "      if (i < 1 || i > len) {"], "readability/bool"]
["src/nvim/memline.c", ["    // get the swap file name that will be used", "    (void)recover_names(fname, FALSE, i, &fname_used);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * Allocate a buffer structure for the swap file that is used for recovery."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * init fields in memline struct"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * open the memfile from the old swap file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * The page size set in mf_open() might be different from the page size"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * try to read block 0"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If we guessed the wrong page size, we have to recalculate the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If .swp file name given directly, use name from swap file for buffer."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  home_replace(NULL, mfp->mf_fname, NameBuff, MAXPATHL, TRUE);", "  smsg(_(\"Using swap file \\\"%s\\\"\"), NameBuff);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    home_replace(NULL, curbuf->b_ffname, NameBuff, MAXPATHL, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * check date of swap file and original file"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Now that we are sure that the file is going to be recovered, clear the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Try reading the original file to obtain the values of 'fileformat',"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    }", "    /*", "     * get block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        if (idx == 0 && line_count != 0) {", "          for (i = 0; i < (int)pp->pb_count; ++i) {", "            line_count -= pp->pb_pointer[i].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["          if (pp->pb_pointer[idx].pe_bnum < 0) {", "            /*", "             * Data block with negative block number."], "readability/old_style_comment"]
["src/nvim/memline.c", ["            }", "            ++idx;                  // get same block again for next index", "            continue;"], "readability/increment"]
["src/nvim/memline.c", ["", "          /*", "           * going one block deeper in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          /*", "           * check number of lines in block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "          for (i = 0; i < dp->db_line_count; ++i) {", "            txt_start = (dp->db_index[i] & DB_INDEX_MASK);"], "readability/increment"]
["src/nvim/memline.c", ["              p = (char_u *)\"???\";", "              ++error;", "            } else {"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * go one block up in the tree"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Compare the buffer contents with the original file.  When they differ"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {", "    for (idx = 1; idx <= lnum; ++idx) {", "      // Need to copy one line, fetching the other one may flush it."], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Delete the lines from the original file and the dummy line from the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  recoverymode = FALSE;", "  if (got_int) {"], "readability/bool"]
["src/nvim/memline.c", ["  } else if (error) {", "    ++no_wait_return;", "    msg(\">>>>>>>>>>>>>\");"], "readability/increment"]
["src/nvim/memline.c", ["    emsg(_(\"E312: Errors detected while recovering; look for lines starting with ???\"));", "    --no_wait_return;", "    msg(_(\"See \\\":help E312\\\" for more information.\"));"], "readability/increment"]
["src/nvim/memline.c", ["  xfree(fname_used);", "  recoverymode = FALSE;", "  if (mfp != NULL) {"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  if (buf != NULL) {  //may be NULL if swap file not found.", "    xfree(buf->b_ml.ml_stack);"], "whitespace/comments"]
["src/nvim/memline.c", ["  if (serious_error && called_from_main) {", "    ml_close(curbuf, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/memline.c", ["      fname_res = fname_buf;", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["      } else {", "        num_names = recov_file_names(names, fname_res, TRUE);", "      }"], "readability/bool"]
["src/nvim/memline.c", ["        }", "        num_names = recov_file_names(names, tail, FALSE);", "        xfree(tail);"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * When no swap file found, wildcard expansion might have failed (e.g."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * remove swapfile name of the current buffer, it must be ignored"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          } else {", "            for (; i < num_files; ++i) {", "              files[i] = files[i + 1];"], "readability/increment"]
["src/nvim/memline.c", ["      if (num_files) {", "        for (int i = 0; i < num_files; ++i) {", "          // print the swap file name"], "readability/increment"]
["src/nvim/memline.c", ["", "    for (int i = 0; i < num_names; ++i) {", "      xfree(names[i]);"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    d = concat_fnames(dir, s, TRUE);", "    xfree(s);"], "readability/bool"]
["src/nvim/memline.c", ["      msg_puts(_(\"   dated: \"));", "    } else", "#endif"], "readability/braces"]
["src/nvim/memline.c", ["", "  /*", "   * print the original file name"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  // Form the normal swap file name pattern by appending \".sw?\".", "  names[num_names] = (char_u *)concat_fnames((char *)path, \".sw?\", FALSE);", "  if (num_names >= 1) {     // check if we have the same name twice"], "readability/bool"]
["src/nvim/memline.c", ["    if (STRCMP(p, names[num_names]) != 0) {", "      ++num_names;", "    } else {"], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    ++num_names;", "  }"], "readability/increment"]
["src/nvim/memline.c", ["        && buf->b_ffname != NULL) {", "      /*", "       * If the original file does not exist anymore or has been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Some of the data blocks may have been changed from negative to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "/*", " * NOTE: The pointer returned by the ml_get_*() functions only remains valid"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * See if it is the same line as requested last time."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  // When starting up, we might still need to create the memfile", "  if (curbuf->b_ml.ml_mfp == NULL && open_buffer(FALSE, NULL, 0) == FAIL) {", "    return FAIL;"], "readability/bool"]
["src/nvim/memline.c", ["  }", "  return ml_append_int(buf, lnum, line, len, newfile, FALSE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the previous line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      && lnum < buf->b_ml.ml_line_count) {", "    /*", "     * Now that the line is not going to be inserted in the block that we"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["    --(buf->b_ml.ml_locked_lineadd);", "    --(buf->b_ml.ml_locked_high);", "    if ((hp = ml_find_line(buf, lnum + 1, ML_INSERT)) == NULL) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  ++buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["  if ((int)dp->db_free >= space_needed) {       // enough room in data block", "    /*", "     * Insert new line in existing data block, or in data block allocated above."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    dp->db_free -= space_needed;", "    ++(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * move the text of the lines that follow to the front"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (line_count > db_idx + 1) {          // if there are following lines", "      /*", "       * Offset is the start of the previous line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              (size_t)(offset - (dp->db_txt_start + len)));", "      for (i = line_count - 1; i > db_idx; --i) {", "        dp->db_index[i + 1] = dp->db_index[i] - len;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * copy the text into the block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Mark the block dirty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  } else {        // not enough space in data block", "    /*", "     * If there is not enough room we have to create a new data block and copy some"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * We are going to allocate a new data block. Depending on the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the right/new block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              line, (size_t)len);", "      ++line_count_right;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    /*", "     * may move lines from the left/old block to the right/new one."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (lines_moved) {", "      /*", "       */"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "      /*", "       * update indexes in the new block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      for (to = line_count_right, from = db_idx + 1;", "           from < line_count_left; ++from, ++to) {", "        dp_right->db_index[to] = dp->db_index[from] + offset;"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * May move the new line into the left (old or new) block."], "readability/old_style_comment"]
["src/nvim/memline.c", ["              line, (size_t)len);", "      ++line_count_left;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * release the two data blocks"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * flush the old data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update pointer blocks for the new data block"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      ip = &(buf->b_ml.ml_stack[stack_idx]);"], "readability/increment"]
["src/nvim/memline.c", ["      }", "      /*", "       * TODO: If the pointer block is full and we are adding at the end"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        }", "        ++pp->pb_count;", "        pp->pb_pointer[pb_idx].pe_line_count = line_count_left;"], "readability/increment"]
["src/nvim/memline.c", ["        if (lineadd) {", "          --(buf->b_ml.ml_stack_top);", "          // fix line count for rest of blocks in the stack"], "readability/increment"]
["src/nvim/memline.c", ["            lineadd;", "          ++(buf->b_ml.ml_stack_top);", "        }"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * We are finished, break the loop here."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * Safety check: fallen out of for loop?"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * If the file becomes empty the last line is replaced by an empty line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  --buf->b_ml.ml_line_count;", ""], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * special case: If there is only one line in the data block it becomes empty."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;", "         --stack_idx) {", "      buf->b_ml.ml_stack_top = 0;           // stack is invalid when failing"], "readability/increment"]
["src/nvim/memline.c", ["        }", "        ++(buf->b_ml.ml_stack_top);", ""], "readability/increment"]
["src/nvim/memline.c", ["  } else {", "    /*", "     * delete the text by moving the next lines forwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * delete the index by moving the next indexes backwards"], "readability/old_style_comment"]
["src/nvim/memline.c", ["     */", "    for (i = idx; i < count - 1; ++i) {", "      dp->db_index[i] = dp->db_index[i + 1] + line_size;"], "readability/increment"]
["src/nvim/memline.c", ["    dp->db_txt_start += line_size;", "    --(dp->db_line_count);", ""], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * mark the block dirty and make sure it is in the file (for recovery)"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * find the data block containing the line"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with lowest_marked line. This is the last line where"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count;) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum) {", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * The search starts with line lowest_marked."], "readability/old_style_comment"]
["src/nvim/memline.c", ["  for (lnum = lowest_marked; lnum <= curbuf->b_ml.ml_line_count;) {", "    /*", "     * Find the data block containing the line."], "readability/old_style_comment"]
["src/nvim/memline.c", ["    for (i = lnum - curbuf->b_ml.ml_locked_low;", "         lnum <= curbuf->b_ml.ml_locked_high; ++i, ++lnum) {", "      if ((dp->db_index[i]) & DB_MARKED) {"], "readability/increment"]
["src/nvim/memline.c", ["", "      /*", "       * if new line fits in data block, replace directly"], "readability/old_style_comment"]
["src/nvim/memline.c", ["          // adjust pointers of this and following lines", "          for (i = idx + 1; i < count; ++i) {", "            dp->db_index[i] -= extra;"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * If there is a locked block check if the wanted line is in it."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      if (action == ML_INSERT) {", "        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        ++(buf->b_ml.ml_locked_lineadd);", "        ++(buf->b_ml.ml_locked_high);", "      } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["      } else if (action == ML_DELETE) {", "        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);"], "readability/increment"]
["src/nvim/memline.c", ["        --(buf->b_ml.ml_locked_lineadd);", "        --(buf->b_ml.ml_locked_high);", "      }"], "readability/increment"]
["src/nvim/memline.c", ["", "    /*", "     * If lines have been added or deleted in the locked block, need to"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (action == ML_FIND) {      // first try stack entries", "    for (top = buf->b_ml.ml_stack_top - 1; top >= 0; --top) {", "      ip = &(buf->b_ml.ml_stack[top]);"], "readability/increment"]
["src/nvim/memline.c", ["  }", "  /*", "   * search downwards in the tree until a data block is found"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "    /*", "     * update high for insert/delete"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    if (action == ML_INSERT) {", "      ++high;", "    } else if (action == ML_DELETE) {"], "readability/increment"]
["src/nvim/memline.c", ["    } else if (action == ML_DELETE) {", "      --high;", "    }"], "readability/increment"]
["src/nvim/memline.c", ["", "    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {"], "readability/bool"]
["src/nvim/memline.c", ["    dirty = FALSE;", "    for (idx = 0; idx < (int)pp->pb_count; ++idx) {", "      t = pp->pb_pointer[idx].pe_line_count;"], "readability/increment"]
["src/nvim/memline.c", ["", "        /*", "         * a negative block number may have been changed"], "readability/old_style_comment"]
["src/nvim/memline.c", ["            pp->pb_pointer[idx].pe_bnum = bnum;", "            dirty = TRUE;", "          }"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count--;", "      dirty = TRUE;", "    } else if (action == ML_INSERT) {"], "readability/bool"]
["src/nvim/memline.c", ["      pp->pb_pointer[idx].pe_line_count++;", "      dirty = TRUE;", "    }"], "readability/bool"]
["src/nvim/memline.c", ["error_noblock:", "  /*", "   * If action is ML_DELETE or ML_INSERT we have to correct the tree for"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  for (idx = buf->b_ml.ml_stack_top - 1; idx >= 0; --idx) {", "    ip = &(buf->b_ml.ml_stack[idx]);"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Try to resolve the full name of the file so that the swapfile name will"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  return vim_FullName((char *)tmp, (char *)buf, MAXPATHL, TRUE);", "}"], "readability/bool"]
["src/nvim/memline.c", ["    if (tail == fname) {            // no path before file name", "      retval = (char_u *)concat_fnames((char *)dname + 2, (char *)tail, TRUE);", "    } else {"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = NUL;", "      t = (char_u *)concat_fnames((char *)fname, (char *)dname + 2, TRUE);", "      *tail = save_char;"], "readability/bool"]
["src/nvim/memline.c", ["      *tail = save_char;", "      retval = (char_u *)concat_fnames((char *)t, (char *)tail, TRUE);", "      xfree(t);"], "readability/bool"]
["src/nvim/memline.c", ["  } else {", "    retval = (char_u *)concat_fnames((char *)dname, (char *)tail, TRUE);", "  }"], "readability/bool"]
["src/nvim/memline.c", ["", "  ++no_wait_return;", "  (void)emsg(_(\"E325: ATTENTION\"));"], "readability/increment"]
["src/nvim/memline.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/memline.c", ["", "  /*", "   * Isolate a directory name from *dirp and put it in dir_name."], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * we try different names until we find one that does not exist yet"], "readability/old_style_comment"]
["src/nvim/memline.c", ["        struct block0 b0;", "        int differ = FALSE;", ""], "readability/bool"]
["src/nvim/memline.c", ["                                 char_to_long(b0.b0_ino))) {", "                  differ = TRUE;", "                }"], "readability/bool"]
["src/nvim/memline.c", ["                               char_to_long(b0.b0_ino))) {", "                differ = TRUE;", "              }"], "readability/bool"]
["src/nvim/memline.c", ["            case 1:", "              buf->b_p_ro = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["              swap_exists_action = SEA_QUIT;", "              got_int = TRUE;", "              break;"], "readability/bool"]
["src/nvim/memline.c", ["", "    /*", "     * Change the \".swp\" extension to find another file that can be used."], "readability/old_style_comment"]
["src/nvim/memline.c", ["      }", "      --fname[n - 2];                   // \".svz\", \".suz\", etc.", "      fname[n - 1] = 'z' + 1;"], "readability/increment"]
["src/nvim/memline.c", ["    }", "    --fname[n - 1];                     // \".swo\", \".swn\", etc.", "  }"], "readability/increment"]
["src/nvim/memline.c", ["         || b0p->b0_magic_int != (int)B0_MAGIC_INT", "         || b0p->b0_magic_short != (short)B0_MAGIC_SHORT", "         || b0p->b0_magic_char != B0_MAGIC_CHAR;"], "runtime/int"]
["src/nvim/memline.c", ["", "  /*", "   * First we try to get the inode from the file name, because the inode in"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * One of the inode numbers is unknown, try a forced vim_FullName() and"], "readability/old_style_comment"]
["src/nvim/memline.c", ["   */", "  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);"], "readability/bool"]
["src/nvim/memline.c", ["  retval_c = vim_FullName((char *)fname_c, (char *)buf_c, MAXPATHL, TRUE);", "  retval_s = vim_FullName((char *)fname_s, (char *)buf_s, MAXPATHL, TRUE);", "  if (retval_c == OK && retval_s == OK) {"], "readability/bool"]
["src/nvim/memline.c", ["", "  /*", "   * Can't compare inodes or file names, guess that the files are different,"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  if (updtype == ML_CHNK_UPDLINE && buf->b_ml.ml_line_count == 1) {", "    /*", "     * First line in empty buffer from ml_flush_line() -- reset"], "readability/old_style_comment"]
["src/nvim/memline.c", ["", "  /*", "   * Find chunk that our line belongs to, curline will be at start of the"], "readability/old_style_comment"]
["src/nvim/memline.c", ["      } else {", "        /*", "         * Line is just prior to last, move count for last"], "readability/old_style_comment"]
["src/nvim/memline.c", ["  }", "  /*", "   * Find the last chunk before the one containing our line. Last chunk is"], "readability/old_style_comment"]
["src/nvim/memline.c", ["    curwin->w_cursor.coladd = 0;", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "build/header_guard"]
["src/nvim/memline_defs.h", ["", "#endif // NVIM_MEMLINE_DEFS_H", ""], "whitespace/comments"]
["src/nvim/memory.c", ["", "/*", " * Avoid repeating the error message many times (they take 1 second each)."], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "    /* Must come first to avoid coming back here when printing the error", "     * message fails, e.g. when setting v:errmsg. */"], "readability/old_style_comment"]
["src/nvim/memory.c", ["", "/*", " * Free everything that we allocated."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Code for menus.  Used for the GUI and 'wildmenu'."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Check for \"disable\" or \"enable\" argument."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is no argument, display all menus."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * If there is only a menu name, display menus with that name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else if (unmenu) {", "    /*", "     * Delete menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, remove a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  } else {", "    /*", "     * Add menu(s)."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "    /*", "     * For the PopUp menu, add a menu for each mode separately."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * If this menu option was previously only available in other"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * Only add system menu items which have not been defined yet."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    // loop over all modes, may add more than one", "    for (i = 0; i < MENU_MODES; ++i) {", "      if (modes & (1 << i)) {"], "readability/increment"]
["src/nvim/menu.c", ["", "/*", " * Set the (sub)menu with the given name to enabled or disabled."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are doing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "      /*", "       * When name is empty, we are removing all menu items for the given"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Free the given menu structure and remove it from the linked list."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Free the menu->string with the given index."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Used when expanding menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Work out what to complete when doing command line completion of menu names."], "readability/old_style_comment"]
["src/nvim/menu.c", ["  // Check for priority numbers, enable and disable", "  for (p = arg; *p; ++p) {", "    if (!ascii_isdigit(*p) && *p != '.') {"], "readability/increment"]
["src/nvim/menu.c", ["  while (*p != NUL && ascii_iswhite(*p)) {", "    ++p;", "  }"], "readability/increment"]
["src/nvim/menu.c", ["", "  for (; *p && !ascii_iswhite(*p); ++p) {", "    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL) {"], "readability/increment"]
["src/nvim/menu.c", ["              || ((menu->modes & expand_modes) == 0x0)) {", "            /*", "             * Menu path continues, but we have reached a leaf."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of (sub)menus (not"], "readability/old_style_comment"]
["src/nvim/menu.c", ["      if (menu->en_dname == NULL) {", "        should_advance = TRUE;", "      }"], "readability/bool"]
["src/nvim/menu.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list of menus and menu"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE when \"name\" matches with menu \"menu\".  The name is compared in"], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  for (i = 0; name[i] != NUL && name[i] != TAB; ++i) {", "    if (name[i] != mname[i]) {"], "readability/increment"]
["src/nvim/menu.c", ["", "/*", " * Modify a menu name starting with \"PopUp\" to include the mode character."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Return TRUE if the name is a menu separator identifier: Starts and ends"], "readability/old_style_comment"]
["src/nvim/menu.c", ["    // Activate visual mode", "    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;"], "readability/bool"]
["src/nvim/menu.c", ["    VIsual_active = TRUE;", "    VIsual_reselect = TRUE;", "    check_cursor();"], "readability/bool"]
["src/nvim/menu.c", ["", "/*", " * Translation of menu names.  Just a simple lookup table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * \":menutrans\"."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "  /*", "   * \":menutrans clear\": clear all translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Find the character just after one part of a menu name."], "readability/old_style_comment"]
["src/nvim/menu.c", ["    if ((*p == '\\\\' || *p == Ctrl_V) && p[1] != NUL) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/menu.c", ["    }", "    ++p;", "  }"], "readability/increment"]
["src/nvim/menu.c", ["", "/*", " * Lookup part of a menu name in the translations."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Unescape the name in the translate dictionary table."], "readability/old_style_comment"]
["src/nvim/menu.c", ["", "/*", " * Isolate the menu name."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * message.c: functions for displaying messages on the command line"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            // displaying confirm_msg", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/bool"]
["src/nvim/message.c", ["static FILE *verbose_fd = NULL;", "static int verbose_did_open = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * When writing messages to the screen, there are many different situations."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * It is possible that displaying a messages causes a problem (e.g.,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (entered >= 3) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  ++entered;", ""], "readability/increment"]
["src/nvim/message.c", ["  msg_start();", "  buf = msg_strtrunc((char_u *)s, FALSE);", "  if (buf != NULL) {"], "readability/bool"]
["src/nvim/message.c", ["  xfree(buf);", "  --entered;", "  return retval;"], "readability/increment"]
["src/nvim/message.c", ["  // First part: Start of the string.", "  for (e = 0; len < half && e < buflen; ++e) {", "    if (s[e] == NUL) {"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Note: Caller of smsg() and smsg_attr() must check the resulting string is"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Remember the last sourcing name/lnum used in an error message, so that it"], "readability/old_style_comment"]
["src/nvim/message.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  }", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/message.c", ["      || emsg_skip > 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "    /*", "     * When using \":silent! cmd\" ignore error messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Display name and line number for the source of the error."], "readability/old_style_comment"]
["src/nvim/message.c", ["  while (len > 0 && *s == '\\n') {", "    ++s;", "    --len;"], "readability/increment"]
["src/nvim/message.c", ["    ++s;", "    --len;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  xfree(p);", "  --msg_hist_len;", "  return OK;"], "readability/increment"]
["src/nvim/message.c", ["", "  /*", "   * When inside vgetc(), we can't wait for a typed character at all."], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    // just pretend CR was hit", "    quit_more = FALSE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    quit_more = FALSE;", "    got_int = FALSE;", "  } else if (exmode_active) {"], "readability/bool"]
["src/nvim/message.c", ["    c = CAR;                    // no need for a return in ex mode", "    got_int = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/message.c", ["", "      /*", "       * Allow scrolling back in the messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["            c = CAR;                            // just pretend CR was hit", "            quit_more = FALSE;", "            got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["            quit_more = FALSE;", "            got_int = FALSE;", "          } else if (c != K_IGNORE) {"], "readability/bool"]
["src/nvim/message.c", ["    os_breakcheck();", "    /*", "     * Avoid that the mouse-up event causes visual mode to start."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Go over the string.  Special characters are translated and printed."], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i) {", "      msg_putchar(rs[i] - 3);"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "      /*", "       * If screen is completely filled and 'more' is set then wait"], "readability/old_style_comment"]
["src/nvim/message.c", ["      if (lines_left > 0) {", "        --lines_left;", "      }"], "readability/increment"]
["src/nvim/message.c", ["      if (msg_col) {", "        --msg_col;", "      }"], "readability/increment"]
["src/nvim/message.c", ["    }", "    ++s;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  } else if (finish && last_msgchunk != NULL) {", "    last_msgchunk->sb_eol = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    do_more_prompt('G');", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["  if (last_msgchunk != NULL) {", "    last_msgchunk->sb_eol = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    if (*p == '\\n') {       // don't display the line break", "      ++p;", "    }"], "readability/increment"]
["src/nvim/message.c", ["    }", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL) {"], "readability/bool"]
["src/nvim/message.c", ["    msg_col = 0;", "    ++msg_row;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  int c;", "  int retval = FALSE;", "  int toscroll;"], "readability/bool"]
["src/nvim/message.c", ["    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i) {", "      mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["  if (typed_char == NUL) {", "    msg_moremsg(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["  for (;;) {", "    /*", "     * Get a typed character directly from the user."], "readability/old_style_comment"]
["src/nvim/message.c", ["        // Jump to the choices of the dialog.", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/message.c", ["      } else {", "        got_int = TRUE;", "        quit_more = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        got_int = TRUE;", "        quit_more = TRUE;", "      }"], "readability/bool"]
["src/nvim/message.c", ["    default:                    // no valid response", "      msg_moremsg(TRUE);", "      continue;"], "readability/bool"]
["src/nvim/message.c", ["        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i) {", "          mp = msg_sb_start(mp->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["              mp = disp_sb_line(i, mp);", "              ++msg_scrolled;", "            }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["{", "  /*", "   * If the string is larger than the window,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    ++msg_silent;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    ++msg_silent;", "  } else {"], "readability/increment"]
["src/nvim/message.c", ["    // always scroll up, don't overwrite", "    msg_scroll = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  verbose_did_open = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["    // Only give the error message once.", "    verbose_did_open = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "  /*", "   * Since we wait for a keypress, don't make the"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  ++no_wait_return;", "  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);"], "readability/increment"]
["src/nvim/message.c", ["  setmouse();", "  --no_wait_return;", "  msg_end_prompt();"], "readability/increment"]
["src/nvim/message.c", ["      if (*r == DLG_HOTKEY_CHAR) {", "        ++r;", "      }"], "readability/increment"]
["src/nvim/message.c", ["                message,", "                (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1) {", "    return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["                    message,", "                    (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1:"], "readability/bool"]
["src/nvim/message.c", ["                    (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "                    dflt, NULL, FALSE)) {", "  case 1:"], "readability/bool"]
["src/nvim/message.h", ["", "/*", " * Types of dialogs passed to do_dialog()."], "readability/old_style_comment"]
["src/nvim/message.h", ["", "/*", " * Return values for functions like vim_dialogyesno()"], "readability/old_style_comment"]
["src/nvim/mouse.c", ["        } else {", "          --curwin->w_topline;", "          curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/mouse.c", ["        if (curwin->w_topfill > 0) {", "          ++count;", "        } else {"], "readability/increment"]
["src/nvim/mouse.c", ["    row -= count;", "    ++lnum;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * move.c: Functions for moving the cursor and scrolling text."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_botline for the current wp->w_topline.  Can be called after"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If w_cline_row is valid, start there."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline and redraw if necessary."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If the cursor is below the bottom of the window, scroll the window"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Need to redraw when topline changed."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update win->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the scrolljump value to use for the current window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true when there are not 'scrolloff' lines above the cursor for the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Check if the cursor has moved.  Set the w_valid flag accordingly."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when some window settings have changed, which require"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set wp->w_topline to a certain number."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of the cursor line (in screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of a line (in screen characters) above"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Make sure the value of curwin->w_botline is valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Mark curwin->w_botline as invalid (because of some change in the buffer)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true if curwin->w_wrow and curwin->w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate cursor position.  Makes sure w_wrow and w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_cline_row and wp->w_cline_height, based on the current value"], "readability/old_style_comment"]
["src/nvim/move.c", ["  wp->w_cline_row = 0;", "  for (linenr_T lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i) {", "    bool valid = false;"], "readability/increment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            // hold at inserted lines", "      }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate wp->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_cline_height only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate w_wcol and w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute offset of a window, occupied by absolute or relative line number,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the difference in column offset for the second screen line of a"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * First make sure that w_topline is valid (after moving the cursor)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the number of virtual columns."], "readability/old_style_comment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["      }", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["      if (hasFolding(curwin->w_topline, &first, NULL)) {", "        ++done;", "        if (!byfold) {"], "readability/increment"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                // approximate w_botline", "    invalidate_botline();"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (hasFolding(curwin->w_cursor.lnum, &first, NULL)) {", "      --wrow;", "      if (first == 1) {"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else {"], "readability/increment"]
["src/nvim/move.c", ["      if (down && wp->w_topline > 1) {", "        --wp->w_topline;", "        wp->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Use as many filler lines as possible for w_topline.  Make sure w_topline"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line down, but don't do it if it would move the"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (can_fill) {", "      ++curwin->w_topfill;", "      check_topfill(curwin, true);"], "readability/increment"]
["src/nvim/move.c", ["    } else {", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            // approximate w_botline", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line up, but don't do it if it would move the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    --lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    ++lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines below lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines above lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the top of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Decrease topline until:"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (hasFolding(curwin->w_cursor.lnum, &top, &bot)) {", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  } else {"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "    /*", "     * If scrolling is needed, scroll at least 'sj' lines."], "readability/old_style_comment"]
["src/nvim/move.c", ["    new_topline = top;", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * If we don't have enough space, put cursor in the middle."], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * If \"always\" is false, only adjust topline to a lower value, higher"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the bottom of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Stop counting lines to scroll when"], "readability/old_style_comment"]
["src/nvim/move.c", ["      i += boff.height;", "      ++line_count;", "    }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Scroll up if the cursor is off the bottom of the screen a bit."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If topline didn't change we need to restore w_botline and w_empty_rows"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    // count a \"~\" line", "        if (atend) {"], "readability/increment"]
["src/nvim/move.c", ["        if (atend) {", "          ++used;", "        }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Correct the cursor position so that it is in a part of the screen at least"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /*", "   * How many lines we would like to have above/below the cursor depends on"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If there are sufficient file-lines above and below the cursor, we can"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Narrow down the area where the cursor can be put by taking lines from"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      ++topline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * move screen 'count' pages up or down and update screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["        if (p_window <= 2) {", "          ++curwin->w_topline;", "        } else {"], "readability/increment"]
["src/nvim/move.c", ["        if (p_window <= 2) {", "          --curwin->w_topline;", "        } else {"], "readability/increment"]
["src/nvim/move.c", ["          if (curwin->w_topfill == loff.fill) {", "            --curwin->w_topline;", "            curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Decide how much overlap to use for page-up or page-down scrolling."], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (flag) {", "    /*", "     * scroll the text up"], "readability/old_style_comment"]
["src/nvim/move.c", ["        if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "          ++curwin->w_cursor.lnum;", "          curwin->w_valid &="], "readability/increment"]
["src/nvim/move.c", ["                           &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * scroll the text down"], "readability/old_style_comment"]
["src/nvim/move.c", ["        }", "        --curwin->w_topline;", "        (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_cursor.lnum > 1) {", "        --curwin->w_cursor.lnum;", "        curwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);"], "readability/increment"]
["src/nvim/move.c", ["        while (--n >= 0 && curwin->w_cursor.lnum > 1) {", "          --curwin->w_cursor.lnum;", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * loop through the cursorbound windows"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]
["src/nvim/msgpack_rpc/channel.c", ["        },", "      });", "    break;"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["      dest = conv(((String) { \\", "      .size = obj->via.attr.size, \\", "      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["      .size = obj->via.attr.size, \\", "      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\", "                   ? xmemdupz(\"\", 0) \\"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\", "                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\", "      break; \\"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["      .data = (obj->via.attr.ptr == NULL || obj->via.attr.size == 0 \\", "                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["                   ? xmemdupz(\"\", 0) \\", "                   : xmemdupz(obj->via.attr.ptr, obj->via.attr.size)), \\", "    })); \\"], "whitespace/alignment"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                      : NULL),", "          }));", "        cur.container = true;"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                .container = false,", "              }));", "          }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["                      : NULL),", "          }));", "        cur.container = true;"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/msgpack_rpc/helpers.c", ["              .container = false,", "            }));", "        }"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // NV_NCH_NOP is set and no operator is pending, get a second char", "                            ((flags & NV_NCH_NOP) == NV_NCH_NOP && !pending_op)", "                            // NV_NCH_ALW is set, always get a second char"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // NV_NCH_ALW is set, always get a second char", "                            || (flags & NV_NCH_ALW) == NV_NCH_ALW", "                            // 'q' without a pending operator, recording or executing a register,"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // - q: => open command-line window", "                            || (cmdchar == 'q'", "                                && !pending_op"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // separate state that \"inherits\" from normal state.", "                            || ((cmdchar == 'a' || cmdchar == 'i')", "                                && (pending_op || VIsual_active)));"], "whitespace/indent"]
["src/nvim/normal.c", ["          // 'showmode' is set and messages can be printed", "          ((p_smd && msg_silent == 0", "            // must restart insert mode(ctrl+o or ctrl+l) or we just entered visual"], "whitespace/indent"]
["src/nvim/normal.c", ["          // no register was used", "          && s->oa.regname == 0", "          && !(s->ca.retval & CA_COMMAND_BUSY)"], "whitespace/indent"]
["src/nvim/normal.c", ["          && s->oa.regname == 0", "          && !(s->ca.retval & CA_COMMAND_BUSY)", "          && stuff_empty()"], "whitespace/indent"]
["src/nvim/normal.c", ["          && !(s->ca.retval & CA_COMMAND_BUSY)", "          && stuff_empty()", "          && typebuf_typed()"], "whitespace/indent"]
["src/nvim/normal.c", ["          && stuff_empty()", "          && typebuf_typed()", "          && emsg_silent == 0"], "whitespace/indent"]
["src/nvim/normal.c", ["          && typebuf_typed()", "          && emsg_silent == 0", "          && !did_wait_return"], "whitespace/indent"]
["src/nvim/normal.c", ["          && emsg_silent == 0", "          && !did_wait_return", "          && s->oa.op_type == OP_NOP);"], "whitespace/indent"]
["src/nvim/normal.c", ["          && !did_wait_return", "          && s->oa.op_type == OP_NOP);", "}"], "whitespace/indent"]
["src/nvim/normal.c", ["  case 'l':", "    s->ca.cmdchar = 'h'; break;", "  case K_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_RIGHT:", "    s->ca.cmdchar = K_LEFT; break;", "  case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_RIGHT:", "    s->ca.cmdchar = K_S_LEFT; break;", "  case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_C_RIGHT:", "    s->ca.cmdchar = K_C_LEFT; break;", "  case 'h':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case 'h':", "    s->ca.cmdchar = 'l'; break;", "  case K_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_LEFT:", "    s->ca.cmdchar = K_RIGHT; break;", "  case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_LEFT:", "    s->ca.cmdchar = K_S_RIGHT; break;", "  case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_C_LEFT:", "    s->ca.cmdchar = K_C_RIGHT; break;", "  case '>':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case '>':", "    s->ca.cmdchar = '<'; break;", "  case '<':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case '<':", "    s->ca.cmdchar = '>'; break;", "  }"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_RIGHT:", "    cap->cmdchar = K_RIGHT; break;", "  case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_LEFT:", "    cap->cmdchar = K_LEFT; break;", "  case K_S_UP:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_UP:", "    cap->cmdchar = K_UP; break;", "  case K_S_DOWN:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_DOWN:", "    cap->cmdchar = K_DOWN; break;", "  case K_S_HOME:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_HOME:", "    cap->cmdchar = K_HOME; break;", "  case K_S_END:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_END:", "    cap->cmdchar = K_END; break;", "  }"], "whitespace/newline"]
["src/nvim/normal.c", ["      if (bytes == chars) {", "        sprintf((char *)showcmd_buf, \"%d\", chars);", "      } else {"], "runtime/printf"]
["src/nvim/normal.c", ["      } else {", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);", "      }"], "runtime/printf"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]
["src/nvim/normal.h", ["", "/*", " * Arguments for operators."], "readability/old_style_comment"]
["src/nvim/normal.h", ["", "/*", " * Arguments for Normal mode commands."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * structure used by block_prep, op_delete and op_yank for blockwise operators"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * The names of operators."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if operator \"op\" always works on whole lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get first operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get second operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_shift - handle a shift operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["  } else {", "    --curwin->w_cursor.lnum;            // put cursor on last line, for \":>\"", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Shift one line of the current block one shiftwidth right or left."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (!left) {", "    /*", "     *  1. Get start vcol"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Firstly, let's find the first non-whitespace character that is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      // TODO: is passing verbatim_copy_end for start of the line OK?", "      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);"], "readability/todo"]
["src/nvim/ops.c", ["", "/*", " * Insert string \"s\" (b_insert ? before : after) block :AKelly"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_reindent - handle reindenting a block of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Mark changed lines so that they will be redrawn.  When Visual", "   * highlighting was present, need to continue until the last line.  When"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Keep the last expression line here, for repeating."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Set the expression for the '=' register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the result of the '=' register expression."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Make a copy of the expression, because evaluating it may cause it to be", "   * changed. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* When we are invoked recursively limit the evaluation to 10 levels.", "   * Then return the string as-is. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the '=' register expression itself, without evaluating it."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Start or stop recording into a yank register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Stuff string \"p\" into yank register \"regname\" as a single line (append if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert lines into typeahead buffer, from last one to first one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * It is possible to get into an endless loop by having CTRL-R a in"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Check for CTRL-C, in case someone tries to paste a few thousand", "     * lines and gets bored. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Handle a delete operation."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Imitate the strange Vi behaviour: If the delete spans more than one"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Check for trying to delete (e.g. \"D\") in an empty line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Do a yank of whatever we're about to delete."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode delete"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Adjust end of operating area for ending on a multi-byte character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put character 'c' at position 'lp'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Replace a whole area with one character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode replace"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if ((numc & 1) && !bd.is_short) {", "          ++bd.endspaces;", "          ++n;"], "readability/increment"]
["src/nvim/ops.c", ["          ++bd.endspaces;", "          ++n;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["      if (oap->end.col) {", "        --oap->end.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  struct block_def bd;", "  int did_change = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["      if (oap->end.col) {", "        --oap->end.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Invoke swapchar() on \"length\" bytes at position \"pos\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_insert - Insert and append operators for Visual mode."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      coladvance_force(oap->op_type == OP_APPEND", "          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND) {"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (oap->op_type == OP_APPEND) {", "        --curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["      // Move the cursor to the character right of the block.", "      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL"], "readability/bool"]
["src/nvim/ops.c", ["             && (curwin->w_cursor.col < bd.textcol + bd.textlen)) {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["        if (bd2.endspaces) {", "          --bd2.textlen;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "    /*", "     * Subsequent calls to ml_get() flush the firstline data - take a"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_change - handle a change operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (u_save_cursor() == FAIL) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/ops.c", ["  } else if (op_delete(oap) == FAIL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "  retval = edit(NUL, FALSE, (linenr_T)1);", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * In Visual block mode, handle copying the new text to all lines of the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * set all the yank registers to empty (called from main())"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (ce != cs && oap->start.coladd > 0) {", "            /* Part of a tab selected -- but don't", "             * double-count it. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Using inserted text works differently, because the register includes"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * For special registers '%' (file name), '#' (alternate file name) and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (regname == '=') {", "      /* For the = register we need to split the string at NL", "       * characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["            }", "            ++ptr;", "            // A trailing '\\n' makes the register linewise."], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Block mode"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        bd.startspaces = incr - bd.endspaces;", "        --bd.textcol;", "        delcount = 1;"], "readability/increment"]
["src/nvim/ops.c", ["        if (oldp[bd.textcol] != TAB) {", "          /* Only a Tab can be split into spaces.  Other", "           * characters will have to be moved to after the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      ++curwin->w_cursor.lnum;", "      if (i == 0) {"], "readability/increment"]
["src/nvim/ops.c", ["    }", "    /*", "     * Line mode: BACKWARD is the same as FORWARD on the previous line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     */", "    else if (dir == BACKWARD) {", "      --lnum;"], "whitespace/newline"]
["src/nvim/ops.c", ["    else if (dir == BACKWARD) {", "      --lnum;", "    }"], "readability/increment"]
["src/nvim/ops.c", ["          lnum++;", "          ++nr_lines;", "          if (flags & PUT_FIXINDENT) {"], "readability/increment"]
["src/nvim/ops.c", ["        if (dir == FORWARD) {", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["  msgmore(nr_lines);", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  VIsual_active = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * When the cursor is on the NUL past the end of the line and it should not be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if lines starting with '#' should be left aligned."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * \":dis\" and \":registers\": Display the contents of the yank registers."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    case kMTLineWise:", "      type = 'l'; break;", "    case kMTCharWise:"], "whitespace/newline"]
["src/nvim/ops.c", ["    case kMTCharWise:", "      type = 'c'; break;", "    default:"], "whitespace/newline"]
["src/nvim/ops.c", ["    default:", "      type = 'b'; break;", "    }"], "whitespace/newline"]
["src/nvim/ops.c", ["    }", "    ++comment_flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["  int *comments = NULL;", "  int remove_comments = (use_formatoptions == TRUE)", "                        && has_format_option(FO_REMOVE_COMS);"], "readability/bool"]
["src/nvim/ops.c", ["        } else {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Move affected lines to the new long one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Delete following lines. To do this we move the cursor there"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set the cursor column:"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if the two comment leaders given are the same.  \"lnum\" is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * If first leader has 'f' flag, the lines can be joined only if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (leader1_flags != NULL) {", "    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST) {"], "readability/increment"]
["src/nvim/ops.c", ["      if (*p == COM_END) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["        if (*(ml_get(lnum) + leader1_len) == NUL) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["        if (leader2_flags == NULL || leader2_len == 0) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        for (p = leader2_flags; *p && *p != ':'; ++p) {", "          if (*p == COM_MIDDLE) {"], "readability/increment"]
["src/nvim/ops.c", ["          if (*p == COM_MIDDLE) {", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * Get current line and next line, compare the leaders."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  line2 = ml_get(lnum + 1);", "  for (idx2 = 0; idx2 < leader2_len; ++idx2) {", "    if (!ascii_iswhite(line2[idx2])) {"], "readability/increment"]
["src/nvim/ops.c", ["      while (ascii_iswhite(line1[idx1])) {", "        ++idx1;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Leave the cursor at the first non-blank of the last formatted line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq' for when using 'formatexpr'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set v:lnum to the first line number and v:count to the number of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["                                  &next_leader_len, &next_leader_flags, do_comments", "                                  );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/parens"]
["src/nvim/ops.c", ["  curwin->w_cursor.lnum--;", "  for (count = line_count; count != 0 && !got_int; --count) {", "    /*"], "readability/increment"]
["src/nvim/ops.c", ["  for (count = line_count; count != 0 && !got_int; --count) {", "    /*", "     * Advance to next paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * The last line to be formatted."], "readability/old_style_comment"]
["src/nvim/ops.c", ["                                      &next_leader_len, &next_leader_flags, do_comments", "                                      );", "      if (do_number_indent) {"], "whitespace/parens"]
["src/nvim/ops.c", ["", "    /*", "     * Skip lines that are not in a paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    } else {", "      /*", "       * For the first line of a paragraph, check indent of second line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * When the comment leader changes, it's the end of the paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * If we have got to the end of a paragraph, or the line is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        smd_save = p_smd;", "        p_smd = FALSE;", "        insertchar(NUL, INSCHAR_FORMAT"], "readability/bool"]
["src/nvim/ops.c", ["                   + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)", "                   + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);"], "whitespace/alignment"]
["src/nvim/ops.c", ["                   + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)", "                   + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "      /*", "       * When still in same paragraph, join the lines together.  But"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.lnum--;", "        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {", "          beep_flush();"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if line \"lnum\" ends in a white character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*s == NUL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Blank lines, and lines containing only the comment leader, are left"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*leader_len > 0) {", "    /*", "     * Search for 'e' flag in comment leader flags."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    while (*flags && *flags != ':' && *flags != COM_END) {", "      ++flags;", "    }"], "readability/increment"]
["src/nvim/ops.c", ["         || (*leader_len > 0 && *flags == COM_END)", "         || startPS(lnum, NUL, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (lnum <= 1) {", "    return TRUE;                // start of the file", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (*p == NUL) {", "    return TRUE;                // after empty line", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1)) {", "    return TRUE;                // missing trailing space in previous line.", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0)) {", "    return TRUE;                // numbered item starts in \"lnum\".", "  }"], "readability/bool"]
["src/nvim/ops.c", ["                   next_leader_len, next_leader_flags)) {", "    return TRUE;                // change of comment leader.", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * prepare a few things for block mode yank/delete/tilde"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return the type of a register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Compute length of resulting string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    len += STRLEN(reg->y_array[i]);", "    /*", "     * Insert a newline between lines and after last line if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Copy the lines of the yank register into the string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert a NL between lines and after the last line if y_type is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (name == '/') {", "    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);", "    return;"], "readability/bool"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **)str; *ss != NULL; ++ss) {", "      newlines++;"], "readability/increment"]
["src/nvim/ops.c", ["      extraline = 1;", "      ++newlines;         // count extra newline at the end", "    }"], "readability/increment"]
["src/nvim/ops.c", ["      append = true;", "      --newlines;         // uncount newline when appending first line", "    }"], "readability/increment"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **)str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " *  Count the number of bytes, characters and \"words\" in a line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (*p_sel == 'e' && max_pos.col > 0) {", "        --max_pos.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      // Check for a CTRL-C every 100000 characters."], "readability/increment"]
["src/nvim/ops.h", ["", "/*", " * Registers:"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * The options that are local to a window or buffer have \"indir\" set to one of"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Options local to a window have a value local to a buffer and global to all"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * These are the global values for options which are also local to a buffer."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Flags"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * options[] is initialized here."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Find default value for 'shell' option."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Set the default for 'backupskip' to include environment variables for"], "readability/old_style_comment"]
["src/nvim/option.c", ["        mustfree = false;", "      } else", "#endif"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * Set all the options (except the terminal options) to their default"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expand environment variables and things like \"~\" for the defaults."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * 'window' is only for backwards compatibility with Vi."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * If GUI is (going to be) used, we can always set the window title and"], "readability/old_style_comment"]
["src/nvim/option.c", ["        && !(opt_flags & OPT_MODELINE)) {", "      /*", "       * \":set all\"  show all options."], "readability/old_style_comment"]
["src/nvim/option.c", ["              && !(flags & P_BOOL))) {", "        /*", "         * print value"], "readability/old_style_comment"]
["src/nvim/option.c", ["              option_last_set_msg(curwin->w_p_script_ctx[", "                                                         (int)options[opt_idx].indir & PV_MASK]);", "            } else if ((int)options[opt_idx].indir & PV_BUF) {"], "whitespace/indent"]
["src/nvim/option.c", ["              option_last_set_msg(curbuf->b_p_script_ctx[", "                                                         (int)options[opt_idx].indir & PV_MASK]);", "            }"], "whitespace/indent"]
["src/nvim/option.c", ["", "          /*", "           * \":set opt!\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["          } else {", "            /*", "             * \":set invopt\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Set 'keywordprg' to \":help\" if an empty"], "readability/old_style_comment"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'backspace' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_bs", "                       && ascii_isdigit(**(char_u **)varp)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'whichwrap' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_ww", "                       && ascii_isdigit(*arg)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Remove '>' before 'dir' and 'bdir', for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (*arg == '>'", "                       && (varp == (char_u *)&p_dir"], "whitespace/newline"]
["src/nvim/option.c", ["", "              /*", "               * Copy the new string into allocated memory."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the string, skip over escaped chars."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Expand environment variables and ~."], "readability/old_style_comment"]
["src/nvim/option.c", ["skip:", "      /*", "       * Advance to next argument."], "readability/old_style_comment"]
["src/nvim/option.c", ["{", "  /*", "   * The option values that are changed when 'bin' changes are"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expanding this with NameBuff, expand_env() must not be passed IObuff."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /* When setting both values of a global option with a local value,", "    * make the local value empty, so that the global value is used. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                                              ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "       ? (((int)options[opt_idx].indir & PV_BOTH)", "          ? OPT_GLOBAL : OPT_LOCAL)"], "whitespace/alignment"]
["src/nvim/option.c", ["          ? OPT_GLOBAL : OPT_LOCAL)", "          : opt_flags));", "  char *const oldval = *varp;"], "whitespace/alignment"]
["src/nvim/option.c", ["                                              ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "       ? (((int)options[opt_idx].indir & PV_BOTH)", "          ? OPT_GLOBAL : OPT_LOCAL)"], "whitespace/alignment"]
["src/nvim/option.c", ["          ? OPT_GLOBAL : OPT_LOCAL)", "          : opt_flags));", "  char *const oldval = *varp;"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /* Get the global option to compare with, otherwise we would have to check", "   * two values for all local options. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      ml_setflags(curbuf);", "      /* Redraw needed when switching to/from \"mac\": a CR in the text", "       * will be displayed differently. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                  : shada_idx)", "                  : opt_idx);", "    // Update free_oldval now that we have the opt_idx for 'shada', otherwise"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * If error detected, restore the previous value."], "readability/old_style_comment"]
["src/nvim/option.c", ["    *varp = oldval;", "    /*", "     * When resetting some values, need to act on it."], "readability/old_style_comment"]
["src/nvim/option.c", ["        && ((int)options[opt_idx].indir & PV_BOTH)) {", "      /* global option with local value set to use global value; free", "       * the local value and make it empty */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * Trigger the autocommand only after setting the flags."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Source the spell/LANG.vim in 'runtimepath'."], "readability/old_style_comment"]
["src/nvim/option.c", ["    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));", "    /* sort the columns for faster usage on screen redraw inside", "     * win_line() */"], "readability/old_style_comment"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  else if ((int *)varp == &p_ssl) {", "    if (p_ssl) {"], "readability/braces"]
["src/nvim/option.c", ["#endif", "  else if ((int *)varp == &curwin->w_p_wrap) {", "    // If 'wrap' is set, set w_leftcol to zero."], "readability/braces"]
["src/nvim/option.c", ["    if (curwin->w_p_arab) {", "      /*", "       * 'arabic' is set, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      /*", "       * 'arabic' is reset, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * End of handling side effects for bool options."], "readability/old_style_comment"]
["src/nvim/option.c", ["    p = options[0].fullname;", "    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {", "      if (s[0] != p[0]) {"], "runtime/int"]
["src/nvim/option.c", ["  } else {", "    *numval = (long)*(int *)varp;  // NOLINT(whitespace/cast)", "  }"], "whitespace/operators"]
["src/nvim/option.c", ["", "    /*", "     * display the items"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Some options are never written:"], "readability/old_style_comment"]
["src/nvim/option.c", ["  switch ((int)p->indir)", "  {", "  // global option with local value: use local value if it's been set"], "whitespace/braces"]
["src/nvim/option.c", ["", "  /*", "   * Skip this when the option defaults have not been set yet.  Happens when"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Don't copy the options set by ex_help(), use the saved values,"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * When the options should be copied (ignoring BCO_ALWAYS), set the"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * For a terminal key code expand_option_idx is < 0."], "readability/old_style_comment"]
["src/nvim/option.c", ["               \"%\" PRId64,", "               (int64_t)*(long *)varp);", "    }"], "whitespace/operators"]
["src/nvim/option.c", ["  if (p_paste) {", "    /*", "     * Paste switched from off to on."], "readability/old_style_comment"]
["src/nvim/option.c", ["  char_u *p = wp->w_p_briopt;", "  while (*p != NUL)", "  {"], "readability/braces"]
["src/nvim/option.c", ["  while (*p != NUL)", "  {", "    if (STRNCMP(p, \"shift:\", 6) == 0"], "whitespace/braces"]
["src/nvim/option.c", ["  } else {", "    type = \"\"; def = NIL;", "  }"], "whitespace/newline"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "build/header_guard"]
["src/nvim/option_defs.h", ["    0, \\", "  })", ""], "whitespace/indent"]
["src/nvim/option_defs.h", ["    0, \\", "  })", ""], "whitespace/indent"]
["src/nvim/option_defs.h", ["", "/*", " * The following are actual variables for the options"], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["", "/*", " * \"indir\" values for window-local options."], "readability/old_style_comment"]
["src/nvim/option_defs.h", ["", "#endif // NVIM_OPTION_DEFS_H", ""], "whitespace/comments"]
["src/nvim/path.c", ["  while (vim_ispathsep(*retval)) {", "    ++retval;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if 'c' is a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Like vim_ispathsep(c), but exclude the colon for MS-Windows."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * return TRUE if 'c' is a path list separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if the directory of \"fname\" exists, FALSE otherwise."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Unix style wildcard expansion code."], "readability/old_style_comment"]
["src/nvim/path.c", ["  while (*path_end != NUL) {", "    /* May ignore a wildcard that has a backslash before it; it will", "     * be removed by rem_backslash() or file_pat_to_reg_pat() below. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["#endif", "                   )) {", "      e = p;"], "whitespace/parens"]
["src/nvim/path.c", ["  // Now we have one wildcard component between \"s\" and \"e\".", "  /* Remove backslashes between \"wildoff\" and the start of the wildcard", "   * component. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["   * component. */", "  for (p = buf + wildoff; p < s; ++p) {", "    if (rem_backslash(p)) {"], "readability/increment"]
["src/nvim/path.c", ["      STRMOVE(p, p + 1);", "      --e;", "      --s;"], "readability/increment"]
["src/nvim/path.c", ["      --e;", "      --s;", "    }"], "readability/increment"]
["src/nvim/path.c", ["  // Check for \"**\" between \"s\" and \"e\".", "  for (p = s; p < e; ++p) {", "    if (p[0] == '*' && p[1] == '*') {"], "readability/increment"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD)) {", "    ++emsg_silent;", "  }"], "readability/increment"]
["src/nvim/path.c", ["  if (flags & (EW_NOERROR | EW_NOTWILD)) {", "    --emsg_silent;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "  /* If \"**\" is by itself, this is the first time we encounter it and more", "   * is following then find matches without any directory. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (starstar && stardepth < 100) {", "          /* For \"**\" in the pattern first go deeper in the tree to", "           * find matches. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["           * find matches. */", "          STRCPY(buf + len, \"/**\");", "          STRCPY(buf + len + 3, path_end);"], "readability/old_style_comment"]
["src/nvim/path.c", ["          STRCPY(buf + len + 3, path_end);", "          ++stardepth;", "          (void)do_path_expand(gap, buf, len + 1, flags, true);"], "readability/increment"]
["src/nvim/path.c", ["          (void)do_path_expand(gap, buf, len + 1, flags, true);", "          --stardepth;", "        }"], "readability/increment"]
["src/nvim/path.c", ["          if ((flags & EW_ALLLINKS) ? os_fileinfo_link((char *)buf, &file_info)", "                                    : os_path_exists(buf)) {", "            addfile(gap, buf, flags);"], "whitespace/alignment"]
["src/nvim/path.c", ["", "/*", " * Moves \"*psep\" back to the previous path separator in \"path\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (*psep > path && vim_ispathsep(**psep)) {", "    --*psep;", "  }"], "readability/increment"]
["src/nvim/path.c", ["", "/*", " * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Split the 'path' option into an array of strings in garray_T.  Relative"], "readability/old_style_comment"]
["src/nvim/path.c", ["    if (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1]))) {", "      /* Relative to current buffer:", "       * \"/path/file\" + \".\" -> \"/path/\""], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Returns a pointer to the file or directory name in \"fname\" that matches the"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "    /* If the {filename} is not unique, change it to ./{filename}.", "     * Else reduce it to {filename} */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" contains what looks like an environment variable."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * expand_env() is called to expand things like \"~user\".  If this fails,"], "readability/old_style_comment"]
["src/nvim/path.c", ["   */", "  if (recursive)", "#ifdef SPECIAL_WILDCHAR"], "readability/braces"]
["src/nvim/path.c", ["#ifdef SPECIAL_WILDCHAR", "  /*", "   * If there are any special wildcard characters which we cannot handle"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  /*", "   * The matching file names are stored in a growarray.  Init it empty."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  for (int i = 0; i < num_pat; ++i) {", "    add_pat = -1;"], "readability/increment"]
["src/nvim/path.c", ["#ifdef UNIX", "        /*", "         * On Unix, if expand_env() can't expand an environment"], "readability/old_style_comment"]
["src/nvim/path.c", ["         */", "        else if (has_env_var(p) || *p == '~') {", "          xfree(p);"], "readability/braces"]
["src/nvim/path.c", ["", "      /*", "       * If there are wildcards: Expand file names and add each match to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                         && vim_ispathsep(p[2]))))) {", "          /* :find completion where 'path' is used.", "           * Recursiveness is OK here. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "      /* When EW_NOTFOUND is used, always add files and dirs.  Makes", "       * \"vim c:/\" work. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if we can expand this backtick thing here."], "readability/old_style_comment"]
["src/nvim/path.c", ["    while (*p != NUL && *p != '\\r' && *p != '\\n') {  // skip over entry", "      ++p;", "    }"], "readability/increment"]
["src/nvim/path.c", ["      *p = i;", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/path.c", ["    while (*cmd != NUL && (*cmd == '\\r' || *cmd == '\\n')) {", "      ++cmd;", "    }"], "readability/increment"]
["src/nvim/path.c", ["#endif", "  /*", "   * Append a slash or backslash after directory names if none is present."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Converts a file name into a canonical form. It simplifies a file name into"], "readability/old_style_comment"]
["src/nvim/path.c", ["  do {", "    /* At this point \"p\" is pointing to the char following a single \"/\"", "     * or \"p\" is at the \"start\" of the (absolute or relative) path name. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      } else {", "        /* Strip \"./\" or \".///\".  If we are at the end of the file name", "         * and there is no trailing path separator, either strip \"/.\" if"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!stripping_disabled) {", "          /* If the preceding component does not exist in the file", "           * system, we strip it.  On Unix, we don't accept a symbolic"], "readability/old_style_comment"]
["src/nvim/path.c", ["          if (!do_strip) {", "            /* If the component exists in the file system, check", "             * that stripping it won't change the meaning of the"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (do_strip) {", "              /* The check for the unstripped file name", "               * above works also for a symbolic link pointing to"], "readability/old_style_comment"]
["src/nvim/path.c", ["                do_strip = false;", "                /* We don't disable stripping of later", "                 * components since the unstripped path name is"], "readability/old_style_comment"]
["src/nvim/path.c", ["        if (!do_strip) {", "          /* Skip the \"..\" or \"../\" and reset the counter for the", "           * components that might be stripped later on. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["        } else {", "          /* Strip previous component.  If the result would get empty", "           * and there is no trailing path separator, leave a single"], "readability/old_style_comment"]
["src/nvim/path.c", ["            if (p > start && tail[-1] == '.') {", "              --p;", "            }"], "readability/increment"]
["src/nvim/path.c", ["", "          --components;", "        }"], "readability/increment"]
["src/nvim/path.c", ["", "    /*", "     * If the file could not be found in a normal way, try applying"], "readability/old_style_comment"]
["src/nvim/path.c", ["        file_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,", "                                      TRUE, rel_fname);", "      }"], "readability/bool"]
["src/nvim/path.c", ["", "    /* Repeat finding the file \"count\" times.  This matters when it", "     * appears several times in the path. */"], "readability/old_style_comment"]
["src/nvim/path.c", ["      xfree(file_name);", "      file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);", "    }"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"name\" is a full (absolute) path name or URL."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"p\" points to just after a path separator."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if file names \"f1\" and \"f2\" are in the same directory."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "  (void)vim_FullName((char *)f1, (char *)ffname, MAXPATHL, FALSE);", "  t1 = path_tail_with_sep(ffname);"], "readability/bool"]
["src/nvim/path.c", ["", "/*", " * Compare path \"p[]\" to \"q[]\"."], "readability/old_style_comment"]
["src/nvim/path.c", ["  if (*exp_pat == '%' || *exp_pat == '#' || *exp_pat == '<') {", "    ++emsg_off;", "    eval_pat = eval_vars(exp_pat, exp_pat, &usedlen,"], "readability/increment"]
["src/nvim/path.c", ["                         NULL, &ignored_msg, NULL);", "    --emsg_off;", "    if (eval_pat != NULL) {"], "readability/increment"]
["src/nvim/path.c", ["", "  /*", "   * Remove names that match 'wildignore'."], "readability/old_style_comment"]
["src/nvim/path.c", ["", "/*", " * Return TRUE if \"fname\" matches with an entry in 'suffixes'."], "readability/old_style_comment"]
["src/nvim/path.h", ["#endif", "#endif", ""], "build/header_guard"]
["src/nvim/path.h", ["#define EW_KEEPDOLLAR   0x800   // do not escape $, $var is expanded", "/* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND", "* is used when executing commands and EW_SILENT for interactive expanding. */"], "readability/old_style_comment"]
["src/nvim/popupmnu.c", ["", "  for (i = 0; i < pum_height; ++i) {", "    idx = i + pum_first;"], "readability/increment"]
["src/nvim/popupmnu.c", ["", "    for (round = 1; round <= 3; ++round) {", "      width = 0;"], "readability/increment"]
["src/nvim/popupmnu.c", ["{", "  int resized = FALSE;", "  int context = pum_height / 2;"], "readability/bool"]
["src/nvim/popupmnu.c", ["              win_setheight((int)lnum);", "              resized = TRUE;", "            }"], "readability/bool"]
["src/nvim/popupmnu.c", ["          curbuf->b_changed = false;", "          curbuf->b_p_ma = FALSE;", "          curwin->w_cursor.lnum = 1;"], "readability/bool"]
["src/nvim/popupmnu.c", ["            if (ins_compl_active() && !resized) {", "              curwin->w_redr_status = FALSE;", "            }"], "readability/bool"]
["src/nvim/profile.h", ["#define TIME_MSG(s) do { \\", "  if (time_fd != NULL) time_msg(s, NULL); \\", "} while (0)"], "readability/braces"]
["src/nvim/quickfix.c", ["", "  for (i = 0; *p != NUL && i < bufsize - 1; ++i) {", "    if (*p == '\\n') {"], "readability/increment"]
["src/nvim/quickfix.c", ["      }", "      --qi->qf_curlist;", "    } else {"], "readability/increment"]
["src/nvim/quickfix.c", ["      }", "      ++qi->qf_curlist;", "    }"], "readability/increment"]
["src/nvim/quickfix.c", ["            if (amount == MAXLNUM) {", "              qfp->qf_cleared = TRUE;", "            } else {"], "readability/bool"]
["src/nvim/quickfix.c", ["", "  for (p = p_mef; *p; ++p) {", "    if (p[0] == '#' && p[1] == '#') {"], "readability/increment"]
["src/nvim/quickfix.c", ["        && !(curbuf->b_flags & BF_NEW)) {", "      failed = FALSE;", "      if (curbuf != newbuf) {"], "readability/bool"]
["src/nvim/quickfix.c", ["  case CMD_helpgrep:", "    au_name = \"helpgrep\"; break;", "  case CMD_lhelpgrep:"], "whitespace/newline"]
["src/nvim/quickfix.c", ["  case CMD_lhelpgrep:", "    au_name = \"lhelpgrep\"; break;", "  default:"], "whitespace/newline"]
["src/nvim/regexp.c", ["", "/*", " * Handling of regular expressions: vim_regcomp(), vim_regexec(), vim_regsub()"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Magic characters have a special meaning, they don't match literally."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * We should define ftpr as a pointer to a function returning a pointer to"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * REGEXP_INRANGE contains all characters which are always special in a []"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Translate '\\x' to its control character, except \"\\n\", which is Magic."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a character class name \"[:name:]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["  static const char *(class_names[]) =", "  {", "    \"alnum:]\","], "whitespace/braces"]
["src/nvim/regexp.c", ["", "/*", " * Specific version of character class functions."], "readability/old_style_comment"]
["src/nvim/regexp.c", [" */", "static short class_tab[256];", ""], "runtime/int"]
["src/nvim/regexp.c", ["", "/*", " * META contains all characters that may be magic, except '^' and '$'."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for an equivalence class name \"[=a=]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check for a collating element \"[.a.]\".  \"pp\" points to the '['."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip over a \"[]\" range."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip past regular expression."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Start parsing at \"str\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Save the current parse state, so that it can be restored and parsing"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Restore a previously saved parse state."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character without advancing."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    } else if (vim_strchr(REGEXP_ABBR, c)) {", "      /*", "       * Handle abbreviations, like \"\\t\" for TAB -- webb"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Eat one lexed character.  Do this in a way that we can undo it."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Skip a character while keeping the value of prev_at_start for at_start."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get the next character from the pattern. We know about magic and such, so"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * put character back.  Works only once!"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the hex string at the current position."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0; i < maxinputlen; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Get and return the value of the decimal string immediately after the"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (i = 0;; ++i) {", "    c = regparse[0];"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * get and return the value of the octal string immediately after the current"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    nr |= hex2nr(c);", "    ++regparse;", "  }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * read_limits - Read two integers to be taken as a minimum and maximum."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  /*", "   * Reverse the range if there was a '-', or make sure it is in the right"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * vim_regexec and friends"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Global work variables for vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Get pointer to the line \"lnum\", which is relative to \"reg_firstlnum\"."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Create a new extmatch and mark it as referenced once."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Add a reference to an extmatch."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Remove a reference to an extmatch.  If there are no references left, free"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check the regexp program for its magic number."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Cleanup the subexpressions, if this wasn't done yet."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Check whether a backreference matches."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["    assert(*n >= 0);", "    result = mb_strnicmp(s1, s2, (size_t)*n);", "  }"], "whitespace/operators"]
["src/nvim/regexp.c", ["", "      /* decompose the character if necessary, into 'base' characters", "       * because I don't care about Arabic, I will hard-code the Hebrew"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * regtilde(): Replace tildes in the pattern by the old pattern."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "  for (p = newsub; *p; ++p) {", "    if ((*p == '~' && magic) || (*p == '\\\\' && *(p + 1) == '~' && !magic)) {"], "readability/increment"]
["src/nvim/regexp.c", ["            s++;", "            /* Change NL to CR here too, so that this works:", "             * :s/abc\\\\\\ndef/\\=\"aaa\\\\\\nbbb\"/  on text:"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["          case 'r':", "            c = CAR;        ++src;  break;", "          case 'n':"], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 'n':", "            c = NL;         ++src;  break;", "          case 't':"], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 't':", "            c = TAB;        ++src;  break;", "          // Oh no!  \\e already has meaning in subst pat :-("], "whitespace/newline"]
["src/nvim/regexp.c", ["          case 'b':", "            c = Ctrl_H;     ++src;  break;", ""], "whitespace/newline"]
["src/nvim/regexp.c", ["", "              ++s;", "              --len;"], "readability/increment"]
["src/nvim/regexp.c", ["              ++s;", "              --len;", "            }"], "readability/increment"]
["src/nvim/regexp.c", ["", "/*", " * Call reg_getline() with the line numbers from the submatch.  If a"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Used for the submatch() function: get the string from the n'th submatch in"], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "    /*", "     * First round: compute the length and allocate memory."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["        if (round == 2) {", "          STRNCPY(retval + len, reg_getline_submatch(lnum),", "                  rsm.sm_mmatch->endpos[no].col);"], "runtime/printf"]
["src/nvim/regexp.c", ["", "/*", " * Compile a regular expression into internal code."], "readability/old_style_comment"]
["src/nvim/regexp.c", ["", "/*", " * Free a compiled regexp program, returned by vim_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " *"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The \"internal use only\" fields in regexp_defs.h are present to pass info from"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure for regexp \"program\".  This is essentially a linear encoding"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The opcodes are:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Flags to be passed up and down."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When regcode is set to this value, code is not emitted and size is computed"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Structure used to save the current input state, when it needs to be"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * When there are alternatives a regstate_T is put on the regstack to remember"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * \"regstack\" and \"backpos\" are used by regmatch().  They are kept over calls"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Both for regstack and backpos tables we use the following strategy of"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Opcode notes:"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * A node is one char of opcode followed by two chars of \"next\" pointer."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Setup to parse the regexp.  Used once to get the length and once to do it."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a byte of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit (if appropriate) a multi-byte character of code"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["    case 0x1eb6:", "      regmbc('A'); regmbc(0xc0); regmbc(0xc1); regmbc(0xc2);", "      regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('A'); regmbc(0xc0); regmbc(0xc1); regmbc(0xc2);", "      regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);", "      regmbc(0x100); regmbc(0x102); regmbc(0x104);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xc3); regmbc(0xc4); regmbc(0xc5);", "      regmbc(0x100); regmbc(0x102); regmbc(0x104);", "      regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x100); regmbc(0x102); regmbc(0x104);", "      regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);", "      regmbc(0x1fa); regmbc(0x202); regmbc(0x226);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1cd); regmbc(0x1de); regmbc(0x1e0);", "      regmbc(0x1fa); regmbc(0x202); regmbc(0x226);", "      regmbc(0x23a); regmbc(0x1e00); regmbc(0x1ea0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1fa); regmbc(0x202); regmbc(0x226);", "      regmbc(0x23a); regmbc(0x1e00); regmbc(0x1ea0);", "      regmbc(0x1ea2); regmbc(0x1ea4); regmbc(0x1ea6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x23a); regmbc(0x1e00); regmbc(0x1ea0);", "      regmbc(0x1ea2); regmbc(0x1ea4); regmbc(0x1ea6);", "      regmbc(0x1ea8); regmbc(0x1eaa); regmbc(0x1eac);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ea2); regmbc(0x1ea4); regmbc(0x1ea6);", "      regmbc(0x1ea8); regmbc(0x1eaa); regmbc(0x1eac);", "      regmbc(0x1eae); regmbc(0x1eb0); regmbc(0x1eb2);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ea8); regmbc(0x1eaa); regmbc(0x1eac);", "      regmbc(0x1eae); regmbc(0x1eb0); regmbc(0x1eb2);", "      regmbc(0x1eb4); regmbc(0x1eb6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1eae); regmbc(0x1eb0); regmbc(0x1eb2);", "      regmbc(0x1eb4); regmbc(0x1eb6);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('B');", "      regmbc(0x181); regmbc(0x243); regmbc(0x1e02);", "      regmbc(0x1e04); regmbc(0x1e06);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x181); regmbc(0x243); regmbc(0x1e02);", "      regmbc(0x1e04); regmbc(0x1e06);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa792:", "      regmbc('C'); regmbc(0xc7);", "      regmbc(0x106); regmbc(0x108); regmbc(0x10a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('C'); regmbc(0xc7);", "      regmbc(0x106); regmbc(0x108); regmbc(0x10a);", "      regmbc(0x10c); regmbc(0x187); regmbc(0x23b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x106); regmbc(0x108); regmbc(0x10a);", "      regmbc(0x10c); regmbc(0x187); regmbc(0x23b);", "      regmbc(0x1e08); regmbc(0xa792);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x10c); regmbc(0x187); regmbc(0x23b);", "      regmbc(0x1e08); regmbc(0xa792);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e12:", "      regmbc('D'); regmbc(0x10e); regmbc(0x110);", "      regmbc(0x18a); regmbc(0x1e0a); regmbc(0x1e0c);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('D'); regmbc(0x10e); regmbc(0x110);", "      regmbc(0x18a); regmbc(0x1e0a); regmbc(0x1e0c);", "      regmbc(0x1e0e); regmbc(0x1e10); regmbc(0x1e12);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x18a); regmbc(0x1e0a); regmbc(0x1e0c);", "      regmbc(0x1e0e); regmbc(0x1e10); regmbc(0x1e12);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ec6:", "      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb); regmbc(0x112);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('E'); regmbc(0xc8); regmbc(0xc9);", "      regmbc(0xca); regmbc(0xcb); regmbc(0x112);", "      regmbc(0x114); regmbc(0x116); regmbc(0x118);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xca); regmbc(0xcb); regmbc(0x112);", "      regmbc(0x114); regmbc(0x116); regmbc(0x118);", "      regmbc(0x11a); regmbc(0x204); regmbc(0x206);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x114); regmbc(0x116); regmbc(0x118);", "      regmbc(0x11a); regmbc(0x204); regmbc(0x206);", "      regmbc(0x228); regmbc(0x246); regmbc(0x1e14);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x11a); regmbc(0x204); regmbc(0x206);", "      regmbc(0x228); regmbc(0x246); regmbc(0x1e14);", "      regmbc(0x1e16); regmbc(0x1e18); regmbc(0x1e1a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x228); regmbc(0x246); regmbc(0x1e14);", "      regmbc(0x1e16); regmbc(0x1e18); regmbc(0x1e1a);", "      regmbc(0x1e1c); regmbc(0x1eb8); regmbc(0x1eba);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e16); regmbc(0x1e18); regmbc(0x1e1a);", "      regmbc(0x1e1c); regmbc(0x1eb8); regmbc(0x1eba);", "      regmbc(0x1ebc); regmbc(0x1ebe); regmbc(0x1ec0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e1c); regmbc(0x1eb8); regmbc(0x1eba);", "      regmbc(0x1ebc); regmbc(0x1ebe); regmbc(0x1ec0);", "      regmbc(0x1ec2); regmbc(0x1ec4); regmbc(0x1ec6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ebc); regmbc(0x1ebe); regmbc(0x1ec0);", "      regmbc(0x1ec2); regmbc(0x1ec4); regmbc(0x1ec6);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa798:", "      regmbc('F'); regmbc(0x191); regmbc(0x1e1e);", "      regmbc(0xa798);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a0:", "      regmbc('G'); regmbc(0x11c); regmbc(0x11e);", "      regmbc(0x120); regmbc(0x122); regmbc(0x193);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('G'); regmbc(0x11c); regmbc(0x11e);", "      regmbc(0x120); regmbc(0x122); regmbc(0x193);", "      regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x120); regmbc(0x122); regmbc(0x193);", "      regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);", "      regmbc(0x1e20); regmbc(0xa7a0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e4); regmbc(0x1e6); regmbc(0x1f4);", "      regmbc(0x1e20); regmbc(0xa7a0);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c67:", "      regmbc('H'); regmbc(0x124); regmbc(0x126);", "      regmbc(0x21e); regmbc(0x1e22); regmbc(0x1e24);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('H'); regmbc(0x124); regmbc(0x126);", "      regmbc(0x21e); regmbc(0x1e22); regmbc(0x1e24);", "      regmbc(0x1e26); regmbc(0x1e28); regmbc(0x1e2a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x21e); regmbc(0x1e22); regmbc(0x1e24);", "      regmbc(0x1e26); regmbc(0x1e28); regmbc(0x1e2a);", "      regmbc(0x2c67);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1eca:", "      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf); regmbc(0x128);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('I'); regmbc(0xcc); regmbc(0xcd);", "      regmbc(0xce); regmbc(0xcf); regmbc(0x128);", "      regmbc(0x12a); regmbc(0x12c); regmbc(0x12e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xce); regmbc(0xcf); regmbc(0x128);", "      regmbc(0x12a); regmbc(0x12c); regmbc(0x12e);", "      regmbc(0x130); regmbc(0x197); regmbc(0x1cf);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x12a); regmbc(0x12c); regmbc(0x12e);", "      regmbc(0x130); regmbc(0x197); regmbc(0x1cf);", "      regmbc(0x208); regmbc(0x20a); regmbc(0x1e2c);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x130); regmbc(0x197); regmbc(0x1cf);", "      regmbc(0x208); regmbc(0x20a); regmbc(0x1e2c);", "      regmbc(0x1e2e); regmbc(0x1ec8); regmbc(0x1eca);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x208); regmbc(0x20a); regmbc(0x1e2c);", "      regmbc(0x1e2e); regmbc(0x1ec8); regmbc(0x1eca);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x248:", "      regmbc('J'); regmbc(0x134); regmbc(0x248);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa740:", "      regmbc('K'); regmbc(0x136); regmbc(0x198);", "      regmbc(0x1e8); regmbc(0x1e30); regmbc(0x1e32);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('K'); regmbc(0x136); regmbc(0x198);", "      regmbc(0x1e8); regmbc(0x1e30); regmbc(0x1e32);", "      regmbc(0x1e34); regmbc(0x2c69); regmbc(0xa740);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e8); regmbc(0x1e30); regmbc(0x1e32);", "      regmbc(0x1e34); regmbc(0x2c69); regmbc(0xa740);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c60:", "      regmbc('L'); regmbc(0x139); regmbc(0x13b);", "      regmbc(0x13d); regmbc(0x13f); regmbc(0x141);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('L'); regmbc(0x139); regmbc(0x13b);", "      regmbc(0x13d); regmbc(0x13f); regmbc(0x141);", "      regmbc(0x23d); regmbc(0x1e36); regmbc(0x1e38);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x13d); regmbc(0x13f); regmbc(0x141);", "      regmbc(0x23d); regmbc(0x1e36); regmbc(0x1e38);", "      regmbc(0x1e3a); regmbc(0x1e3c); regmbc(0x2c60);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x23d); regmbc(0x1e36); regmbc(0x1e38);", "      regmbc(0x1e3a); regmbc(0x1e3c); regmbc(0x2c60);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e42:", "      regmbc('M'); regmbc(0x1e3e); regmbc(0x1e40);", "      regmbc(0x1e42);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a4:", "      regmbc('N'); regmbc(0xd1);", "      regmbc(0x143); regmbc(0x145); regmbc(0x147);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('N'); regmbc(0xd1);", "      regmbc(0x143); regmbc(0x145); regmbc(0x147);", "      regmbc(0x1f8); regmbc(0x1e44); regmbc(0x1e46);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x143); regmbc(0x145); regmbc(0x147);", "      regmbc(0x1f8); regmbc(0x1e44); regmbc(0x1e46);", "      regmbc(0x1e48); regmbc(0x1e4a); regmbc(0xa7a4);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1f8); regmbc(0x1e44); regmbc(0x1e46);", "      regmbc(0x1e48); regmbc(0x1e4a); regmbc(0xa7a4);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ee2:", "      regmbc('O'); regmbc(0xd2); regmbc(0xd3); regmbc(0xd4);", "      regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('O'); regmbc(0xd2); regmbc(0xd3); regmbc(0xd4);", "      regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);", "      regmbc(0x14c); regmbc(0x14e); regmbc(0x150);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xd5); regmbc(0xd6); regmbc(0xd8);", "      regmbc(0x14c); regmbc(0x14e); regmbc(0x150);", "      regmbc(0x19f); regmbc(0x1a0); regmbc(0x1d1);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x14c); regmbc(0x14e); regmbc(0x150);", "      regmbc(0x19f); regmbc(0x1a0); regmbc(0x1d1);", "      regmbc(0x1ea); regmbc(0x1ec); regmbc(0x1fe);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x19f); regmbc(0x1a0); regmbc(0x1d1);", "      regmbc(0x1ea); regmbc(0x1ec); regmbc(0x1fe);", "      regmbc(0x20c); regmbc(0x20e); regmbc(0x22a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ea); regmbc(0x1ec); regmbc(0x1fe);", "      regmbc(0x20c); regmbc(0x20e); regmbc(0x22a);", "      regmbc(0x22c); regmbc(0x22e); regmbc(0x230);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x20c); regmbc(0x20e); regmbc(0x22a);", "      regmbc(0x22c); regmbc(0x22e); regmbc(0x230);", "      regmbc(0x1e4c); regmbc(0x1e4e); regmbc(0x1e50);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x22c); regmbc(0x22e); regmbc(0x230);", "      regmbc(0x1e4c); regmbc(0x1e4e); regmbc(0x1e50);", "      regmbc(0x1e52); regmbc(0x1ecc); regmbc(0x1ece);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e4c); regmbc(0x1e4e); regmbc(0x1e50);", "      regmbc(0x1e52); regmbc(0x1ecc); regmbc(0x1ece);", "      regmbc(0x1ed0); regmbc(0x1ed2); regmbc(0x1ed4);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e52); regmbc(0x1ecc); regmbc(0x1ece);", "      regmbc(0x1ed0); regmbc(0x1ed2); regmbc(0x1ed4);", "      regmbc(0x1ed6); regmbc(0x1ed8); regmbc(0x1eda);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ed0); regmbc(0x1ed2); regmbc(0x1ed4);", "      regmbc(0x1ed6); regmbc(0x1ed8); regmbc(0x1eda);", "      regmbc(0x1edc); regmbc(0x1ede); regmbc(0x1ee0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ed6); regmbc(0x1ed8); regmbc(0x1eda);", "      regmbc(0x1edc); regmbc(0x1ede); regmbc(0x1ee0);", "      regmbc(0x1ee2);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c63:", "      regmbc('P'); regmbc(0x1a4); regmbc(0x1e54);", "      regmbc(0x1e56); regmbc(0x2c63);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('P'); regmbc(0x1a4); regmbc(0x1e54);", "      regmbc(0x1e56); regmbc(0x2c63);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x24a:", "      regmbc('Q'); regmbc(0x24a);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a6:", "      regmbc('R'); regmbc(0x154); regmbc(0x156);", "      regmbc(0x210); regmbc(0x212); regmbc(0x158);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('R'); regmbc(0x154); regmbc(0x156);", "      regmbc(0x210); regmbc(0x212); regmbc(0x158);", "      regmbc(0x24c); regmbc(0x1e58); regmbc(0x1e5a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x210); regmbc(0x212); regmbc(0x158);", "      regmbc(0x24c); regmbc(0x1e58); regmbc(0x1e5a);", "      regmbc(0x1e5c); regmbc(0x1e5e); regmbc(0x2c64);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x24c); regmbc(0x1e58); regmbc(0x1e5a);", "      regmbc(0x1e5c); regmbc(0x1e5e); regmbc(0x2c64);", "      regmbc(0xa7a6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a8:", "      regmbc('S'); regmbc(0x15a); regmbc(0x15c);", "      regmbc(0x15e); regmbc(0x160); regmbc(0x218);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('S'); regmbc(0x15a); regmbc(0x15c);", "      regmbc(0x15e); regmbc(0x160); regmbc(0x218);", "      regmbc(0x1e60); regmbc(0x1e62); regmbc(0x1e64);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x15e); regmbc(0x160); regmbc(0x218);", "      regmbc(0x1e60); regmbc(0x1e62); regmbc(0x1e64);", "      regmbc(0x1e66); regmbc(0x1e68); regmbc(0x2c7e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e60); regmbc(0x1e62); regmbc(0x1e64);", "      regmbc(0x1e66); regmbc(0x1e68); regmbc(0x2c7e);", "      regmbc(0xa7a8);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e70:", "      regmbc('T'); regmbc(0x162); regmbc(0x164);", "      regmbc(0x166); regmbc(0x1ac); regmbc(0x23e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('T'); regmbc(0x162); regmbc(0x164);", "      regmbc(0x166); regmbc(0x1ac); regmbc(0x23e);", "      regmbc(0x1ae); regmbc(0x21a); regmbc(0x1e6a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x166); regmbc(0x1ac); regmbc(0x23e);", "      regmbc(0x1ae); regmbc(0x21a); regmbc(0x1e6a);", "      regmbc(0x1e6c); regmbc(0x1e6e); regmbc(0x1e70);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ae); regmbc(0x21a); regmbc(0x1e6a);", "      regmbc(0x1e6c); regmbc(0x1e6e); regmbc(0x1e70);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ef0:", "      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc); regmbc(0x168);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('U'); regmbc(0xd9); regmbc(0xda);", "      regmbc(0xdb); regmbc(0xdc); regmbc(0x168);", "      regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xdb); regmbc(0xdc); regmbc(0x168);", "      regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);", "      regmbc(0x170); regmbc(0x172); regmbc(0x1af);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x16a); regmbc(0x16c); regmbc(0x16e);", "      regmbc(0x170); regmbc(0x172); regmbc(0x1af);", "      regmbc(0x1d3); regmbc(0x1d5); regmbc(0x1d7);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x170); regmbc(0x172); regmbc(0x1af);", "      regmbc(0x1d3); regmbc(0x1d5); regmbc(0x1d7);", "      regmbc(0x1d9); regmbc(0x1db); regmbc(0x214);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d3); regmbc(0x1d5); regmbc(0x1d7);", "      regmbc(0x1d9); regmbc(0x1db); regmbc(0x214);", "      regmbc(0x216); regmbc(0x244); regmbc(0x1e72);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d9); regmbc(0x1db); regmbc(0x214);", "      regmbc(0x216); regmbc(0x244); regmbc(0x1e72);", "      regmbc(0x1e74); regmbc(0x1e76); regmbc(0x1e78);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x216); regmbc(0x244); regmbc(0x1e72);", "      regmbc(0x1e74); regmbc(0x1e76); regmbc(0x1e78);", "      regmbc(0x1e7a); regmbc(0x1ee4); regmbc(0x1ee6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e74); regmbc(0x1e76); regmbc(0x1e78);", "      regmbc(0x1e7a); regmbc(0x1ee4); regmbc(0x1ee6);", "      regmbc(0x1ee8); regmbc(0x1eea); regmbc(0x1eec);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e7a); regmbc(0x1ee4); regmbc(0x1ee6);", "      regmbc(0x1ee8); regmbc(0x1eea); regmbc(0x1eec);", "      regmbc(0x1eee); regmbc(0x1ef0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ee8); regmbc(0x1eea); regmbc(0x1eec);", "      regmbc(0x1eee); regmbc(0x1ef0);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e7e:", "      regmbc('V'); regmbc(0x1b2); regmbc(0x1e7c);", "      regmbc(0x1e7e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e88:", "      regmbc('W'); regmbc(0x174); regmbc(0x1e80);", "      regmbc(0x1e82); regmbc(0x1e84); regmbc(0x1e86);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('W'); regmbc(0x174); regmbc(0x1e80);", "      regmbc(0x1e82); regmbc(0x1e84); regmbc(0x1e86);", "      regmbc(0x1e88);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e8c:", "      regmbc('X'); regmbc(0x1e8a); regmbc(0x1e8c);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ef8:", "      regmbc('Y'); regmbc(0xdd); regmbc(0x176);", "      regmbc(0x178); regmbc(0x1b3); regmbc(0x232);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('Y'); regmbc(0xdd); regmbc(0x176);", "      regmbc(0x178); regmbc(0x1b3); regmbc(0x232);", "      regmbc(0x24e); regmbc(0x1e8e); regmbc(0x1ef2);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x178); regmbc(0x1b3); regmbc(0x232);", "      regmbc(0x24e); regmbc(0x1e8e); regmbc(0x1ef2);", "      regmbc(0x1ef4); regmbc(0x1ef6); regmbc(0x1ef8);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x24e); regmbc(0x1e8e); regmbc(0x1ef2);", "      regmbc(0x1ef4); regmbc(0x1ef6); regmbc(0x1ef8);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c6b:", "      regmbc('Z'); regmbc(0x179); regmbc(0x17b);", "      regmbc(0x17d); regmbc(0x1b5); regmbc(0x1e90);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('Z'); regmbc(0x179); regmbc(0x17b);", "      regmbc(0x17d); regmbc(0x1b5); regmbc(0x1e90);", "      regmbc(0x1e92); regmbc(0x1e94); regmbc(0x2c6b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x17d); regmbc(0x1b5); regmbc(0x1e90);", "      regmbc(0x1e92); regmbc(0x1e94); regmbc(0x2c6b);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c65:", "      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('a'); regmbc(0xe0); regmbc(0xe1);", "      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);", "      regmbc(0xe5); regmbc(0x101); regmbc(0x103);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xe2); regmbc(0xe3); regmbc(0xe4);", "      regmbc(0xe5); regmbc(0x101); regmbc(0x103);", "      regmbc(0x105); regmbc(0x1ce); regmbc(0x1df);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xe5); regmbc(0x101); regmbc(0x103);", "      regmbc(0x105); regmbc(0x1ce); regmbc(0x1df);", "      regmbc(0x1e1); regmbc(0x1fb); regmbc(0x201);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x105); regmbc(0x1ce); regmbc(0x1df);", "      regmbc(0x1e1); regmbc(0x1fb); regmbc(0x201);", "      regmbc(0x203); regmbc(0x227); regmbc(0x1d8f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e1); regmbc(0x1fb); regmbc(0x201);", "      regmbc(0x203); regmbc(0x227); regmbc(0x1d8f);", "      regmbc(0x1e01); regmbc(0x1e9a); regmbc(0x1ea1);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x203); regmbc(0x227); regmbc(0x1d8f);", "      regmbc(0x1e01); regmbc(0x1e9a); regmbc(0x1ea1);", "      regmbc(0x1ea3); regmbc(0x1ea5); regmbc(0x1ea7);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e01); regmbc(0x1e9a); regmbc(0x1ea1);", "      regmbc(0x1ea3); regmbc(0x1ea5); regmbc(0x1ea7);", "      regmbc(0x1ea9); regmbc(0x1eab); regmbc(0x1ead);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ea3); regmbc(0x1ea5); regmbc(0x1ea7);", "      regmbc(0x1ea9); regmbc(0x1eab); regmbc(0x1ead);", "      regmbc(0x1eaf); regmbc(0x1eb1); regmbc(0x1eb3);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ea9); regmbc(0x1eab); regmbc(0x1ead);", "      regmbc(0x1eaf); regmbc(0x1eb1); regmbc(0x1eb3);", "      regmbc(0x1eb5); regmbc(0x1eb7); regmbc(0x2c65);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1eaf); regmbc(0x1eb1); regmbc(0x1eb3);", "      regmbc(0x1eb5); regmbc(0x1eb7); regmbc(0x2c65);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('b');", "      regmbc(0x180); regmbc(0x253); regmbc(0x1d6c);", "      regmbc(0x1d80); regmbc(0x1e03); regmbc(0x1e05);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x180); regmbc(0x253); regmbc(0x1d6c);", "      regmbc(0x1d80); regmbc(0x1e03); regmbc(0x1e05);", "      regmbc(0x1e07);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa794:", "      regmbc('c'); regmbc(0xe7); regmbc(0x107);", "      regmbc(0x109); regmbc(0x10b); regmbc(0x10d);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('c'); regmbc(0xe7); regmbc(0x107);", "      regmbc(0x109); regmbc(0x10b); regmbc(0x10d);", "      regmbc(0x188); regmbc(0x23c); regmbc(0x1e09);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x109); regmbc(0x10b); regmbc(0x10d);", "      regmbc(0x188); regmbc(0x23c); regmbc(0x1e09);", "      regmbc(0xa793); regmbc(0xa794);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x188); regmbc(0x23c); regmbc(0x1e09);", "      regmbc(0xa793); regmbc(0xa794);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e13:", "      regmbc('d'); regmbc(0x10f); regmbc(0x111);", "      regmbc(0x257); regmbc(0x1d6d); regmbc(0x1d81);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('d'); regmbc(0x10f); regmbc(0x111);", "      regmbc(0x257); regmbc(0x1d6d); regmbc(0x1d81);", "      regmbc(0x1d91); regmbc(0x1e0b); regmbc(0x1e0d);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x257); regmbc(0x1d6d); regmbc(0x1d81);", "      regmbc(0x1d91); regmbc(0x1e0b); regmbc(0x1e0d);", "      regmbc(0x1e0f); regmbc(0x1e11); regmbc(0x1e13);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d91); regmbc(0x1e0b); regmbc(0x1e0d);", "      regmbc(0x1e0f); regmbc(0x1e11); regmbc(0x1e13);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ec7:", "      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb); regmbc(0x113);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('e'); regmbc(0xe8); regmbc(0xe9);", "      regmbc(0xea); regmbc(0xeb); regmbc(0x113);", "      regmbc(0x115); regmbc(0x117); regmbc(0x119);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xea); regmbc(0xeb); regmbc(0x113);", "      regmbc(0x115); regmbc(0x117); regmbc(0x119);", "      regmbc(0x11b); regmbc(0x205); regmbc(0x207);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x115); regmbc(0x117); regmbc(0x119);", "      regmbc(0x11b); regmbc(0x205); regmbc(0x207);", "      regmbc(0x229); regmbc(0x247); regmbc(0x1d92);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x11b); regmbc(0x205); regmbc(0x207);", "      regmbc(0x229); regmbc(0x247); regmbc(0x1d92);", "      regmbc(0x1e15); regmbc(0x1e17); regmbc(0x1e19);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x229); regmbc(0x247); regmbc(0x1d92);", "      regmbc(0x1e15); regmbc(0x1e17); regmbc(0x1e19);", "      regmbc(0x1e1b); regmbc(0x1e1d); regmbc(0x1eb9);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e15); regmbc(0x1e17); regmbc(0x1e19);", "      regmbc(0x1e1b); regmbc(0x1e1d); regmbc(0x1eb9);", "      regmbc(0x1ebb); regmbc(0x1ebd); regmbc(0x1ebf);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e1b); regmbc(0x1e1d); regmbc(0x1eb9);", "      regmbc(0x1ebb); regmbc(0x1ebd); regmbc(0x1ebf);", "      regmbc(0x1ec1); regmbc(0x1ec3); regmbc(0x1ec5);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ebb); regmbc(0x1ebd); regmbc(0x1ebf);", "      regmbc(0x1ec1); regmbc(0x1ec3); regmbc(0x1ec5);", "      regmbc(0x1ec7);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa799:", "      regmbc('f'); regmbc(0x192); regmbc(0x1d6e);", "      regmbc(0x1d82); regmbc(0x1e1f); regmbc(0xa799);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('f'); regmbc(0x192); regmbc(0x1d6e);", "      regmbc(0x1d82); regmbc(0x1e1f); regmbc(0xa799);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a1:", "      regmbc('g'); regmbc(0x11d); regmbc(0x11f);", "      regmbc(0x121); regmbc(0x123); regmbc(0x1e5);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('g'); regmbc(0x11d); regmbc(0x11f);", "      regmbc(0x121); regmbc(0x123); regmbc(0x1e5);", "      regmbc(0x1e7); regmbc(0x1f5); regmbc(0x260);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x121); regmbc(0x123); regmbc(0x1e5);", "      regmbc(0x1e7); regmbc(0x1f5); regmbc(0x260);", "      regmbc(0x1d83); regmbc(0x1e21); regmbc(0xa7a1);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e7); regmbc(0x1f5); regmbc(0x260);", "      regmbc(0x1d83); regmbc(0x1e21); regmbc(0xa7a1);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa795:", "      regmbc('h'); regmbc(0x125); regmbc(0x127);", "      regmbc(0x21f); regmbc(0x1e23); regmbc(0x1e25);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('h'); regmbc(0x125); regmbc(0x127);", "      regmbc(0x21f); regmbc(0x1e23); regmbc(0x1e25);", "      regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e2b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x21f); regmbc(0x1e23); regmbc(0x1e25);", "      regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e2b);", "      regmbc(0x1e96); regmbc(0x2c68); regmbc(0xa795);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e27); regmbc(0x1e29); regmbc(0x1e2b);", "      regmbc(0x1e96); regmbc(0x2c68); regmbc(0xa795);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ecb:", "      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef); regmbc(0x129);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('i'); regmbc(0xec); regmbc(0xed);", "      regmbc(0xee); regmbc(0xef); regmbc(0x129);", "      regmbc(0x12b); regmbc(0x12d); regmbc(0x12f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xee); regmbc(0xef); regmbc(0x129);", "      regmbc(0x12b); regmbc(0x12d); regmbc(0x12f);", "      regmbc(0x1d0); regmbc(0x209); regmbc(0x20b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x12b); regmbc(0x12d); regmbc(0x12f);", "      regmbc(0x1d0); regmbc(0x209); regmbc(0x20b);", "      regmbc(0x268); regmbc(0x1d96); regmbc(0x1e2d);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d0); regmbc(0x209); regmbc(0x20b);", "      regmbc(0x268); regmbc(0x1d96); regmbc(0x1e2d);", "      regmbc(0x1e2f); regmbc(0x1ec9); regmbc(0x1ecb);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x268); regmbc(0x1d96); regmbc(0x1e2d);", "      regmbc(0x1e2f); regmbc(0x1ec9); regmbc(0x1ecb);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x249:", "      regmbc('j'); regmbc(0x135); regmbc(0x1f0);", "      regmbc(0x249);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa741:", "      regmbc('k'); regmbc(0x137); regmbc(0x199);", "      regmbc(0x1e9); regmbc(0x1d84); regmbc(0x1e31);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('k'); regmbc(0x137); regmbc(0x199);", "      regmbc(0x1e9); regmbc(0x1d84); regmbc(0x1e31);", "      regmbc(0x1e33); regmbc(0x1e35); regmbc(0x2c6a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e9); regmbc(0x1d84); regmbc(0x1e31);", "      regmbc(0x1e33); regmbc(0x1e35); regmbc(0x2c6a);", "      regmbc(0xa741);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c61:", "      regmbc('l'); regmbc(0x13a); regmbc(0x13c);", "      regmbc(0x13e); regmbc(0x140); regmbc(0x142);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('l'); regmbc(0x13a); regmbc(0x13c);", "      regmbc(0x13e); regmbc(0x140); regmbc(0x142);", "      regmbc(0x19a); regmbc(0x1e37); regmbc(0x1e39);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x13e); regmbc(0x140); regmbc(0x142);", "      regmbc(0x19a); regmbc(0x1e37); regmbc(0x1e39);", "      regmbc(0x1e3b); regmbc(0x1e3d); regmbc(0x2c61);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x19a); regmbc(0x1e37); regmbc(0x1e39);", "      regmbc(0x1e3b); regmbc(0x1e3d); regmbc(0x2c61);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e43:", "      regmbc('m'); regmbc(0x1d6f); regmbc(0x1e3f);", "      regmbc(0x1e41); regmbc(0x1e43);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('m'); regmbc(0x1d6f); regmbc(0x1e3f);", "      regmbc(0x1e41); regmbc(0x1e43);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a5:", "      regmbc('n'); regmbc(0xf1); regmbc(0x144);", "      regmbc(0x146); regmbc(0x148); regmbc(0x149);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('n'); regmbc(0xf1); regmbc(0x144);", "      regmbc(0x146); regmbc(0x148); regmbc(0x149);", "      regmbc(0x1f9); regmbc(0x1d70); regmbc(0x1d87);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x146); regmbc(0x148); regmbc(0x149);", "      regmbc(0x1f9); regmbc(0x1d70); regmbc(0x1d87);", "      regmbc(0x1e45); regmbc(0x1e47); regmbc(0x1e49);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1f9); regmbc(0x1d70); regmbc(0x1d87);", "      regmbc(0x1e45); regmbc(0x1e47); regmbc(0x1e49);", "      regmbc(0x1e4b); regmbc(0xa7a5);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e45); regmbc(0x1e47); regmbc(0x1e49);", "      regmbc(0x1e4b); regmbc(0xa7a5);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ee3:", "      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('o'); regmbc(0xf2); regmbc(0xf3);", "      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);", "      regmbc(0xf8); regmbc(0x14d); regmbc(0x14f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xf4); regmbc(0xf5); regmbc(0xf6);", "      regmbc(0xf8); regmbc(0x14d); regmbc(0x14f);", "      regmbc(0x151); regmbc(0x1a1); regmbc(0x1d2);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xf8); regmbc(0x14d); regmbc(0x14f);", "      regmbc(0x151); regmbc(0x1a1); regmbc(0x1d2);", "      regmbc(0x1eb); regmbc(0x1ed); regmbc(0x1ff);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x151); regmbc(0x1a1); regmbc(0x1d2);", "      regmbc(0x1eb); regmbc(0x1ed); regmbc(0x1ff);", "      regmbc(0x20d); regmbc(0x20f); regmbc(0x22b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1eb); regmbc(0x1ed); regmbc(0x1ff);", "      regmbc(0x20d); regmbc(0x20f); regmbc(0x22b);", "      regmbc(0x22d); regmbc(0x22f); regmbc(0x231);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x20d); regmbc(0x20f); regmbc(0x22b);", "      regmbc(0x22d); regmbc(0x22f); regmbc(0x231);", "      regmbc(0x275); regmbc(0x1e4d); regmbc(0x1e4f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x22d); regmbc(0x22f); regmbc(0x231);", "      regmbc(0x275); regmbc(0x1e4d); regmbc(0x1e4f);", "      regmbc(0x1e51); regmbc(0x1e53); regmbc(0x1ecd);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x275); regmbc(0x1e4d); regmbc(0x1e4f);", "      regmbc(0x1e51); regmbc(0x1e53); regmbc(0x1ecd);", "      regmbc(0x1ecf); regmbc(0x1ed1); regmbc(0x1ed3);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e51); regmbc(0x1e53); regmbc(0x1ecd);", "      regmbc(0x1ecf); regmbc(0x1ed1); regmbc(0x1ed3);", "      regmbc(0x1ed5); regmbc(0x1ed7); regmbc(0x1ed9);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ecf); regmbc(0x1ed1); regmbc(0x1ed3);", "      regmbc(0x1ed5); regmbc(0x1ed7); regmbc(0x1ed9);", "      regmbc(0x1edb); regmbc(0x1edd); regmbc(0x1edf);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ed5); regmbc(0x1ed7); regmbc(0x1ed9);", "      regmbc(0x1edb); regmbc(0x1edd); regmbc(0x1edf);", "      regmbc(0x1ee1); regmbc(0x1ee3);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1edb); regmbc(0x1edd); regmbc(0x1edf);", "      regmbc(0x1ee1); regmbc(0x1ee3);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e57:", "      regmbc('p'); regmbc(0x1a5); regmbc(0x1d71);", "      regmbc(0x1d7d); regmbc(0x1d88); regmbc(0x1e55);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('p'); regmbc(0x1a5); regmbc(0x1d71);", "      regmbc(0x1d7d); regmbc(0x1d88); regmbc(0x1e55);", "      regmbc(0x1e57);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2a0:", "      regmbc('q'); regmbc(0x24b); regmbc(0x2a0);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a7:", "      regmbc('r'); regmbc(0x155); regmbc(0x157);", "      regmbc(0x159); regmbc(0x211); regmbc(0x213);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('r'); regmbc(0x155); regmbc(0x157);", "      regmbc(0x159); regmbc(0x211); regmbc(0x213);", "      regmbc(0x24d); regmbc(0x1d72); regmbc(0x1d73);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x159); regmbc(0x211); regmbc(0x213);", "      regmbc(0x24d); regmbc(0x1d72); regmbc(0x1d73);", "      regmbc(0x1d89); regmbc(0x1e59); regmbc(0x27d);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x24d); regmbc(0x1d72); regmbc(0x1d73);", "      regmbc(0x1d89); regmbc(0x1e59); regmbc(0x27d);", "      regmbc(0x1e5b); regmbc(0x1e5d); regmbc(0x1e5f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d89); regmbc(0x1e59); regmbc(0x27d);", "      regmbc(0x1e5b); regmbc(0x1e5d); regmbc(0x1e5f);", "      regmbc(0xa7a7);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0xa7a9:", "      regmbc('s'); regmbc(0x15b); regmbc(0x15d);", "      regmbc(0x15f); regmbc(0x161); regmbc(0x23f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('s'); regmbc(0x15b); regmbc(0x15d);", "      regmbc(0x15f); regmbc(0x161); regmbc(0x23f);", "      regmbc(0x219); regmbc(0x1d74); regmbc(0x1d8a);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x15f); regmbc(0x161); regmbc(0x23f);", "      regmbc(0x219); regmbc(0x1d74); regmbc(0x1d8a);", "      regmbc(0x1e61); regmbc(0x1e63); regmbc(0x1e65);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x219); regmbc(0x1d74); regmbc(0x1d8a);", "      regmbc(0x1e61); regmbc(0x1e63); regmbc(0x1e65);", "      regmbc(0x1e67); regmbc(0x1e69); regmbc(0xa7a9);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e61); regmbc(0x1e63); regmbc(0x1e65);", "      regmbc(0x1e67); regmbc(0x1e69); regmbc(0xa7a9);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c66:", "      regmbc('t'); regmbc(0x163); regmbc(0x165);", "      regmbc(0x167); regmbc(0x1ab); regmbc(0x21b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('t'); regmbc(0x163); regmbc(0x165);", "      regmbc(0x167); regmbc(0x1ab); regmbc(0x21b);", "      regmbc(0x1ad); regmbc(0x288); regmbc(0x1d75);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x167); regmbc(0x1ab); regmbc(0x21b);", "      regmbc(0x1ad); regmbc(0x288); regmbc(0x1d75);", "      regmbc(0x1e6b); regmbc(0x1e6d); regmbc(0x1e6f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ad); regmbc(0x288); regmbc(0x1d75);", "      regmbc(0x1e6b); regmbc(0x1e6d); regmbc(0x1e6f);", "      regmbc(0x1e71); regmbc(0x1e97); regmbc(0x2c66);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e6b); regmbc(0x1e6d); regmbc(0x1e6f);", "      regmbc(0x1e71); regmbc(0x1e97); regmbc(0x2c66);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ef1:", "      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc); regmbc(0x169);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('u'); regmbc(0xf9); regmbc(0xfa);", "      regmbc(0xfb); regmbc(0xfc); regmbc(0x169);", "      regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0xfb); regmbc(0xfc); regmbc(0x169);", "      regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);", "      regmbc(0x171); regmbc(0x173); regmbc(0x1d6);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x16b); regmbc(0x16d); regmbc(0x16f);", "      regmbc(0x171); regmbc(0x173); regmbc(0x1d6);", "      regmbc(0x1d8); regmbc(0x1da); regmbc(0x1dc);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x171); regmbc(0x173); regmbc(0x1d6);", "      regmbc(0x1d8); regmbc(0x1da); regmbc(0x1dc);", "      regmbc(0x215); regmbc(0x217); regmbc(0x1b0);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d8); regmbc(0x1da); regmbc(0x1dc);", "      regmbc(0x215); regmbc(0x217); regmbc(0x1b0);", "      regmbc(0x1d4); regmbc(0x289); regmbc(0x1d7e);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x215); regmbc(0x217); regmbc(0x1b0);", "      regmbc(0x1d4); regmbc(0x289); regmbc(0x1d7e);", "      regmbc(0x1d99); regmbc(0x1e73); regmbc(0x1e75);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d4); regmbc(0x289); regmbc(0x1d7e);", "      regmbc(0x1d99); regmbc(0x1e73); regmbc(0x1e75);", "      regmbc(0x1e77); regmbc(0x1e79); regmbc(0x1e7b);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d99); regmbc(0x1e73); regmbc(0x1e75);", "      regmbc(0x1e77); regmbc(0x1e79); regmbc(0x1e7b);", "      regmbc(0x1ee5); regmbc(0x1ee7); regmbc(0x1ee9);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e77); regmbc(0x1e79); regmbc(0x1e7b);", "      regmbc(0x1ee5); regmbc(0x1ee7); regmbc(0x1ee9);", "      regmbc(0x1eeb); regmbc(0x1eed); regmbc(0x1eef);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1ee5); regmbc(0x1ee7); regmbc(0x1ee9);", "      regmbc(0x1eeb); regmbc(0x1eed); regmbc(0x1eef);", "      regmbc(0x1ef1);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e7f:", "      regmbc('v'); regmbc(0x28b); regmbc(0x1d8c);", "      regmbc(0x1e7d); regmbc(0x1e7f);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('v'); regmbc(0x28b); regmbc(0x1d8c);", "      regmbc(0x1e7d); regmbc(0x1e7f);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e98:", "      regmbc('w'); regmbc(0x175); regmbc(0x1e81);", "      regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('w'); regmbc(0x175); regmbc(0x1e81);", "      regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87);", "      regmbc(0x1e89); regmbc(0x1e98);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1e83); regmbc(0x1e85); regmbc(0x1e87);", "      regmbc(0x1e89); regmbc(0x1e98);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1e8d:", "      regmbc('x'); regmbc(0x1e8b); regmbc(0x1e8d);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x1ef9:", "      regmbc('y'); regmbc(0xfd); regmbc(0xff);", "      regmbc(0x177); regmbc(0x1b4); regmbc(0x233);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('y'); regmbc(0xfd); regmbc(0xff);", "      regmbc(0x177); regmbc(0x1b4); regmbc(0x233);", "      regmbc(0x24f); regmbc(0x1e8f); regmbc(0x1e99);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x177); regmbc(0x1b4); regmbc(0x233);", "      regmbc(0x24f); regmbc(0x1e8f); regmbc(0x1e99);", "      regmbc(0x1ef3); regmbc(0x1ef5); regmbc(0x1ef7);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x24f); regmbc(0x1e8f); regmbc(0x1e99);", "      regmbc(0x1ef3); regmbc(0x1ef5); regmbc(0x1ef7);", "      regmbc(0x1ef9);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case 0x2c6c:", "      regmbc('z'); regmbc(0x17a); regmbc(0x17c);", "      regmbc(0x17e); regmbc(0x1b6); regmbc(0x1d76);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc('z'); regmbc(0x17a); regmbc(0x17c);", "      regmbc(0x17e); regmbc(0x1b6); regmbc(0x1d76);", "      regmbc(0x1d8e); regmbc(0x1e91); regmbc(0x1e93);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x17e); regmbc(0x1b6); regmbc(0x1d76);", "      regmbc(0x1d8e); regmbc(0x1e91); regmbc(0x1e93);", "      regmbc(0x1e95); regmbc(0x2c6c);"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      regmbc(0x1d8e); regmbc(0x1e91); regmbc(0x1e93);", "      regmbc(0x1e95); regmbc(0x2c6c);", "      return;"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["", "/*", " * Emit a node."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Write a four bytes number at \"p\" and return pointer to the next char."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regnext - dig the \"next\" pointer out of a node"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Like regtail, on item after a BRANCH; nop if none."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Insert an operator in front of already-emitted operand."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["      case 'd':", "        i = getdecchrs(); break;", "      case 'o':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case 'o':", "        i = getoctchrs(); break;", "      case 'x':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case 'x':", "        i = gethexchrs(2); break;", "      case 'u':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case 'u':", "        i = gethexchrs(4); break;", "      case 'U':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case 'U':", "        i = gethexchrs(8); break;", "      default:"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      default:", "        i = -1; break;", "      }"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["          if (*regparse == '-') {", "            ++regparse;", "            // The '-' is not used for a range at the end and"], "readability/increment"]
["src/nvim/regexp_bt.c", ["          // 'cpoptions' is not included.", "          else if (*regparse == '\\\\'", "                   && (vim_strchr(REGEXP_INRANGE, regparse[1]) != NULL"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["              } else if ((c_class =", "                            get_coll_element(&regparse)) != 0) {", "                // produce a collating element"], "whitespace/alignment"]
["src/nvim/regexp_bt.c", ["                                   && !one_exactly", "                                   && !is_Magic(c))); ++len) {", "      c = no_Magic(c);"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["    case '=':", "      lop = MATCH; break;                                 // \\@=", "    case '!':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case '!':", "      lop = NOMATCH; break;                               // \\@!", "    case '>':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["    case '>':", "      lop = SUBPAT; break;                                // \\@>", "    case '<':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case '=':", "        lop = BEHIND; break;                               // \\@<=", "      case '!':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      case '!':", "        lop = NOBEHIND; break;                             // \\@<!", "      }"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["      reginsert_limits(BRACE_LIMITS, minval, maxval, ret);", "      ++num_complex_braces;", "    }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | or & operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Parse one alternative of an | operator."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["    parno = regnpar;", "    ++regnpar;", "    ret = regnode(MOPEN + parno);"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * bt_regcomp() - compile a regular expression into internal code for the"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Check if during the previous call to vim_regcomp the EOL item \"$\" has been"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Get a number after a backslash that is inside []."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["  case 'd':", "    nr = getdecchrs(); break;", "  case 'o':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["  case 'o':", "    nr = getoctchrs(); break;", "  case 'x':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["  case 'x':", "    nr = gethexchrs(2); break;", "  case 'u':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["  case 'u':", "    nr = gethexchrs(4); break;", "  case 'U':"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["  case 'U':", "    nr = gethexchrs(8); break;", "  }"], "whitespace/newline"]
["src/nvim/regexp_bt.c", ["", "/*", " * Free a compiled regexp program, returned by bt_regcomp()."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * The arguments from BRACE_LIMITS are stored here.  They are actually local"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Tentatively set the sub-expression start to the current position (after"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["        scan += len;", "        ++count;", "      }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["      }", "      ++count;", "    }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Push an item onto the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Pop an item from the regstack."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["          no = op - BRACE_COMPLEX;", "          ++brace_count[no];", ""], "readability/increment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];             // decrement match count", "        }"], "readability/increment"]
["src/nvim/regexp_bt.c", ["          reg_restore(&rp->rs_un.regsave, &backpos);", "          --brace_count[rp->rs_no];", "          // continue with the items after \"\\{}\""], "readability/increment"]
["src/nvim/regexp_bt.c", ["", "/*", " * Compare a number with the operand of RE_LNUM, RE_COL or RE_VCOL."], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regdump - dump a regexp onto stdout in vaguely comprehensible form"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["", "/*", " * regprop - printable representation of opcode"], "readability/old_style_comment"]
["src/nvim/regexp_bt.c", ["  case MOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"MOPEN%d\", OP(op) - MOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case MCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"MCLOSE%d\", OP(op) - MCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case BACKREF + 9:", "    sprintf(buf + STRLEN(buf), \"BACKREF%d\", OP(op) - BACKREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case ZOPEN + 9:", "    sprintf(buf + STRLEN(buf), \"ZOPEN%d\", OP(op) - ZOPEN);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case ZCLOSE + 9:", "    sprintf(buf + STRLEN(buf), \"ZCLOSE%d\", OP(op) - ZCLOSE);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case ZREF + 9:", "    sprintf(buf + STRLEN(buf), \"ZREF%d\", OP(op) - ZREF);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  case BRACE_COMPLEX + 9:", "    sprintf(buf + STRLEN(buf), \"BRACE_COMPLEX%d\", OP(op) - BRACE_COMPLEX);", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_bt.c", ["  default:", "    sprintf(buf + STRLEN(buf), \"corrupt %d\", OP(op));", "    p = NULL;"], "runtime/printf"]
["src/nvim/regexp_defs.h", ["// marker so line numbers and indices both start at 1", "/*", " * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE"], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * The number of sub-matches is limited to 10."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * In the NFA engine: how many braces are allowed."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure returned by vim_regcomp() to pass on to vim_regexec()."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the back track matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used by the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure to be used for single-line matching."], "readability/old_style_comment"]
["src/nvim/regexp_defs.h", ["", "/*", " * Structure used to store external references: \"\\z\\(\\)\" to \"\\z\\1\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * NFA regular expression implementation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with an anchor, must match at start"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with a character which must match"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list contains just literal text and nothing"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate more space for post_start.  Called when"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Search between \"start\" and \"end\" and try to recognize a"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["    case 0x1ef9:", "      EMIT2('y') EMIT2(y_acute) EMIT2(y_diaeresis)", "      EMIT2(0x177) EMIT2(0x1b4) EMIT2(0x233) EMIT2(0x24f)"], "whitespace/cast"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Code to parse regular expression."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      case 'd':", "        nr = getdecchrs(); break;", "      case 'o':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'o':", "        nr = getoctchrs(); break;", "      case 'x':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'x':", "        nr = gethexchrs(2); break;", "      case 'u':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'u':", "        nr = gethexchrs(4); break;", "      case 'U':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'U':", "        nr = gethexchrs(8); break;", "      default:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      default:", "        nr = -1; break;", "      }"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["collection:", "    /*", "     * [abc]  uses NFA_START_COLL - NFA_END_COLL"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (*endp == ']') {", "      /*", "       * Try to reverse engineer character classes. For example,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      }", "      /*", "       * Failed to recognize a character class. Use the simple"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case Magic('+'):", "    /*", "     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse one or more pieces, concatenated.  It matches a match for the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse a branch, one or more concats, separated by \"\\&\".  It matches the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_MATCH:", "    STRCPY(code, \"NFA_MATCH \"); break;", "  case NFA_SPLIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    STRCPY(code, \"NFA_SPLIT \"); break;", "  case NFA_CONCAT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CONCAT:", "    STRCPY(code, \"NFA_CONCAT \"); break;", "  case NFA_NEWL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NEWL:", "    STRCPY(code, \"NFA_NEWL \"); break;", "  case NFA_ZSTART:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZSTART:", "    STRCPY(code, \"NFA_ZSTART\"); break;", "  case NFA_ZEND:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZEND:", "    STRCPY(code, \"NFA_ZEND\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF1:", "    STRCPY(code, \"NFA_BACKREF1\"); break;", "  case NFA_BACKREF2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF2:", "    STRCPY(code, \"NFA_BACKREF2\"); break;", "  case NFA_BACKREF3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF3:", "    STRCPY(code, \"NFA_BACKREF3\"); break;", "  case NFA_BACKREF4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF4:", "    STRCPY(code, \"NFA_BACKREF4\"); break;", "  case NFA_BACKREF5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF5:", "    STRCPY(code, \"NFA_BACKREF5\"); break;", "  case NFA_BACKREF6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF6:", "    STRCPY(code, \"NFA_BACKREF6\"); break;", "  case NFA_BACKREF7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF7:", "    STRCPY(code, \"NFA_BACKREF7\"); break;", "  case NFA_BACKREF8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF8:", "    STRCPY(code, \"NFA_BACKREF8\"); break;", "  case NFA_BACKREF9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF9:", "    STRCPY(code, \"NFA_BACKREF9\"); break;", "  case NFA_ZREF1:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF1:", "    STRCPY(code, \"NFA_ZREF1\"); break;", "  case NFA_ZREF2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF2:", "    STRCPY(code, \"NFA_ZREF2\"); break;", "  case NFA_ZREF3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF3:", "    STRCPY(code, \"NFA_ZREF3\"); break;", "  case NFA_ZREF4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF4:", "    STRCPY(code, \"NFA_ZREF4\"); break;", "  case NFA_ZREF5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF5:", "    STRCPY(code, \"NFA_ZREF5\"); break;", "  case NFA_ZREF6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF6:", "    STRCPY(code, \"NFA_ZREF6\"); break;", "  case NFA_ZREF7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF7:", "    STRCPY(code, \"NFA_ZREF7\"); break;", "  case NFA_ZREF8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF8:", "    STRCPY(code, \"NFA_ZREF8\"); break;", "  case NFA_ZREF9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF9:", "    STRCPY(code, \"NFA_ZREF9\"); break;", "  case NFA_SKIP:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SKIP:", "    STRCPY(code, \"NFA_SKIP\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;", "  case NFA_PREV_ATOM_NO_WIDTH_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;", "  case NFA_PREV_ATOM_LIKE_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_LIKE_PATTERN:", "    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NOPEN:", "    STRCPY(code, \"NFA_NOPEN\"); break;", "  case NFA_NCLOSE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NCLOSE:", "    STRCPY(code, \"NFA_NCLOSE\"); break;", "  case NFA_START_INVISIBLE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE:", "    STRCPY(code, \"NFA_START_INVISIBLE\"); break;", "  case NFA_START_INVISIBLE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;", "  case NFA_START_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;", "  case NFA_START_INVISIBLE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;", "  case NFA_START_INVISIBLE_BEFORE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;", "  case NFA_START_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_PATTERN:", "    STRCPY(code, \"NFA_START_PATTERN\"); break;", "  case NFA_END_INVISIBLE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_INVISIBLE:", "    STRCPY(code, \"NFA_END_INVISIBLE\"); break;", "  case NFA_END_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_END_INVISIBLE_NEG\"); break;", "  case NFA_END_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_PATTERN:", "    STRCPY(code, \"NFA_END_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COMPOSING:", "    STRCPY(code, \"NFA_COMPOSING\"); break;", "  case NFA_END_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_COMPOSING:", "    STRCPY(code, \"NFA_END_COMPOSING\"); break;", "  case NFA_OPT_CHARS:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OPT_CHARS:", "    STRCPY(code, \"NFA_OPT_CHARS\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOL:", "    STRCPY(code, \"NFA_EOL \"); break;", "  case NFA_BOL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOL:", "    STRCPY(code, \"NFA_BOL \"); break;", "  case NFA_EOW:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOW:", "    STRCPY(code, \"NFA_EOW \"); break;", "  case NFA_BOW:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOW:", "    STRCPY(code, \"NFA_BOW \"); break;", "  case NFA_EOF:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOF:", "    STRCPY(code, \"NFA_EOF \"); break;", "  case NFA_BOF:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOF:", "    STRCPY(code, \"NFA_BOF \"); break;", "  case NFA_LNUM:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM:", "    STRCPY(code, \"NFA_LNUM \"); break;", "  case NFA_LNUM_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM_GT:", "    STRCPY(code, \"NFA_LNUM_GT \"); break;", "  case NFA_LNUM_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM_LT:", "    STRCPY(code, \"NFA_LNUM_LT \"); break;", "  case NFA_COL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL:", "    STRCPY(code, \"NFA_COL \"); break;", "  case NFA_COL_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL_GT:", "    STRCPY(code, \"NFA_COL_GT \"); break;", "  case NFA_COL_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL_LT:", "    STRCPY(code, \"NFA_COL_LT \"); break;", "  case NFA_VCOL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL:", "    STRCPY(code, \"NFA_VCOL \"); break;", "  case NFA_VCOL_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL_GT:", "    STRCPY(code, \"NFA_VCOL_GT \"); break;", "  case NFA_VCOL_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL_LT:", "    STRCPY(code, \"NFA_VCOL_LT \"); break;", "  case NFA_MARK:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK:", "    STRCPY(code, \"NFA_MARK \"); break;", "  case NFA_MARK_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK_GT:", "    STRCPY(code, \"NFA_MARK_GT \"); break;", "  case NFA_MARK_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK_LT:", "    STRCPY(code, \"NFA_MARK_LT \"); break;", "  case NFA_CURSOR:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CURSOR:", "    STRCPY(code, \"NFA_CURSOR \"); break;", "  case NFA_VISUAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VISUAL:", "    STRCPY(code, \"NFA_VISUAL \"); break;", "  case NFA_ANY_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY_COMPOSING:", "    STRCPY(code, \"NFA_ANY_COMPOSING \"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_STAR:", "    STRCPY(code, \"NFA_STAR \"); break;", "  case NFA_STAR_NONGREEDY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_STAR_NONGREEDY:", "    STRCPY(code, \"NFA_STAR_NONGREEDY \"); break;", "  case NFA_QUEST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_QUEST:", "    STRCPY(code, \"NFA_QUEST\"); break;", "  case NFA_QUEST_NONGREEDY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_QUEST_NONGREEDY:", "    STRCPY(code, \"NFA_QUEST_NON_GREEDY\"); break;", "  case NFA_EMPTY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EMPTY:", "    STRCPY(code, \"NFA_EMPTY\"); break;", "  case NFA_OR:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OR:", "    STRCPY(code, \"NFA_OR\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_COLL:", "    STRCPY(code, \"NFA_START_COLL\"); break;", "  case NFA_END_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_COLL:", "    STRCPY(code, \"NFA_END_COLL\"); break;", "  case NFA_START_NEG_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_NEG_COLL:", "    STRCPY(code, \"NFA_START_NEG_COLL\"); break;", "  case NFA_END_NEG_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_NEG_COLL:", "    STRCPY(code, \"NFA_END_NEG_COLL\"); break;", "  case NFA_RANGE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE:", "    STRCPY(code, \"NFA_RANGE\"); break;", "  case NFA_RANGE_MIN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE_MIN:", "    STRCPY(code, \"NFA_RANGE_MIN\"); break;", "  case NFA_RANGE_MAX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE_MAX:", "    STRCPY(code, \"NFA_RANGE_MAX\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ALNUM:", "    STRCPY(code, \"NFA_CLASS_ALNUM\"); break;", "  case NFA_CLASS_ALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ALPHA:", "    STRCPY(code, \"NFA_CLASS_ALPHA\"); break;", "  case NFA_CLASS_BLANK:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BLANK:", "    STRCPY(code, \"NFA_CLASS_BLANK\"); break;", "  case NFA_CLASS_CNTRL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_CNTRL:", "    STRCPY(code, \"NFA_CLASS_CNTRL\"); break;", "  case NFA_CLASS_DIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_DIGIT:", "    STRCPY(code, \"NFA_CLASS_DIGIT\"); break;", "  case NFA_CLASS_GRAPH:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_GRAPH:", "    STRCPY(code, \"NFA_CLASS_GRAPH\"); break;", "  case NFA_CLASS_LOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_LOWER:", "    STRCPY(code, \"NFA_CLASS_LOWER\"); break;", "  case NFA_CLASS_PRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PRINT:", "    STRCPY(code, \"NFA_CLASS_PRINT\"); break;", "  case NFA_CLASS_PUNCT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PUNCT:", "    STRCPY(code, \"NFA_CLASS_PUNCT\"); break;", "  case NFA_CLASS_SPACE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_SPACE:", "    STRCPY(code, \"NFA_CLASS_SPACE\"); break;", "  case NFA_CLASS_UPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_UPPER:", "    STRCPY(code, \"NFA_CLASS_UPPER\"); break;", "  case NFA_CLASS_XDIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_XDIGIT:", "    STRCPY(code, \"NFA_CLASS_XDIGIT\"); break;", "  case NFA_CLASS_TAB:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_TAB:", "    STRCPY(code, \"NFA_CLASS_TAB\"); break;", "  case NFA_CLASS_RETURN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_RETURN:", "    STRCPY(code, \"NFA_CLASS_RETURN\"); break;", "  case NFA_CLASS_BACKSPACE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BACKSPACE:", "    STRCPY(code, \"NFA_CLASS_BACKSPACE\"); break;", "  case NFA_CLASS_ESCAPE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ESCAPE:", "    STRCPY(code, \"NFA_CLASS_ESCAPE\"); break;", "  case NFA_CLASS_IDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_IDENT:", "    STRCPY(code, \"NFA_CLASS_IDENT\"); break;", "  case NFA_CLASS_KEYWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_KEYWORD:", "    STRCPY(code, \"NFA_CLASS_KEYWORD\"); break;", "  case NFA_CLASS_FNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_FNAME:", "    STRCPY(code, \"NFA_CLASS_FNAME\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY:", "    STRCPY(code, \"NFA_ANY\"); break;", "  case NFA_IDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_IDENT:", "    STRCPY(code, \"NFA_IDENT\"); break;", "  case NFA_SIDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SIDENT:", "    STRCPY(code, \"NFA_SIDENT\"); break;", "  case NFA_KWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_KWORD:", "    STRCPY(code, \"NFA_KWORD\"); break;", "  case NFA_SKWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SKWORD:", "    STRCPY(code, \"NFA_SKWORD\"); break;", "  case NFA_FNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_FNAME:", "    STRCPY(code, \"NFA_FNAME\"); break;", "  case NFA_SFNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SFNAME:", "    STRCPY(code, \"NFA_SFNAME\"); break;", "  case NFA_PRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PRINT:", "    STRCPY(code, \"NFA_PRINT\"); break;", "  case NFA_SPRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPRINT:", "    STRCPY(code, \"NFA_SPRINT\"); break;", "  case NFA_WHITE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_WHITE:", "    STRCPY(code, \"NFA_WHITE\"); break;", "  case NFA_NWHITE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NWHITE:", "    STRCPY(code, \"NFA_NWHITE\"); break;", "  case NFA_DIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_DIGIT:", "    STRCPY(code, \"NFA_DIGIT\"); break;", "  case NFA_NDIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NDIGIT:", "    STRCPY(code, \"NFA_NDIGIT\"); break;", "  case NFA_HEX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_HEX:", "    STRCPY(code, \"NFA_HEX\"); break;", "  case NFA_NHEX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NHEX:", "    STRCPY(code, \"NFA_NHEX\"); break;", "  case NFA_OCTAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OCTAL:", "    STRCPY(code, \"NFA_OCTAL\"); break;", "  case NFA_NOCTAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NOCTAL:", "    STRCPY(code, \"NFA_NOCTAL\"); break;", "  case NFA_WORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_WORD:", "    STRCPY(code, \"NFA_WORD\"); break;", "  case NFA_NWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NWORD:", "    STRCPY(code, \"NFA_NWORD\"); break;", "  case NFA_HEAD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_HEAD:", "    STRCPY(code, \"NFA_HEAD\"); break;", "  case NFA_NHEAD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NHEAD:", "    STRCPY(code, \"NFA_NHEAD\"); break;", "  case NFA_ALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ALPHA:", "    STRCPY(code, \"NFA_ALPHA\"); break;", "  case NFA_NALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NALPHA:", "    STRCPY(code, \"NFA_NALPHA\"); break;", "  case NFA_LOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LOWER:", "    STRCPY(code, \"NFA_LOWER\"); break;", "  case NFA_NLOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NLOWER:", "    STRCPY(code, \"NFA_NLOWER\"); break;", "  case NFA_UPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_UPPER:", "    STRCPY(code, \"NFA_UPPER\"); break;", "  case NFA_NUPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NUPPER:", "    STRCPY(code, \"NFA_NUPPER\"); break;", "  case NFA_LOWER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LOWER_IC:", "    STRCPY(code, \"NFA_LOWER_IC\"); break;", "  case NFA_NLOWER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NLOWER_IC:", "    STRCPY(code, \"NFA_NLOWER_IC\"); break;", "  case NFA_UPPER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_UPPER_IC:", "    STRCPY(code, \"NFA_UPPER_IC\"); break;", "  case NFA_NUPPER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NUPPER_IC:", "    STRCPY(code, \"NFA_NUPPER_IC\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the postfix notation of the current regexp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA starting with a root node \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);", "    fprintf(debugf, \" %s\", p);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA state machine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse r.e. @expr and convert it into postfix form."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Represents an NFA state plus zero or one or two arrows exiting."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate and initialize nfa_state_T."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * A partially built NFA without the matching state filled in."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize a Frag_T struct and return it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Create singleton list containing just outp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Patch the list of states at out to point to start."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Join the two lists l1 and l2, returning the combination."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Stack used for transforming postfix form into NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Push an item onto the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Pop an item from the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the maximum byte length of anything matching \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Convert a postfix form into its equivalent NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (p = postfix; p < end; ++p) {", "    switch (*p) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      case NFA_NOPEN:", "        mclose = NFA_NCLOSE; break;", "      case NFA_ZOPEN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN:", "        mclose = NFA_ZCLOSE; break;", "      case NFA_ZOPEN1:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN1:", "        mclose = NFA_ZCLOSE1; break;", "      case NFA_ZOPEN2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN2:", "        mclose = NFA_ZCLOSE2; break;", "      case NFA_ZOPEN3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN3:", "        mclose = NFA_ZCLOSE3; break;", "      case NFA_ZOPEN4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN4:", "        mclose = NFA_ZCLOSE4; break;", "      case NFA_ZOPEN5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN5:", "        mclose = NFA_ZCLOSE5; break;", "      case NFA_ZOPEN6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN6:", "        mclose = NFA_ZCLOSE6; break;", "      case NFA_ZOPEN7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN7:", "        mclose = NFA_ZCLOSE7; break;", "      case NFA_ZOPEN8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN8:", "        mclose = NFA_ZCLOSE8; break;", "      case NFA_ZOPEN9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN9:", "        mclose = NFA_ZCLOSE9; break;", "      case NFA_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_COMPOSING:", "        mclose = NFA_END_COMPOSING; break;", "      default:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * After building the NFA program, inspect it to add optimization hints."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (i = 0; i < prog->nstate; ++i) {", "    c = prog->state[i].c;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Copy the submatches from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but exclude the main match."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but only do the end of the main match if \\ze is present."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (add_here) {", "          for (k = 0; k < l->n && k < listindex; ++k) {", "            if (l->t[k].state->id == state->id) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.multi[i].start_lnum = -1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.line[i].start = NULL;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["  }", "  --l->n;", "  *ip = listidx - 1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check character class \"class\" against current character c."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Save list IDs for all NFA states of \"prog\" into \"list\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = 0;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Restore list IDs from \"list\" to all NFA states."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = list[i];", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Recursively call nfa_regmatch()"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the chance of a match with \"state\" failing."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Skip until the char \"c\" we know a match must start with."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with match_text."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Run for each character."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#endif", "    /*", "     * If the state lists are empty we can stop."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /*", "       * Handle the possible codes of the current state."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Compile a regular expression into internal code for the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * In order to build the NFA, we parse the input regexp twice:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 1"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 2"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Free a compiled regexp program, returned by nfa_regcomp()."], "readability/old_style_comment"]
["src/nvim/runtime.c", ["    if (vim_ispathsep_nocolon(*p)) {", "      p4 = p3; p3 = p2; p2 = p1; p1 = p;", "    }"], "whitespace/newline"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["", "#define MB_FILLER_CHAR '<'  /* character used when a double-width character", "                             * doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows to be redrawn later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Mark all windows that are editing the current buffer to be updated later."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Changed something in the current window, at buffer line \"lnum\", that"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* must_redraw is reset here, so that when we run into some weird", "    * reason to redraw while busy redrawing (e.g., asynchronous"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Postpone the redrawing when it's not needed and when being called", "   * recursively. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Only start redrawing if there is really something to do."], "readability/old_style_comment"]
["src/nvim/screen.c", ["               && curwin->w_old_curswant == curwin->w_curswant)", "           )) {", "    curwin->w_redr_type = type;"], "whitespace/parens"]
["src/nvim/screen.c", ["", "  /*", "   * Correct stored syntax highlighting info for changes in each displayed"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Go from top to bottom through the windows, redrawing the ones that need"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Reset b_mod_set flags.  Going through all windows is probably faster", "   * than going through all buffers (there could be many buffers). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Clear or redraw the command line.  Done last, because scrolling may", "   * mess up the command line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Update a single window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int type;", "  int top_end = 0;              /* Below last row of the top area that needs", "                                   updating.  0 when no top area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no top area updating. */", "  int mid_start = 999;          /* first row of the mid area that needs", "                                   updating.  999 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  999 when no mid area updating. */", "  int mid_end = 0;              /* Below last row of the mid area that needs", "                                   updating.  0 when no mid area updating. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["                                   updating.  0 when no mid area updating. */", "  int bot_start = 999;          /* first row of the bot area that needs", "                                   updating.  999 when no bot area updating */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Force redraw when width of 'number' or 'relativenumber' column", "   * changes. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  } else {", "    /*", "     * Set mod_top to the first line that needs displaying because of"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        mod_top = buf->b_mod_top;", "        /* Need to redraw lines above the change that may be included", "         * in a pattern match. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * A change in a line can cause lines above it to become folded or"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* Find last valid w_lines[] entry above mod_top.  Set lnumt to", "       * the line below it.  If there is no valid entry, use w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      lnumb = MAXLNUM;", "      for (i = 0; i < wp->w_lines_valid; ++i) {", "        if (wp->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["", "    /* When a change starts above w_topline and the end is below", "     * w_topline, start redrawing at w_topline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* When line numbers are displayed need to redraw all lines below", "     * inserted/deleted lines. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * When only displaying the lines at the top, set top_end.  Used when"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    j = 0;", "    for (i = 0; i < wp->w_lines_valid; ++i) {", "      j += wp->w_lines[i].wl_size;"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * If there are no changes on the screen that require a complete redraw,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                       && wp->w_topfill > wp->w_old_topfill)", "                   )) {", "      /*"], "whitespace/parens"]
["src/nvim/screen.c", ["                   )) {", "      /*", "       * New topline is above old topline: May scroll down."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* count the number of lines we are off, counting a sequence", "         * of folded lines as one */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    } else {", "      /*", "       * New topline is at or below old topline: May scroll up."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (j == -1) {", "        /* if wp->w_topline is not in wp->w_lines[].wl_lnum redraw all", "         * lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Try to delete the correct number of lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["         */", "        /* If the topline didn't change, delete old filler lines,", "         * otherwise delete filler lines of the new topline... */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0) {", "          /*", "           * Skip the lines (below the deleted lines) that are still"], "readability/old_style_comment"]
["src/nvim/screen.c", ["            wp->w_lines[idx] = wp->w_lines[j];", "            /* stop at line that didn't fit, unless it is still", "             * valid (no lines deleted) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      } else {", "        /*", "         * Find the line numbers that need to be updated: The lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * If in block mode and changed column or curwin->w_curswant:"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * There is no need to update lines above the top of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * If we know the value of w_botline, use it to restrict the update to"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Find the minimal part to be updated."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        }", "        ++idx;", "        if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid) {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * Update all the window rows."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  for (;;) {", "    /* stop updating when reached the end of the window (check for _past_", "     * the end of the window is at the end of the loop) */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Remember the starting row of the line that is going to be dealt", "     * with.  It is used further down when the line doesn't fit. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /*", "       * When at start of changed lines: May scroll following lines"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "        /* Count the old number of window rows, using w_lines[], which", "         * should still contain the sizes for the lines as they are"], "readability/old_style_comment"]
["src/nvim/screen.c", ["         * currently displayed. */", "        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid"], "readability/increment"]
["src/nvim/screen.c", ["        for (i = idx; i < wp->w_lines_valid; ++i) {", "          /* Only valid lines have a meaningful wl_lnum.  Invalid", "           * lines are part of the changed area. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["              && wp->w_lines[i].wl_lastlnum + 1 == mod_bot) {", "            /* Must have found the last valid entry above mod_bot.", "             * Add following invalid entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["             * Add following invalid entries. */", "            ++i;", "            while (i < wp->w_lines_valid"], "readability/increment"]
["src/nvim/screen.c", ["        if (i >= wp->w_lines_valid) {", "          /* We can't find a valid line below the changed lines,", "           * need to redraw until the end of the window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["        } else {", "          /* Able to count old number of rows: Count new window", "           * rows, and may insert/delete lines */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (xtra_rows < 0) {", "            /* May scroll text up.  If there is not enough", "             * remaining text or scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          } else if (xtra_rows > 0) {", "            /* May scroll text down.  If there is not enough", "             * remaining text of scrolling fails, must redraw the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "          /* When not updating the rest, may need to move w_lines[]", "           * entries. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                x += wp->w_lines[j++].wl_size;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/screen.c", ["", "              /* The w_lines[] entries for inserted lines are", "               * now invalid, but wl_size may be used above."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                wp->w_lines[i].wl_size = 0;", "                wp->w_lines[i--].wl_valid = FALSE;", "              }"], "readability/bool"]
["src/nvim/screen.c", ["", "      /*", "       * When lines are folded, display one line for all of them."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  /*", "   * End of loop over all window lines."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Let the syntax stuff know we stop parsing here."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * If we didn't hit the end of the file, and we didn't finish the last"], "readability/old_style_comment"]
["src/nvim/screen.c", ["    if (lnum == wp->w_topline) {", "      /*", "       * Single line that does not fit!"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  if (dollar_vcol == -1) {", "    /*", "     * There is a trick with w_botline.  If we invalidate it on each"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  while (**color_cols >= 0 && vcol > **color_cols) {", "    ++*color_cols;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["  int syntax_attr = 0;                  // attributes desired by syntax", "  int has_syntax = FALSE;               // this buffer has syntax highl.", "  int save_did_emsg;"], "readability/bool"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  // column where nextline[] starts", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  int nextlinecol = 0;                  // column where nextline[] starts", "  int nextline_idx = 0;                 /* index in nextline[] where next line", "                                           starts */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     // line number for \"checked_col\"", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/multiline_comment"]
["src/nvim/screen.c", ["  static linenr_T checked_lnum = 0;     // line number for \"checked_col\"", "  static int checked_col = 0;           /* column in \"checked_lnum\" up to which", "                                         * there are no spell errors */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* To be able to spell-check over line boundaries copy the end of the", "     * current line into nextline[].  Above the start of the next line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (v < SPWORDLEN) {", "        /* Short line, use it completely and append the start of the", "         * next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * 'nowrap' or 'wrap' and a single line that doesn't fit: Advance to the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /* Handle a character that's not completely on the screen: Put ptr at", "     * that character but skip the first few screen characters. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Adjust for when the inverted text is before the screen,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if (len == 0 || (int)wp->w_cursor.col > ptr - line) {", "        /* no bad word found at line start, don't check until end of a", "         * word */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Correct highlighting for cursor that can't be disabled."], "readability/old_style_comment"]
["src/nvim/screen.c", ["      if ((colnr_T)fromcol == wp->w_virtcol) {", "        /* highlighting starts at cursor, let it start just after the", "         * cursor */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_SIGN;", "        /* Show the sign column when there are any signs in this", "         * buffer or when using Netbeans. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        draw_state = WL_NR;", "        /* Display the absolute or relative line number. After the", "         * first fill with blanks when the 'n' flag isn't in 'cpo' */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["      // (area_attr may be 0 when \"noinvcur\" is set).", "      else if (line_attr != 0 && ((fromcol == -10 && tocol == MAXCOL)", "                                  || vcol < fromcol || vcol_prev < fromcol_prev"], "whitespace/newline"]
["src/nvim/screen.c", ["", "        /* Get syntax attribute, unless still at the start of the line", "         * (double-wide char that doesn't fit). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (has_syntax && v > 0) {", "          /* Get the syntax attribute for the character.  If there", "           * is an error, disable syntax highlighting. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          save_did_emsg = did_emsg;", "          did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["          if (did_emsg) {", "            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;"], "readability/bool"]
["src/nvim/screen.c", ["            wp->w_s->b_syn_error = TRUE;", "            has_syntax = FALSE;", "          } else {"], "readability/bool"]
["src/nvim/screen.c", ["", "        /* Check spelling (unless at the end of the line).", "         * Only do this when there is no syntax highlighting, the"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* Use nextline[] if possible, it has the start of the", "             * next line concatenated. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "            /* In Insert mode only highlight a word that", "             * doesn't touch the cursor. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                && (p - nextline) + len > nextline_idx) {", "              /* Remember that the good word continues at the", "               * start of the next line. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["                  && (p - nextline) + cap_col >= nextline_idx) {", "                /* Remember that the word in the next line", "                 * must start with a capital. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          char_u *p = ptr - (mb_off + 1);", "          // TODO: is passing p for start of the line OK?", "          n_extra = win_lbr_chartabsize(wp, line, p, (colnr_T)vcol, NULL) - 1;"], "readability/todo"]
["src/nvim/screen.c", ["", "      /*", "       * Handling of non-printable characters."], "readability/old_style_comment"]
["src/nvim/screen.c", ["            memset(p, ' ', n_extra);", "            STRNCPY(p, p_extra + 1, STRLEN(p_extra) - 1);", "            p[n_extra] = NUL;"], "runtime/printf"]
["src/nvim/screen.c", ["", "    /* In the cursor line and we may be concealing characters: correct", "     * the cursor column when we reach its position. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (n != 0) {", "          /* At the window boundary, highlight the last character", "           * instead (better than nothing). */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --col;", "          --off;"], "readability/increment"]
["src/nvim/screen.c", ["          --col;", "          --off;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++col;", "          ++off;"], "readability/increment"]
["src/nvim/screen.c", ["          ++col;", "          ++off;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["        }", "        ++vcol;", "        eol_hl_off = 1;"], "readability/increment"]
["src/nvim/screen.c", ["", "      /*", "       * Update w_cline_height and w_cline_folded if the cursor line was"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          // now it's time to backup one cell", "          --off;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --off;", "          --col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_rl) {", "        --off;", "        --col;"], "readability/increment"]
["src/nvim/screen.c", ["        --off;", "        --col;", "      } else {"], "readability/increment"]
["src/nvim/screen.c", ["      } else {", "        ++off;", "        ++col;"], "readability/increment"]
["src/nvim/screen.c", ["        ++off;", "        ++col;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["    } else if (wp->w_p_cole > 0 && is_concealing) {", "      --n_skip;", "      ++vcol_off;"], "readability/increment"]
["src/nvim/screen.c", ["      --n_skip;", "      ++vcol_off;", "      if (n_extra > 0) {"], "readability/increment"]
["src/nvim/screen.c", ["      if (wp->w_p_wrap) {", "        /*", "         * Special voodoo required if 'wrap' is on."], "readability/old_style_comment"]
["src/nvim/screen.c", ["          if (wp->w_p_rl) {", "            --boguscols;", "            --col;"], "readability/increment"]
["src/nvim/screen.c", ["            --boguscols;", "            --col;", "          } else {"], "readability/increment"]
["src/nvim/screen.c", ["          } else {", "            ++boguscols;", "            ++col;"], "readability/increment"]
["src/nvim/screen.c", ["            ++boguscols;", "            ++col;", "          }"], "readability/increment"]
["src/nvim/screen.c", ["        if (wp->w_p_rl) {", "          --boguscols;", "          --col;"], "readability/increment"]
["src/nvim/screen.c", ["          --boguscols;", "          --col;", "        } else {"], "readability/increment"]
["src/nvim/screen.c", ["        } else {", "          ++boguscols;", "          ++col;"], "readability/increment"]
["src/nvim/screen.c", ["          ++boguscols;", "          ++col;", "        }"], "readability/increment"]
["src/nvim/screen.c", ["    } else {", "      --n_skip;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "    /* Only advance the \"vcol\" when after the 'number' or 'relativenumber'", "     * column. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["        && filler_todo <= 0) {", "      ++vcol;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "    /*", "     * At end of screen line and there is more to come: Display the line"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "      /* When not wrapping and finished diff lines, or when displayed", "       * '$' and highlighting until last column, break here. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["           && filler_todo <= 0", "           ) || lcs_eol_one == -1) {", "        break;"], "whitespace/parens"]
["src/nvim/screen.c", ["      if (row == endrow) {", "        ++row;", "        break;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Mirror text \"str\" for right-left displaying."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  for (p1 = str, p2 = str + STRLEN(str) - 1; p1 < p2; ++p1, --p2) {", "    t = *p1;"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines that need to be redrawn."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Redraw all status lines at the bottom of frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the number of characters that should be skipped in a status match."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    // check if match fits on the screen", "    for (i = first_match; i < match; ++i) {", "      clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["      clen = 2;", "      for (i = match; i < num_matches; ++i) {", "        clen += status_match_len(xp, L_MATCH(i)) + 2;"], "readability/increment"]
["src/nvim/screen.c", ["    } else {", "      for (; *s != NUL; ++s) {", "        s += skip_status_match_char(xp, s);"], "readability/increment"]
["src/nvim/screen.c", ["    *(buf + len++) = '>';", "    ++clen;", "  }"], "readability/increment"]
["src/nvim/screen.c", ["        *p = '<';", "        ++len;", "      }"], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * May need to draw the character below the vertical separator."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  }", "  busy = FALSE;", "}"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Redraw the status line according to 'statusline' and take care of any"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* When called recursively return.  This can happen when the statusline", "   * contains an expression that triggers a redraw. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* There is a tiny chance that this gets called recursively: When", "   * redrawing a status line triggers redrawing the ruler or tabline."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /* Temporarily reset 'cursorbind', we don't want a side effect from moving", "   * the cursor away and back. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["  p_crb_save = ewp->w_p_crb;", "  ewp->w_p_crb = FALSE;", ""], "readability/bool"]
["src/nvim/screen.c", ["", "  /* Make a copy, because the statusline may include a function call that", "   * might change the option value and free the memory. */"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Draw each snippet with the specified highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Prepare for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Clean up for 'hlsearch' highlighting."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Note that the window sizes are updated before reallocating the arrays,"], "readability/old_style_comment"]
["src/nvim/screen.c", ["   */", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/screen.c", ["", "  /*", "   * Do not apply autocommands more than 3 times to avoid an endless loop"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Set cursor to its position in the current window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * The rest of the routines in this file perform screen manipulations. The"], "readability/old_style_comment"]
["src/nvim/screen.c", ["          case 0:", "            p = N_(\" VISUAL\"); break;", "          case 1:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 1:", "            p = N_(\" VISUAL LINE\"); break;", "          case 2:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 2:", "            p = N_(\" VISUAL BLOCK\"); break;", "          case 4:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 4:", "            p = N_(\" SELECT\"); break;", "          case 5:"], "whitespace/newline"]
["src/nvim/screen.c", ["          case 5:", "            p = N_(\" SELECT LINE\"); break;", "          default:"], "whitespace/newline"]
["src/nvim/screen.c", ["          default:", "            p = N_(\" SELECT BLOCK\"); break;", "          }"], "whitespace/newline"]
["src/nvim/screen.c", ["", "      need_clear = TRUE;", "    }"], "readability/bool"]
["src/nvim/screen.c", ["", "/*", " * Position for a mode message."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Draw the tab pages line at the top of the Vim window."], "readability/old_style_comment"]
["src/nvim/screen.c", ["  int use_sep_chars = (t_colors < 8", "                       );", ""], "whitespace/parens"]
["src/nvim/screen.c", ["    FOR_ALL_TABS(tp) {", "      ++tabcount;", "    }"], "readability/increment"]
["src/nvim/screen.c", ["", "/*", " * Get buffer name for \"buf\" into NameBuff[]."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Get the character to use in a status line.  Get its attributes in \"*attr\"."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if redrawing should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return TRUE if printing messages should currently be done."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Check if cursor.lnum is valid, since win_redr_ruler() may be called"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "  /*", "   * Only draw the ruler when something changed."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * Some sprintfs return the length, some return a pointer."], "readability/old_style_comment"]
["src/nvim/screen.c", ["                 (wp->w_buffer->b_ml.ml_flags & ML_EMPTY) ? (int64_t)0L", "                                                          : (int64_t)wp->w_cursor.lnum);", "    size_t len = STRLEN(buffer);"], "whitespace/alignment"]
["src/nvim/screen.c", ["", "    /*", "     * Add a \"50%\" if there is room for it."], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "/*", " * Return the width of the 'number' and 'relativenumber' column."], "readability/old_style_comment"]
["src/nvim/screen.c", ["    lnum /= 10;", "    ++n;", "  } while (lnum > 0);"], "readability/increment"]
["src/nvim/screen.c", ["", "  /* curwin->w_buffer can be NULL when we are closing a window and the", "   * buffer has already been closed and removing a scrollbar causes a resize"], "readability/old_style_comment"]
["src/nvim/screen.c", ["", "    /*", "     * We only redraw when it's needed:"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * search.c: code for normal mode searching commands"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Type used by find_pattern_in_path() to remember which included files have"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If no pattern given, use a previously defined pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Save the currently used pattern in the appropriate place,"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Get search pattern used by search_regcomp()."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Save the search patterns, so they can be restored later."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Return TRUE when case should be ignored for search pattern \"pat\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  return last_t_cmd == TRUE;", "}"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Reset search direction to forward.  For \"gd\" and \"gD\" commands."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Set the last search pattern.  For \":let @/ =\" and ShaDa file."], "readability/old_style_comment"]
["src/nvim/search.c", ["  set_vv_searchforward();", "  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;", "  spats[idx].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Get a regexp program for the last used search pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           // So it doesn't beep if bad expr", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/increment"]
["src/nvim/search.c", ["  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);", "  --emsg_off;", "}"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * find the string"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  called_emsg = FALSE;", "  do {  // loop for count"], "readability/bool"]
["src/nvim/search.c", ["    found = 0;                  // default: not found", "    at_first_line = TRUE;       // default: start in first line", "    if (pos->lnum == 0) {       // correct lnum for when starting in line 0"], "readability/bool"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        // not in first line now", "    }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Start searching in current line, unless searching backwards and"], "readability/old_style_comment"]
["src/nvim/search.c", ["      lnum = pos->lnum - 1;", "      at_first_line = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     // loop twice if 'wrapscan' set", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/increment"]
["src/nvim/search.c", ["      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;", "           lnum += dir, at_first_line = FALSE) {", "        // Stop after checking \"stop_lnum\", if it's set."], "readability/bool"]
["src/nvim/search.c", ["", "          /*", "           * Forward search in the first line: match should be after"], "readability/old_style_comment"]
["src/nvim/search.c", ["                          < (int)start_pos.col + extra_col))) {", "              /*", "               * If vi-compatible searching, continue at the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (dir == BACKWARD) {", "            /*", "             * Now, if there are multiple matches on this line,"], "readability/old_style_comment"]
["src/nvim/search.c", ["                  || (nmatched =", "                        vim_regexec_multi(&regmatch, win, buf, lnum + matchpos.lnum, matchcol,", "                                          tm, timed_out)) == 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["                  || (nmatched =", "                        vim_regexec_multi(&regmatch, win, buf, lnum + matchpos.lnum, matchcol,", "                                          tm, timed_out)) == 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["", "            /*", "             * If there is only a match after the cursor, skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      at_first_line = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0) {"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * A line offset is not remembered, this is vi compatible."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Save the values for when (options & SEARCH_KEEP) is used."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Find out the direction of the search."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Turn 'hlsearch' highlighting back on."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (pat != NULL && *pat != NUL) {   // look for (new) offset", "      /*", "       * Find end of regular expression."], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;", "      spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        ++p;", "        while (ascii_isdigit(*p)) {  // skip number"], "readability/increment"]
["src/nvim/search.c", ["        while (ascii_isdigit(*p)) {  // skip number", "          ++p;", "        }"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * If there is a character offset, subtract it from the current"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c) {", "          if (decl(&pos) == -1) {"], "readability/increment"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c) {", "          if (incl(&pos) == -1) {"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * Add character and/or line offset"], "readability/old_style_comment"]
["src/nvim/search.c", ["        // to the left, check for start of file", "        else {", "          while (c++ < 0) {"], "whitespace/newline"]
["src/nvim/search.c", ["        // to the left, check for start of file", "        else {", "          while (c++ < 0) {"], "readability/braces"]
["src/nvim/search.c", ["    }", "    ++pat;", "  }"], "readability/increment"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * search_for_exact_line(buf, pos, dir, pat)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)", "                : STRNCMP(p, pat, compl_length)) == 0) {", "        return OK;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "/*", " * Character Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * \"Other\" Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatch - find the matching paren or brace"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Raw string start is found at linep[startpos.col - 1]."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatchlimit -- find the matching paren or brace, if it exists within"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * if initc given, look in the table for the matching character"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    /*", "     * Either initc is '#', or no initc was given and we need to look"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * initc was not given, must look for something to match under"], "readability/old_style_comment"]
["src/nvim/search.c", ["        // Are we on a comment?", "        else if (linep[pos.col] == '/') {", "          if (linep[pos.col + 1] == '*') {"], "whitespace/newline"]
["src/nvim/search.c", ["", "      /*", "       * If we are not on a comment or the # at the start of a line, then"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!hash_dir && !comment_dir) {", "        /*", "         * Find the brace under or after the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (linep[pos.col] == NUL && pos.col) {", "          --pos.col;", "        }"], "readability/increment"]
["src/nvim/search.c", ["    if (hash_dir) {", "      /*", "       * Look for matching #if, #else, #elif, or #endif"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (!got_int) {", "    /*", "     * Go to the next position, forward or backward. We could use"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        --pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["        }", "        ++pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["      // Note: comments do not nest, and we ignore quotes in them", "      // TODO: ignore comment brackets inside strings", "      if (comment_dir == FORWARD) {"], "readability/todo"]
["src/nvim/search.c", ["      } else {    // Searching backwards", "        /*", "         * A comment may contain / * or / /, it may also start or end"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'), braces inside"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else if (do_quotes == -1) {", "      /*", "       * Count the number of quotes in the line, skipping \\\" and '\"'."], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start = do_quotes;", "      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards) {"], "readability/increment"]
["src/nvim/search.c", ["            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\'')) {", "          ++do_quotes;", "        }"], "readability/increment"]
["src/nvim/search.c", ["        if (*ptr == '\\\\' && ptr[1] != NUL) {", "          ++ptr;", "        }"], "readability/increment"]
["src/nvim/search.c", ["", "      /*", "       * If we find an uneven count, check current line and previous"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If 'smartmatch' is set:"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col) {", "          if (linep[col] != '\\\\') {"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'):"], "readability/old_style_comment"]
["src/nvim/search.c", ["    default:", "      /*", "       * For Lisp skip over backslashed (), {} and []."], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Only show match for chars in the 'matchpairs' option."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * brief pause, unless 'm' is present in 'cpo' and a character is"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&pos);", "      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum) {"], "readability/bool"]
["src/nvim/search.c", ["        if (dir == BACKWARD && pos.lnum != startlnum) {", "          ++pos.lnum;", "        }"], "readability/increment"]
["src/nvim/search.c", ["  if (both && *ml_get(curr) == '}') {   // include line with '}'", "    ++curr;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "/*", " * check if the string 's' is a nroff macro that is in option 'opt'"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    ++macro;", "    if (macro[0] == NUL) {"], "readability/increment"]
["src/nvim/search.c", ["", "/*", " * startPS: return TRUE if line 'lnum' is the start of a section or paragraph."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * The following routines do the word searches performed by the 'w', 'W',"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * To perform these searches, characters are placed into one of three"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * cls() - returns the class of character at curwin->w_cursor"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * We always move at least one character, unless on the last"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Go one char past end of current word (if any)"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * go to next non-white"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (cls() == 0) {", "      /*", "       * We'll stop if we land on a blank line"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * bck_word() - move backward 'count' words"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the first char of the", "     * first line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (!stop || sclass == cls() || sclass == 0) {", "      /*", "       * Skip white space before the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move backward to start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * end_word() - move to the end of the word"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If we're in the middle of a word, we just have to move to the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (cls() == sclass && sclass != 0) {", "      /*", "       * Move forward to end of the current word"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else if (!stop || sclass == 0) {", "      /*", "       * We were at the end of a word. Go to the end of the next word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move forward to the end of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       // we move only one word less", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to before the start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to end of the previous word"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Go back to the start of the word or the start of white space"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool inclusive = true;", "  int include_white = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * When Visual mode is not active, or when the VIsual area is only one"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!VIsual_active || equalpos(curwin->w_cursor, VIsual)) {", "    /*", "     * Go to start of current word or white space."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If the start is on white space, and white space should be included"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL) {", "        return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * If the start is not on white space, and white space should be"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0) {"], "readability/bool"]
["src/nvim/search.c", ["      if (include) {", "        include_white = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * When count is still > 0, extend with more objects."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (VIsual_active && lt(curwin->w_cursor, VIsual)) {", "      /*", "       * In Visual mode, with cursor at start: move cursor back."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Move cursor forward one word and/or white area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        /*", "         * If end is just past a new-line, we don't want to include"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["                        || (curwin->w_cursor.col == 0 && !inclusive))) {", "    /*", "     * If we don't include white space at the end, move the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find sentence(s) under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * When the Visual area is bigger than one character: Extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(start_pos, VIsual)) {", "      /*", "       * Cursor at start of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Cursor at end of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (*p_sel == 'e') {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If the cursor started on a blank, check if it is just before the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (start_blank) {", "      --ncount;", "    }"], "readability/increment"]
["src/nvim/search.c", ["  if (include) {", "    /*", "     * If the blank in front of the sentence is included, exclude the"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (*p_sel == 'e') {", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive."], "readability/old_style_comment"]
["src/nvim/search.c", ["      // cursor on '(' or '{', move cursor just after it", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching ')', '}', etc."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  /*", "   * If we start on \"<aaa>\" select that block."], "readability/old_style_comment"]
["src/nvim/search.c", ["again:", "  /*", "   * Search backwards for unclosed \"<aaa>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching \"</aaa>\".  First isolate the \"aaa\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["  int retval = OK;", "  int do_white = FALSE;", "  int t;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * When visual area is more than one line: extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["      prev_start_is_white = -1;", "      for (t = 0; t < 2; ++t) {", "        start_lnum += dir;"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * First move back to the start_lnum of the paragraph or white lines"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    --start_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Move past the end of any white lines."], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum)) {", "    ++end_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  --end_lnum;", "  i = count;"], "readability/increment"]
["src/nvim/search.c", ["  if (!include && white_in_front) {", "    --i;", "  }"], "readability/increment"]
["src/nvim/search.c", ["    if (include || !do_white) {", "      ++end_lnum;", "      /*"], "readability/increment"]
["src/nvim/search.c", ["      ++end_lnum;", "      /*", "       * skip to end of paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["             && !startPS(end_lnum + 1, 0, 0)) {", "        ++end_lnum;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * skip to end of white lines after paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["             && linewhite(end_lnum + 1)) {", "        ++end_lnum;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If there are no empty lines at the end, try to find some empty lines at"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (start_lnum > 1 && linewhite(start_lnum - 1)) {", "      --start_lnum;", "    }"], "readability/increment"]
["src/nvim/search.c", ["                                             line[col_start - n - 1]) != NULL) {", "        ++n;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      while (ascii_iswhite(line[col_end + 1])) {", "        ++col_end;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      while (col_start > 0 && ascii_iswhite(line[col_start - 1])) {", "        --col_start;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      && (vis_empty || !inside_quotes)) {", "    ++col_start;", "  }"], "readability/increment"]
["src/nvim/search.c", ["       || (!vis_empty && inside_quotes)", "       ) && inc_cursor() == 2) {", "    inclusive = true;"], "whitespace/parens"]
["src/nvim/search.c", ["", "/*", " * return TRUE if line 'lnum' is empty or has white chars only."], "readability/old_style_comment"]
["src/nvim/search.c", ["    assert(len <= INT_MAX);", "    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    // ignore case according to p_ic, p_scs and pat"], "runtime/printf"]
["src/nvim/search.c", ["    }", "    incl_regmatch.rm_ic = FALSE;        // don't ignore case in incl. pat.", "  }"], "readability/bool"]
["src/nvim/search.c", ["    }", "    def_regmatch.rm_ic = FALSE;         // don't ignore case in define pat.", "  }"], "readability/bool"]
["src/nvim/search.c", ["      }", "      already_searched = FALSE;", "      if (new_fname != NULL) {"], "readability/bool"]
["src/nvim/search.c", ["        while (depth_displayed < depth && !got_int) {", "          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++) {"], "readability/increment"]
["src/nvim/search.c", ["          } else {", "            /*", "             * Isolate the file name."], "readability/old_style_comment"]
["src/nvim/search.c", ["              if (p[-1] == '\"' || p[-1] == '<') {", "                --p;", "                ++i;"], "readability/increment"]
["src/nvim/search.c", ["                --p;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["              if (p[i] == '\"' || p[i] == '>') {", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["            bigger[i].lnum = 0;", "            bigger[i].matched = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["            xfree(files[old_files].name);", "            ++old_files;", "          }"], "readability/increment"]
["src/nvim/search.c", ["          files[depth].lnum = 0;", "          files[depth].matched = FALSE;", "          if (action == ACTION_EXPAND) {"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Check if the line is a define (type == FIND_DEFINE)"], "readability/old_style_comment"]
["src/nvim/search.c", ["          && vim_regexec(&def_regmatch, line, (colnr_T)0)) {", "        /*", "         * Pattern must be first identifier after 'define', so skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Look for a match.  Don't do this if we are looking for a"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "            /*", "             * Also check for a \"/ *\" or \"/ /\" before the match."], "readability/old_style_comment"]
["src/nvim/search.c", ["                || (p[0] == '/' && p[1] == '*') || p[0] == '*') {", "              for (p = line; *p && p < startp; ++p) {", "                if (matched"], "readability/increment"]
["src/nvim/search.c", ["          // IOSIZE > compl_length, so the STRNCPY works", "          STRNCPY(IObuff, aux, i);", ""], "runtime/printf"]
["src/nvim/search.c", ["            }", "            STRNCPY(IObuff + i, aux, p - aux);", "            i += (int)(p - aux);"], "runtime/printf"]
["src/nvim/search.c", ["          curwin->w_cursor.col = (colnr_T)(startp - line);", "          curwin->w_set_curswant = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Read the next line.  When reading an included file and encountering"], "readability/old_style_comment"]
["src/nvim/search.c", ["      fclose(files[depth].fp);", "      --old_files;", "      files[old_files].name = files[depth].name;"], "readability/increment"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\n') {", "        --p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\r') {", "        --p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["    }", "    msg_prt_line(line, FALSE);", "    ui_flush();                        // show one line at a time"], "readability/bool"]
["src/nvim/search.c", ["      }", "      ++*lnum;", "    } else {"], "readability/increment"]
["src/nvim/sha256.c", ["  temp2 = S2(a) + F0(a, b, c); \\", "  (d) += temp1; (h) = temp1 + temp2; \\", "}"], "whitespace/newline"]
["src/nvim/shada.c", ["  kSDReadUndisableableData = (", "                              (1 << kSDItemSearchPattern)", "                              | (1 << kSDItemSubString)"], "whitespace/indent"]
["src/nvim/shada.c", ["                              (1 << kSDItemSearchPattern)", "                              | (1 << kSDItemSubString)", "                              | (1 << kSDItemJump)),  ///< Data reading which cannot be disabled by"], "whitespace/indent"]
["src/nvim/shada.c", ["                              | (1 << kSDItemSubString)", "                              | (1 << kSDItemJump)),  ///< Data reading which cannot be disabled by", "                                                      ///< &shada or other options except for disabling"], "whitespace/indent"]
["src/nvim/shada.c", ["          .value = {", "    .v_type = VAR_UNKNOWN,", "    .vval = { .v_string = NULL }"], "whitespace/indent"]
["src/nvim/shada.c", ["    .v_type = VAR_UNKNOWN,", "    .vval = { .v_string = NULL }", "  },"], "whitespace/indent"]
["src/nvim/shada.c", ["    .vval = { .v_string = NULL }", "  },", "          .additional_elements = NULL),"], "whitespace/indent"]
["src/nvim/shada.c", ["          .sep = (char)(history_type == HIST_SEARCH", "                         ? (char)hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]", "                         : 0),"], "whitespace/alignment"]
["src/nvim/shada.c", ["                         ? (char)hist_he.hisstr[STRLEN(hist_he.hisstr) + 1]", "                         : 0),", "          .additional_elements = hist_he.additional_elements,"], "whitespace/alignment"]
["src/nvim/shada.c", ["  const unsigned srni_flags = (unsigned)(", "                                         (flags & kShaDaWantInfo", "       ? (kSDReadUndisableableData"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         (flags & kShaDaWantInfo", "       ? (kSDReadUndisableableData", "          | kSDReadRegisters"], "whitespace/alignment"]
["src/nvim/shada.c", ["             : 0))", "             : 0)", "                                         | (want_marks && get_shada_parameter('\\'') > 0"], "whitespace/alignment"]
["src/nvim/shada.c", ["             : 0)", "                                         | (want_marks && get_shada_parameter('\\'') > 0", "         ? kSDReadLocalMarks | kSDReadChanges"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (want_marks && get_shada_parameter('\\'') > 0", "         ? kSDReadLocalMarks | kSDReadChanges", "         : 0)"], "whitespace/alignment"]
["src/nvim/shada.c", ["         ? kSDReadLocalMarks | kSDReadChanges", "         : 0)", "                                         | (get_old_files"], "whitespace/alignment"]
["src/nvim/shada.c", ["         : 0)", "                                         | (get_old_files", "         ? kSDReadLocalMarks"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (get_old_files", "         ? kSDReadLocalMarks", "         : 0));"], "whitespace/alignment"]
["src/nvim/shada.c", ["         ? kSDReadLocalMarks", "         : 0));", "  if (srni_flags == 0) {"], "whitespace/alignment"]
["src/nvim/shada.c", ["                                         (flags & kShaDaWantInfo", "       ? (kSDReadUndisableableData", "          | kSDReadRegisters"], "whitespace/alignment"]
["src/nvim/shada.c", ["             : 0))", "             : 0)", "                                         | (want_marks && get_shada_parameter('\\'') > 0"], "whitespace/alignment"]
["src/nvim/shada.c", ["                                         | (want_marks && get_shada_parameter('\\'') > 0", "         ? kSDReadLocalMarks | kSDReadChanges", "         : 0)"], "whitespace/alignment"]
["src/nvim/shada.c", ["         ? kSDReadLocalMarks | kSDReadChanges", "         : 0)", "                                         | (get_old_files"], "whitespace/alignment"]
["src/nvim/shada.c", ["                                         | (get_old_files", "         ? kSDReadLocalMarks", "         : 0));"], "whitespace/alignment"]
["src/nvim/shada.c", ["         ? kSDReadLocalMarks", "         : 0));", "  if (srni_flags == 0) {"], "whitespace/alignment"]
["src/nvim/shada.c", ["        (cur_entry.data.search_pattern.is_substitute_pattern", "           ? &get_substitute_pattern", "           : &get_search_pattern)(&pat);"], "whitespace/alignment"]
["src/nvim/shada.c", ["           ? &get_substitute_pattern", "           : &get_search_pattern)(&pat);", "        if (pat.pat != NULL && pat.timestamp >= cur_entry.timestamp) {"], "whitespace/alignment"]
["src/nvim/shada.c", ["      (cur_entry.data.search_pattern.is_substitute_pattern", "         ? &set_substitute_pattern", "         : &set_search_pattern)((SearchPattern) {"], "whitespace/alignment"]
["src/nvim/shada.c", ["         ? &set_substitute_pattern", "         : &set_search_pattern)((SearchPattern) {", "        .magic = cur_entry.data.search_pattern.magic,"], "whitespace/alignment"]
["src/nvim/shada.c", ["         : &set_search_pattern)((SearchPattern) {", "        .magic = cur_entry.data.search_pattern.magic,", "        .no_scs = !cur_entry.data.search_pattern.smartcase,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .magic = cur_entry.data.search_pattern.magic,", "        .no_scs = !cur_entry.data.search_pattern.smartcase,", "        .off = {"], "whitespace/indent"]
["src/nvim/shada.c", ["        .no_scs = !cur_entry.data.search_pattern.smartcase,", "        .off = {", "          .dir = cur_entry.data.search_pattern.search_backward ? '?' : '/',"], "whitespace/indent"]
["src/nvim/shada.c", ["        },", "        .pat = (char_u *)cur_entry.data.search_pattern.pat,", "        .additional_data = cur_entry.data.search_pattern.additional_data,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .pat = (char_u *)cur_entry.data.search_pattern.pat,", "        .additional_data = cur_entry.data.search_pattern.additional_data,", "        .timestamp = cur_entry.timestamp,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .additional_data = cur_entry.data.search_pattern.additional_data,", "        .timestamp = cur_entry.timestamp,", "      });"], "whitespace/indent"]
["src/nvim/shada.c", ["        .timestamp = cur_entry.timestamp,", "      });", "      if (cur_entry.data.search_pattern.is_last_used) {"], "whitespace/indent"]
["src/nvim/shada.c", ["         : &set_search_pattern)((SearchPattern) {", "        .magic = cur_entry.data.search_pattern.magic,", "        .no_scs = !cur_entry.data.search_pattern.smartcase,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .magic = cur_entry.data.search_pattern.magic,", "        .no_scs = !cur_entry.data.search_pattern.smartcase,", "        .off = {"], "whitespace/indent"]
["src/nvim/shada.c", ["        .no_scs = !cur_entry.data.search_pattern.smartcase,", "        .off = {", "          .dir = cur_entry.data.search_pattern.search_backward ? '?' : '/',"], "whitespace/indent"]
["src/nvim/shada.c", ["        },", "        .pat = (char_u *)cur_entry.data.search_pattern.pat,", "        .additional_data = cur_entry.data.search_pattern.additional_data,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .pat = (char_u *)cur_entry.data.search_pattern.pat,", "        .additional_data = cur_entry.data.search_pattern.additional_data,", "        .timestamp = cur_entry.timestamp,"], "whitespace/indent"]
["src/nvim/shada.c", ["        .additional_data = cur_entry.data.search_pattern.additional_data,", "        .timestamp = cur_entry.timestamp,", "      });"], "whitespace/indent"]
["src/nvim/shada.c", ["        .timestamp = cur_entry.timestamp,", "      });", "      if (cur_entry.data.search_pattern.is_last_used) {"], "whitespace/indent"]
["src/nvim/shada.c", ["                    (buf == NULL", "                       ? (jl_entry.fname != NULL", "                          && STRCMP(fm.fname, jl_entry.fname) == 0)"], "whitespace/alignment"]
["src/nvim/shada.c", ["                          && STRCMP(fm.fname, jl_entry.fname) == 0)", "                       : fm.fmark.fnum == jl_entry.fmark.fnum),", "                    free_xfmark, SDE_TO_XFMARK, ADJUST_IDX, DUMMY_AFTERFREE);"], "whitespace/alignment"]
["src/nvim/shada.c", ["                    (buf == NULL", "                       ? (jl_entry.fname != NULL", "                          && STRCMP(fm.fname, jl_entry.fname) == 0)"], "whitespace/alignment"]
["src/nvim/shada.c", ["                          && STRCMP(fm.fname, jl_entry.fname) == 0)", "                       : fm.fmark.fnum == jl_entry.fmark.fnum),", "                    free_xfmark, SDE_TO_XFMARK, ADJUST_IDX, DUMMY_AFTERFREE);"], "whitespace/alignment"]
["src/nvim/shada.c", ["    const size_t arr_size = 2 + (size_t)is_hist_search + (size_t)(", "                                                                  tv_list_len(entry.data.", "                                                                              history_item."], "whitespace/indent"]
["src/nvim/shada.c", ["    const size_t arr_size = 2 + (size_t)(", "                                         tv_list_len(entry.data.global_var.additional_elements));", "    msgpack_pack_array(spacker, arr_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["    const size_t arr_size = 1 + (size_t)(", "                                         tv_list_len(entry.data.sub_string.additional_elements));", "    msgpack_pack_array(spacker, arr_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["    const size_t map_size = (size_t)(", "                                     1  // Search pattern is always present", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.magic)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     1  // Search pattern is always present", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.magic)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_last_used)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.magic)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_last_used)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.smartcase)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.is_last_used)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.smartcase)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.has_line_offset)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.smartcase)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.has_line_offset)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.place_cursor_at_end)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.has_line_offset)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.place_cursor_at_end)", "                                     + ONE_IF_NOT_DEFAULT(entry,"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.place_cursor_at_end)", "                                     + ONE_IF_NOT_DEFAULT(entry,", "                                                          search_pattern.is_substitute_pattern)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                          search_pattern.is_substitute_pattern)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.highlighted)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.offset)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.highlighted)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.offset)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.search_backward)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.offset)", "                                     + ONE_IF_NOT_DEFAULT(entry, search_pattern.search_backward)", "                                     // finally, additional data:"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     // finally, additional data:", "                                     + (size_t)(", "                                                entry.data.search_pattern.additional_data"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + (size_t)(", "                                                entry.data.search_pattern.additional_data", "              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                entry.data.search_pattern.additional_data", "              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used", "              : 0));"], "whitespace/indent"]
["src/nvim/shada.c", ["              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used", "              : 0));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + (size_t)(", "                                                entry.data.search_pattern.additional_data", "              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                entry.data.search_pattern.additional_data", "              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used", "              : 0));"], "whitespace/indent"]
["src/nvim/shada.c", ["              ? entry.data.search_pattern.additional_data->dv_hashtab.ht_used", "              : 0));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["    const size_t map_size = (size_t)(", "                                     1  // File name", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.lnum)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     1  // File name", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.lnum)", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.col)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.lnum)", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.col)", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.name)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, filemark.mark.col)", "                                     + ONE_IF_NOT_DEFAULT(entry, filemark.name)", "                                     // Additional entries, if any:"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     // Additional entries, if any:", "                                     + (size_t)(", "                                                entry.data.filemark.additional_data == NULL"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + (size_t)(", "                                                entry.data.filemark.additional_data == NULL", "              ? 0"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                entry.data.filemark.additional_data == NULL", "              ? 0", "              : entry.data.filemark.additional_data->dv_hashtab.ht_used));"], "whitespace/indent"]
["src/nvim/shada.c", ["              ? 0", "              : entry.data.filemark.additional_data->dv_hashtab.ht_used));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + (size_t)(", "                                                entry.data.filemark.additional_data == NULL", "              ? 0"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                entry.data.filemark.additional_data == NULL", "              ? 0", "              : entry.data.filemark.additional_data->dv_hashtab.ht_used));"], "whitespace/indent"]
["src/nvim/shada.c", ["              ? 0", "              : entry.data.filemark.additional_data->dv_hashtab.ht_used));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/indent"]
["src/nvim/shada.c", ["    assert(entry.type == kSDItemJump || entry.type == kSDItemChange", "             ? CHECK_DEFAULT(entry, filemark.name)", "             : true);"], "whitespace/alignment"]
["src/nvim/shada.c", ["             ? CHECK_DEFAULT(entry, filemark.name)", "             : true);", "    if (!CHECK_DEFAULT(entry, filemark.name)) {"], "whitespace/alignment"]
["src/nvim/shada.c", ["    const size_t map_size = (size_t)(", "                                     2  // Register contents and name", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.type)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     2  // Register contents and name", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.type)", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.width)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, reg.type)", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.width)", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.is_unnamed)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + ONE_IF_NOT_DEFAULT(entry, reg.width)", "                                     + ONE_IF_NOT_DEFAULT(entry, reg.is_unnamed)", "                                     // Additional entries, if any:"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     // Additional entries, if any:", "                                     + (size_t)(entry.data.reg.additional_data == NULL", "                      ? 0"], "whitespace/indent"]
["src/nvim/shada.c", ["                                     + (size_t)(entry.data.reg.additional_data == NULL", "                      ? 0", "                      : entry.data.reg.additional_data->dv_hashtab.ht_used));"], "whitespace/alignment"]
["src/nvim/shada.c", ["                      ? 0", "                      : entry.data.reg.additional_data->dv_hashtab.ht_used));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/alignment"]
["src/nvim/shada.c", ["                                     + (size_t)(entry.data.reg.additional_data == NULL", "                      ? 0", "                      : entry.data.reg.additional_data->dv_hashtab.ht_used));"], "whitespace/alignment"]
["src/nvim/shada.c", ["                      ? 0", "                      : entry.data.reg.additional_data->dv_hashtab.ht_used));", "    msgpack_pack_map(spacker, map_size);"], "whitespace/alignment"]
["src/nvim/shada.c", ["      const size_t map_size = (size_t)(", "                                       1  // Buffer name", "                                       + (size_t)(entry.data.buffer_list.buffers[i].pos.lnum"], "whitespace/indent"]
["src/nvim/shada.c", ["                                       1  // Buffer name", "                                       + (size_t)(entry.data.buffer_list.buffers[i].pos.lnum", "                                                  != default_pos.lnum)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                  != default_pos.lnum)", "                                       + (size_t)(entry.data.buffer_list.buffers[i].pos.col", "                                                  != default_pos.col)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                       // Additional entries, if any:", "                                       + (size_t)(", "                                                  entry.data.buffer_list.buffers[i].additional_data"], "whitespace/indent"]
["src/nvim/shada.c", ["                                       + (size_t)(", "                                                  entry.data.buffer_list.buffers[i].additional_data", "                                                  == NULL"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                  entry.data.buffer_list.buffers[i].additional_data", "                                                  == NULL", "                ? 0"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                  == NULL", "                ? 0", "                : (entry.data.buffer_list.buffers[i].additional_data"], "whitespace/indent"]
["src/nvim/shada.c", ["                ? 0", "                : (entry.data.buffer_list.buffers[i].additional_data", "                   ->dv_hashtab.ht_used)));"], "whitespace/indent"]
["src/nvim/shada.c", ["                                       + (size_t)(", "                                                  entry.data.buffer_list.buffers[i].additional_data", "                                                  == NULL"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                  entry.data.buffer_list.buffers[i].additional_data", "                                                  == NULL", "                ? 0"], "whitespace/indent"]
["src/nvim/shada.c", ["                                                  == NULL", "                ? 0", "                : (entry.data.buffer_list.buffers[i].additional_data"], "whitespace/indent"]
["src/nvim/shada.c", ["                ? 0", "                : (entry.data.buffer_list.buffers[i].additional_data", "                   ->dv_hashtab.ht_used)));"], "whitespace/indent"]
["src/nvim/shada.c", ["      COMPARE_WITH_ENTRY((entry.data.search_pattern.is_substitute_pattern", "                            ? &wms->sub_search_pattern", "                            : &wms->search_pattern), entry);"], "whitespace/alignment"]
["src/nvim/shada.c", ["                            ? &wms->sub_search_pattern", "                            : &wms->search_pattern), entry);", "      break;"], "whitespace/alignment"]
["src/nvim/shada.c", ["            .place_cursor_at_end = (", "                                    is_substitute_pattern", "                ? defaults.data.search_pattern.place_cursor_at_end"], "whitespace/indent"]
["src/nvim/shada.c", ["  const unsigned srni_flags = (unsigned)(", "                                         kSDReadUndisableableData", "                                         | kSDReadUnknown"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         kSDReadUndisableableData", "                                         | kSDReadUnknown", "                                         | (dump_history ? kSDReadHistory : 0)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | kSDReadUnknown", "                                         | (dump_history ? kSDReadHistory : 0)", "                                         | (dump_registers ? kSDReadRegisters : 0)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (dump_history ? kSDReadHistory : 0)", "                                         | (dump_registers ? kSDReadRegisters : 0)", "                                         | (dump_global_vars ? kSDReadVariables : 0)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (dump_registers ? kSDReadRegisters : 0)", "                                         | (dump_global_vars ? kSDReadVariables : 0)", "                                         | (dump_global_marks ? kSDReadGlobalMarks : 0)"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (dump_global_vars ? kSDReadVariables : 0)", "                                         | (dump_global_marks ? kSDReadGlobalMarks : 0)", "                                         | (num_marked_files ? kSDReadLocalMarks |"], "whitespace/indent"]
["src/nvim/shada.c", ["                                         | (dump_global_marks ? kSDReadGlobalMarks : 0)", "                                         | (num_marked_files ? kSDReadLocalMarks |", "                                            kSDReadChanges : 0));"], "whitespace/indent"]
["src/nvim/shada.c", ["    strsize = (", "               unpacked.data.via.array.ptr[1].via.bin.size", "               + 1  // Zero byte"], "whitespace/indent"]
["src/nvim/shada.c", ["               unpacked.data.via.array.ptr[1].via.bin.size", "               + 1  // Zero byte", "               + 1);  // Separator character"], "whitespace/indent"]
["src/nvim/shada.c", ["               + 1  // Zero byte", "               + 1);  // Separator character", "    entry->data.history_item.string = xmalloc(strsize);"], "whitespace/indent"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "build/header_guard"]
["src/nvim/sign_defs.h", ["", "#endif // NVIM_SIGN_DEFS_H", ""], "whitespace/comments"]
["src/nvim/spell.c", ["typedef struct {", "  short sft_score;              // lowest score used", "  char_u sft_word[1];           // soundfolded word, actually longer"], "runtime/int"]
["src/nvim/spell.c", ["  // language.", "  for (lpi = 0; lpi < wp->w_s->b_langp.ga_len; ++lpi) {", "    mi.mi_lp = LANGP_ENTRY(wp->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      endidx[endidxcnt++] = arridx++;", "      --len;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++wlen;", "        --flen;"], "readability/increment"]
["src/nvim/spell.c", ["        ++wlen;", "        --flen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (endidxcnt > 0) {", "    --endidxcnt;", "    arridx = endidx[endidxcnt];"], "readability/increment"]
["src/nvim/spell.c", ["    for (len = byts[arridx - 1]; len > 0 && byts[arridx] == 0;", "         --len, ++arridx) {", "      uint32_t flags = idxs[arridx];"], "readability/increment"]
["src/nvim/spell.c", ["      // mip->mi_prefarridx that find_prefix() filled.", "      else if (mode == FIND_PREFIX && !prefix_found) {", "        c = valid_word_prefix(mip->mi_prefcnt, mip->mi_prefarridx,"], "whitespace/newline"]
["src/nvim/spell.c", ["        if (!byte_in_str(mip->mi_complen == 0", "                ? slang->sl_compstartflags", "                : slang->sl_compallflags,"], "whitespace/alignment"]
["src/nvim/spell.c", ["                ? slang->sl_compstartflags", "                : slang->sl_compallflags,", "                         ((unsigned)flags >> 24))) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["      // Check NEEDCOMPOUND: can't use word without compounding.", "      else if (flags & WF_NEEDCOMP) {", "        continue;"], "whitespace/newline"]
["src/nvim/spell.c", ["#endif", "        ++mip->mi_complen;", "        if (flags & WF_COMPROOT) {"], "readability/increment"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT) {", "          ++mip->mi_compextra;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["        // to find the \".add\" file(s).", "        for (int lpi = 0; lpi < mip->mi_win->w_s->b_langp.ga_len; ++lpi) {", "          if (slang->sl_nobreak) {"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        --mip->mi_complen;", "        if (flags & WF_COMPROOT) {"], "readability/increment"]
["src/nvim/spell.c", ["        if (flags & WF_COMPROOT) {", "          --mip->mi_compextra;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  if (!byte_in_str(sp->ts_complen == sp->ts_compsplit", "          ? slang->sl_compstartflags : slang->sl_compallflags, flag)) {", "    return false;"], "whitespace/alignment"]
["src/nvim/spell.c", ["  // loop over all the COMPOUNDRULE entries", "  for (p = slang->sl_comprules; *p != NUL; ++p) {", "    // loop over the flags in the compound word we have made, match"], "readability/increment"]
["src/nvim/spell.c", ["    // them against the current rule entry", "    for (i = 0;; ++i) {", "      c = compflags[i];"], "readability/increment"]
["src/nvim/spell.c", ["        // compare against all the flags in []", "        ++p;", "        while (*p != ']' && *p != NUL) {"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  prefid = (unsigned)flags >> 24;", "  for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt) {", "    pidx = slang->sl_pidxs[arridx + prefcnt];"], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == 0) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[lo];", "    ++wlen;", "    --flen;"], "readability/increment"]
["src/nvim/spell.c", ["    ++wlen;", "    --flen;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["              (void)syn_get_id(wp, lnum, (colnr_T)col,", "                               FALSE, &can_spell, FALSE);", "              if (!can_spell) {"], "readability/bool"]
["src/nvim/spell.c", ["      if (lnum < wp->w_buffer->b_ml.ml_line_count) {", "        ++lnum;", "      } else if (!p_ws) {"], "readability/increment"]
["src/nvim/spell.c", ["      // Capcol skips over the inserted space.", "      --capcol;", ""], "readability/increment"]
["src/nvim/spell.c", ["  // autocommand may load it then.", "  for (round = 1; round <= 2; ++round) {", "    // Find the first spell file for \"lang\" in 'runtimepath' and load it."], "readability/increment"]
["src/nvim/spell.c", ["", "  for (int i = 0; i < lp->sl_prefixcnt; ++i) {", "    vim_regfree(lp->sl_prefprog[i]);"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (p = str; *p != NUL; ++p) {", "    if (*p == n) {"], "readability/increment"]
["src/nvim/spell.c", ["    len = 0;", "    for (int i = 0; i < slang->sl_syl_items.ga_len; ++i) {", "      syl = ((syl_item_T *)slang->sl_syl_items.ga_data) + i;"], "readability/increment"]
["src/nvim/spell.c", ["    if (len != 0) {     // found a match, count syllable", "      ++cnt;", "      skip = false;"], "readability/increment"]
["src/nvim/spell.c", ["      } else if (!skip) {", "        ++cnt;                      // Yes, count it", "        skip = true;                // don't count following syllable chars"], "readability/increment"]
["src/nvim/spell.c", ["  spf = curwin->w_s->b_p_spf;", "  for (round = 0; round == 0 || *spf != NUL; ++round) {", "    if (round == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["      // If it was already found above then skip it.", "      for (c = 0; c < ga.ga_len; ++c) {", "        p = LANGP_ENTRY(ga, c)->lp_slang->sl_fname;"], "readability/increment"]
["src/nvim/spell.c", ["  // with the same name.  E.g. for \"en-math\" use \"en\".", "  for (int i = 0; i < ga.ga_len; ++i) {", "    lp = LANGP_ENTRY(ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["      // find first similar language that does sound folding", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["      // find first similar language that has REP items", "      for (int j = 0; j < ga.ga_len; ++j) {", "        lp2 = LANGP_ENTRY(ga, j);"], "readability/increment"]
["src/nvim/spell.c", ["      if (SPELL_ISUPPER(c)) {", "        ++u;", "        if (p == word) {"], "readability/increment"]
["src/nvim/spell.c", ["      } else {", "        ++l;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  if (buf != NULL) {", "    ml_close(buf, TRUE);", "    xfree(buf);"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (i = 0; i < 256; ++i) {", "    sp->st_fold[i] = i;"], "readability/increment"]
["src/nvim/spell.c", ["  // that is done separately.", "  for (i = '0'; i <= '9'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'A'; i <= 'Z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["  }", "  for (i = 'a'; i <= 'z'; ++i) {", "    sp->st_isw[i] = true;"], "readability/increment"]
["src/nvim/spell.c", ["    end_visual_mode();", "  } else", "  // Find the start of the badly spelled word."], "readability/braces"]
["src/nvim/spell.c", ["", "    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {"], "readability/bool"]
["src/nvim/spell.c", ["    msg_scroll = TRUE;", "    for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "      stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["", "    cmdmsg_rl = FALSE;", "    msg_col = 0;"], "readability/bool"]
["src/nvim/spell.c", ["    regmatch.regprog = curwin->w_s->b_cap_prog;", "    regmatch.rm_ic = FALSE;", "    p = line + endcol;"], "readability/bool"]
["src/nvim/spell.c", ["  frompat = xmalloc(STRLEN(repl_from) + 7);", "  sprintf((char *)frompat, \"\\\\V\\\\<%s\\\\>\", repl_from);", "  p_ws = false;"], "runtime/printf"]
["src/nvim/spell.c", ["      if (curwin->w_cursor.lnum != prev_lnum) {", "        ++sub_nlines;", "        prev_lnum = curwin->w_cursor.lnum;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++sub_nsubs;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  ga_grow(gap, sug.su_ga.ga_len);", "  for (int i = 0; i < sug.su_ga.ga_len; ++i) {", "    stp = &SUG(sug.su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // languages (e.g., \"pl,en\").", "  for (int i = 0; i < curbuf->b_s.b_langp.ga_len; ++i) {", "    lp = LANGP_ENTRY(curbuf->b_s.b_langp, i);"], "readability/increment"]
["src/nvim/spell.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/spell.c", ["", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"prefix\");", "#endif"], "runtime/printf"]
["src/nvim/spell.c", ["          go_deeper(stack, depth, 0);", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["      // End of word in tree.", "      ++sp->ts_curi;                    // eat one NUL byte", ""], "readability/increment"]
["src/nvim/spell.c", ["", "      // TODO: how about splitting in the soundfold tree?", "      if (fword_ends"], "readability/todo"]
["src/nvim/spell.c", ["          smsg(\"------ %s -------\", fword);", "          for (j = 0; j < depth; ++j) {", "            smsg(\"%s\", changename[j]);"], "readability/increment"]
["src/nvim/spell.c", ["        // different.  It's done like a split.", "        // TODO: word split for soundfold words", "        try_split = (sp->ts_fidx - repextra < su->su_badlen)"], "readability/todo"]
["src/nvim/spell.c", ["          sp->ts_flags |= TSF_DIDSPLIT;", "          --sp->ts_curi;                    // do the same NUL again", "          compflags[sp->ts_complen] = NUL;"], "readability/increment"]
["src/nvim/spell.c", ["            if (!try_compound && !fword_ends) {", "              sprintf(changename[depth], \"%.*s-%s: split\",", "                      sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["            } else {", "              sprintf(changename[depth], \"%.*s-%s: compound\",", "                      sp->ts_twordlen, tword, fword + sp->ts_fidx);"], "runtime/printf"]
["src/nvim/spell.c", ["", "            ++depth;", "            sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["            if (try_compound) {", "              ++sp->ts_complen;", "            } else {"], "readability/increment"]
["src/nvim/spell.c", ["          if (newscore > 0) {", "            sprintf(changename[depth], \"%.*s-%s: subst %c to %c\",", "                    sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          } else {", "            sprintf(changename[depth], \"%.*s-%s: accept %c\",", "                    sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "          ++depth;", "          sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["          sp = &stack[depth];", "          ++sp->ts_fidx;", "          tword[sp->ts_twordlen++] = c;"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: delete %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++sp->ts_curi;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: insert %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["#endif", "        ++depth;", "        sp = &stack[depth];"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "        sprintf(changename[depth], \"%.*s-%s: swap3 %c and %c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate left %c%c%c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3L;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["        p = fword + sp->ts_fidx;", "        sprintf(changename[depth], \"%.*s-%s: rotate right %c%c%c\",", "                sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["        sp->ts_state = STATE_UNROT3R;", "        ++depth;", "        p = fword + sp->ts_fidx;"], "readability/increment"]
["src/nvim/spell.c", ["#ifdef DEBUG_TRIEWALK", "          sprintf(changename[depth], \"%.*s-%s: replace %s with %s\",", "                  sp->ts_twordlen, tword, fword + sp->ts_fidx,"], "runtime/printf"]
["src/nvim/spell.c", ["          // Change the \"from\" to the \"to\" string.", "          ++depth;", "          fl = (int)STRLEN(ftp->ft_from);"], "readability/increment"]
["src/nvim/spell.c", ["      // Did all possible states at this level, go up one level.", "      --depth;", ""], "readability/increment"]
["src/nvim/spell.c", ["      // kword is getting too long, continue one level up", "      --depth;", "    } else if (++round[depth] > 2) {"], "readability/increment"]
["src/nvim/spell.c", ["      // level up", "      --depth;", "    } else {"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (tryidx = arridx[depth]; l > 0; --l) {", "        // Perform a binary search in the list of accepted bytes."], "readability/increment"]
["src/nvim/spell.c", ["        if (round[depth] == 1) {", "          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],", "                  flen);"], "runtime/printf"]
["src/nvim/spell.c", ["        } else {", "          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],", "                  ulen);"], "runtime/printf"]
["src/nvim/spell.c", ["", "        ++depth;", "        arridx[depth] = tryidx;"], "readability/increment"]
["src/nvim/spell.c", ["  // Use the sound-folding of the first language that supports it.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["          sstp->st_orglen = stp->st_orglen;", "          ++su->su_sga.ga_len;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_ga.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["", "      for (int i = 0; i < su->su_ga.ga_len; ++i) {", "        stp = &SUG(su->su_ga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  // Add the alternate score to su_sga.", "  for (int i = 0; i < su->su_sga.ga_len; ++i) {", "    stp = &SUG(su->su_sga, i);"], "readability/increment"]
["src/nvim/spell.c", ["  stp = &SUG(ga, 0);", "  for (int i = 0; i < su->su_ga.ga_len || i < su->su_sga.ga_len; ++i) {", "    // round 1: get a suggestion from su_ga"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: get a suggestion from su_sga", "    for (round = 1; round <= 2; ++round) {", "      gap = round == 1 ? &su->su_ga : &su->su_sga;"], "readability/increment"]
["src/nvim/spell.c", ["        int j;", "        for (j = 0; j < ga.ga_len; ++j) {", "          if (STRCMP(stp[j].st_word, p) == 0) {"], "readability/increment"]
["src/nvim/spell.c", ["  if (ga.ga_len > su->su_maxcount) {", "    for (int i = su->su_maxcount; i < ga.ga_len; ++i) {", "      xfree(stp[i].st_word);"], "readability/increment"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      // try all kinds of inserts/deletes/swaps/etc.", "      // TODO: also soundfold the next words, so that we can try joining", "      // and splitting"], "readability/todo"]
["src/nvim/spell.c", ["  // .sug file has been loaded.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["      todo = (int)slang->sl_sounddone.ht_used;", "      for (hi = slang->sl_sounddone.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spell.c", ["          xfree(HI2SFT(hi));", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["    wordcount = 0;", "    for (wlen = 0; wlen < MAXWLEN - 3; ++wlen) {", "      i = 1;"], "readability/increment"]
["src/nvim/spell.c", ["      if (byts[n + 1] == NUL) {", "        ++wordcount;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      // skip over the NUL bytes", "      for (; byts[n + i] == NUL; ++i) {", "        if (i > byts[n]) {              // safety check"], "readability/increment"]
["src/nvim/spell.c", ["      // One of the siblings must have the word.", "      for (; i < byts[n]; ++i) {", "        wc = idxs[idxs[n + i]];         // nr of words under this byte"], "readability/increment"]
["src/nvim/spell.c", ["    // Go over the possible flags and regions.", "    for (; i <= byts[n] && byts[n + i] == NUL; ++i) {", "      char_u cword[MAXWLEN];"], "readability/increment"]
["src/nvim/spell.c", ["      while (len > 0 && byts[arridx] == NUL) {", "        ++arridx;", "        --len;"], "readability/increment"]
["src/nvim/spell.c", ["        ++arridx;", "        --len;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++wordnr;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      wordnr += idxs[idxs[arridx]];", "      ++arridx;", "      if (--len == 0) {         // end of the bytes, didn't find it"], "readability/increment"]
["src/nvim/spell.c", ["    arridx = idxs[arridx];", "    ++wlen;", ""], "readability/increment"]
["src/nvim/spell.c", ["      while (ptr[wlen] == ' ' || ptr[wlen] == TAB) {", "        ++wlen;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  stp = &SUG(*gap, 0);", "  for (int i = gap->ga_len - 1; i >= 0; --i) {", "    // Need to append what follows to check for \"the the\"."], "readability/increment"]
["src/nvim/spell.c", ["      xfree(stp[i].st_word);", "      --gap->ga_len;", "      if (i < gap->ga_len) {"], "readability/increment"]
["src/nvim/spell.c", ["  if (su->su_sallang != NULL) {", "    for (int i = 0; i < su->su_ga.ga_len; ++i) {", "      rescore_one(su, &SUG(su->su_ga, i));"], "readability/increment"]
["src/nvim/spell.c", ["      for (; ((ws = smp[n].sm_lead_w)[0] & 0xff) == (c & 0xff)", "           && ws[0] != NUL; ++n) {", "        // Quickly skip entries that don't match the word.  Most"], "readability/increment"]
["src/nvim/spell.c", ["          if (k > 2) {", "            for (j = 2; j < k; ++j) {", "              if (word[i + j] != ws[j]) {"], "readability/increment"]
["src/nvim/spell.c", ["          while (*pf != NUL && *pf != word[i + k]) {", "            ++pf;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["          }", "          ++k;", "        }"], "readability/increment"]
["src/nvim/spell.c", ["            for (; ((ws = smp[n0].sm_lead_w)[0] & 0xff)", "                 == (c0 & 0xff); ++n0) {", "              // Quickly skip entries that don't match the word."], "readability/increment"]
["src/nvim/spell.c", ["                  pf = word + i + k + 1;", "                  for (j = 2; j < k0; ++j) {", "                    if (*pf++ != ws[j]) {"], "readability/increment"]
["src/nvim/spell.c", ["                while (*pf != NUL && *pf != word[i + k0]) {", "                  ++pf;", "                }"], "readability/increment"]
["src/nvim/spell.c", ["                }", "                ++k0;", "              }"], "readability/increment"]
["src/nvim/spell.c", ["      if (*badsound == '*') {", "        ++badsound;", "      } else {"], "readability/increment"]
["src/nvim/spell.c", ["      } else {", "        ++goodsound;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["  while (*pl == *ps && *pl != NUL) {", "    ++pl;", "    ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["    ++pl;", "    ++ps;", "  }"], "readability/increment"]
["src/nvim/spell.c", ["    // Must delete two characters from \"pl\".", "    ++pl;               // first delete", "    while (*pl == *ps) {"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl == *ps) {", "      ++pl;", "      ++ps;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl;", "      ++ps;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      while (*pl2 == *ps2) {", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["        }", "        ++pl2;", "        ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["        ++pl2;", "        ++ps2;", "      }"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["    while (*pl2 == *ps2) {", "      ++pl2;", "      ++ps2;"], "readability/increment"]
["src/nvim/spell.c", ["      ++pl2;", "      ++ps2;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["  CNT(0, 0) = 0;", "  for (j = 1; j <= goodlen; ++j) {", "    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;"], "readability/increment"]
["src/nvim/spell.c", ["", "  for (i = 1; i <= badlen; ++i) {", "    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;"], "readability/increment"]
["src/nvim/spell.c", ["      }", "      ++bi;", "      ++gi;"], "readability/increment"]
["src/nvim/spell.c", ["      ++bi;", "      ++gi;", "    }"], "readability/increment"]
["src/nvim/spell.c", ["      // round 1: try inserting a char in badword", "      for (round = 0; round <= 1; ++round) {", "        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);"], "readability/increment"]
["src/nvim/spell.c", ["              }", "              ++bi2;", "              ++gi2;"], "readability/increment"]
["src/nvim/spell.c", ["              ++bi2;", "              ++gi2;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["            stack[stackidx].score = score_off;", "            ++stackidx;", "          }"], "readability/increment"]
["src/nvim/spell.c", ["        // Do the substitution.", "        ++gi;", "        ++bi;"], "readability/increment"]
["src/nvim/spell.c", ["        ++gi;", "        ++bi;", "        continue;"], "readability/increment"]
["src/nvim/spell.c", ["    // pop an item from the stack", "    --stackidx;", "    gi = stack[stackidx].goodi;"], "readability/increment"]
["src/nvim/spell.c", ["  // regions or none at all.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["  // Loop over all files loaded for the entries in 'spelllang'.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spell.c", ["    // round 2: keep-case tree", "    for (round = 1; round <= 2; ++round) {", "      if (round == 1) {"], "readability/increment"]
["src/nvim/spell.c", ["          // Done all bytes at this node, go up one level.", "          --depth;", "          line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["          n = arridx[depth] + curi[depth];", "          ++curi[depth];", "          c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["                if (pat == NULL) {", "                  ++lnum;", "                }"], "readability/increment"]
["src/nvim/spell.c", ["                && mb_strnicmp(word, pat, (size_t)depth) != 0) {", "              --depth;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["        // Done all bytes at this node, go up one level.", "        --depth;", "        line_breakcheck();"], "readability/increment"]
["src/nvim/spell.c", ["        n += curi[depth];", "        ++curi[depth];", "        c = byts[n];"], "readability/increment"]
["src/nvim/spell.c", ["          // End of prefix, find out how many IDs there are.", "          for (i = 1; i < len; ++i) {", "            if (byts[n + i] != 0) {"], "readability/increment"]
["src/nvim/spell.c", ["                      (c & WF_RAREPFX) ? (flags | WF_RARE)", "                                       : flags, lnum);", "            if (lnum != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["            if (lnum != 0) {", "              ++lnum;", "            }"], "readability/increment"]
["src/nvim/spell.c", ["                        (c & WF_RAREPFX) ? (flags | WF_RARE)", "                                         : flags, lnum);", "              if (lnum != 0) {"], "whitespace/alignment"]
["src/nvim/spell.c", ["              if (lnum != 0) {", "                ++lnum;", "              }"], "readability/increment"]
["src/nvim/spell_defs.h", ["  idx_T ts_arridx;              // index in tree array, start of node", "  short ts_curi;                // index in list of child nodes", "  char_u ts_fidx;               // index in fword[], case-folded bad word"], "runtime/int"]
["src/nvim/spell_defs.h", ["#define SPELL_TOUPPER(c) ((c) >= 128 ? mb_toupper(c) \\", "                                     : (int)spelltab.st_upper[c])", ""], "whitespace/alignment"]
["src/nvim/spellfile.c", ["  uint16_t wn_flags;            // WF_ flags", "  short wn_region;              // region mask", ""], "runtime/int"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd,; );", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd,; );", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/parens"]
["src/nvim/spellfile.c", ["", "      --depth;", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // End of word, count it.", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        while (byts[n + 1] == 0) {", "          ++n;", "          ++curi[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++n;", "          ++curi[depth];", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        // Normal char, go one level deeper to count the words.", "        ++depth;", "        arridx[depth] = idxs[n];"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Do this for all languages that support sound folding.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i) {", "        buf[i] = getc(fd);                              // <fileID>"], "readability/increment"]
["src/nvim/spellfile.c", ["      ga_init(&ga, 1, 100);", "      for (wordnr = 0; wordnr < wcount; ++wordnr) {", "        ga.ga_len = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd,; );", "  lp->sl_regions[len] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd,; );", "  lp->sl_regions[len] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd,; );", "      buf[n + 1] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd,; );", "      buf[n + 1] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>", "  for (; gap->ga_len < cnt; ++gap->ga_len) {", "    int c;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Fill the first-index table.", "  for (int i = 0; i < 256; ++i) {", "    first[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  for (int i = 0; i < gap->ga_len; ++i) {", "    ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    int i = 0;", "    for (; i < ccnt; ++i) {", "      c = getc(fd);                             // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      smp->sm_oneof = p;", "      for (++i; i < ccnt; ++i) {", "        c = getc(fd);                           // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      SPELL_READ_NONNUL_BYTES(                  // <salfrom>", "                                                (char *)p, (size_t)(ccnt - i), fd,", "                                                xfree(smp->sm_lead));"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                                                (char *)p, (size_t)(ccnt - i), fd,", "                                                xfree(smp->sm_lead));", "      p += (ccnt - i);"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    // Read one word at a time.", "    for (i = 0;; ++i) {", "      c = getc(fd);"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  --todo;", "  c = getc(fd);                                         // <compmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compminlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compsylmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  } else {", "    --todo;", "    c = getc(fd);           // only use the lower byte for now"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);           // only use the lower byte for now", "    --todo;", "    slang->sl_compoptions = c;"], "readability/increment"]
["src/nvim/spellfile.c", ["  sfirst = lp->sl_sal_first;", "  for (int i = 0; i < 256; ++i) {", "    sfirst[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Read the byte values, flag/region bytes and shared indexes.", "  for (i = 1; i <= len; ++i) {", "    c = getc(fd);                                       // <byte>"], "readability/increment"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i) {", "    if (byts[startidx + i] != 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    np->wn_u1.index = FALSE;", "    spell_clear_flags(np->wn_child);"], "readability/bool"]
["src/nvim/spellfile.c", ["  } else {", "    node->wn_u1.index = TRUE;", ""], "readability/bool"]
["src/nvim/spellfile.c", ["", "#endif // SPELL_PRINTTREE", ""], "whitespace/comments"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["      while (*p != NUL && *p <= ' ') {  // skip white space and CR/NL", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["        while (*p >= ' ' || *p == TAB) {  // skip until CR/NL", "          ++p;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        while (*p > ' ') {  // skip until white space or CR/NL", "          ++p;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)", "                || is_aff_rule(items, itemcnt, \"RARE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)", "                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        if (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0) {", "          ++lasti;", "          cur_aff->ah_follows = true;"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (*items[0] == 'P') {", "              sprintf((char *)buf, \"^%s\", items[4]);", "            } else {"], "runtime/printf"]
["src/nvim/spellfile.c", ["            } else {", "              sprintf((char *)buf, \"%s$\", items[4]);", "            }"], "runtime/printf"]
["src/nvim/spellfile.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                              aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spellfile.c", ["              for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;", "                   --idx) {", "                p = ((char_u **)spin->si_prefcond.ga_data)[idx];"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (aff_todo == 0 && !did_postpone_prefix) {", "              --spin->si_newprefID;", "              cur_aff->ah_newID = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["          add_fromto(spin, items[0][3] == 'S'", "              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["                       STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                                                  : items[2]);", "          }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        for (i = 1; i < itemcnt; ++i) {", "          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (affile->af_flagtype == AFT_NUM && *p == ',') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!ascii_isdigit(**pp)) {", "      ++*pp;            // always advance, avoid getting stuck", "      return 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (aff->af_flagtype == AFT_NUM && *p == ',') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    todo = (int)ht->ht_used;", "    for (hi = ht->ht_array; todo > 0; ++hi) {", "      if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (!HASHITEM_EMPTY(hi)) {", "        --todo;", "        ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", "    if (line[0] == '#' || line[0] == '/') {"], "readability/increment"]
["src/nvim/spellfile.c", ["    while (l > 0 && line[l - 1] <= ' ') {", "      --l;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(w)) {", "      ++non_ascii;", "      xfree(pc);"], "readability/increment"]
["src/nvim/spellfile.c", ["      }", "      ++duplicate;", "    } else {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["                // same ID twice.", "                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j) {", "                    if (pfxlist[i] == use_pfxlist[j]) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                // Avoid adding the same ID twice.", "                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;"], "readability/increment"]
["src/nvim/spellfile.c", ["                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j) {", "                    if (pfxlist[i] == use_pfxlist[j]) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    while (l > 0 && rline[l - 1] <= ' ') {", "      --l;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (*line == '/') {", "      ++line;", "      if (STRNCMP(line, \"encoding=\", 9) == 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(line)) {", "      ++non_ascii;", "      continue;"], "readability/increment"]
["src/nvim/spellfile.c", ["    bl->sb_used = 0;", "    ++spin->si_blocks_cnt;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  ++spin->si_foldwcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++spin->si_keepwcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Add each byte of the word to the tree, including the NUL at the end.", "  for (i = 0;; ++i) {", "    // When there is more than one reference to this node we need to make"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (node != NULL && node->wn_refs > 1) {", "      --node->wn_refs;", "      copyprev = prev;"], "readability/increment"]
["src/nvim/spellfile.c", ["        if (np->wn_child != NULL) {", "          ++np->wn_child->wn_refs;              // child gets extra ref", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["  // count nr of words added since last message", "  ++spin->si_msg_count;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    memset(n, 0, sizeof(wordnode_T));", "    --spin->si_free_count;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["      free_wordnode(spin, np);", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++cnt;          // length field", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_first_free = n;", "  ++spin->si_free_count;", "}"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifndef SPELL_PRINTTREE", "    if (spin->si_verbose || p_verbose > 2)", "#endif"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL && !got_int; np = np->wn_sibling) {", "    ++len;", "    if ((child = np->wn_child) != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["            // its siblings is unlinked from the tree.", "            ++tp->wn_refs;", "            compressed += deref_wordnode(spin, child);"], "readability/increment"]
["src/nvim/spellfile.c", ["    fputc(128, fd);                                     // <charflagslen>", "    for (size_t i = 128; i < 256; ++i) {", "      flags = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // round 3: SN_REPSAL section", "  for (unsigned int round = 1; round <= 3; ++round) {", "    garray_T *gap;"], "readability/increment"]
["src/nvim/spellfile.c", ["    assert(gap->ga_len >= 0);", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (round == 2) {", "      ++l;                            // count <salflags>", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)gap->ga_len, 2);    // <repcount> or <salcount>", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      // <rep> : <repfromlen> <repfrom> <reptolen> <repto>"], "readability/increment"]
["src/nvim/spellfile.c", ["      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];", "      for (unsigned int rr = 1; rr <= 2; ++rr) {", "        char_u *p = rr == 1 ? ftp->ft_from : ftp->ft_to;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // round 2: write the bytes", "    for (unsigned int round = 1; round <= 2; ++round) {", "      size_t todo;"], "readability/increment"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          }", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["    assert(spin->si_comppat.ga_len >= 0);", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      l += STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)spin->si_comppat.ga_len, 2);  // <comppatcount>", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      char_u *p = ((char_u **)(spin->si_comppat.ga_data))[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_memtot = 0;", "  for (unsigned int round = 1; round <= 3; ++round) {", "    wordnode_T *tree;"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling) {", "    ++siblingcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["", "      --depth;", "      line_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["", "        ++words_done;", "        ++wordcount[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++words_done;", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["", "  for (linenr_T lnum = 1; lnum <= wcount; ++lnum) {", "    // <sugline>: <sugnr> ... NUL"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Get the region names if there are more than 2 arguments.", "    for (i = 0; i < incount; ++i) {", "      afile[i] = NULL;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Words are stored in the case-folded and keep-case trees.", "    for (i = 0; i < incount && !error; ++i) {", "      spin.si_conv.vc_type = CONV_NONE;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i) {", "      if (afile[i] != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["", "    for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i) {", "      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (undo) {", "              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "              smsg(_(\"Word '%.*s' removed from %s\"),"], "readability/bool"]
["src/nvim/spellfile.c", ["", "      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);"], "readability/bool"]
["src/nvim/spellfile.c", ["", "  for (i = 0; i < 128; ++i) {", "    if (i < cnt) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    // check that it's the same table", "    for (i = 0; i < 256; ++i) {", "      if (spelltab.st_isw[i] != new_st->st_isw[i]"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i) {", "    lp->sl_map_array[i] = 0;"], "readability/increment"]
["src/nvim/strings.c", ["  // and expect the remainder to be zeroed out.", "  return (char_u *)strncpy(xmallocz(len), (char *)string, len);", "}"], "runtime/printf"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave(), but any characters found in esc_chars are preceded"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave_escaped(), but when \"bsl\" is true also escape"], "readability/old_style_comment"]
["src/nvim/strings.c", ["{", "  /*", "   * First count the number of backslashes required."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++length;                           // count an ordinary char", "  }"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Escape \"string\" for use as a shell argument with system()."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* Only csh and similar shells expand '!' within single quotes.  For sh and", "   * the like we must not put a backslash before it, it will be taken"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         // insert backslash", "      if (csh_like && do_special) {"], "readability/increment"]
["src/nvim/strings.c", ["      if (csh_like && do_special) {", "        ++length;                       // insert backslash", "      }"], "readability/increment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         // insert backslash", "      p += l - 1;"], "readability/increment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      *d++ = '\\'';", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strnsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * ASCII lower-to-upper case translation, language independent."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * delete spaces at the end of a string"], "readability/old_style_comment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP))", "/*", " * Compare two strings, ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP))", "/*", " * Compare two strings, for length \"len\", ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Sort an array of strings."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Return true if string \"s\" contains a non-ASCII character (128 or higher)."], "readability/old_style_comment"]
["src/nvim/strings.c", ["  if (s != NULL) {", "    for (p = s; *p != NUL; ++p) {", "      if (*p >= 128) {"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Concatenate two strings and return the result in allocated memory."], "readability/old_style_comment"]
["src/nvim/strings.c", ["        case '0':", "          zero_padding = 1; p++; continue;", "        case '-':"], "whitespace/newline"]
["src/nvim/strings.c", ["        case '-':", "          justify_left = 1; p++; continue;", "        // if both '0' and '-' flags appear, '0' should be ignored"], "whitespace/newline"]
["src/nvim/strings.c", ["        case '\\'':", "          p++; continue;", "        default:"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'i':", "        fmt_spec = 'd'; break;", "      case 'D':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'D':", "        fmt_spec = 'd'; length_modifier = 'l'; break;", "      case 'U':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'U':", "        fmt_spec = 'u'; length_modifier = 'l'; break;", "      case 'O':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'O':", "        fmt_spec = 'o'; length_modifier = 'l'; break;", "      default:"], "whitespace/newline"]
["src/nvim/strings.c", ["            arg = (", "                   tvs", "                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                   tvs", "                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)", "                    : va_arg(ap, long long));  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)", "                    : va_arg(ap, long long));  // NOLINT (runtime/int)", "            break;"], "whitespace/indent"]
["src/nvim/strings.c", ["            arg = (tvs", "                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (unsigned int)(tvs", "                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (uint16_t)(tvs", "                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (uintmax_t)(unsigned long long)(  // NOLINT (runtime/int)", "                                                     tvs", "                    ? ((unsigned long long)  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                                                     tvs", "                    ? ((unsigned long long)  // NOLINT (runtime/int)", "                       tv_nr(tvs, &arg_idx))"], "whitespace/indent"]
["src/nvim/strings.c", ["                       tv_nr(tvs, &arg_idx))", "                    : va_arg(ap, unsigned long long));  // NOLINT (runtime/int)", "            break;"], "whitespace/indent"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));", "            break;"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * syntax.c: code for syntax highlighting"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * For the current state we need to remember more than just the idx."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Struct to reduce the number of arguments to get_syn_options(), it's used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Flags for b_syn_sync_flags:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The attributes of the syntax item that has been recognized."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Methods of combining two clusters"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Syntax group IDs have different types:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Annoying Hack(TM):  \":syn include\" needs this pointer to pass to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Another Annoying Hack(TM):  To prevent rules from other \":syn include\"'d"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * In a hashtable item \"hi_key\" points to \"keyword\" in a keyentry."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * To reduce the time spent in keepend(), remember at which level in the state"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The next possible match in the current line for any pattern is remembered,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * A state stack is an array of integers or stateitem_T, stored in a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The current state (within the line) of the recognition engine."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Start the syntax recognition for a line.  This function is normally called"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * After switching buffers, invalidate current_state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Allocate syntax stack when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the state of the end of the previous line is useful, store it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (!current_state_stored) {", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the current_lnum is now the same as \"lnum\", keep the current"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Try to synchronize from a saved state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If \"lnum\" is before or far beyond a line with a saved state, need to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Advance from the sync point or saved state until the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * We cannot simply discard growarrays full of state_items or buf_states; we"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Cleanup the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try to find a synchronisation point for line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Clear any current state that might be hanging around."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Start at least \"minlines\" back.  Default starting point for parsing is"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * 1. Search backwards for the end of a C-style comment."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Skip lines that end in a backslash."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; start_lnum > 1; --start_lnum) {", "      line = ml_get(start_lnum - 1);"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the line is inside a comment, need to find the syntax item that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /*", "   * 2. Search backwards for given sync patterns."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "      /*", "       * Check if the previous line has the line-continuation pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Start with nothing on the state stack"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      for (current_lnum = lnum; current_lnum < end_lnum; ++current_lnum) {", "        syn_start_line();"], "readability/increment"]
["src/nvim/syntax.c", ["            found_m_endpos = cur_si->si_m_endpos;", "            /*", "             * Continue after the match (be aware of a zero-length"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            } else {", "              ++current_col;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["            if (syn_getcurline()[current_col] != NUL) {", "              ++current_col;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * If a sync point was encountered, break here."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (found_flags) {", "        /*", "         * Put the item that was specified by the sync point on the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * When using \"grouphere\", continue from the sync point"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the line-continuation pattern matches in line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Prepare the current state for the start of a line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        cur_si->si_h_endpos = cur_si->si_m_endpos;", "        cur_si->si_ends = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0) {", "    for (; i > keepend_level; --i) {", "      if (CUR_STATE(i).si_flags & HL_EXTEND) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * EXPLANATION OF THE SYNTAX STATE STACK CACHE"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["}", "/*", " * Free b_sst_array[] for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Allocate the syntax state stack for syn_buf when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           from = from->sst_next) {", "        ++to;", "        *to = *from;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Check for changes in a buffer to affect stored syntax states.  Uses the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to find the \"tick\" for the oldest entry that can"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to make the entries for the oldest tick at an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Free the allocated memory for a syn_state item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  block->b_sst_firstfree = p;", "  ++block->b_sst_freecount;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Find an entry in the list of state stacks at or before \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try saving the current state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the current state contains a start or end pattern that continues"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i >= 0; --i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else if (sp == NULL || sp->sst_lnum != current_lnum) {", "    /*", "     * Add a new entry"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      syn_block->b_sst_firstfree = p->sst_next;", "      --syn_block->b_sst_freecount;", "      if (sp == NULL) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    for (i = 0; i < sp->sst_stacksize; ++i) {", "      bp[i].bs_idx = CUR_STATE(i).si_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Copy a state stack from \"from\" in b_sst_array[] to current_state;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (i = 0; i < from->sst_stacksize; ++i) {", "      CUR_STATE(i).si_idx = bp[i].bs_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["      }", "      CUR_STATE(i).si_ends = FALSE;", "      CUR_STATE(i).si_m_lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * We stop parsing syntax above line \"lnum\".  If the stored state at or below"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * End of handling of the state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check the state stack when:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (sp != NULL && sp->sst_lnum == lnum) {", "      /*", "       * finish the previous line (needed when not all of the line was"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Compare the current state with the previously saved state of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Store the current state in b_sst_array[] for later use."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Skip from the current column to \"col\", get the attributes for \"col\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * No character, no attributes!  Past end of line?"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL && current_col != 0) {", "    /*", "     * If we found a match after the last column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * When in the previous column there was a match but it could not be used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Repeat matching keywords and patterns, to find contained items at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * 1. Check for a current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        || cur_si->si_cont_list != NULL) {", "      /*", "       * 2. Check for keywords, if on a keyword char after a non-keyword"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_endpos.col = endcol;", "              cur_si->si_ends = TRUE;", "              cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "      /*", "       * 3. Check for patterns (only if no keyword found)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_id == 0 && syn_block->b_syn_patterns.ga_len) {", "        /*", "         * If we didn't check for a match yet, or we are past it, check"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (next_match_idx < 0 || next_match_col < (int)current_col) {", "          /*", "           * Check all relevant patterns for a match at this"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /*", "               * Compute the first column of the match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If a previously found match starts at a lower"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If we matched this pattern at this position"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * Grab the external submatches before they get"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * For a \"oneline\" the end must be found in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              }", "              /*", "               * For a \"match\" the size must be > 0 after the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              else if (spp->sp_type == SPTYPE_MATCH) {", "                syn_add_end_off(&hl_endpos, &regmatch, spp,"], "whitespace/newline"]
["src/nvim/syntax.c", ["                    && (int)endpos.col + syncing < startcol) {", "                  /*", "                   * If an empty string is matched, may need"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * keep the best match so far in next_match_*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * If we found a match at the current column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Handle searching for nextgroup match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_next_list != NULL && !keep_next_list) {", "      /*", "       * If a nextgroup was not found, continue looking for one if:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * If a nextgroup was found: Use it, and continue looking for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Use attributes from the current state, if within its highlighting."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (cur_si != NULL) {", "    for (int idx = current_state.ga_len - 1; idx >= 0; --idx) {", "      sip = &CUR_STATE(idx);"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * set \"can_spell\" to TRUE if spell checking is supposed to be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Check for end of current state (and the states before it) at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          && syn_getcurline()[current_col] != NUL) {", "        ++current_col;", "        check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["        check_state_ends();", "        --current_col;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Push the next match onto the stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Push the item in current_state stack;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  {", "    /*", "     * If it's a start-skip-end type that crosses lines, figure out how"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_h_endpos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_flags |= next_match_flags;"], "readability/bool"]
["src/nvim/syntax.c", ["    save_flags = cur_si->si_flags & (HL_CONCEAL | HL_CONCEALENDS);", "    /*", "     * If the start pattern has another highlight group, push another item"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_eos_pos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check for end of current state (and the states before it)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && cur_si->si_m_endpos.col <= current_col))) {", "      /*", "       * If there is an end pattern group ID, highlight the end pattern"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a match or region.  This"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * For transparent items, take attr from outer item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check the current stack for patterns with \"keepend\" flag."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * This check can consume a lot of time; only do it from the level where"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the last index of an \"extend\" item.  \"keepend\" items before that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i) {", "    if (CUR_STATE(i).si_flags & HL_EXTEND) {"], "readability/increment"]
["src/nvim/syntax.c", ["  maxpos_h.col = 0;", "  for (; i < current_state.ga_len; ++i) {", "    sip = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["      limit_pos_zero(&sip->si_eoe_pos, &maxpos);", "      sip->si_ends = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * We need to find the end of the region.  It may continue in the next"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      // a \"oneline\" never continues in the next line", "      sip->si_ends = TRUE;", "      sip->si_m_endpos.lnum = current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["      // continues in the next line", "      sip->si_ends = FALSE;", "      sip->si_m_endpos.lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["    sip->si_eoe_pos = end_endpos;", "    sip->si_ends = TRUE;", "    sip->si_end_idx = end_idx;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add a new state to the current state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove a state from the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);", "    --current_state.ga_len;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for being called with a START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the SKIP or first END pattern after the last START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    ++idx;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   *    Lookup the SKIP pattern (if present)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp_skip = spp;", "    ++idx;", "  } else {"], "readability/increment"]
["src/nvim/syntax.c", ["  for (;;) {", "    /*", "     * Find end pattern that matches first after \"matchcol\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    best_idx = -1;", "    for (idx = start_idx; idx < syn_block->b_syn_patterns.ga_len; ++idx) {", "      int lc_col = matchcol;"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If all end patterns have been tried, and there is no match, the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the skip pattern matches before the end pattern,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Match from start pattern to end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the end group is highlighted differently, adjust the pointers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\", unless pos->lnum is zero."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get current line in syntax buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Call vim_regexec() to find a match with \"rmp\" in \"syn_buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    ++st->count;", "    if (r > 0) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (r > 0) {", "      ++st->match;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["    rmp->endpos[0].lnum += lnum;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax conceal\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax case\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    case SYNFLD_START:", "      msg(\"syntax foldlevel start\");   break;", "    case SYNFLD_MINIMUM:"], "whitespace/newline"]
["src/nvim/syntax.c", ["    case SYNFLD_MINIMUM:", "      msg(\"syntax foldlevel minimum\"); break;", "    default:"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax spell\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear all syntax info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get rid of ownsyntax for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear syncing info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove one pattern from the buffer's pattern list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (spp->sp_flags & HL_FOLD) {", "    --block->b_syn_folditems;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["          sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax pattern.  When clearing all, must be called from"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax cluster."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax clear\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * We have to disable this within \":syn include @group filename\","], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: Clear all syntax items."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * Clear the group IDs that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear one syntax group for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax on\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax reset\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax manual\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax off\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: List all group IDs and all syntax clusters."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * List the group IDs and syntax clusters that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  static struct name_list namelist1[] =", "  {", "    { HL_DISPLAY, \"display\" },"], "whitespace/braces"]
["src/nvim/syntax.c", ["  static struct name_list namelist2[] =", "  {", "    { HL_SKIPWHITE, \"skipwhite\" },"], "whitespace/braces"]
["src/nvim/syntax.c", ["      }", "      --idx;", "      msg_putchar(' ');"], "readability/increment"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i) {", "    if (flags & nlist[i].flag) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax cluster, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    --todo;", "    kp_prev = NULL;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear a whole keyword table."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["  if (cont_in_list != NULL) {", "    curwin->w_s->b_syn_containedin = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check if there are enough arguments.  The first argument may be a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (;;) {", "    /*", "     * This is used very often when a large number of keywords is defined."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Adjustments to syntax item when declared in a \":syn include\"'d file."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax include [@{group-name}] filename\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (arg[0] == '@') {", "    ++arg;", "    rest = get_group_name(arg, &group_name_end);"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Everything that's left, up to the next command, should be the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Save and restore the existing top-level grouplist id and \":syn"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax keyword {group-name} [{option}] keyword ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {           // all arguments are valid", "    /*", "     * Check for trailing command and illegal trailing arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the pattern in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.cont_in_list != NULL) {", "          curwin->w_s->b_syn_containedin = TRUE;", "        }"], "readability/bool"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.flags & HL_FOLD) {", "          ++curwin->w_s->b_syn_folditems;", "        }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Something failed, free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=') {", "      ++key_end;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["    } else {", "      /*", "       * Allocate room for a syn_pattern, and link it in the list of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {", "    /*", "     * Check for trailing garbage or command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the start/skip/end in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int idx = curwin->w_s->b_syn_patterns.ga_len;", "        for (item = ITEM_START; item <= ITEM_END; ++item) {", "          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp->pp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["              if (syn_opt_arg.cont_in_list != NULL) {", "                curwin->w_s->b_syn_containedin = TRUE;", "              }"], "readability/bool"]
["src/nvim/syntax.c", ["            }", "            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;"], "readability/increment"]
["src/nvim/syntax.c", ["            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD) {"], "readability/increment"]
["src/nvim/syntax.c", ["            if (syn_opt_arg.flags & HL_FOLD) {", "              ++curwin->w_s->b_syn_folditems;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item) {", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Handle degenerate cases."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * First, loop through the lists until one of them is empty."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*g1 && *g2) {", "      /*", "       * We always want to add from the first list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      /*", "       * We only want to add from the second list if we're adding the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Now add the leftovers from whichever list didn't get finished"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (round == 1) {", "      /*", "       * If the group ended up empty, we don't need to allocate any"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Finally, put the new list in place."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_scl_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax cluster {cluster-name} [contains={groupname},..]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * On first call for current buffer: Init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get one pattern for a \":syntax match\" or \":syntax region\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       // end delimiter not found"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for a match, highlight or region offset."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  ++end;", "  do {"], "readability/increment"]
["src/nvim/syntax.c", ["        case 'e':", "          idx += SPO_COUNT; break;", "        default:"], "whitespace/newline"]
["src/nvim/syntax.c", ["        default:", "          idx = -1; break;", "        }"], "whitespace/newline"]
["src/nvim/syntax.c", ["        }", "        ++end;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax sync ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u *next_arg;", "  int illegal = FALSE;", "  int finished = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;", "  int finished = FALSE;", "  long n;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg_start)) {", "    syn_cmd_list(eap, TRUE);", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["        emsg(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          // end delimiter not found"], "readability/bool"]
["src/nvim/syntax.c", ["      if (*arg_end != *next_arg) {          // end delimiter not found", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (STRCMP(key, \"MATCH\") == 0) {", "        syn_cmd_match(eap, TRUE);", "      } else if (STRCMP(key, \"REGION\") == 0) {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else if (STRCMP(key, \"REGION\") == 0) {", "        syn_cmd_region(eap, TRUE);", "      } else if (STRCMP(key, \"CLEAR\") == 0) {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else if (STRCMP(key, \"CLEAR\") == 0) {", "        syn_cmd_clear(eap, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else {", "        illegal = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      finished = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["      } else {", "        /*", "         * Handle full group name."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          regmatch.rm_ic = TRUE;", "          id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["        }", "        ++count;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Make a copy of an ID list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           && cur_si > (stateitem_T *)(current_state.ga_data)) {", "      --cur_si;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["                                          HL_CONTAINED)) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (list == NULL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * If list is ID_LIST_ALL, we are in a transparent item that isn't"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the first item is \"ALLBUT\", return TRUE if \"id\" is NOT in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (item - SYNID_ALLBUT != ssp->inc_tag) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_TOP != ssp->inc_tag || contained) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["    item = *++list;", "    retval = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/syntax.c", ["  } else {", "    retval = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Return \"retval\" if id is in the contains list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (scl_list != NULL && depth < 30) {", "        ++depth;", "        r = in_id_list(NULL, scl_list, ssp, contained);"], "readability/increment"]
["src/nvim/syntax.c", ["        r = in_id_list(NULL, scl_list, ssp, contained);", "        --depth;", "        if (r) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntax\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Reset include_link, include_default, include_none to 0."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :match and :echohl command: Add \"None\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :syntax command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list syntax names for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get extra information about the syntax item.  Must be called right after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return conceal substitution character"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the syntax ID at position \"i\" in the current stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function called to get folding level for line \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntime\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  time_entry_T *p;", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    synpat_T *spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["  msg_puts(\"\\n\");", "  for (int idx = 0; idx < ga.ga_len && !got_int; ++idx) {", "    p = ((time_entry_T *)ga.ga_data) + idx;"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Code to handle tags and the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold pointers to various items in a tag line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold info about the tag pattern being used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Tag for preview window is remembered separately, to avoid messing up the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            || type == DT_CSCOPE", "            )) {", "      if (g_do_tagpreview != 0) {"], "whitespace/parens"]
["src/nvim/tag.c", ["      } else {", "        /*", "         * If the last used entry is not at the top, delete all tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (saved_fmark.fnum != curbuf->b_fnum) {", "          /*", "           * Jump to other file. If this fails (e.g. because the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if ((tagstackidx += count - 1) >= tagstacklen) {", "            /*", "             * Beyond the last one, just give an error message and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        case DT_FIRST:", "          cur_match = count - 1; break;", "        case DT_SELECT:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_LAST:", "          cur_match = MAXCOL - 1; break;", "        case DT_NEXT:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_NEXT:", "          cur_match += count; break;", "        case DT_PREV:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_PREV:", "          cur_match -= count; break;", "        }"], "whitespace/newline"]
["src/nvim/tag.c", ["    } else {", "      /*", "       * For \":tag [arg]\" or \":tselect\" remember position before the jump."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Repeat searching for tags, when a file has not been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        flags = TAG_REGEXP;", "        ++name;", "      } else {"], "readability/increment"]
["src/nvim/tag.c", ["          parse_match(matches[j], &tagp);", "          for (i = idx; i < new_num_matches; ++i) {", "            parse_match(new_matches[i], &tagp2);"], "readability/increment"]
["src/nvim/tag.c", ["", "      /*", "       * Only when going to try the next match, report that the previous"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Jump to the desired match."], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (use_tagstack) {", "            --tagstackidx;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["          if (type == DT_PREV) {", "            --cur_match;", "          } else {"], "readability/increment"]
["src/nvim/tag.c", ["            type = DT_NEXT;", "            ++cur_match;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["    if (!new_tag && (", "                     (g_do_tagpreview != 0", "                      && i == ptag_entry.cur_match)"], "whitespace/indent"]
["src/nvim/tag.c", ["                      && i == ptag_entry.cur_match)", "                     || (use_tagstack", "                         && i == tagstack[tagstackidx].cur_match))) {"], "whitespace/indent"]
["src/nvim/tag.c", ["", "/*", " * Free cached tags."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Print the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));", "  for (i = 0; i < tagstacklen; ++i) {", "    if (tagstack[i].tagname != NULL) {"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Compare two strings, for length \"len\", ignoring case the ASCII way."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Extract info from the tag search pattern \"pats->pat\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int noic = (flags & TAG_NOIC);", "  int get_it_again = FALSE;", "  int use_cscope = (flags & TAG_CSCOPE);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Allocate memory for the buffers that are used"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Initialize a few variables"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    // don't want error for invalid RE here", "  prepare_pats(&orgpat, has_re);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * When finding a specified number of matches, first try with matching"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                           && (findall || orgpat.headlen == 0 || !p_tbs));", "  for (round = 1; round <= 2; ++round) {", "    linear = (orgpat.headlen == 0 || !p_tbs || round == 2);"], "readability/increment"]
["src/nvim/tag.c", ["            help_pri = 1;", "            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0) {"], "readability/increment"]
["src/nvim/tag.c", ["              if (STRICMP(help_lang, \"en\") != 0) {", "                ++help_pri;", "              }"], "readability/increment"]
["src/nvim/tag.c", ["", "      /*", "       * Read and parse the lines in the file one by one"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * For binary search: compute the next offset to use."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * When jumping around in the file, first read a line to find the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * Not jumping around in the file: Read the next line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        else {", "          // skip empty and blank lines"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          // skip empty and blank lines"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * When still at the start of the file, check for Emacs tags file"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Read header line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * When there is no tag head, or ignoring case, need to do a"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * Skip this line if the length of the tag is different and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (state == TS_BINARY) {", "            /*", "             * Simplistic check for unsorted tags file."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Compare the current tag with the searched tag."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * A match with a shorter tag means to search forward."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * First try matching with the pattern literally (also when it is"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (orgpat.len != cmplen) {", "          match = FALSE;", "        } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * Has a regexp: Also find tags matching regexp."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        match_re = FALSE;", "        if (!match && orgpat.regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["            if (orgpat.regmatch.rm_ic) {", "              orgpat.regmatch.rm_ic = FALSE;", "              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,"], "readability/bool"]
["src/nvim/tag.c", ["                                        (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;", "            }"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Stop searching if sufficient tags have been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    }", "    orgpat.regmatch.rm_ic = TRUE;       // try another time while ignoring case", "  }"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Move the matches from the ga_match[] arrays into one list of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Callback function for finding all \"tags\" and \"tags-??\" files in"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /*", "     * For help files it's done in a completely different way:"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      }", "      ++tnp->tn_hf_idx;", "      STRCPY(buf, p_hf);"], "readability/increment"]
["src/nvim/tag.c", ["    tnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)", "        ? curbuf->b_p_tags : p_tags);", "    tnp->tn_np = tnp->tn_tags;"], "whitespace/alignment"]
["src/nvim/tag.c", ["", "  /*", "   * Loop until we have found a file name that can be used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      tnp->tn_did_filefind_init = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Copy next file name into buf."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                             r_ptr, 100,", "                                             FALSE,                   // don't free visited list", "                                             FINDFILE_FILE,           // we search for a file"], "readability/bool"]
["src/nvim/tag.c", ["                                             FINDFILE_FILE,           // we search for a file", "                                             tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["      if (tnp->tn_search_ctx != NULL) {", "        tnp->tn_did_filefind_init = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Free the contents of a tagname_T that was filled by get_tagfname()."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (*p != NUL) {", "    ++p;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["  if (*p != NUL) {", "    ++p;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Check if tagname is a static tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (STRNCMP(p, \"file:\", 5) == 0) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Find out the actual file name of a tag.  Concatenate the tags file name"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  {", "    /*", "     * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name, when needed (for environment variables)."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Check if the file with the tag exists before abandoning the current"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/tag.c", ["", "    /*", "     * If we are reusing a window, we may change dir when"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (!curwin->w_p_pvw) {", "      full_fname = (char_u *)FullName_save((char *)fname, FALSE);", "      fname = full_fname;"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Make the preview window the current window."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If 'cpoptions' contains 't', store the search pattern for the \"n\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If the command is a search, try here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (pbuf[0] == '/' || pbuf[0] == '?') {", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["      p_ws = true;              // need 'wrapscan' for backward searches", "      p_ic = FALSE;             // don't ignore case now", "      p_scs = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["      p_ic = FALSE;             // don't ignore case now", "      p_scs = FALSE;", "      save_lnum = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * try again, ignore case now"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          /*", "           * Only give a message when really guessed, not when 'ic'"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (retval == OK) {", "      /*", "       * For a help buffer: Put the cursor line at the top of the window,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name (for environment variables) when needed."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            MAXPATHL - (p - tag_fname));", "    /*", "     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Check if we have a tag for the buffer with name \"buf_ffname\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int c;", "  int retval = FALSE;", "  char_u *fullname;"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Find the end of the tagaddress."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n')) {", "        --end;", "      }"], "readability/increment"]
["src/nvim/tag.c", ["  if (ret == OK && num_matches > 0) {", "    for (i = 0; i < num_matches; ++i) {", "      int parse_result = parse_match(matches[i], &tp);"], "readability/increment"]
["src/nvim/tag.c", ["            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':') {", "              ++p;", "            }"], "readability/increment"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ') {", "                ++p;", "              }"], "readability/increment"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ') {", "                ++p;", "              }"], "readability/increment"]
["src/nvim/terminal.c", ["    case K_LEFTMOUSE:", "      pressed = true; FALLTHROUGH;", "    case K_LEFTRELEASE:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_LEFTRELEASE:", "      button = 1; break;", "    case K_MOUSEMOVE:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_MOUSEMOVE:", "      button = 0; break;", "    case K_MIDDLEDRAG:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_MIDDLEMOUSE:", "      pressed = true; FALLTHROUGH;", "    case K_MIDDLERELEASE:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_MIDDLERELEASE:", "      button = 2; break;", "    case K_RIGHTDRAG:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_RIGHTMOUSE:", "      pressed = true; FALLTHROUGH;", "    case K_RIGHTRELEASE:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_RIGHTRELEASE:", "      button = 3; break;", "    case K_MOUSEDOWN:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_MOUSEDOWN:", "      pressed = true; button = 4; break;", "    case K_MOUSEUP:"], "whitespace/newline"]
["src/nvim/terminal.c", ["    case K_MOUSEUP:", "      pressed = true; button = 5; break;", "    default:"], "whitespace/newline"]
["src/nvim/terminal.c", ["  Terminal *term;", "  void *stub; (void)(stub);", "  // don't process autocommands while updating terminal buffers"], "whitespace/newline"]
["src/nvim/testing.c", ["    case BS:", "      ga_concat(gap, \"\\\\b\"); break;", "    case ESC:"], "whitespace/newline"]
["src/nvim/testing.c", ["    case ESC:", "      ga_concat(gap, \"\\\\e\"); break;", "    case FF:"], "whitespace/newline"]
["src/nvim/testing.c", ["    case FF:", "      ga_concat(gap, \"\\\\f\"); break;", "    case NL:"], "whitespace/newline"]
["src/nvim/testing.c", ["    case NL:", "      ga_concat(gap, \"\\\\n\"); break;", "    case TAB:"], "whitespace/newline"]
["src/nvim/testing.c", ["    case TAB:", "      ga_concat(gap, \"\\\\t\"); break;", "    case CAR:"], "whitespace/newline"]
["src/nvim/testing.c", ["    case CAR:", "      ga_concat(gap, \"\\\\r\"); break;", "    case '\\\\':"], "whitespace/newline"]
["src/nvim/testing.c", ["    case '\\\\':", "      ga_concat(gap, \"\\\\\\\\\"); break;", "    default:"], "whitespace/newline"]
["src/nvim/tui/input.c", ["", "  row--; col--;  // Termkey uses 1-based coordinates", "  buf[len++] = '<';"], "whitespace/newline"]
["src/nvim/tui/tui.c", ["  default:", "    abort(); break;", "  case SHAPE_BLOCK:"], "whitespace/newline"]
["src/nvim/tui/tui.c", ["  case SHAPE_BLOCK:", "    shape = 1; break;", "  case SHAPE_HOR:"], "whitespace/newline"]
["src/nvim/tui/tui.c", ["  case SHAPE_HOR:", "    shape = 3; break;", "  case SHAPE_VER:"], "whitespace/newline"]
["src/nvim/tui/tui.c", ["  case SHAPE_VER:", "    shape = 5; break;", "  }"], "whitespace/newline"]
["src/nvim/undo.c", ["", "/*", " * undo.c: multi level undo facility"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#if defined(U_DEBUG)", "/*", " * Check the undo structures for being valid.  Print a warning when something"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  }", "  ++header_count;", "  if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1) {"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * Save the current line for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the line \"lnum\" (used by \":s\" and \"~\" command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * A new line is inserted before line \"lnum\" (used by :s command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Common code for various ways to save text before a change."], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    /*", "     * If we undid more than we redid, move the entry lists before and"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * free headers to keep the size right"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    /*", "     * When saving a single line, and it has been saved just before, it"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      prev_uep = NULL;", "      for (i = 0; i < 10; ++i) {", "        if (uep == NULL) {"], "readability/increment"]
["src/nvim/undo.c", ["                    : uep->ue_bot))", "                    : uep->ue_lcount != buf->b_ml.ml_line_count)", "            || (uep->ue_size > 1"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "  /*", "   * add lines in front of entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    uep->ue_array = xmalloc(sizeof(char_u *) * (size_t)size);", "    for (i = 0, lnum = top + 1; i < size; ++i) {", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * Decide about the permission to use for the undo file.  If the buffer"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  // Check there is no problem in undo info before writing.", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["#ifdef UNIX", "  /*", "   * Try to set the group of the undo file same as the original file. If"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Write the header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Iteratively serialize UHPs and their UEPs from the top down."], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      ++headers_written;", "#endif"], "readability/increment"]
["src/nvim/undo.c", ["  // a pointer corresponding to the header with that sequence number.", "  short old_idx = -1, new_idx = -1, cur_idx = -1;", "  for (int i = 0; i < num_head; i++) {"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      old_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      new_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      cur_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["  xfree(uhp_table_used);", "  u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /*", "   * If we get an undo command while executing a macro, we behave like the"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Repeat the previous undo or redo."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * May do this twice:"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur", "                      : uhp->uh_seq > curbuf->b_u_seq_cur)", "            && ((dosec && val == closest)"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   : uhp->uh_seq > closest_seq)", "                   : closest == closest_start", "                || (val > target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   : uhp->uh_seq > closest_seq)", "                   : closest == closest_start", "                || (val > target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["      // go to alternate branch if we haven't been there", "      else if (uhp->uh_alt_next.ptr != NULL", "               && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * save marks before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (top < newlnum) {", "      /* If the saved cursor is somewhere in this undo block, move it to", "       * the remembered position.  Makes \"gwap\" put the cursor back"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Use the first line that actually changed.  Avoids that", "         * undoing auto-formatting puts the cursor in the previous"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i) {", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["        newarray[i] = u_save_line(lnum);", "        /* remember we deleted the last line in the buffer, and a", "         * dummy empty line will be inserted */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (newsize) {", "      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*"], "readability/increment"]
["src/nvim/undo.c", ["      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*", "         * If the file is empty, there is an empty line 1 that we"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * insert this entry in front of the new entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * restore marks from before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (i = 0; i < NMARKS; ++i) {", "    if (curhead->uh_namedm[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  /*", "   * If the cursor is only off by one line, put it at the same position as"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      && curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY) {", "    --u_newcount;", "  }"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * \":undolist\": List the leafs of the undo tree"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * 1: walk the tree to find all leafs, put the info in \"ga\"."], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "      ++changes;", "    }"], "readability/increment"]
["src/nvim/undo.c", ["    // go to alternate branch if we haven't been there", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "      --changes;", "    } else {"], "readability/increment"]
["src/nvim/undo.c", ["        uhp = uhp->uh_next.ptr;", "        --changes;", "      }"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * \":undojoin\": continue adding to the last entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Called after writing or reloading the file and setting b_changed to FALSE."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * After reloading a buffer which was saved for 'undoreload': Find the first"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Increase the write count, store it in the last undo header, what would be"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  ++buf->b_u_save_nr_last;", "  buf->b_u_save_nr_cur = buf->b_u_save_nr_last;"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * Get pointer to last added entry."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_getbot(): compute the line number of the previous u_save"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (uep != NULL) {", "    /*", "     * the new ue_bot is computed from the number of lines that has been"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  xfree((char_u *)uhp);", "  --buf->b_u_numhead;", "}"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * free entry 'uep' and 'n' lines in uep->ue_array[]"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * invalidate the undo buffer; called when storage has already been released"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * save the line \"lnum\" for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * clear the line saved for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Implementation of the \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free all allocated memory blocks for the buffer 'buf'."], "readability/old_style_comment"]
["src/nvim/version.c", ["  if (((row >= 2) && (Columns >= 50)) || colon) {", "    for (i = 0; i < (int)ARRAY_SIZE(lines); ++i) {", "      p = lines[i];"], "readability/increment"]
["src/nvim/version.c", ["  screenclear();", "  intro_message(TRUE);", "  wait_return(TRUE);"], "readability/bool"]
["src/nvim/version.c", ["  intro_message(TRUE);", "  wait_return(TRUE);", "}"], "readability/bool"]
["src/nvim/vim.h", ["", "#ifndef TRUE", "# define FALSE  0           // note: this is an int, not a long!"], "readability/bool"]
["src/nvim/vim.h", ["#ifndef TRUE", "# define FALSE  0           // note: this is an int, not a long!", "# define TRUE   1"], "readability/bool"]
["src/nvim/vim.h", ["# define FALSE  0           // note: this is an int, not a long!", "# define TRUE   1", "#endif"], "readability/bool"]
["src/nvim/vim.h", ["", "#define MAYBE   2           // sometimes used for a variant on TRUE", ""], "readability/bool"]
["src/nvim/vim.h", ["#endif", "#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["#define STRCPY(d, s)        strcpy((char *)(d), (char *)(s))", "#define STRNCPY(d, s, n)    strncpy((char *)(d), (char *)(s), (size_t)(n))", "#define STRLCPY(d, s, n)    xstrlcpy((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["", "#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))", "#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/vim.h", ["#define STRCAT(d, s)        strcat((char *)(d), (char *)(s))", "#define STRNCAT(d, s, n)    strncat((char *)(d), (char *)(s), (size_t)(n))", "#define STRLCAT(d, s, n)    xstrlcat((char *)(d), (char *)(s), (size_t)(n))"], "runtime/printf"]
["src/nvim/viml/parser/expressions.c", ["      ret.data.var.autoload = (", "                               memchr(pline.data + 2, AUTOLOAD_CHAR, ret.len - 2)", "                               != NULL);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                               memchr(pline.data + 2, AUTOLOAD_CHAR, ret.len - 2)", "                               != NULL);", "      // Previous CHARREG stopped at autoload character in order to make it"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    ret.data.cmp.type = ((ret.data.cmp.inv ^ haseqsign)", "                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);", "    break;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["  const ExprOpAssociativity bop_node_ass = (", "                                            (bop_node->type == kExprNodeCall", "                                             || bop_node->type == kExprNodeSubscript)"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    const bool is_concat_or_subscript = (", "                                         want_node == kENodeValue", "                                         && kv_size(ast_stack) > 1"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                         want_node == kENodeValue", "                                         && kv_size(ast_stack) > 1", "                                         && (*kv_Z(ast_stack,"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                         && kv_size(ast_stack) > 1", "                                         && (*kv_Z(ast_stack,", "                                                   1))->type == kExprNodeConcatOrSubscript);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    const int lexer_additional_flags = (", "                                        kELFlagPeek", "                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                        kELFlagPeek", "                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)", "                                        | ((want_node == kENodeValue"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)", "                                        | ((want_node == kENodeValue", "                                            && (kv_size(ast_stack) == 1"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["    const bool node_is_key = (", "                              is_concat_or_subscript", "                              && (cur_token.type == kExprLexPlainIdentifier"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              is_concat_or_subscript", "                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);", "    if (is_concat_or_subscript && !node_is_key) {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        cur_node->data.opt.ident = (", "                                    pline.data + cur_token.start.col + cur_token.len);", "        cur_node->data.opt.ident_len = 0;"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["        cur_node->data.opt.scope = (", "                                    cur_token.len == 3", "              ? (ExprOptScope)pline.data[cur_token.start.col + 1]"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                    cur_token.len == 3", "              ? (ExprOptScope)pline.data[cur_token.start.col + 1]", "              : kExprOptScopeUnspecified);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["              ? (ExprOptScope)pline.data[cur_token.start.col + 1]", "              : kExprOptScopeUnspecified);", "      } else {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["      const size_t scope_shift = (", "                                  cur_token.data.opt.scope == kExprOptScopeUnspecified ? 0 : 2);", "      if (scope_shift) {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                   new_top_node->data.fig.opening_hl_idx).group = (", "                                                                   HL(FigureBrace));", "            }"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                   new_top_node->data.fig.opening_hl_idx).group = (", "                                                                   HL(FigureBrace));", "            }"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["      const ExprVarScope scope = (cur_token.type == kExprLexInvalid", "                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);", "      if (want_node == kENodeValue) {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        const uint8_t prefix_length = base_to_prefix_length[", "                                                            cur_token.data.num.base];", "        viml_parser_highlight(pstate, cur_token.start, prefix_length,"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["        ERROR_FROM_TOKEN_AND_MSG(cur_token, (is_double", "                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));", "      }"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      NEW_NODE_WITH_CUR_POS(cur_node, (is_double", "                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));", "      *top_node_p = cur_node;"], "whitespace/alignment"]
["src/nvim/window.c", ["", "/*", " * split the current window, implements CTRL-W s and :split"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * When \"new_wp\" is NULL: split the current window in two."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Check if we are able to split the current window and compute its"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * allocate new window structure and link it in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Reorganise the tree of frames to insert the new window."], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (flags & WSP_BELOW) {", "      before = FALSE;", "    } else if (flags & WSP_ABOVE) {"], "readability/bool"]
["src/nvim/window.c", ["    } else if (flags & WSP_ABOVE) {", "      before = TRUE;", "    } else if (flags & WSP_VERT) {"], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * equalize the window sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"oldp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize window \"newp\" from window \"old\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  newp->w_alist = oldp->w_alist;", "  ++newp->w_alist->al_refcount;", "  newp->w_arg_idx = oldp->w_arg_idx;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Return the number of windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++count;", "  }"], "readability/increment"]
["src/nvim/window.c", ["  // todo is number of windows left to create", "  for (todo = count - 1; todo > 0; --todo) {", "    if (vertical) {"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Exchange current and next window"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * find window to exchange with"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * 1. remove curwin from the list. Remember after which window it was in wp2"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Move the current window to the very top/bottom/left/right of the screen."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Move window \"win1\" to below/right of \"win2\" and make \"win1\" the current"], "readability/old_style_comment"]
["src/nvim/window.c", ["/// Make all windows the same height.", "///'next_curwin' will soon be the current window, make sure it has enough rows.", "///"], "whitespace/comments"]
["src/nvim/window.c", ["", "      /*", "       * Compute width for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin) {", "        --totwincount;                  // don't count curwin", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "      /*", "       * Compute height for \"next_curwin\" window and room available for"], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (has_next_curwin) {", "        --totwincount;                  // don't count curwin", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * Closing the last window in a tab page.  First go to another tab"], "readability/old_style_comment"]
["src/nvim/window.c", ["  char_u prev_idx[NUMBUFLEN];", "  sprintf((char *)prev_idx, \"%i\", tabpage_index(prev_curtab));", ""], "runtime/printf"]
["src/nvim/window.c", ["", "    /*", "     * Be careful: If autocommands delete the window or cause this window"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (wp->w_p_pvw || bt_quickfix(wp->w_buffer)) {", "      /*", "       * If the cursor goes to the preview or the quickfix window, try"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * If last window has a status line now and we don't want one,"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Close window \"win\" in tab page \"tp\", which is not the current tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (first_tabpage->tp_next != NULL) {", "    tabpage_close(TRUE);", "  }"], "readability/bool"]
["src/nvim/window.c", ["", "  /*", "   * If there is only one window there is nothing to remove."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Remove the window from its frame."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the tabpage that will be used if the current one is closed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Find the left-upper window in frame \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Add a status line to windows at the bottom of \"frp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (wp->w_width > 0) {            // don't make it negative", "        --wp->w_width;", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Set frame width from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set frame height from the window it contains."], "readability/old_style_comment"]
["src/nvim/window.c", ["      if (p_wmw == 0 && topfrp->fr_win == curwin && next_curwin == NULL) {", "        ++m;", "      }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window and put an empty buffer in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate the first window or the first window in a new tab page."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a frame for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Initialize the window and frame size to the maximum."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Allocate a new tabpage_T and init the values."], "readability/old_style_comment"]
["src/nvim/window.c", ["  init_var_dict(tp->tp_vars, &tp->tp_winvar, VAR_SCOPE);", "  tp->tp_diff_invalid = TRUE;", "  tp->tp_ch_used = p_ch;"], "readability/bool"]
["src/nvim/window.c", ["  diff_clear(tp);", "  for (idx = 0; idx < SNAP_COUNT; ++idx) {", "    clear_snapshot(tp, idx);"], "readability/increment"]
["src/nvim/window.c", ["             && n < after; tp = tp->tp_next) {", "          ++n;", "        }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Open a new tab page if \":tab cmd\" was used.  It will edit the same buffer,"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create up to \"maxcount\" tabpages with empty windows."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Don't execute autocommands while creating the tab pages.  Must do that"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  for (todo = count - 1; todo > 0; --todo) {", "    if (win_new_tabpage(0, NULL) == FAIL) {"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Find tab page \"n\" (first one is 1).  Returns NULL when not found."], "readability/old_style_comment"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && i != n; tp = tp->tp_next) {", "    ++i;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Get index of tab page \"tp\".  First one has index 1."], "readability/old_style_comment"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp != NULL && tp != ftp; tp = tp->tp_next) {", "    ++i;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Go to tab page \"n\".  For \":tab N\" and \"Ngt\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["    ttp = curtab;", "    for (i = n; i < 0; ++i) {", "      for (tp = first_tabpage; tp->tp_next != ttp && tp->tp_next != NULL;"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Enter window \"wp\" in tab page \"tp\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  for (tp = first_tabpage; tp->tp_next != NULL && n < nr; tp = tp->tp_next) {", "    ++n;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Go to another window."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Find the tabpage for window \"win\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find an upwards or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the bottom or top frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["  while (count--) {", "    /*", "     * First go upwards in the tree of frames until we find a left or"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * Now go downwards to find the leftmost or rightmost frame in it."], "readability/old_style_comment"]
["src/nvim/window.c", ["    prevwin = curwin;           // remember for CTRL-W p", "    curwin->w_redr_status = TRUE;", "  }"], "readability/bool"]
["src/nvim/window.c", ["  block_autocmds();", "  /*", "   * link the window in the window list"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Append window \"wp\" in the window list after window \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Append frame \"frp\" in a frame list after frame \"after\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Insert frame \"frp\" in a frame list before frame \"before\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Remove a frame from a frame list."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Rows changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Called from win_new_shellsize() after Columns changed."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Save the size of all windows in \"gap\"."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Update the position of the windows in frame \"topfrp\", using the width and"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set current window height and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set the window height of window \"win\" and take care of repositioning other"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set the height of a frame to \"height\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Column of frames: try to change only frames in this column."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    /*", "     * Do this twice:"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["                      + frame_minheight(curfrp->fr_parent, NOWIN) - (int)p_wmh - 1);", "      //NOTREACHED", "    }"], "whitespace/comments"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new height"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames after the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0) {"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * Set current window width and take care of repositioning other windows to"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Set the width of a frame to \"width\" and take care that all frames and"], "readability/old_style_comment"]
["src/nvim/window.c", ["  } else {", "    /*", "     * Row of frames: try to change only frames in this row."], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 1; run <= 2; ++run) {", "      room = 0;"], "readability/increment"]
["src/nvim/window.c", ["", "    /*", "     * Compute the number of lines we will take from others frames (can be"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * set the current frame to the new width"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "    /*", "     * First take lines from the frames right of the current frame.  If"], "readability/old_style_comment"]
["src/nvim/window.c", ["     */", "    for (run = 0; run < 2; ++run) {", "      if (run == 0) {"], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * Grow frame fr by \"offset\" lines."], "readability/old_style_comment"]
["src/nvim/window.c", ["  }", "  /*", "   * Now make the other frames smaller."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Separator line of dragwin is dragged \"offset\" lines right (negative is left)."], "readability/old_style_comment"]
["src/nvim/window.c", ["          || wp->w_topline > 1)) {", "    /*", "     * Find a value for w_topline that shows the cursor at the same"], "readability/old_style_comment"]
["src/nvim/window.c", ["    if (sline < 0) {", "      /*", "       * Cursor line would go off top of screen if w_wrow was this high."], "readability/old_style_comment"]
["src/nvim/window.c", ["          line_size = 1;", "          --sline;", "          break;"], "readability/increment"]
["src/nvim/window.c", ["      if (sline < 0) {", "        /*", "         * Line we want at top would go off top of screen.  Use next"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * command_height: called whenever p_ch has been changed"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Resize frame \"frp\" to be \"n\" lines higher (negative for less high)."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Get the file name at the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Return the file name under or after the cursor."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * search forward for what could be the start of a file name"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search backward for first char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "  /*", "   * Search forward for the last char of the file name."], "readability/old_style_comment"]
["src/nvim/window.c", ["      // Skip over the \"\\\" in \"\\ \".", "      ++len;", "    }"], "readability/increment"]
["src/nvim/window.c", ["", "  /*", "   * If there is trailing punctuation, remove it."], "readability/old_style_comment"]
["src/nvim/window.c", ["      && ptr[len - 2] != '.') {", "    --len;", "  }"], "readability/increment"]
["src/nvim/window.c", ["", "/*", " * A snapshot of the window sizes, to restore them after closing the help"], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Create a snapshot of the current frame sizes."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Remove any existing snapshot."], "readability/old_style_comment"]
["src/nvim/window.c", ["", "/*", " * Copy the size of snapshot frame \"sn\" to frame \"fr\".  Do the same for all"], "readability/old_style_comment"]

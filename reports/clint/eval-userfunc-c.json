["src/nvim/eval/userfunc.c", ["", "  /*", "   * Get the arguments."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    }", "    ++argcount;", "    if (*argp != ',') {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (*argp == ')') {", "    ++argp;", "  } else {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++depth;", "  // Save search patterns and redo buffer."], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  }", "  ++fp->uf_calls;", "  // check for CTRL-C hit"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    v->di_tv.vval.v_dict = selfdict;", "    ++selfdict->dv_refcount;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (p_verbose >= 12) {", "      ++no_wait_return;", "      verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["      verbose_leave_scroll();", "      --no_wait_return;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (func_or_func_caller_profiling) {", "    ++fp->uf_tm_count;", "    call_start = profile_start();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  save_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  --RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (p_verbose >= 12 && sourcing_name != NULL) {", "    ++no_wait_return;", "    verbose_enter_scroll();"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    verbose_leave_scroll();", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    }", "    /*", "     * The function call (or \"FuncUndefined\" autocommand sequence) might"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["  if (end == NULL || (lv.ll_tv != NULL && (lead > 2 || lv.ll_range))) {", "    /*", "     * Report an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function\" without argument: list functions."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      todo = (int)func_hashtab.ht_used;", "      for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", "          fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function /pat\": list functions matching pattern."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["        todo = (int)func_hashtab.ht_used;", "        for (hi = func_hashtab.ht_array; todo > 0 && !got_int; ++hi) {", "          if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["          if (!HASHITEM_EMPTY(hi)) {", "            --todo;", "            fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    if (*p == '/') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (name == NULL && (fudi.fd_dict == NULL || !paren) && !eap->skip) {", "    /*", "     * Return on an invalid expression in braces, unless the expression"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    } else {", "      eap->skip = TRUE;", "    }"], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  saved_did_emsg = did_emsg;", "  did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * \":function name(arg1, arg2)\" Define function."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["      while (arg[j] != NUL && (j == 0 ? eval_isnamec1(arg[j])", "                                      : eval_isnamec(arg[j]))) {", "        ++j;"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["                                      : eval_isnamec(arg[j]))) {", "        ++j;", "      }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["        emsg_funcname(N_", "                        (\"E932: Closure function should not be at top level: %s\"),", "                      name == NULL ? (char_u *)\"\" : name);"], "whitespace/alignment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * Read the body of the function, until \":endfunction\" is found."], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["", "  /*", "   * If there are no errors, add the function"], "readability/old_style_comment"]
["src/nvim/eval/userfunc.c", ["    xfree(name);", "    sprintf(numbuf, \"%d\", ++func_nr);", "    name = vim_strsave((char_u *)numbuf);"], "runtime/printf"]
["src/nvim/eval/userfunc.c", ["    if (done++ > 0) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  typval_T rettv;", "  int returning = FALSE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval/userfunc.c", ["  } else {", "    current_funccal->returned = TRUE;", ""], "readability/bool"]
["src/nvim/eval/userfunc.c", ["  if (fcp->dbg_tick != debug_tick) {", "    fcp->breakpoint = dbg_find_breakpoint(FALSE, fp->uf_name,", "                                          sourcing_lnum);"], "readability/bool"]

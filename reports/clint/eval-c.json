["src/nvim/eval.c", ["", "/*", " * eval.c: Expression evaluation."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Old Vim variables such as \"v:version\" are also available without the \"v:\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Array to hold the hashtab with variables local to each sourced script."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "/*", " * Info used by a \":for\" loop."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /* Script-local variables. First clear all the variables and in a second", "   * loop free the scriptvar_T, because a variable in one script might hold"], "readability/old_style_comment"]
["src/nvim/eval.c", ["   * a reference to the whole scope of another script. */", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    vars_clear(&SCRIPT_VARS(i));"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    xfree(SCRIPT_SV(i));"], "readability/increment"]
["src/nvim/eval.c", ["", "  /* check if we can write to the variable: set it to or append an empty", "   * string */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  save_emsg = did_emsg;", "  did_emsg = FALSE;", "  tv.v_type = VAR_STRING;"], "readability/bool"]
["src/nvim/eval.c", ["", "  ++emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", ""], "readability/increment"]
["src/nvim/eval.c", ["  if (p_verbose == 0) {", "    ++emsg_off;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (p_verbose == 0) {", "    --emsg_off;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["", "  ++emsg_off;", "  if (use_sandbox) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (use_sandbox) {", "    ++sandbox;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  ++textlock;", "  *cp = NUL;"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --emsg_off;", "  if (use_sandbox) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (use_sandbox) {", "    --sandbox;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --textlock;", ""], "readability/increment"]
["src/nvim/eval.c", ["    if (eap->skip) {", "      ++emsg_skip;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["  if (*arg != '[') {", "    /*", "     * \":let var = expr\" or \":for var in list\""], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (*arg == ';') {", "      /* Put the rest of the list (may be empty) in the var after ';'.", "       * Create a new list for this. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++*var_count;", ""], "readability/increment"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && !got_int; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["{", "  int error = FALSE;", "  int len;"], "readability/bool"]
["src/nvim/eval.c", ["      if (len <= 0) {", "        /* This is mainly to keep test 49 working: when expanding", "         * curly braces fails overrule the exception error message. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        }", "        error = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/eval.c", ["              case 'g':", "                list_glob_vars(first); break;", "              case 'b':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'b':", "                list_buf_vars(first); break;", "              case 'w':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'w':", "                list_win_vars(first); break;", "              case 't':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 't':", "                list_tab_vars(first); break;", "              case 'v':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'v':", "                list_vim_vars(first); break;", "              case 's':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 's':", "                list_script_vars(first); break;", "              case 'l':"], "whitespace/newline"]
["src/nvim/eval.c", ["              case 'l':", "                list_func_vars(first); break;", "              default:"], "whitespace/newline"]
["src/nvim/eval.c", ["", "  /*", "   * \":let $VAR = expr\": Set environment variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["            case '+':", "              n = numval + n; break;", "            case '-':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '-':", "              n = numval - n; break;", "            case '*':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '*':", "              n = numval * n; break;", "            case '/':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '/':", "              n = num_divide(numval, n); break;", "            case '%':"], "whitespace/newline"]
["src/nvim/eval.c", ["            case '%':", "              n = num_modulus(numval, n); break;", "            }"], "whitespace/newline"]
["src/nvim/eval.c", ["  }", "  /*", "   * \":let var = expr\": Set internal variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  else if (eval_isnamec1(*arg) || *arg == '{') {", "    lval_T lv;"], "whitespace/newline"]
["src/nvim/eval.c", ["  typval_T var2;", "  int empty1 = FALSE;", "  listitem_T *ni;"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Assign the List values to the list items."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if (skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["{", "  int got_eq = FALSE;", "  int c;"], "readability/bool"]
["src/nvim/eval.c", ["      if (c == '&') {", "        ++xp->xp_pattern;", "        xp->xp_context = cmdidx != CMD_let || got_eq"], "readability/increment"]
["src/nvim/eval.c", ["    } else if (c == '=') {", "      got_eq = TRUE;", "      xp->xp_context = EXPAND_EXPRESSION;"], "readability/bool"]
["src/nvim/eval.c", ["        if (xp->xp_pattern[1] == '|') {", "          ++xp->xp_pattern;", "          xp->xp_context = EXPAND_EXPRESSION;"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Local string buffer for the next two functions to store a variable name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    } else {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    while (HASHITEM_EMPTY(hi)) {", "      ++hi;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * The \"evaluate\" argument: When FALSE, the argument is only parsed but not"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  if ((*arg)[0] == '?') {", "    result = FALSE;", "    if (evaluate) {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Check for the \":\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the third variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"||\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = FALSE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = FALSE;", "  while ((*arg)[0] == '|' && (*arg)[1] == '|') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat until there is no following \"&&\"."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  first = TRUE;", "  result = TRUE;"], "readability/bool"]
["src/nvim/eval.c", ["  first = TRUE;", "  result = TRUE;", "  while ((*arg)[0] == '&' && (*arg)[1] == '&') {"], "readability/bool"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * If there is a comparative operator, use it."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["   */", "  if (eval6(arg, rettv, evaluate, FALSE) == FAIL) {", "    return FAIL;"], "readability/bool"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '+', '-' or '.' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["    if (evaluate) {", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Get the first variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Repeat computing, until no '*', '/' or '%' is following."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "      /*", "       * Compute the result."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      if (*p == 'e' || *p == 'E') {", "        ++p;", "        if (*p == '-' || *p == '+') {"], "readability/increment"]
["src/nvim/eval.c", ["        if (*p == '-' || *p == '+') {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["  case '@':", "    ++*arg;", "    if (evaluate) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg != NUL) {", "      ++*arg;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (**arg == ')') {", "      ++*arg;", "    } else if (ret == OK) {"], "readability/increment"]
["src/nvim/eval.c", ["  if (**arg == '.') {", "    /*", "     * dict.name"], "readability/old_style_comment"]
["src/nvim/eval.c", ["  } else {", "    /*", "     * something[idx]"], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "    /*", "     * Get the second variable from inside the [:]."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping backslashed characters."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling backslashed"], "readability/old_style_comment"]
["src/nvim/eval.c", ["      case 'b':", "        *name++ = BS; ++p; break;", "      case 'e':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'e':", "        *name++ = ESC; ++p; break;", "      case 'f':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'f':", "        *name++ = FF; ++p; break;", "      case 'n':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'n':", "        *name++ = NL; ++p; break;", "      case 'r':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 'r':", "        *name++ = CAR; ++p; break;", "      case 't':"], "whitespace/newline"]
["src/nvim/eval.c", ["      case 't':", "        *name++ = TAB; ++p; break;", ""], "whitespace/newline"]
["src/nvim/eval.c", ["          while (--n >= 0 && ascii_isxdigit(p[1])) {", "            ++p;", "            nr = (nr << 4) + hex2nr(*p);"], "readability/increment"]
["src/nvim/eval.c", ["        }", "        ++name;", "        break;"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Find the end of the string, skipping ''."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++reduce;", "      ++p;"], "readability/increment"]
["src/nvim/eval.c", ["      ++reduce;", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * Copy the string into allocated memory, handling '' to ' reduction."], "readability/old_style_comment"]
["src/nvim/eval.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * Garbage collection for lists and dictionaries."], "readability/old_style_comment"]
["src/nvim/eval.c", ["  // script-local variables", "  for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "    ABORTING(set_ref_in_ht)(&SCRIPT_VARS(i), copyID, NULL);"], "readability/increment"]
["src/nvim/eval.c", ["", "  /*", "   * First check if it's not a curly-braces thing: {expr}."], "readability/old_style_comment"]
["src/nvim/eval.c", ["", "  ++*arg;", "  name = *arg;"], "readability/increment"]
["src/nvim/eval.c", ["    save_did_emsg = did_emsg;", "    did_emsg = FALSE;", ""], "readability/bool"]
["src/nvim/eval.c", ["      todo = (int)ht->ht_used;", "      for (hi = ht->ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["        if (!HASHITEM_EMPTY(hi)) {", "          --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["", "/*", " * \"setwinvar()\" and \"settabwinvar()\" functions"], "readability/old_style_comment"]
["src/nvim/eval.c", ["    char *d = res;", "    for (char *s = res; *s; ++s) {", "      if (s[0] == CAR && s[1] == NL) {"], "readability/increment"]
["src/nvim/eval.c", ["      if (s[0] == CAR && s[1] == NL) {", "        ++s;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["", "    /*", "     * Include any <SID> etc in the expanded string:"], "readability/old_style_comment"]
["src/nvim/eval.c", ["        if (*p == '\\\\' && p[1] != NUL) {", "          ++p;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["      if (*p == '[') {", "        ++br_nest;", "      } else if (*p == ']') {"], "readability/increment"]
["src/nvim/eval.c", ["      } else if (*p == ']') {", "        --br_nest;", "      }"], "readability/increment"]
["src/nvim/eval.c", ["        if (selfdict != NULL) {", "          ++selfdict->dv_refcount;", "        }"], "readability/increment"]
["src/nvim/eval.c", ["  {", "    /* Re-allocating ga_data means that an ht_array pointing to", "     * ht_smallarray becomes invalid.  We can recognize this: ht_mask is"], "readability/old_style_comment"]
["src/nvim/eval.c", ["     * at its init value.  Also reset \"v_dict\", it's always the same. */", "    for (int i = 1; i <= ga_scripts.ga_len; ++i) {", "      ht = &SCRIPT_VARS(i);"], "readability/increment"]
["src/nvim/eval.c", ["      init_var_dict(&sv->sv_dict, &sv->sv_var, VAR_SCOPE);", "      ++ga_scripts.ga_len;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["{", "  /* Now the dict needs to be freed if no one else is using it, go back to", "   * normal reference counting. */"], "readability/old_style_comment"]
["src/nvim/eval.c", ["{", "  vars_clear_ext(ht, TRUE);", "}"], "readability/bool"]
["src/nvim/eval.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", ""], "readability/increment"]
["src/nvim/eval.c", ["    if (*string == '[') {", "      ++string;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    if (*string == '{') {", "      ++string;", "    }"], "readability/increment"]
["src/nvim/eval.c", ["    msg_clr_eos();", "    *first = FALSE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  }", "  ++recurse;", ""], "readability/increment"]
["src/nvim/eval.c", ["      to->vval.v_dict = from->vval.v_dict->dv_copydict;", "      ++to->vval.v_dict->dv_refcount;", "    } else {"], "readability/increment"]
["src/nvim/eval.c", ["  }", "  --recurse;", "  return ret;"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    ++emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/eval.c", ["", "  ++p;", "  if (*p == 'g' && p[1] == ':') {"], "readability/increment"]
["src/nvim/eval.c", ["", "  fp->uf_profiling = TRUE;", "}"], "readability/bool"]
["src/nvim/eval.c", ["", "  for (hi = func_hashtab.ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      fp = HI2UF(hi);"], "readability/increment"]
["src/nvim/eval.c", ["", "        for (int i = 0; i < fp->uf_lines.ga_len; ++i) {", "          if (FUNCLINE(fp, i) == NULL) {"], "readability/increment"]
["src/nvim/eval.c", ["          prof_func_line(fd, fp->uf_tml_count[i],", "                         &fp->uf_tml_total[i], &fp->uf_tml_self[i], TRUE);", "          fprintf(fd, \"%s\\n\", FUNCLINE(fp, i));"], "readability/bool"]
["src/nvim/eval.c", ["          prof_total_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"TOTAL\", FALSE);", "    qsort((void *)sorttab, (size_t)st_len, sizeof(ufunc_T *),"], "readability/bool"]
["src/nvim/eval.c", ["          prof_self_cmp);", "    prof_sort_list(fd, sorttab, st_len, \"SELF\", TRUE);", "  }"], "readability/bool"]
["src/nvim/eval.c", ["  fprintf(fd, \"count  total (s)   self (s)  function\\n\");", "  for (i = 0; i < 20 && i < st_len; ++i) {", "    fp = sorttab[i];"], "readability/increment"]
["src/nvim/eval.c", ["  if (fp->uf_profiling && fp->uf_tml_idx >= 0) {", "    fp->uf_tml_execed = TRUE;", "  }"], "readability/bool"]
["src/nvim/eval.c", ["    if (fp->uf_tml_execed) {", "      ++fp->uf_tml_count[fp->uf_tml_idx];", "      fp->uf_tml_start = profile_end(fp->uf_tml_start);"], "readability/increment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' '),", "                   p,"], "whitespace/alignment"]
["src/nvim/eval.c", ["                   ((this_var->di_tv.v_type == VAR_STRING) ? '\"'", "                                                           : ' ')) < 0)", "          || put_eol(fd) == FAIL) {"], "whitespace/alignment"]
["src/nvim/eval.c", ["         && (src[*usedlen + 1] == 'e' || src[*usedlen + 1] == 'r')) {", "    /* find a '.' in the tail:", "     * - for second :e: before the current fname"], "readability/old_style_comment"]
["src/nvim/eval.c", ["          *bufp = s;", "          didit = TRUE;", "          xfree(sub);"], "readability/bool"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = f1 == f2; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = f1 != f2; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = f1 > f2; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = f1 >= f2; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = f1 < f2; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = f1 <= f2; break;", "    case EXPR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = n1 == n2; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = n1 != n2; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = n1 > n2; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = n1 >= n2; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = n1 < n2; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = n1 <= n2; break;", "    case EXPR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_EQUAL:", "      n1 = i == 0; break;", "    case EXPR_ISNOT:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_NEQUAL:", "      n1 = i != 0; break;", "    case EXPR_GREATER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GREATER:", "      n1 = i > 0; break;", "    case EXPR_GEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_GEQUAL:", "      n1 = i >= 0; break;", "    case EXPR_SMALLER:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SMALLER:", "      n1 = i < 0; break;", "    case EXPR_SEQUAL:"], "whitespace/newline"]
["src/nvim/eval.c", ["    case EXPR_SEQUAL:", "      n1 = i <= 0; break;", ""], "whitespace/newline"]

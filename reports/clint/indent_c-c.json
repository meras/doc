["src/nvim/indent_c.c", ["#endif", "/*", " * Find the start of a comment, not knowing if we are in a comment right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Check if the comment start we found is inside a string."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the start of a raw string, not knowing if we are in one right now."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip to the end of a \"string\" and a 'c' character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * We loop, because strings may be concatenated: \"date\"\"time\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Functions for C-indenting."], "readability/old_style_comment"]
["src/nvim/indent_c.c", [" */", "/*", " * Below \"XXX\" means that this function may unlock the current line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return true if the string \"line\" starts with a word from 'cinwords'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip over white space and C comments within the line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* Perl/shell # comment comment continues until eol.  Require a space", "     * before # to avoid recognizing $#array. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if there is no code at *s.  White space and comments are"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check previous lines for a \"//\" line comment, skipping over blank lines."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    quote = *s;", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  while (vim_isIDc(*s)) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["  if (*s && *s == quote) {", "    ++s;", "  }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Only accept a label if the previous line is terminated or is a case"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  while (curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", ""], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If we're in a comment or raw string now, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    curwin->w_cursor = cursor_save;", "    if (cin_isterminated(line, TRUE, FALSE)", "        || cin_isscopedecl(line)"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize structure initialization and enumerations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    for (i = 0; i < (int)ARRAY_SIZE(skip); ++i) {", "      l = (int)strlen(skip[i]);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["  if (cin_starts_with(s, \"case\")) {", "    for (s += 4; *s; ++s) {", "      s = cin_skipcomment(s);"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a \"default\" switch label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return a pointer to the first non-empty non-comment character after a ':'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["{", "  for (; *l; ++l) {", "    if (*l == ':') {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "/*", " * Get indent of line \"lnum\", skipping a label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find indent for line \"lnum\", ignoring any case or jump label."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first variable name after a type in a declaration."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the indent of the first non-blank after an equal sign."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize a preprocessor statement: Any line that starts with '#'."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["    if (cin_ispreproc(line)) {", "      retval = TRUE;", "      *lnump = lnum;"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a C or C++ comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Recognize the start of a \"//\" comment."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  unsigned n_open = 0;", "  int is_else = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "      /* ',' at the end: continue looking in the next line.", "       * At the end: check for ',' in the next line, for this style:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check if this is a \"while\" that should have a matching \"do\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Check whether in \"p\" there is an \"if\", \"for\" or \"while\" before \"*poffset\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if we are at the end of a do-while."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (*s == ';' && cin_nocode(s + 1)) {", "        /* Found \");\" at end of the line, now check there is \"while\"", "         * before the matching '('.  XXX */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            curwin->w_cursor.lnum = trypos->lnum;", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Find the position of a C++ base-class declaration or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "  /* Search for a line starting with '#', empty, ending in ';' or containing", "   * '{' or '}' and start below it.  This handles the following situations:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (s[1] == ':') {", "        /* skip double colon. It can't be a constructor", "         * initialization any more */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * initialization any more */", "        lookfor_ctor_init = FALSE;", "        s = cin_skipcomment(s + 2);"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (lookfor_ctor_init || class_or_struct) {", "        /* we have something found, that looks like the start of", "         * cpp-base-class-declaration or constructor-initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["               || (STRNCMP(s, \"struct\", 6) == 0 && !vim_isIDc(s[6]))) {", "      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;"], "readability/bool"]
["src/nvim/indent_c.c", ["      class_or_struct = TRUE;", "      lookfor_ctor_init = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {", "        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;", "      } else if (s[0] == ')') {"], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (s[0] == ')') {", "        /* Constructor-initialization is assumed if we come across", "         * something like \"):\" */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["         * something like \"):\" */", "        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;"], "readability/bool"]
["src/nvim/indent_c.c", ["        class_or_struct = FALSE;", "        lookfor_ctor_init = TRUE;", "      } else if (s[0] == '?') {"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE if string \"s\" ends with the string \"find\", possibly followed by"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Return TRUE when \"s\" starts with \"word\" and then a non-ID character."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Skip strings, chars and comments until at or past \"trypos\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Find the '{' at the start of the block we are in."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return ind_maxparen corrected for the difference in line number between the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Set w_cursor.col to the column number of the last unmatched ')' or '{' in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  int i;", "  int retval = FALSE;", "  int open_count = 0;"], "readability/bool"]
["src/nvim/indent_c.c", ["        curwin->w_cursor.col = i;", "        retval = TRUE;", "      }"], "readability/bool"]
["src/nvim/indent_c.c", ["", "/*", " * Parse 'cinoptions' and set the values in \"curbuf\"."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * Set the default values."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["   */", "  /* Spaces from a block's opening brace the prevailing indent for that", "   * block should be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace that's at the end of a", "   * line is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent for a line that is not preceded by", "   * an opening brace. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the prevailing indent a leftmost open brace should be", "   * located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the matching open brace (real location for one at the left", "   * edge; imaginary location from one that ends a line) the matching close"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the edge of the line an open brace sitting in the leftmost", "   * column is imagined to be. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces jump labels should be shifted to the left if N is non-negative,", "   * otherwise the jump label will be put to column 1. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the class declaration indent a scope declaration label", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Amount a cpp base class declaration or constructor initialization", "   * should be indented. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* additional spaces beyond the prevailing indent a continuation line", "   * should be located. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Spaces from the indent of the line with an unclosed parentheses, which", "   * itself is also unclosed. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* If the opening paren is the last nonwhite character on the line, and", "   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Suppress ignoring white space when lining up with the character after", "   * an unclosed parentheses. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Boolean: if non-zero, use b_ind_in_comment even if there is something", "   * after the comment opener. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Handle continuation lines containing conditions of if(), for() and", "   * while(). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/indent_c.c", ["", "    /* When adding an entry here, also update the default 'cinoptions' in", "     * doc/indent.txt, and add explanation for it! */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Return the desired indent for C code."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /* Get a copy of the current contents of the line.", "   * This is required, because only the most recent line obtained with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * In insert mode and the cursor is on a ')' truncate the line at the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "  /*", "   * If we are inside a raw string don't change the indent."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a \"//\" comment and there is a \"//\" comment in a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If we're inside a comment and not looking at the start of the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    int start_off = 0;", "    int done = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["      } else if (what == COM_END) {", "        /* If our line starts with the middle comment string, line it", "         * up with the comment opener per the 'comments' option. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            && STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {", "          done = TRUE;", "          if (curwin->w_cursor.lnum > 1) {"], "readability/bool"]
["src/nvim/indent_c.c", ["          if (curwin->w_cursor.lnum > 1) {", "            /* If the start comment string matches in the previous", "             * line, use the indent of that line plus offset.  If"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /* If our line starts with the end comment string, line it up", "         * with the middle comment */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /* If our line starts with an asterisk, line up with the", "     * asterisk in the comment opener; otherwise, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (trypos != NULL && tryposBrace != NULL) {", "      /* Both an unmatched '(' and '{' is found.  Use the one which is", "       * closer to the current cursor position, set the other to NULL. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      our_paren_pos = *trypos;", "      /*", "       * If the matching paren is more than one line away, use the indent of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /*", "       * Line up with line where the matching paren is. XXX"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        if (curbuf->b_ind_if_for_while) {", "          /* Look for the outermost opening parenthesis on this line", "           * and check whether it belongs to an \"if\", \"for\" or \"while\". */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /* Ignore a '(' in front of the line that has a match before", "           * our matching '('. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && ignore_paren_col == 0)) {", "          /*", "           * If we're looking at a close paren, line up right there;"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                && cin_ends_in(l, (char_u *)\"(\", NULL)) {", "              /* look for opening unmatched paren, indent one level", "               * for each additional level */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              n = 1;", "              for (col = 0; col < our_paren_pos.col; ++col) {", "                switch (l[col]) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Find how indented the paren is, or the character after it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["        } else {", "          /* Add b_ind_unclosed2 for each '(' before our matching one,", "           * but ignore (void) before the line (ignore_paren_col). */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          while ((int)our_paren_pos.col > ignore_paren_col) {", "            --our_paren_pos.col;", "            switch (*ml_get_pos(&our_paren_pos)) {"], "readability/increment"]
["src/nvim/indent_c.c", ["", "          /* Use b_ind_unclosed once, when the first '(' is not inside", "           * braces */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * For a line starting with ')' use the minimum of the two"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /*", "       * Now figure out how indented the line is in general."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      if (theline[0] == '}') {", "        /*", "         * they may want closing braces to line up with something"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["      } else {", "        /*", "         * If we're looking at an \"else\", try to find an \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * We get here if we are not on an \"while-of-do\" or \"else\" (or"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        /*", "         * if the '{' is  _really_ at the left margin, use the imaginary"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "        lookfor_break = FALSE;", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "          /*", "           * If we went all the way back to the start of our scope, line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  < ourscope - curbuf->b_ind_maxparen) {", "                /* nothing found (abuse curbuf->b_ind_maxparen as", "                 * limit) assume terminated line (i.e. a variable"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're in a comment or raw string now, skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we are at top level and the line looks like a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["                  || !cin_isfuncdecl(&l, curwin->w_cursor.lnum, 0)) {", "                /* if the line is terminated with another ','", "                 * it is a continued variable initialization."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                /* if it is an enum declaration or an assignment,", "                 * we are done."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* it's a variable declaration, add indentation", "               * like in"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor_cpp_namespace) {", "                /*", "                 * Looking for C++ namespace, need to look further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "                /* If we're in a comment or raw string now, skip", "                 * to the start of it. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * If this is a switch() label, may line up relative to that."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          if (iscase || cin_isscopedecl(l)) {", "            /* we are only looking for cpp base class", "             * declaration/initialization any longer */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /* When looking for a \"do\" we are not interested in", "             * labels. */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Try to get the indent of a statement before the switch"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Looking for a switch() label or C++ scope declaration,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore jump labels with nothing after them."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * Ignore #defines, #if, etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {", "            /* only look, whether there is a cpp base class", "             * declaration or initialization before the opening brace."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "          /*", "           * What happens next depends on the line being terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          terminated = cin_isterminated(l, FALSE, TRUE);", ""], "readability/bool"]
["src/nvim/indent_c.c", ["            if (trypos != NULL) {", "              /*", "               * Check if we are on a case label now.  This is"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Skip over continuation lines to find the one to get the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If this is just above the line we are indenting, and it"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              amount = cur_amount;", "              /*", "               * Only add b_ind_open_extra when the current line"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (curbuf->b_ind_cpp_baseclass && !curbuf->b_ind_js) {", "                /* have to look back, whether it is a cpp base", "                 * class declaration or initialization */"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Check if we are after an \"if\", \"while\", etc."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If this is just above the line we are indenting, we"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Special trick: when expecting the while () after a"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When searching for a terminated line, don't use the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (cin_iselse(l) && whilelevel == 0) {", "                /* If we're looking at \"} else\", let's make sure we", "                 * find the opening brace of the enclosing scope,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * If we're below an unterminated line that is not an"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * Found two unterminated lines on a row, line up with"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["              if (lookfor == LOOKFOR_ENUM_OR_INIT) {", "                /* Found two lines ending in ',', lineup with the", "                 * lowest one, but check for cpp base class"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * Check if we are after a while (cond);"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["          else if (cin_iswhileofdo_end(terminated)) {  // XXX", "            /*", "             * Found an unterminated line after a while ();, line up"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            ++whilelevel;", "          }"], "readability/increment"]
["src/nvim/indent_c.c", ["          }", "          /*", "           * We are after a \"normal\" statement."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["           */", "          else {", "            /*"], "readability/braces"]
["src/nvim/indent_c.c", ["          else {", "            /*", "             * Skip single break line, if before a switch label. It"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Handle \"do {\" line."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above an unterminated line. Add"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "            /*", "             * Found a terminated line above a terminated line or \"if\""], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["            }", "            /*", "             * First line above the one we're indenting is terminated."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "whitespace/newline"]
["src/nvim/indent_c.c", ["             */", "            else {", "              /*"], "readability/braces"]
["src/nvim/indent_c.c", ["            else {", "              /*", "               * position the cursor over the rightmost paren, so"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /* When aligning with the case statement, don't align", "               * with a statement after it."], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * Get indent and pointer to text for current line,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * When a terminated line starts with \"else\" skip to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "              /*", "               * If we're at the end of a block, skip to the start of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  }", "  /*", "   * If the NEXT line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ',', use one level of"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "      /* For a line ending in ',' that is a continuation line go", "       * back to the first line with a backslash:"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the line looks like a function declaration, and we're"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Finding the closing '}' of a previous function.  Put"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Find a line only has a semicolon that belongs to a previous"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the PREVIOUS line is a function declaration, the current"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * If the previous line ends in ';' and the line before the"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * Doesn't look like anything interesting -- so just"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["  if (lookfor == LOOKFOR_IF) {", "    elselevel = 1;", "    whilelevel = 0;"], "readability/braces"]
["src/nvim/indent_c.c", ["  } else {", "    elselevel = 0;", "    whilelevel = 1;"], "readability/braces"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've gone outside the braces entirely,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if the brace enclosing this is further"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * and if they're enclosed in a *deeper* brace,"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was an \"else\" (that's not an \"else if\")"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if it was a \"while\" then we need to go back to"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["    if (cin_iswhileofdo(look, curwin->w_cursor.lnum)) {", "      ++whilelevel;", "      continue;"], "readability/increment"]
["src/nvim/indent_c.c", ["    if (cin_isif(look)) {", "      elselevel--;", "      /*"], "readability/braces"]
["src/nvim/indent_c.c", ["      elselevel--;", "      /*", "       * When looking for an \"if\" ignore \"while\"s that"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "    /*", "     * if we've used up all the elses, then"], "readability/old_style_comment"]
["src/nvim/indent_c.c", ["", "/*", " * Do C or expression indenting on the current line."], "readability/old_style_comment"]

["src/nvim/fileio.c", ["", "/* When converting, a read() or write() may leave some bytes to be converted", " * for the next call.  The value is guessed... */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/* We have to guess how much a sequence of bytes may expand when converting", " * with iconv() to be able to allocate a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "/*", " * Structure to pass arguments from buf_write() to buf_write_bytes()."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0) {", "    msg_scroll = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  // may truncate the message to avoid a hit-return prompt", "  msg_outtrans_attr(msg_may_trunc(FALSE, IObuff), attr);", "  msg_clr_eos();"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the read file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((shortmess(SHM_OVER) || curbuf->b_help) && p_verbose == 0) {", "    msg_scroll = FALSE;         // overwrite previous file message", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    msg_scroll = TRUE;          // don't overwrite previous file message", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file we take the readonly flag from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (check_readonly && !readonlymode) {", "    curbuf->b_p_ro = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef UNIX", "      /*", "       * Use the protection bits of the original file for the swap file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Only set the 'ro' flag for readonly files the first time they are"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if ((check_readonly && file_readonly) || curbuf->b_help) {", "    curbuf->b_p_ro = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (!read_buffer) {", "      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_eol = TRUE;", "      curbuf->b_start_eol = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    curbuf->b_p_bomb = FALSE;", "    curbuf->b_start_bomb = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;         // don't wait for return yet", ""], "readability/increment"]
["src/nvim/fileio.c", ["    if (aborting()) {       // autocmds may abort script processing", "      --no_wait_return;", "      msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["      msg_scroll = msg_save;", "      curbuf->b_p_ro = TRUE;            // must use \"w!\" now", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    /*", "     * Don't allow the autocommands to change the current buffer."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      curbuf->b_p_ro = TRUE;            // must use \"w!\" now", "      return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  msg_scroll = FALSE;                   // overwrite the file message", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Set linecnt now, before the \"retry\" caused by a wrong guess for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Decide which 'encoding' to use or use first."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Jump back here to retry reading the file in different ways."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["      curbuf->b_p_bomb = FALSE;", "      curbuf->b_start_bomb = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * When retrying with another \"fenc\" and the first time \"fileformat\""], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      fileformat = get_fileformat_force(curbuf, eap);", "      try_unix = try_dos = try_mac = FALSE;", "    } else if (curbuf->b_p_bin) {"], "readability/bool"]
["src/nvim/fileio.c", ["  if (advance_fenc) {", "    /*", "     * Try the next entry in 'fileencodings'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Conversion may be required when the encoding of the file is different"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Use the 'charconvert' expression when conversion is required"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  while (!error && !got_int) {", "    /*", "     * We allocate as much space for the file as we can get, plus"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (read_buffer) {", "          /*", "           * Read bytes from curbuf.  Used for converting text read"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["                n = (int)(size - tlen);", "                for (ni = 0; ni < n; ++ni) {", "                  if (p[ni] == NL) {"], "readability/increment"]
["src/nvim/fileio.c", ["        } else {", "          /*", "           * Read bytes from the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          } else if (conv_restlen > 0) {", "            /*", "             * Reached end-of-file but some trailing bytes could"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["            // Remember the first linenr with an illegal byte", "            else if (illegal_byte == 0) {", "              illegal_byte = curbuf->b_ml.ml_line_count"], "whitespace/newline"]
["src/nvim/fileio.c", ["#endif", "                                                    )) {", "                while (conv_restlen > 0) {"], "whitespace/parens"]
["src/nvim/fileio.c", ["                  *(--ptr) = bad_char_behavior;", "                  --conv_restlen;", "                }"], "readability/increment"]
["src/nvim/fileio.c", ["", "      /*", "       * At start of file: Check for BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (set_options) {", "            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["            curbuf->b_p_bomb = TRUE;", "            curbuf->b_start_bomb = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["      conv_restlen = 0;", "      /*", "       * Break here for a read error or end-of-file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (iconv_fd != (iconv_t)-1) {", "        /*", "         * Attempt conversion of the read bytes to 'encoding' using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * If there is conversion error or not enough room try using"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          // Deal with a bad byte and continue with the next.", "          ++fromp;", "          --from_size;"], "readability/increment"]
["src/nvim/fileio.c", ["          ++fromp;", "          --from_size;", "          if (bad_char_behavior == BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = *(fromp - 1);", "            --to_size;", "          } else if (bad_char_behavior != BAD_DROP) {"], "readability/increment"]
["src/nvim/fileio.c", ["            *top++ = bad_char_behavior;", "            --to_size;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["            while (tail > ptr && (*tail & 0xc0) == 0x80) {", "              --tail;", "            }"], "readability/increment"]
["src/nvim/fileio.c", ["                memmove(p, p + 1, todo - 1);", "                --p;", "                --size;"], "readability/increment"]
["src/nvim/fileio.c", ["                --p;", "                --size;", "              } else if (bad_char_behavior != BAD_KEEP) {"], "readability/increment"]
["src/nvim/fileio.c", ["", "      /*", "       * when reading the first part of a file: guess EOL type"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * This loop is executed once for every character read."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (fileformat == EOL_MAC) {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            }", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["          } else {", "            --skip_count;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["    } else {", "      --ptr;", "      while (++ptr, --size >= 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["            }", "            ++lnum;", "            if (--read_count == 0) {"], "readability/increment"]
["src/nvim/fileio.c", ["          } else {", "            --skip_count;", "          }"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we get EOF in the middle of a line, note the fact and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (set_options) {", "      curbuf->b_p_eol = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  --no_wait_return;                     // may wait for return now", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * In recovery mode everything but autocommands is skipped."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * If we were reading from the same terminal as where messages go,"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (newfile) {", "          curbuf->b_p_ro = TRUE;                // must use \"w!\" now", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[fifo]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[socket]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[character special]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, shortmess(SHM_RO) ? _(\"[RO]\") : _(\"[readonly]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        msg_add_eol();", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[CR missing]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[NOT converted]\"));", "        c = TRUE;", "      } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[converted]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (conv_error != 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);"], "runtime/printf"]
["src/nvim/fileio.c", ["                _(\"[CONVERSION ERROR in line %\" PRId64 \"]\"), (int64_t)conv_error);", "        c = TRUE;", "      } else if (illegal_byte > 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else if (illegal_byte > 0) {", "        sprintf((char *)IObuff + STRLEN(IObuff),", "                _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);"], "runtime/printf"]
["src/nvim/fileio.c", ["                _(\"[ILLEGAL BYTE in line %\" PRId64 \"]\"), (int64_t)illegal_byte);", "        c = TRUE;", "      } else if (error) {"], "readability/bool"]
["src/nvim/fileio.c", ["        STRCAT(IObuff, _(\"[READ ERRORS]\"));", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (msg_add_fileformat(fileformat)) {", "        c = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["                    || (illegal_byte > 0 && bad_char_behavior != BAD_KEEP)", "                    )) {", "      curbuf->b_p_ro = TRUE;"], "whitespace/parens"]
["src/nvim/fileio.c", ["                    )) {", "      curbuf->b_p_ro = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * In Ex mode: cursor at last new line."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Get the marks before executing autocommands, so they can be used there."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * We remember if the last line of the read didn't have"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * When opening a new file locate undo info and read it."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * The output from the autocommands should not overwrite anything and"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  lnum = curbuf->b_ml.ml_line_count - linecnt + 1;", "  for (s = p; s < endp; ++s) {", "    if (*s == '\\n') {"], "readability/increment"]
["src/nvim/fileio.c", ["    if (*s == '\\n') {", "      ++lnum;", "    }"], "readability/increment"]
["src/nvim/fileio.c", ["  eap->force_bin = buf->b_p_bin ? FORCE_BIN : FORCE_NOBIN;", "  eap->read_edit = FALSE;", "  eap->forceit = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["  eap->read_edit = FALSE;", "  eap->forceit = FALSE;", "}"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* Always set b_marks_read; needed when 'shada' is changed to include", "   * the ' parameter after opening a buffer. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#if defined(UNIX)", "  int made_writable = FALSE;                // 'w' bit has been set", "#endif"], "readability/bool"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/multiline_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  vim_acl_T acl = NULL;                 /* ACL copied from original file to", "                                           backup or new file */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#endif", "  int write_undo_file = FALSE;", "  context_sha256_T sha_ctx;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (buf->b_ml.ml_mfp == NULL) {", "    /* This can happen during startup when there is a stray \"w\" in the", "     * vimrc file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Disallow writing from .exrc and .vimrc in current directory for"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  write_info.bw_conv_buf = NULL;", "  write_info.bw_conv_error = FALSE;", "  write_info.bw_conv_error_lnum = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* After writing a file changedtick changes but we don't want to display", "   * the line. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If there is no file name yet, use the one for the written file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  } else {", "    overwriting = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  ++no_wait_return;                 // don't wait for return yet", ""], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * Set '[ and '] marks to the lines to be written."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    aco_save_T aco;", "    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_ffname = FALSE;", "    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_sfname = FALSE;", "    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_f = FALSE;", "    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int buf_fname_s = FALSE;", "    int did_cmd = FALSE;", "    int nofile_err = FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    int did_cmd = FALSE;", "    int nofile_err = FALSE;", "    int empty_memline = (buf->b_ml.ml_mfp == NULL);"], "readability/bool"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply PRE autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEAPPENDCMD,", "                                           sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf)) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEAPPENDPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPRE,", "                           NULL, sfname, FALSE, curbuf, eap);", "    } else if (reset_changed && whole) {"], "readability/bool"]
["src/nvim/fileio.c", ["      did_cmd = apply_autocmds_exarg(EVENT_BUFWRITECMD,", "                                     sfname, sfname, FALSE, curbuf, eap);", "      if (did_cmd) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (was_changed && !curbufIsChanged()) {", "          /* Written everything correctly and BufWriteCmd has reset", "           * 'modified': Correct the undo information so that an"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_BUFWRITEPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (!(did_cmd = apply_autocmds_exarg(EVENT_FILEWRITECMD,", "                                           sfname, sfname, FALSE, curbuf, eap))) {", "        if (overwriting && bt_nofile(curbuf)) {"], "readability/bool"]
["src/nvim/fileio.c", ["        if (overwriting && bt_nofile(curbuf)) {", "          nofile_err = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["          apply_autocmds_exarg(EVENT_FILEWRITEPRE,", "                               sfname, sfname, FALSE, curbuf, eap);", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["          || aborting()) {", "        /* An aborting error, interrupt or exception in the", "         * autocommands. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (buf == NULL) {", "          /* The buffer was deleted.  We assume it was written", "           * (can't retry anyway). */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the number of lines in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (end < start) {", "          --no_wait_return;", "          msg_scroll = msg_save;"], "readability/increment"]
["src/nvim/fileio.c", ["", "    /*", "     * The autocommands may have changed the name of the buffer, which may"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (shortmess(SHM_OVER) && !exiting) {", "    msg_scroll = FALSE;             // overwrite previous file message", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["  } else {", "    msg_scroll = TRUE;              // don't overwrite previous file message", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  }", "  msg_scroll = FALSE;               // always overwrite the file message now", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Get information about original file (if there is one)."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      /* It's a device of some kind (or a fifo) which we can write to", "       * but for which we can't make a backup. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       * but for which we can't make a backup. */", "      device = TRUE;", "      newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["      device = TRUE;", "      newfile = TRUE;", "      perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (c == NODE_WRITABLE) {", "    device = TRUE;", "    newfile = TRUE;"], "readability/bool"]
["src/nvim/fileio.c", ["    device = TRUE;", "    newfile = TRUE;", "    perm = -1;"], "readability/bool"]
["src/nvim/fileio.c", ["  if (!device && !newfile) {", "    /*", "     * Check if the file is really writable (when renaming the file to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Check if the timestamp hasn't changed since reading the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["#ifdef HAVE_ACL", "  /*", "   * For systems that support ACL: get the ACL from the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If 'backupskip' is not empty, don't make a backup for some files."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Save the value of got_int and reset it.  We don't want a previous"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  prev_got_int = got_int;", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * If we are not appending or filtering, the file exists, and the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if ((bkc & BKC_YES) || append) {       // \"yes\"", "      backup_copy = TRUE;", "    } else if ((bkc & BKC_AUTO)) {          // \"auto\""], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * Don't rename the file when:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      } else {", "        /*", "         * Check if we can create a file and set the owner/group to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (fd < 0) {           // can't write in directory", "          backup_copy = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/fileio.c", ["              || (long)file_info.stat.st_mode != perm) {", "            backup_copy = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["#endif", "          /* Close the file before removing it, on MS-Windows we", "           * can't delete an open file. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Break symlinks and/or hardlinks if we've been asked to."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          && !os_fileinfo_id_equal(&file_info, &file_info_old)) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["              || os_fileinfo_id_equal(&file_info, &file_info_old))) {", "        backup_copy = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * Try to make the backup in each directory in the 'bdir' option."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name, using an entry in 'bdir'."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (rootname == NULL) {", "          some_error = TRUE;                // out of memory", "          goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["            xfree(rootname);", "            some_error = TRUE;                          // out of memory", "            goto nobackup;"], "readability/bool"]
["src/nvim/fileio.c", ["", "          /*", "           * Check if backup file already exists."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /*", "         * Try to create the backup file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       * Make a backup by renaming the original file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["       */", "      /*", "       * If 'cpoptions' includes the \"W\" flag, we don't want to"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "      /*", "       *"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      while (*dirp) {", "        /*", "         * Isolate one directory name and make the backup file name."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (backup != NULL) {", "          /*", "           * If we are not going to keep the backup file, don't"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      }", "      write_info.bw_first = TRUE;", "    } else"], "readability/bool"]
["src/nvim/fileio.c", ["      write_info.bw_first = TRUE;", "    } else", "#endif"], "readability/braces"]
["src/nvim/fileio.c", ["", "    /*", "     * When the file needs to be converted with 'charconvert' after"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    notconverted = TRUE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)", "                                     : (O_CREAT | O_TRUNC)),", "                           perm < 0 ? 0666 : (perm & 0777))) < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["                            (forceit ? (O_APPEND | O_CREAT) : O_APPEND)", "                                     : (O_CREAT | O_TRUNC)),", "                           perm < 0 ? 0666 : (perm & 0777))) < 0) {"], "whitespace/alignment"]
["src/nvim/fileio.c", ["          SET_ERRMSG(xmalloc(300));", "          vim_snprintf(errmsg, 300,", "                       _(\"E513: write error, conversion failed in line %\" PRIdLINENR"], "runtime/printf"]
["src/nvim/fileio.c", ["  lnum -= start;            // compute number of written lines", "  --no_wait_return;         // may wait for return now", ""], "readability/increment"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\" CONVERSION ERROR\"));", "      c = TRUE;", "      if (write_info.bw_conv_error_lnum != 0) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[NOT converted]\"));", "      c = TRUE;", "    } else if (converted) {"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[converted]\"));", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["      STRCAT(IObuff, _(\"[Device]\"));", "      c = TRUE;", "    } else if (newfile) {"], "readability/bool"]
["src/nvim/fileio.c", ["      msg_add_eol();", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (msg_add_fileformat(fileformat)) {", "      c = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /* When written everything correctly: reset 'modified'.  Unless not", "   * writing to the original file and '+' is not in 'cpoptions'. */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If written to the current file, update the timestamp of the swap file"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * If we kept a backup until now, and we are in patch mode, then we make"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (backup != NULL) {", "      /*", "       * If the original file does not exist yet"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    }", "    /*", "     * If there is no backup file, remember that a (new) file was"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "whitespace/newline"]
["src/nvim/fileio.c", ["     */", "    else {", "      int empty_fd;"], "readability/braces"]
["src/nvim/fileio.c", ["", "  /*", "   * Remove the backup unless 'backup' option is set"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Finish up.  We get here either after failure or success."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["fail:", "  --no_wait_return;             // may wait for return now", "nofail:"], "readability/increment"]
["src/nvim/fileio.c", ["", "  /*", "   * When writing the whole file and 'undofile' is set, also write the undo"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Apply POST autocommands."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEAPPENDPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    } else if (filtering) {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILTERWRITEPOST, NULL, fname,", "                           FALSE, curbuf, eap);", "    } else if (reset_changed && whole) {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_BUFWRITEPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    } else {"], "readability/bool"]
["src/nvim/fileio.c", ["      apply_autocmds_exarg(EVENT_FILEWRITEPOST, fname, fname,", "                           FALSE, curbuf, eap);", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["    if (aborting()) {       // autocmds may abort script processing", "      retval = FALSE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Skip conversion when writing the BOM."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    if (flags & FIO_UTF8) {", "      /*", "       * Convert latin1 in the buffer to UTF-8 in the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["    } else if (flags & (FIO_UCS4 | FIO_UTF16 | FIO_UCS2 | FIO_LATIN1)) {", "      /*", "       * Convert UTF-8 bytes in the buffer to UCS-2, UCS-4, UTF-16 or"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "          /* Use remainder of previous call.  Append the start of", "           * buf[] to get a full sequence.  Might still be too"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (n > ip->bw_restlen + len) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          if (n > len - wlen) {", "            /* We have an incomplete byte sequence at the end to", "             * be written.  We can't convert it without the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        if (ucs2bytes(c, &p, flags) && !ip->bw_conv_error) {", "          ip->bw_conv_error = TRUE;", "          ip->bw_conv_error_lnum = ip->bw_start_lnum;"], "readability/bool"]
["src/nvim/fileio.c", ["        if (c == NL) {", "          ++ip->bw_start_lnum;", "        }"], "readability/increment"]
["src/nvim/fileio.c", ["", "        /* Need to concatenate the remainder of the previous call and", "         * the bytes of the current call.  Use the end of the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "        /* There is a bug in iconv() on Linux (which appears to be", "         * wide-spread) which sets \"to\" to NULL and messes up \"tolen\"."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["        }", "        ip->bw_first = FALSE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["", "      /*", "       * If iconv() has an error or there is not enough room, fail."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["          || fromlen > CONV_RESTLEN) {", "        ip->bw_conv_error = TRUE;", "        return FAIL;"], "readability/bool"]
["src/nvim/fileio.c", ["      if (flags & FIO_UTF16) {", "        /* Make two words, ten bits of the character in each.  First", "         * word is 0xd800 - 0xdbff, second one 0xdc00 - 0xdfff */"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (*fenc == NUL || STRCMP(p_enc, fenc) == 0) {", "    same_encoding = TRUE;", "    fenc_flags = 0;"], "readability/bool"]
["src/nvim/fileio.c", ["    fnamelen = strlen(retval);", "    prepend_dot = FALSE;  // nothing to prepend a dot to", "  } else {"], "readability/bool"]
["src/nvim/fileio.c", ["    retval = xmalloc(fnamelen + extlen + 3);", "    strcpy(retval, fname);", "  }"], "runtime/printf"]
["src/nvim/fileio.c", ["  // ext can start with '.' and cannot exceed 3 more characters.", "  strcpy(s, ext);", ""], "runtime/printf"]
["src/nvim/fileio.c", ["", "  /*", "   * When the names are identical, there is nothing to do.  When they refer"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "    /*", "     * Find a name that doesn't exist and is in the same directory."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Delete the \"to\" file, this is required on some systems to make the"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * First try a normal rename, return if it works."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "  /*", "   * Rename() failed, try copying the file."], "readability/old_style_comment"]
["src/nvim/fileio.c", ["", "static int already_warned = FALSE;", ""], "readability/bool"]
["src/nvim/fileio.c", ["  if (no_check_timestamps > 0) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["  if (focus && did_check_timestamps) {", "    need_check_timestamps = TRUE;", "    return FALSE;"], "readability/bool"]
["src/nvim/fileio.c", ["    need_check_timestamps = TRUE;", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["    }", "    --no_wait_return;", "    need_check_timestamps = FALSE;"], "readability/increment"]
["src/nvim/fileio.c", ["    --no_wait_return;", "    need_check_timestamps = FALSE;", "    if (need_wait_return && didit == 2) {"], "readability/bool"]
["src/nvim/fileio.c", ["            mesg = _(", "                    \"W12: Warning: File \\\"%s\\\" has changed and the buffer was changed in Vim as well\");", "            mesg2 = _(\"See \\\":help W12\\\" for more info.\");"], "whitespace/indent"]
["src/nvim/fileio.c", ["      }", "      already_warned = TRUE;", "    }"], "readability/bool"]
["src/nvim/fileio.c", ["", "  /*", "   * Try for a match with the pattern with:"], "readability/old_style_comment"]
["src/nvim/fileio.c", ["  if (allow_dirs != NULL) {", "    *allow_dirs = FALSE;", "  }"], "readability/bool"]
["src/nvim/fileio.c", ["      while (p[1] == '*') {  // \"**\" matches like \"*\"", "        ++p;", "      }"], "readability/increment"]
["src/nvim/fileio.c", ["          if (allow_dirs != NULL) {", "            *allow_dirs = TRUE;", "          }"], "readability/bool"]
["src/nvim/fileio.c", ["            ) {", "          *allow_dirs = TRUE;", "        }"], "readability/bool"]
["src/nvim/fileio.c", ["      if (allow_dirs != NULL) {", "        *allow_dirs = TRUE;", "      }"], "readability/bool"]
["src/nvim/fileio.c", ["      reg_pat[i++] = ')';", "      --nested;", "      break;"], "readability/increment"]

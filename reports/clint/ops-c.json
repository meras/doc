["src/nvim/ops.c", ["", "/*", " * ops.c: implementation of various operators: op_shift, op_delete, op_tilde,"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * structure used by block_prep, op_delete and op_yank for blockwise operators"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * The names of operators."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if operator \"op\" always works on whole lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get first operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get second operator command character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_shift - handle a shift operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["  } else {", "    --curwin->w_cursor.lnum;            // put cursor on last line, for \":>\"", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Shift one line of the current block one shiftwidth right or left."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (!left) {", "    /*", "     *  1. Get start vcol"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Firstly, let's find the first non-whitespace character that is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      // TODO: is passing verbatim_copy_end for start of the line OK?", "      incr = lbr_chartabsize(line, verbatim_copy_end, verbatim_copy_width);"], "readability/todo"]
["src/nvim/ops.c", ["", "/*", " * Insert string \"s\" (b_insert ? before : after) block :AKelly"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_reindent - handle reindenting a block of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Mark changed lines so that they will be redrawn.  When Visual", "   * highlighting was present, need to continue until the last line.  When"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Keep the last expression line here, for repeating."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\""], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Set the expression for the '=' register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the result of the '=' register expression."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* Make a copy of the expression, because evaluating it may cause it to be", "   * changed. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /* When we are invoked recursively limit the evaluation to 10 levels.", "   * Then return the string as-is. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Get the '=' register expression itself, without evaluating it."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Start or stop recording into a yank register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Stuff string \"p\" into yank register \"regname\" as a single line (append if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert lines into typeahead buffer, from last one to first one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * It is possible to get into an endless loop by having CTRL-R a in"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /* Check for CTRL-C, in case someone tries to paste a few thousand", "     * lines and gets bored. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Handle a delete operation."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Imitate the strange Vi behaviour: If the delete spans more than one"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Check for trying to delete (e.g. \"D\") in an empty line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Do a yank of whatever we're about to delete."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode delete"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Adjust end of operating area for ending on a multi-byte character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Put character 'c' at position 'lp'"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Replace a whole area with one character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * block mode replace"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        if ((numc & 1) && !bd.is_short) {", "          ++bd.endspaces;", "          ++n;"], "readability/increment"]
["src/nvim/ops.c", ["          ++bd.endspaces;", "          ++n;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["      if (oap->end.col) {", "        --oap->end.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Handle the (non-standard vi) tilde operator.  Also for \"gu\", \"gU\" and \"g?\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  struct block_def bd;", "  int did_change = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["      if (oap->end.col) {", "        --oap->end.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Invoke swapchar() on \"length\" bytes at position \"pos\"."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_insert - Insert and append operators for Visual mode."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      coladvance_force(oap->op_type == OP_APPEND", "          ? oap->end_vcol + 1 : getviscol());", "      if (oap->op_type == OP_APPEND) {"], "whitespace/alignment"]
["src/nvim/ops.c", ["      if (oap->op_type == OP_APPEND) {", "        --curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["      // Move the cursor to the character right of the block.", "      curwin->w_set_curswant = TRUE;", "      while (*get_cursor_pos_ptr() != NUL"], "readability/bool"]
["src/nvim/ops.c", ["             && (curwin->w_cursor.col < bd.textcol + bd.textlen)) {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["        if (bd2.endspaces) {", "          --bd2.textlen;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "    /*", "     * Subsequent calls to ml_get() flush the firstline data - take a"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * op_change - handle a change operation"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (u_save_cursor() == FAIL) {", "      return FALSE;", "    }"], "readability/bool"]
["src/nvim/ops.c", ["  } else if (op_delete(oap) == FAIL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "  retval = edit(NUL, FALSE, (linenr_T)1);", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * In Visual block mode, handle copying the new text to all lines of the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * set all the yank registers to empty (called from main())"], "readability/old_style_comment"]
["src/nvim/ops.c", ["          if (ce != cs && oap->start.coladd > 0) {", "            /* Part of a tab selected -- but don't", "             * double-count it. */"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Using inserted text works differently, because the register includes"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * For special registers '%' (file name), '#' (alternate file name) and"], "readability/old_style_comment"]
["src/nvim/ops.c", ["    if (regname == '=') {", "      /* For the = register we need to split the string at NL", "       * characters."], "readability/old_style_comment"]
["src/nvim/ops.c", ["            }", "            ++ptr;", "            // A trailing '\\n' makes the register linewise."], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Block mode"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        bd.startspaces = incr - bd.endspaces;", "        --bd.textcol;", "        delcount = 1;"], "readability/increment"]
["src/nvim/ops.c", ["        if (oldp[bd.textcol] != TAB) {", "          /* Only a Tab can be split into spaces.  Other", "           * characters will have to be moved to after the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      ++curwin->w_cursor.lnum;", "      if (i == 0) {"], "readability/increment"]
["src/nvim/ops.c", ["    }", "    /*", "     * Line mode: BACKWARD is the same as FORWARD on the previous line"], "readability/old_style_comment"]
["src/nvim/ops.c", ["     */", "    else if (dir == BACKWARD) {", "      --lnum;"], "whitespace/newline"]
["src/nvim/ops.c", ["    else if (dir == BACKWARD) {", "      --lnum;", "    }"], "readability/increment"]
["src/nvim/ops.c", ["          lnum++;", "          ++nr_lines;", "          if (flags & PUT_FIXINDENT) {"], "readability/increment"]
["src/nvim/ops.c", ["        if (dir == FORWARD) {", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/ops.c", ["  msgmore(nr_lines);", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "  VIsual_active = FALSE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * When the cursor is on the NUL past the end of the line and it should not be"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if lines starting with '#' should be left aligned."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * \":dis\" and \":registers\": Display the contents of the yank registers."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    case kMTLineWise:", "      type = 'l'; break;", "    case kMTCharWise:"], "whitespace/newline"]
["src/nvim/ops.c", ["    case kMTCharWise:", "      type = 'c'; break;", "    default:"], "whitespace/newline"]
["src/nvim/ops.c", ["    default:", "      type = 'b'; break;", "    }"], "whitespace/newline"]
["src/nvim/ops.c", ["    }", "    ++comment_flags;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["  int *comments = NULL;", "  int remove_comments = (use_formatoptions == TRUE)", "                        && has_format_option(FO_REMOVE_COMS);"], "readability/bool"]
["src/nvim/ops.c", ["        } else {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["        if (p_js && (endcurr1 == '.' || endcurr1 == '?' || endcurr1 == '!')) {", "          ++spaces[t];", "        }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Move affected lines to the new long one."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Delete following lines. To do this we move the cursor there"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set the cursor column:"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  curwin->w_cursor.coladd = 0;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if the two comment leaders given are the same.  \"lnum\" is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * If first leader has 'f' flag, the lines can be joined only if the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (leader1_flags != NULL) {", "    for (p = leader1_flags; *p && *p != ':'; ++p) {", "      if (*p == COM_FIRST) {"], "readability/increment"]
["src/nvim/ops.c", ["      if (*p == COM_END) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["        if (*(ml_get(lnum) + leader1_len) == NUL) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["        if (leader2_flags == NULL || leader2_len == 0) {", "          return FALSE;", "        }"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        for (p = leader2_flags; *p && *p != ':'; ++p) {", "          if (*p == COM_MIDDLE) {"], "readability/increment"]
["src/nvim/ops.c", ["          if (*p == COM_MIDDLE) {", "            return TRUE;", "          }"], "readability/bool"]
["src/nvim/ops.c", ["        }", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/ops.c", ["", "  /*", "   * Get current line and next line, compare the leaders."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  line2 = ml_get(lnum + 1);", "  for (idx2 = 0; idx2 < leader2_len; ++idx2) {", "    if (!ascii_iswhite(line2[idx2])) {"], "readability/increment"]
["src/nvim/ops.c", ["      while (ascii_iswhite(line1[idx1])) {", "        ++idx1;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "  /*", "   * Leave the cursor at the first non-blank of the last formatted line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (oap->end_adjusted && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " * Implementation of the format operator 'gq' for when using 'formatexpr'."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Set v:lnum to the first line number and v:count to the number of lines."], "readability/old_style_comment"]
["src/nvim/ops.c", ["                                  &next_leader_len, &next_leader_flags, do_comments", "                                  );", "  is_end_par = (is_not_par || next_is_not_par);"], "whitespace/parens"]
["src/nvim/ops.c", ["  curwin->w_cursor.lnum--;", "  for (count = line_count; count != 0 && !got_int; --count) {", "    /*"], "readability/increment"]
["src/nvim/ops.c", ["  for (count = line_count; count != 0 && !got_int; --count) {", "    /*", "     * Advance to next paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * The last line to be formatted."], "readability/old_style_comment"]
["src/nvim/ops.c", ["                                      &next_leader_len, &next_leader_flags, do_comments", "                                      );", "      if (do_number_indent) {"], "whitespace/parens"]
["src/nvim/ops.c", ["", "    /*", "     * Skip lines that are not in a paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    } else {", "      /*", "       * For the first line of a paragraph, check indent of second line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * When the comment leader changes, it's the end of the paragraph."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "      /*", "       * If we have got to the end of a paragraph, or the line is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        smd_save = p_smd;", "        p_smd = FALSE;", "        insertchar(NUL, INSCHAR_FORMAT"], "readability/bool"]
["src/nvim/ops.c", ["                   + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)", "                   + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);"], "whitespace/alignment"]
["src/nvim/ops.c", ["                   + (do_comments && do_comments_list", "               ? INSCHAR_COM_LIST : 0)", "                   + (avoid_fex ? INSCHAR_NO_FEX : 0), second_indent);"], "whitespace/alignment"]
["src/nvim/ops.c", ["", "      /*", "       * When still in same paragraph, join the lines together.  But"], "readability/old_style_comment"]
["src/nvim/ops.c", ["        curwin->w_cursor.lnum--;", "        if (do_join(2, TRUE, FALSE, FALSE, false) == FAIL) {", "          beep_flush();"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE if line \"lnum\" ends in a white character."], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*s == NUL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Blank lines, and lines containing only the comment leader, are left"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (*leader_len > 0) {", "    /*", "     * Search for 'e' flag in comment leader flags."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    while (*flags && *flags != ':' && *flags != COM_END) {", "      ++flags;", "    }"], "readability/increment"]
["src/nvim/ops.c", ["         || (*leader_len > 0 && *flags == COM_END)", "         || startPS(lnum, NUL, FALSE);", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * Return TRUE when a paragraph starts in line \"lnum\".  Return FALSE when the"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (lnum <= 1) {", "    return TRUE;                // start of the file", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (*p == NUL) {", "    return TRUE;                // after empty line", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_WHITE_PAR) && !ends_in_white(lnum - 1)) {", "    return TRUE;                // missing trailing space in previous line.", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  if (has_format_option(FO_Q_NUMBER) && (get_number_indent(lnum) > 0)) {", "    return TRUE;                // numbered item starts in \"lnum\".", "  }"], "readability/bool"]
["src/nvim/ops.c", ["                   next_leader_len, next_leader_flags)) {", "    return TRUE;                // change of comment leader.", "  }"], "readability/bool"]
["src/nvim/ops.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ops.c", ["", "/*", " * prepare a few things for block mode yank/delete/tilde"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "/*", " * Return the type of a register."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Compute length of resulting string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["    len += STRLEN(reg->y_array[i]);", "    /*", "     * Insert a newline between lines and after last line if"], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "  /*", "   * Copy the lines of the yank register into the string."], "readability/old_style_comment"]
["src/nvim/ops.c", ["", "    /*", "     * Insert a NL between lines and after the last line if y_type is"], "readability/old_style_comment"]
["src/nvim/ops.c", ["  if (name == '/') {", "    set_last_search_pat(str, RE_SEARCH, TRUE, TRUE);", "    return;"], "readability/bool"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **)str; *ss != NULL; ++ss) {", "      newlines++;"], "readability/increment"]
["src/nvim/ops.c", ["      extraline = 1;", "      ++newlines;         // count extra newline at the end", "    }"], "readability/increment"]
["src/nvim/ops.c", ["      append = true;", "      --newlines;         // uncount newline when appending first line", "    }"], "readability/increment"]
["src/nvim/ops.c", ["  if (str_list) {", "    for (char_u **ss = (char_u **)str; *ss != NULL; ++ss, ++lnum) {", "      size_t ss_len = STRLEN(*ss);"], "readability/increment"]
["src/nvim/ops.c", ["", "/*", " *  Count the number of bytes, characters and \"words\" in a line."], "readability/old_style_comment"]
["src/nvim/ops.c", ["      if (*p_sel == 'e' && max_pos.col > 0) {", "        --max_pos.col;", "      }"], "readability/increment"]
["src/nvim/ops.c", ["", "    for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count; ++lnum) {", "      // Check for a CTRL-C every 100000 characters."], "readability/increment"]

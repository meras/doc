["src/nvim/spellfile.c", ["  uint16_t wn_flags;            // WF_ flags", "  short wn_region;              // region mask", ""], "runtime/int"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd,; );", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  char buf[VIMSPELLMAGICL];", "  SPELL_READ_BYTES(buf, VIMSPELLMAGICL, fd,; );", "  if (memcmp(buf, VIMSPELLMAGIC, VIMSPELLMAGICL) != 0) {"], "whitespace/parens"]
["src/nvim/spellfile.c", ["", "      --depth;", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        // End of word, count it.", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["        while (byts[n + 1] == 0) {", "          ++n;", "          ++curi[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["          ++n;", "          ++curi[depth];", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        // Normal char, go one level deeper to count the words.", "        ++depth;", "        arridx[depth] = idxs[n];"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Do this for all languages that support sound folding.", "  for (int lpi = 0; lpi < curwin->w_s->b_langp.ga_len; ++lpi) {", "    lp = LANGP_ENTRY(curwin->w_s->b_langp, lpi);"], "readability/increment"]
["src/nvim/spellfile.c", ["      // <SUGHEADER>: <fileID> <versionnr> <timestamp>", "      for (i = 0; i < VIMSUGMAGICL; ++i) {", "        buf[i] = getc(fd);                              // <fileID>"], "readability/increment"]
["src/nvim/spellfile.c", ["      ga_init(&ga, 1, 100);", "      for (wordnr = 0; wordnr < wcount; ++wordnr) {", "        ga.ga_len = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd,; );", "  lp->sl_regions[len] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["  }", "  SPELL_READ_NONNUL_BYTES((char *)lp->sl_regions, (size_t)len, fd,; );", "  lp->sl_regions[len] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd,; );", "      buf[n + 1] = NUL;"], "whitespace/newline"]
["src/nvim/spellfile.c", ["      buf[0] = '^';  // always match at one position only", "      SPELL_READ_NONNUL_BYTES(buf + 1, (size_t)n, fd,; );", "      buf[n + 1] = NUL;"], "whitespace/parens"]
["src/nvim/spellfile.c", ["  // <rep> : <repfromlen> <repfrom> <reptolen> <repto>", "  for (; gap->ga_len < cnt; ++gap->ga_len) {", "    int c;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Fill the first-index table.", "  for (int i = 0; i < 256; ++i) {", "    first[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  for (int i = 0; i < gap->ga_len; ++i) {", "    ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    int i = 0;", "    for (; i < ccnt; ++i) {", "      c = getc(fd);                             // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      smp->sm_oneof = p;", "      for (++i; i < ccnt; ++i) {", "        c = getc(fd);                           // <salfrom>"], "readability/increment"]
["src/nvim/spellfile.c", ["      SPELL_READ_NONNUL_BYTES(                  // <salfrom>", "                                                (char *)p, (size_t)(ccnt - i), fd,", "                                                xfree(smp->sm_lead));"], "whitespace/indent"]
["src/nvim/spellfile.c", ["                                                (char *)p, (size_t)(ccnt - i), fd,", "                                                xfree(smp->sm_lead));", "      p += (ccnt - i);"], "whitespace/indent"]
["src/nvim/spellfile.c", ["    // Read one word at a time.", "    for (i = 0;; ++i) {", "      c = getc(fd);"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  --todo;", "  c = getc(fd);                                         // <compmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compminlen>"], "readability/increment"]
["src/nvim/spellfile.c", ["", "  --todo;", "  c = getc(fd);                                         // <compsylmax>"], "readability/increment"]
["src/nvim/spellfile.c", ["  } else {", "    --todo;", "    c = getc(fd);           // only use the lower byte for now"], "readability/increment"]
["src/nvim/spellfile.c", ["    c = getc(fd);           // only use the lower byte for now", "    --todo;", "    slang->sl_compoptions = c;"], "readability/increment"]
["src/nvim/spellfile.c", ["  sfirst = lp->sl_sal_first;", "  for (int i = 0; i < 256; ++i) {", "    sfirst[i] = -1;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Read the byte values, flag/region bytes and shared indexes.", "  for (i = 1; i <= len; ++i) {", "    c = getc(fd);                                       // <byte>"], "readability/increment"]
["src/nvim/spellfile.c", ["  // remove SHARED_MASK)", "  for (i = 1; i <= len; ++i) {", "    if (byts[startidx + i] != 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL; np = np->wn_sibling) {", "    np->wn_u1.index = FALSE;", "    spell_clear_flags(np->wn_child);"], "readability/bool"]
["src/nvim/spellfile.c", ["  } else {", "    node->wn_u1.index = TRUE;", ""], "readability/bool"]
["src/nvim/spellfile.c", ["", "#endif // SPELL_PRINTTREE", ""], "whitespace/comments"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["      while (*p != NUL && *p <= ' ') {  // skip white space and CR/NL", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["        while (*p >= ' ' || *p == TAB) {  // skip until CR/NL", "          ++p;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["        while (*p > ' ') {  // skip until white space or CR/NL", "          ++p;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"RAR\" later", "      else if ((is_aff_rule(items, itemcnt, \"RAR\", 2)", "                || is_aff_rule(items, itemcnt, \"RARE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["      }", "      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)"], "readability/todo"]
["src/nvim/spellfile.c", ["      // TODO: remove \"KEP\" later", "      else if ((is_aff_rule(items, itemcnt, \"KEP\", 2)", "                || is_aff_rule(items, itemcnt, \"KEEPCASE\", 2))"], "whitespace/newline"]
["src/nvim/spellfile.c", ["        if (itemcnt > lasti && STRCMP(items[lasti], \"S\") == 0) {", "          ++lasti;", "          cur_aff->ah_follows = true;"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (*items[0] == 'P') {", "              sprintf((char *)buf, \"^%s\", items[4]);", "            } else {"], "runtime/printf"]
["src/nvim/spellfile.c", ["            } else {", "              sprintf((char *)buf, \"%s$\", items[4]);", "            }"], "runtime/printf"]
["src/nvim/spellfile.c", ["                    if (aff_entry->ae_cond != NULL) {", "                      sprintf((char *)buf, \"^%s\",", "                              aff_entry->ae_cond);"], "runtime/printf"]
["src/nvim/spellfile.c", ["              for (idx = spin->si_prefcond.ga_len - 1; idx >= 0;", "                   --idx) {", "                p = ((char_u **)spin->si_prefcond.ga_data)[idx];"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (aff_todo == 0 && !did_postpone_prefix) {", "              --spin->si_newprefID;", "              cur_aff->ah_newID = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["          add_fromto(spin, items[0][3] == 'S'", "              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["              ? &spin->si_repsal", "              : &spin->si_rep, items[1], items[2]);", "        }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["      // Accept \"SAL from to\" and \"SAL from to  #comment\".", "      else if (is_aff_rule(items, itemcnt, \"SAL\", 3)) {", "        if (do_sal) {"], "whitespace/newline"]
["src/nvim/spellfile.c", ["                       STRCMP(items[2], \"_\") == 0 ? (char_u *)\"\"", "                                                  : items[2]);", "          }"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["", "        for (i = 1; i < itemcnt; ++i) {", "          if (HASHITEM_EMPTY(hash_find(&spin->si_commonwords,"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (affile->af_flagtype == AFT_NUM && *p == ',') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!ascii_isdigit(**pp)) {", "      ++*pp;            // always advance, avoid getting stuck", "      return 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (aff->af_flagtype == AFT_NUM && *p == ',') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    todo = (int)ht->ht_used;", "    for (hi = ht->ht_array; todo > 0; ++hi) {", "      if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["      if (!HASHITEM_EMPTY(hi)) {", "        --todo;", "        ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", "    if (line[0] == '#' || line[0] == '/') {"], "readability/increment"]
["src/nvim/spellfile.c", ["    while (l > 0 && line[l - 1] <= ' ') {", "      --l;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(w)) {", "      ++non_ascii;", "      xfree(pc);"], "readability/increment"]
["src/nvim/spellfile.c", ["      }", "      ++duplicate;", "    } else {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (affile->af_flagtype == AFT_NUM && *p == ',') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0 && retval == OK; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      ah = HI2AH(hi);"], "readability/increment"]
["src/nvim/spellfile.c", ["                // same ID twice.", "                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                for (i = 0; i < pfxlen; ++i) {", "                  for (j = 0; j < use_pfxlen; ++j) {", "                    if (pfxlist[i] == use_pfxlist[j]) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                // Avoid adding the same ID twice.", "                for (i = pfxlen; pfxlist[i] != NUL; ++i) {", "                  for (j = use_pfxlen;"], "readability/increment"]
["src/nvim/spellfile.c", ["                  for (j = use_pfxlen;", "                       use_pfxlist[j] != NUL; ++j) {", "                    if (pfxlist[i] == use_pfxlist[j]) {"], "readability/increment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["                                 use_condit & (xht == NULL", "                                    ? ~0 :  ~CONDIT_SUF),", "                                 use_flags, use_pfxlist, pfxlen) == FAIL) {"], "whitespace/alignment"]
["src/nvim/spellfile.c", ["    line_breakcheck();", "    ++lnum;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    while (l > 0 && rline[l - 1] <= ' ') {", "      --l;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (*line == '/') {", "      ++line;", "      if (STRNCMP(line, \"encoding=\", 9) == 0) {"], "readability/increment"]
["src/nvim/spellfile.c", ["        }", "        ++p;", "      }"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (spin->si_ascii && has_non_ascii(line)) {", "      ++non_ascii;", "      continue;"], "readability/increment"]
["src/nvim/spellfile.c", ["    bl->sb_used = 0;", "    ++spin->si_blocks_cnt;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  }", "  ++spin->si_foldwcount;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++spin->si_keepwcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Add each byte of the word to the tree, including the NUL at the end.", "  for (i = 0;; ++i) {", "    // When there is more than one reference to this node we need to make"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (node != NULL && node->wn_refs > 1) {", "      --node->wn_refs;", "      copyprev = prev;"], "readability/increment"]
["src/nvim/spellfile.c", ["        if (np->wn_child != NULL) {", "          ++np->wn_child->wn_refs;              // child gets extra ref", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["  // count nr of words added since last message", "  ++spin->si_msg_count;", ""], "readability/increment"]
["src/nvim/spellfile.c", ["    memset(n, 0, sizeof(wordnode_T));", "    --spin->si_free_count;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["      free_wordnode(spin, np);", "      ++cnt;", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    }", "    ++cnt;          // length field", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_first_free = n;", "  ++spin->si_free_count;", "}"], "readability/increment"]
["src/nvim/spellfile.c", ["#ifndef SPELL_PRINTTREE", "    if (spin->si_verbose || p_verbose > 2)", "#endif"], "readability/braces"]
["src/nvim/spellfile.c", ["  for (np = node; np != NULL && !got_int; np = np->wn_sibling) {", "    ++len;", "    if ((child = np->wn_child) != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["            // its siblings is unlinked from the tree.", "            ++tp->wn_refs;", "            compressed += deref_wordnode(spin, child);"], "readability/increment"]
["src/nvim/spellfile.c", ["    fputc(128, fd);                                     // <charflagslen>", "    for (size_t i = 128; i < 256; ++i) {", "      flags = 0;"], "readability/increment"]
["src/nvim/spellfile.c", ["  // round 3: SN_REPSAL section", "  for (unsigned int round = 1; round <= 3; ++round) {", "    garray_T *gap;"], "readability/increment"]
["src/nvim/spellfile.c", ["    assert(gap->ga_len >= 0);", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["    if (round == 2) {", "      ++l;                            // count <salflags>", "    }"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)gap->ga_len, 2);    // <repcount> or <salcount>", "    for (size_t i = 0; i < (size_t)gap->ga_len; ++i) {", "      // <rep> : <repfromlen> <repfrom> <reptolen> <repto>"], "readability/increment"]
["src/nvim/spellfile.c", ["      fromto_T *ftp = &((fromto_T *)gap->ga_data)[i];", "      for (unsigned int rr = 1; rr <= 2; ++rr) {", "        char_u *p = rr == 1 ? ftp->ft_from : ftp->ft_to;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // round 2: write the bytes", "    for (unsigned int round = 1; round <= 2; ++round) {", "      size_t todo;"], "readability/increment"]
["src/nvim/spellfile.c", ["      todo = spin->si_commonwords.ht_used;", "      for (hi = spin->si_commonwords.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/spellfile.c", ["          }", "          --todo;", "        }"], "readability/increment"]
["src/nvim/spellfile.c", ["    assert(spin->si_comppat.ga_len >= 0);", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      l += STRLEN(((char_u **)(spin->si_comppat.ga_data))[i]) + 1;"], "readability/increment"]
["src/nvim/spellfile.c", ["    put_bytes(fd, (uintmax_t)spin->si_comppat.ga_len, 2);  // <comppatcount>", "    for (size_t i = 0; i < (size_t)spin->si_comppat.ga_len; ++i) {", "      char_u *p = ((char_u **)(spin->si_comppat.ga_data))[i];"], "readability/increment"]
["src/nvim/spellfile.c", ["  spin->si_memtot = 0;", "  for (unsigned int round = 1; round <= 3; ++round) {", "    wordnode_T *tree;"], "readability/increment"]
["src/nvim/spellfile.c", ["  for (wordnode_T *np = node; np != NULL; np = np->wn_sibling) {", "    ++siblingcount;", "  }"], "readability/increment"]
["src/nvim/spellfile.c", ["", "      --depth;", "      line_breakcheck();"], "readability/increment"]
["src/nvim/spellfile.c", ["      n = arridx[depth] + curi[depth];", "      ++curi[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["", "        ++words_done;", "        ++wordcount[depth];"], "readability/increment"]
["src/nvim/spellfile.c", ["        ++words_done;", "        ++wordcount[depth];", ""], "readability/increment"]
["src/nvim/spellfile.c", ["", "  for (linenr_T lnum = 1; lnum <= wcount; ++lnum) {", "    // <sugline>: <sugnr> ... NUL"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Get the region names if there are more than 2 arguments.", "    for (i = 0; i < incount; ++i) {", "      afile[i] = NULL;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Words are stored in the case-folded and keep-case trees.", "    for (i = 0; i < incount && !error; ++i) {", "      spin.si_conv.vc_type = CONV_NONE;"], "readability/increment"]
["src/nvim/spellfile.c", ["    // Free the .aff file structures.", "    for (i = 0; i < incount; ++i) {", "      if (afile[i] != NULL) {"], "readability/increment"]
["src/nvim/spellfile.c", ["", "    for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i) {", "      copy_option_part(&spf, fnamebuf, MAXPATHL, \",\");"], "readability/increment"]
["src/nvim/spellfile.c", ["            if (undo) {", "              home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "              smsg(_(\"Word '%.*s' removed from %s\"),"], "readability/bool"]
["src/nvim/spellfile.c", ["", "      home_replace(NULL, fname, NameBuff, MAXPATHL, TRUE);", "      smsg(_(\"Word '%.*s' added to %s\"), len, word, NameBuff);"], "readability/bool"]
["src/nvim/spellfile.c", ["", "  for (i = 0; i < 128; ++i) {", "    if (i < cnt) {"], "readability/increment"]
["src/nvim/spellfile.c", ["    // check that it's the same table", "    for (i = 0; i < 256; ++i) {", "      if (spelltab.st_isw[i] != new_st->st_isw[i]"], "readability/increment"]
["src/nvim/spellfile.c", ["  // Init the array and hash tables empty.", "  for (i = 0; i < 256; ++i) {", "    lp->sl_map_array[i] = 0;"], "readability/increment"]

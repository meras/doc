["src/nvim/regexp_nfa.c", ["", "/*", " * NFA regular expression implementation."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with an anchor, must match at start"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list starts with a character which must match"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Figure out if the NFA state list contains just literal text and nothing"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate more space for post_start.  Called when"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Search between \"start\" and \"end\" and try to recognize a"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Produce the bytes for equivalence class \"c\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["{", "#define EMIT2(c)   EMIT(c); EMIT(NFA_CONCAT);", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["    case 0x1ef9:", "      EMIT2('y') EMIT2(y_acute) EMIT2(y_diaeresis)", "      EMIT2(0x177) EMIT2(0x1b4) EMIT2(0x233) EMIT2(0x24f)"], "whitespace/cast"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Code to parse regular expression."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse the lowest level."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Character classes."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      case 'd':", "        nr = getdecchrs(); break;", "      case 'o':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'o':", "        nr = getoctchrs(); break;", "      case 'x':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'x':", "        nr = gethexchrs(2); break;", "      case 'u':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'u':", "        nr = gethexchrs(4); break;", "      case 'U':"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case 'U':", "        nr = gethexchrs(8); break;", "      default:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      default:", "        nr = -1; break;", "      }"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["collection:", "    /*", "     * [abc]  uses NFA_START_COLL - NFA_END_COLL"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    if (*endp == ']') {", "      /*", "       * Try to reverse engineer character classes. For example,"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["      }", "      /*", "       * Failed to recognize a character class. Use the simple"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse something followed by possible [*+=]."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case Magic('+'):", "    /*", "     * Trick: Normally, (a*)\\+ would match the whole input \"aaa\".  The"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse one or more pieces, concatenated.  It matches a match for the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse a branch, one or more concats, separated by \"\\&\".  It matches the"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["  case NFA_MATCH:", "    STRCPY(code, \"NFA_MATCH \"); break;", "  case NFA_SPLIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPLIT:", "    STRCPY(code, \"NFA_SPLIT \"); break;", "  case NFA_CONCAT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CONCAT:", "    STRCPY(code, \"NFA_CONCAT \"); break;", "  case NFA_NEWL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NEWL:", "    STRCPY(code, \"NFA_NEWL \"); break;", "  case NFA_ZSTART:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZSTART:", "    STRCPY(code, \"NFA_ZSTART\"); break;", "  case NFA_ZEND:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZEND:", "    STRCPY(code, \"NFA_ZEND\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF1:", "    STRCPY(code, \"NFA_BACKREF1\"); break;", "  case NFA_BACKREF2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF2:", "    STRCPY(code, \"NFA_BACKREF2\"); break;", "  case NFA_BACKREF3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF3:", "    STRCPY(code, \"NFA_BACKREF3\"); break;", "  case NFA_BACKREF4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF4:", "    STRCPY(code, \"NFA_BACKREF4\"); break;", "  case NFA_BACKREF5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF5:", "    STRCPY(code, \"NFA_BACKREF5\"); break;", "  case NFA_BACKREF6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF6:", "    STRCPY(code, \"NFA_BACKREF6\"); break;", "  case NFA_BACKREF7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF7:", "    STRCPY(code, \"NFA_BACKREF7\"); break;", "  case NFA_BACKREF8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF8:", "    STRCPY(code, \"NFA_BACKREF8\"); break;", "  case NFA_BACKREF9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BACKREF9:", "    STRCPY(code, \"NFA_BACKREF9\"); break;", "  case NFA_ZREF1:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF1:", "    STRCPY(code, \"NFA_ZREF1\"); break;", "  case NFA_ZREF2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF2:", "    STRCPY(code, \"NFA_ZREF2\"); break;", "  case NFA_ZREF3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF3:", "    STRCPY(code, \"NFA_ZREF3\"); break;", "  case NFA_ZREF4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF4:", "    STRCPY(code, \"NFA_ZREF4\"); break;", "  case NFA_ZREF5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF5:", "    STRCPY(code, \"NFA_ZREF5\"); break;", "  case NFA_ZREF6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF6:", "    STRCPY(code, \"NFA_ZREF6\"); break;", "  case NFA_ZREF7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF7:", "    STRCPY(code, \"NFA_ZREF7\"); break;", "  case NFA_ZREF8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF8:", "    STRCPY(code, \"NFA_ZREF8\"); break;", "  case NFA_ZREF9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ZREF9:", "    STRCPY(code, \"NFA_ZREF9\"); break;", "  case NFA_SKIP:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SKIP:", "    STRCPY(code, \"NFA_SKIP\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH\"); break;", "  case NFA_PREV_ATOM_NO_WIDTH_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_NO_WIDTH_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_NO_WIDTH_NEG\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE\"); break;", "  case NFA_PREV_ATOM_JUST_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_JUST_BEFORE_NEG:", "    STRCPY(code, \"NFA_PREV_ATOM_JUST_BEFORE_NEG\"); break;", "  case NFA_PREV_ATOM_LIKE_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PREV_ATOM_LIKE_PATTERN:", "    STRCPY(code, \"NFA_PREV_ATOM_LIKE_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NOPEN:", "    STRCPY(code, \"NFA_NOPEN\"); break;", "  case NFA_NCLOSE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NCLOSE:", "    STRCPY(code, \"NFA_NCLOSE\"); break;", "  case NFA_START_INVISIBLE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE:", "    STRCPY(code, \"NFA_START_INVISIBLE\"); break;", "  case NFA_START_INVISIBLE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_FIRST\"); break;", "  case NFA_START_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG\"); break;", "  case NFA_START_INVISIBLE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_NEG_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE\"); break;", "  case NFA_START_INVISIBLE_BEFORE_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_FIRST\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG\"); break;", "  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_INVISIBLE_BEFORE_NEG_FIRST:", "    STRCPY(code, \"NFA_START_INVISIBLE_BEFORE_NEG_FIRST\"); break;", "  case NFA_START_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_PATTERN:", "    STRCPY(code, \"NFA_START_PATTERN\"); break;", "  case NFA_END_INVISIBLE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_INVISIBLE:", "    STRCPY(code, \"NFA_END_INVISIBLE\"); break;", "  case NFA_END_INVISIBLE_NEG:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_INVISIBLE_NEG:", "    STRCPY(code, \"NFA_END_INVISIBLE_NEG\"); break;", "  case NFA_END_PATTERN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_PATTERN:", "    STRCPY(code, \"NFA_END_PATTERN\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COMPOSING:", "    STRCPY(code, \"NFA_COMPOSING\"); break;", "  case NFA_END_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_COMPOSING:", "    STRCPY(code, \"NFA_END_COMPOSING\"); break;", "  case NFA_OPT_CHARS:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OPT_CHARS:", "    STRCPY(code, \"NFA_OPT_CHARS\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOL:", "    STRCPY(code, \"NFA_EOL \"); break;", "  case NFA_BOL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOL:", "    STRCPY(code, \"NFA_BOL \"); break;", "  case NFA_EOW:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOW:", "    STRCPY(code, \"NFA_EOW \"); break;", "  case NFA_BOW:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOW:", "    STRCPY(code, \"NFA_BOW \"); break;", "  case NFA_EOF:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EOF:", "    STRCPY(code, \"NFA_EOF \"); break;", "  case NFA_BOF:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_BOF:", "    STRCPY(code, \"NFA_BOF \"); break;", "  case NFA_LNUM:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM:", "    STRCPY(code, \"NFA_LNUM \"); break;", "  case NFA_LNUM_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM_GT:", "    STRCPY(code, \"NFA_LNUM_GT \"); break;", "  case NFA_LNUM_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LNUM_LT:", "    STRCPY(code, \"NFA_LNUM_LT \"); break;", "  case NFA_COL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL:", "    STRCPY(code, \"NFA_COL \"); break;", "  case NFA_COL_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL_GT:", "    STRCPY(code, \"NFA_COL_GT \"); break;", "  case NFA_COL_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_COL_LT:", "    STRCPY(code, \"NFA_COL_LT \"); break;", "  case NFA_VCOL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL:", "    STRCPY(code, \"NFA_VCOL \"); break;", "  case NFA_VCOL_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL_GT:", "    STRCPY(code, \"NFA_VCOL_GT \"); break;", "  case NFA_VCOL_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VCOL_LT:", "    STRCPY(code, \"NFA_VCOL_LT \"); break;", "  case NFA_MARK:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK:", "    STRCPY(code, \"NFA_MARK \"); break;", "  case NFA_MARK_GT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK_GT:", "    STRCPY(code, \"NFA_MARK_GT \"); break;", "  case NFA_MARK_LT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_MARK_LT:", "    STRCPY(code, \"NFA_MARK_LT \"); break;", "  case NFA_CURSOR:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CURSOR:", "    STRCPY(code, \"NFA_CURSOR \"); break;", "  case NFA_VISUAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_VISUAL:", "    STRCPY(code, \"NFA_VISUAL \"); break;", "  case NFA_ANY_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY_COMPOSING:", "    STRCPY(code, \"NFA_ANY_COMPOSING \"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_STAR:", "    STRCPY(code, \"NFA_STAR \"); break;", "  case NFA_STAR_NONGREEDY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_STAR_NONGREEDY:", "    STRCPY(code, \"NFA_STAR_NONGREEDY \"); break;", "  case NFA_QUEST:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_QUEST:", "    STRCPY(code, \"NFA_QUEST\"); break;", "  case NFA_QUEST_NONGREEDY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_QUEST_NONGREEDY:", "    STRCPY(code, \"NFA_QUEST_NON_GREEDY\"); break;", "  case NFA_EMPTY:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_EMPTY:", "    STRCPY(code, \"NFA_EMPTY\"); break;", "  case NFA_OR:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OR:", "    STRCPY(code, \"NFA_OR\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_COLL:", "    STRCPY(code, \"NFA_START_COLL\"); break;", "  case NFA_END_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_COLL:", "    STRCPY(code, \"NFA_END_COLL\"); break;", "  case NFA_START_NEG_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_START_NEG_COLL:", "    STRCPY(code, \"NFA_START_NEG_COLL\"); break;", "  case NFA_END_NEG_COLL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_END_NEG_COLL:", "    STRCPY(code, \"NFA_END_NEG_COLL\"); break;", "  case NFA_RANGE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE:", "    STRCPY(code, \"NFA_RANGE\"); break;", "  case NFA_RANGE_MIN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE_MIN:", "    STRCPY(code, \"NFA_RANGE_MIN\"); break;", "  case NFA_RANGE_MAX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_RANGE_MAX:", "    STRCPY(code, \"NFA_RANGE_MAX\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ALNUM:", "    STRCPY(code, \"NFA_CLASS_ALNUM\"); break;", "  case NFA_CLASS_ALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ALPHA:", "    STRCPY(code, \"NFA_CLASS_ALPHA\"); break;", "  case NFA_CLASS_BLANK:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BLANK:", "    STRCPY(code, \"NFA_CLASS_BLANK\"); break;", "  case NFA_CLASS_CNTRL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_CNTRL:", "    STRCPY(code, \"NFA_CLASS_CNTRL\"); break;", "  case NFA_CLASS_DIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_DIGIT:", "    STRCPY(code, \"NFA_CLASS_DIGIT\"); break;", "  case NFA_CLASS_GRAPH:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_GRAPH:", "    STRCPY(code, \"NFA_CLASS_GRAPH\"); break;", "  case NFA_CLASS_LOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_LOWER:", "    STRCPY(code, \"NFA_CLASS_LOWER\"); break;", "  case NFA_CLASS_PRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PRINT:", "    STRCPY(code, \"NFA_CLASS_PRINT\"); break;", "  case NFA_CLASS_PUNCT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_PUNCT:", "    STRCPY(code, \"NFA_CLASS_PUNCT\"); break;", "  case NFA_CLASS_SPACE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_SPACE:", "    STRCPY(code, \"NFA_CLASS_SPACE\"); break;", "  case NFA_CLASS_UPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_UPPER:", "    STRCPY(code, \"NFA_CLASS_UPPER\"); break;", "  case NFA_CLASS_XDIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_XDIGIT:", "    STRCPY(code, \"NFA_CLASS_XDIGIT\"); break;", "  case NFA_CLASS_TAB:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_TAB:", "    STRCPY(code, \"NFA_CLASS_TAB\"); break;", "  case NFA_CLASS_RETURN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_RETURN:", "    STRCPY(code, \"NFA_CLASS_RETURN\"); break;", "  case NFA_CLASS_BACKSPACE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_BACKSPACE:", "    STRCPY(code, \"NFA_CLASS_BACKSPACE\"); break;", "  case NFA_CLASS_ESCAPE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_ESCAPE:", "    STRCPY(code, \"NFA_CLASS_ESCAPE\"); break;", "  case NFA_CLASS_IDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_IDENT:", "    STRCPY(code, \"NFA_CLASS_IDENT\"); break;", "  case NFA_CLASS_KEYWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_KEYWORD:", "    STRCPY(code, \"NFA_CLASS_KEYWORD\"); break;", "  case NFA_CLASS_FNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_CLASS_FNAME:", "    STRCPY(code, \"NFA_CLASS_FNAME\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ANY:", "    STRCPY(code, \"NFA_ANY\"); break;", "  case NFA_IDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_IDENT:", "    STRCPY(code, \"NFA_IDENT\"); break;", "  case NFA_SIDENT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SIDENT:", "    STRCPY(code, \"NFA_SIDENT\"); break;", "  case NFA_KWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_KWORD:", "    STRCPY(code, \"NFA_KWORD\"); break;", "  case NFA_SKWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SKWORD:", "    STRCPY(code, \"NFA_SKWORD\"); break;", "  case NFA_FNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_FNAME:", "    STRCPY(code, \"NFA_FNAME\"); break;", "  case NFA_SFNAME:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SFNAME:", "    STRCPY(code, \"NFA_SFNAME\"); break;", "  case NFA_PRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_PRINT:", "    STRCPY(code, \"NFA_PRINT\"); break;", "  case NFA_SPRINT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_SPRINT:", "    STRCPY(code, \"NFA_SPRINT\"); break;", "  case NFA_WHITE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_WHITE:", "    STRCPY(code, \"NFA_WHITE\"); break;", "  case NFA_NWHITE:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NWHITE:", "    STRCPY(code, \"NFA_NWHITE\"); break;", "  case NFA_DIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_DIGIT:", "    STRCPY(code, \"NFA_DIGIT\"); break;", "  case NFA_NDIGIT:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NDIGIT:", "    STRCPY(code, \"NFA_NDIGIT\"); break;", "  case NFA_HEX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_HEX:", "    STRCPY(code, \"NFA_HEX\"); break;", "  case NFA_NHEX:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NHEX:", "    STRCPY(code, \"NFA_NHEX\"); break;", "  case NFA_OCTAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_OCTAL:", "    STRCPY(code, \"NFA_OCTAL\"); break;", "  case NFA_NOCTAL:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NOCTAL:", "    STRCPY(code, \"NFA_NOCTAL\"); break;", "  case NFA_WORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_WORD:", "    STRCPY(code, \"NFA_WORD\"); break;", "  case NFA_NWORD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NWORD:", "    STRCPY(code, \"NFA_NWORD\"); break;", "  case NFA_HEAD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_HEAD:", "    STRCPY(code, \"NFA_HEAD\"); break;", "  case NFA_NHEAD:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NHEAD:", "    STRCPY(code, \"NFA_NHEAD\"); break;", "  case NFA_ALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_ALPHA:", "    STRCPY(code, \"NFA_ALPHA\"); break;", "  case NFA_NALPHA:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NALPHA:", "    STRCPY(code, \"NFA_NALPHA\"); break;", "  case NFA_LOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LOWER:", "    STRCPY(code, \"NFA_LOWER\"); break;", "  case NFA_NLOWER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NLOWER:", "    STRCPY(code, \"NFA_NLOWER\"); break;", "  case NFA_UPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_UPPER:", "    STRCPY(code, \"NFA_UPPER\"); break;", "  case NFA_NUPPER:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NUPPER:", "    STRCPY(code, \"NFA_NUPPER\"); break;", "  case NFA_LOWER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_LOWER_IC:", "    STRCPY(code, \"NFA_LOWER_IC\"); break;", "  case NFA_NLOWER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NLOWER_IC:", "    STRCPY(code, \"NFA_NLOWER_IC\"); break;", "  case NFA_UPPER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_UPPER_IC:", "    STRCPY(code, \"NFA_UPPER_IC\"); break;", "  case NFA_NUPPER_IC:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["  case NFA_NUPPER_IC:", "    STRCPY(code, \"NFA_NUPPER_IC\"); break;", ""], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the postfix notation of the current regexp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA starting with a root node \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["    STRNCPY(save, &p[last], 2);", "    STRNCPY(&p[last], \"+-\", 2);", "    fprintf(debugf, \" %s\", p);"], "runtime/printf"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Print the NFA state machine."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["}", "#endif      /* REGEXP_DEBUG */", ""], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Parse r.e. @expr and convert it into postfix form."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Represents an NFA state plus zero or one or two arrows exiting."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Allocate and initialize nfa_state_T."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * A partially built NFA without the matching state filled in."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Initialize a Frag_T struct and return it."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Create singleton list containing just outp."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Patch the list of states at out to point to start."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Join the two lists l1 and l2, returning the combination."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Stack used for transforming postfix form into NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Push an item onto the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Pop an item from the stack."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the maximum byte length of anything matching \"state\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Convert a postfix form into its equivalent NFA."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (p = postfix; p < end; ++p) {", "    switch (*p) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["      case NFA_NOPEN:", "        mclose = NFA_NCLOSE; break;", "      case NFA_ZOPEN:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN:", "        mclose = NFA_ZCLOSE; break;", "      case NFA_ZOPEN1:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN1:", "        mclose = NFA_ZCLOSE1; break;", "      case NFA_ZOPEN2:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN2:", "        mclose = NFA_ZCLOSE2; break;", "      case NFA_ZOPEN3:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN3:", "        mclose = NFA_ZCLOSE3; break;", "      case NFA_ZOPEN4:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN4:", "        mclose = NFA_ZCLOSE4; break;", "      case NFA_ZOPEN5:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN5:", "        mclose = NFA_ZCLOSE5; break;", "      case NFA_ZOPEN6:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN6:", "        mclose = NFA_ZCLOSE6; break;", "      case NFA_ZOPEN7:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN7:", "        mclose = NFA_ZCLOSE7; break;", "      case NFA_ZOPEN8:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN8:", "        mclose = NFA_ZCLOSE8; break;", "      case NFA_ZOPEN9:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_ZOPEN9:", "        mclose = NFA_ZCLOSE9; break;", "      case NFA_COMPOSING:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["      case NFA_COMPOSING:", "        mclose = NFA_END_COMPOSING; break;", "      default:"], "whitespace/newline"]
["src/nvim/regexp_nfa.c", ["", "/*", " * After building the NFA program, inspect it to add optimization hints."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  for (i = 0; i < prog->nstate; ++i) {", "    c = prog->state[i].c;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Copy the submatches from \"from\" to \"to\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but exclude the main match."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Like copy_sub() but only do the end of the main match if \\ze is present."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["        if (add_here) {", "          for (k = 0; k < l->n && k < listindex; ++k) {", "            if (l->t[k].state->id == state->id) {"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.multi[i].start_lnum = -1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["        save_in_use = sub->in_use;", "        for (i = sub->in_use; i < subidx; ++i) {", "          sub->list.line[i].start = NULL;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["  }", "  --l->n;", "  *ip = listidx - 1;"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check character class \"class\" against current character c."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Save list IDs for all NFA states of \"prog\" into \"list\"."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = 0;", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Restore list IDs from \"list\" to all NFA states."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["    p->lastlist[1] = list[i];", "    ++p;", "  }"], "readability/increment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Recursively call nfa_regmatch()"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Estimate the chance of a match with \"state\" failing."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Skip until the char \"c\" we know a match must start with."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Check for a match with match_text."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * Run for each character."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["#endif", "    /*", "     * If the state lists are empty we can stop."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "      /*", "       * Handle the possible codes of the current state."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Compile a regular expression into internal code for the NFA matcher."], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * In order to build the NFA, we parse the input regexp twice:"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 1"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "  /*", "   * PASS 2"], "readability/old_style_comment"]
["src/nvim/regexp_nfa.c", ["", "/*", " * Free a compiled regexp program, returned by nfa_regcomp()."], "readability/old_style_comment"]

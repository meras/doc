["src/nvim/eval/funcs.c", ["    if (buf == NULL) {", "      /* No full path name match, try a match with a URL or a \"nofile\"", "       * buffer, these don't use the full path. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  save_magic = p_magic;", "  p_magic = TRUE;", "  save_cpo = p_cpo;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  byteidx(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["          case 'E':", "            type = VIM_ERROR; break;", "          case 'Q':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'Q':", "            type = VIM_QUESTION; break;", "          case 'I':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'I':", "            type = VIM_INFO; break;", "          case 'W':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'W':", "            type = VIM_WARNING; break;", "          case 'G':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'G':", "            type = VIM_GENERIC; break;", "          }"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      todo = error ? 0 : (int)d->dv_hashtab.ht_used;", "      for (hi = d->dv_hashtab.ht_array; todo > 0; ++hi) {", "        if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  foldclosed_both(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["                + STRLEN(s));     // concatenated", "    sprintf((char *)r, txt, dashes, count);", "    len = (int)STRLEN(r);"], "runtime/printf"]
["src/nvim/eval/funcs.c", ["        for (wp = firstwin; wp != win; wp = wp->w_next) {", "          ++winnr;", "        }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["", "  /* When the optional second argument is non-zero, don't remove matches", "  * for 'wildignore' and don't put matches for 'suffixes' at the end. */"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, FALSE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_user_input(argvars, rettv, TRUE, inputsecret_flag);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int mode;", "  int abbr = FALSE;", "  int get_dict = FALSE;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["  int abbr = FALSE;", "  int get_dict = FALSE;", "  mapblock_T *mp;"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  filter_map(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  get_maparg(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        TV_LIST_ITEM_TV(li3)->vval.v_number = (varnumber_T)(", "                                                            regmatch.startp[0] - expr);", "        TV_LIST_ITEM_TV(li4)->vval.v_number = (varnumber_T)("], "whitespace/indent"]
["src/nvim/eval/funcs.c", ["        TV_LIST_ITEM_TV(li4)->vval.v_number = (varnumber_T)(", "                                                            regmatch.endp[0] - expr);", "        if (l != NULL) {"], "whitespace/indent"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, TRUE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["{", "  max_min(argvars, rettv, FALSE);", "}"], "readability/bool"]
["src/nvim/eval/funcs.c", ["        } else {", "          /* Change \"prev\" buffer to be the right size.  This way", "           * the bytes are only copied once, and very long lines are"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["      if (p - start + prevlen >= prevsize) {", "        /* A common use case is ordinary text files and \"prev\" gets a", "         * fragment of a line, so the first allocation is made"], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  union {", "    struct { int32_t low, high; } split;", "    proftime_T prof;"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'b':", "        dir = BACKWARD; break;", "      case 'w':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'w':", "        p_ws = true; break;", "      case 'W':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'W':", "        p_ws = false; break;", "      default:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'c':", "            mask = SP_START; break;", "          case 'e':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'e':", "            mask = SP_END; break;", "          case 'm':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'm':", "            mask = SP_RETCOUNT; break;", "          case 'n':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'n':", "            mask = SP_NOMOVE; break;", "          case 'p':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'p':", "            mask = SP_SUBPAT; break;", "          case 'r':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'r':", "            mask = SP_REPEAT; break;", "          case 's':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 's':", "            mask = SP_SETPCMARK; break;", "          case 'z':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["          case 'z':", "            mask = SP_COLUMN; break;", "          }"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["", "  /*", "   * This function does not accept SP_REPEAT and SP_RETCOUNT flags."], "readability/old_style_comment"]
["src/nvim/eval/funcs.c", ["                        (attr == HLF_SPB ? \"bad\"", "                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr =="], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr ==", "                         HLF_SPC ? \"caps\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                         HLF_SPC ? \"caps\"", "                                 :", "                         NULL), -1);"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                        (attr == HLF_SPB ? \"bad\"", "                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                         : attr == HLF_SPR ? \"rare\"", "                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr =="], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                                                           : attr == HLF_SPL ? \"local\"", "                                                                             : attr ==", "                         HLF_SPC ? \"caps\""], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["                         HLF_SPC ? \"caps\"", "                                 :", "                         NULL), -1);"], "whitespace/alignment"]
["src/nvim/eval/funcs.c", ["      }", "      ++nr;", "    }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["  case VAR_NUMBER:", "    n = VAR_TYPE_NUMBER; break;", "  case VAR_STRING:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_STRING:", "    n = VAR_TYPE_STRING; break;", "  case VAR_PARTIAL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_FUNC:", "    n = VAR_TYPE_FUNC; break;", "  case VAR_LIST:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_LIST:", "    n = VAR_TYPE_LIST; break;", "  case VAR_DICT:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_DICT:", "    n = VAR_TYPE_DICT; break;", "  case VAR_FLOAT:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_FLOAT:", "    n = VAR_TYPE_FLOAT; break;", "  case VAR_BOOL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_BOOL:", "    n = VAR_TYPE_BOOL; break;", "  case VAR_SPECIAL:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_SPECIAL:", "    n = VAR_TYPE_SPECIAL; break;", "  case VAR_BLOB:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["  case VAR_BLOB:", "    n = VAR_TYPE_BLOB; break;", "  case VAR_UNKNOWN:"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["    getvvcol(curwin, fp, NULL, NULL, &vcol);", "    ++vcol;", "  }"], "readability/increment"]
["src/nvim/eval/funcs.c", ["      case 'b':", "        binary = true; break;", "      case 'a':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'a':", "        append = true; break;", "      case 's':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 's':", "        do_fsync = true; break;", "      case 'S':"], "whitespace/newline"]
["src/nvim/eval/funcs.c", ["      case 'S':", "        do_fsync = false; break;", "      default:"], "whitespace/newline"]

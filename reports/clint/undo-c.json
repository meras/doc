["src/nvim/undo.c", ["", "/*", " * undo.c: multi level undo facility"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * When 'u' flag included in 'cpoptions', we behave like vi.  Need to remember"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#if defined(U_DEBUG)", "/*", " * Check the undo structures for being valid.  Print a warning when something"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  }", "  ++header_count;", "  if (uhp == curbuf->b_u_curhead && ++seen_b_u_curhead > 1) {"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * Save the current line for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines between \"top\" and \"bot\" for both the \"u\" and \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the line \"lnum\" (used by \":s\" and \"~\" command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * A new line is inserted before line \"lnum\" (used by :s command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Save the lines \"lnum\" - \"lnum\" + nlines (used by delete command)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Common code for various ways to save text before a change."], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    /*", "     * If we undid more than we redid, move the entry lists before and"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * free headers to keep the size right"], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "    /*", "     * When saving a single line, and it has been saved just before, it"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      prev_uep = NULL;", "      for (i = 0; i < 10; ++i) {", "        if (uep == NULL) {"], "readability/increment"]
["src/nvim/undo.c", ["                    : uep->ue_bot))", "                    : uep->ue_lcount != buf->b_ml.ml_line_count)", "            || (uep->ue_size > 1"], "whitespace/alignment"]
["src/nvim/undo.c", ["", "  /*", "   * add lines in front of entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    uep->ue_array = xmalloc(sizeof(char_u *) * (size_t)size);", "    for (i = 0, lnum = top + 1; i < size; ++i) {", "      fast_breakcheck();"], "readability/increment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * Decide about the permission to use for the undo file.  If the buffer"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  // Check there is no problem in undo info before writing.", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["#ifdef UNIX", "  /*", "   * Try to set the group of the undo file same as the original file. If"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Write the header."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * Iteratively serialize UHPs and their UEPs from the top down."], "readability/old_style_comment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "      ++headers_written;", "#endif"], "readability/increment"]
["src/nvim/undo.c", ["  // a pointer corresponding to the header with that sequence number.", "  short old_idx = -1, new_idx = -1, cur_idx = -1;", "  for (int i = 0; i < num_head; i++) {"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      old_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      new_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["      assert(i <= SHRT_MAX);", "      cur_idx = (short)i;", "      SET_FLAG(i);"], "runtime/int"]
["src/nvim/undo.c", ["  xfree(uhp_table_used);", "  u_check(TRUE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Undo the previous undo or redo (vi compatible)."], "readability/old_style_comment"]
["src/nvim/undo.c", ["{", "  /*", "   * If we get an undo command while executing a macro, we behave like the"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * If 'cpoptions' contains 'u': Repeat the previous undo or redo."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * May do this twice:"], "readability/old_style_comment"]
["src/nvim/undo.c", ["        if ((step < 0 ? uhp->uh_seq <= curbuf->b_u_seq_cur", "                      : uhp->uh_seq > curbuf->b_u_seq_cur)", "            && ((dosec && val == closest)"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   : uhp->uh_seq > closest_seq)", "                   : closest == closest_start", "                || (val > target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                   : uhp->uh_seq > closest_seq)", "                   : closest == closest_start", "                || (val > target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : val - target <= target - closest)", "                       : (closest > target", "                       ? target - val <= closest - target"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       : (closest > target", "                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {"], "whitespace/alignment"]
["src/nvim/undo.c", ["                       ? target - val <= closest - target", "                       : target - val <= target - closest)))) {", "          closest = val;"], "whitespace/alignment"]
["src/nvim/undo.c", ["      // go to alternate branch if we haven't been there", "      else if (uhp->uh_alt_next.ptr != NULL", "               && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["", "  /*", "   * save marks before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (top < newlnum) {", "      /* If the saved cursor is somewhere in this undo block, move it to", "       * the remembered position.  Makes \"gwap\" put the cursor back"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      } else {", "        /* Use the first line that actually changed.  Avoids that", "         * undoing auto-formatting puts the cursor in the previous"], "readability/old_style_comment"]
["src/nvim/undo.c", ["         * line. */", "        for (i = 0; i < newsize && i < oldsize; ++i) {", "          if (STRCMP(uep->ue_array[i], ml_get(top + 1 + i)) != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["        newarray[i] = u_save_line(lnum);", "        /* remember we deleted the last line in the buffer, and a", "         * dummy empty line will be inserted */"], "readability/old_style_comment"]
["src/nvim/undo.c", ["    if (newsize) {", "      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*"], "readability/increment"]
["src/nvim/undo.c", ["      for (lnum = top, i = 0; i < newsize; ++i, ++lnum) {", "        /*", "         * If the file is empty, there is an empty line 1 that we"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "    /*", "     * insert this entry in front of the new entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * restore marks from before undo/redo"], "readability/old_style_comment"]
["src/nvim/undo.c", ["   */", "  for (i = 0; i < NMARKS; ++i) {", "    if (curhead->uh_namedm[i].mark.lnum != 0) {"], "readability/increment"]
["src/nvim/undo.c", ["", "  /*", "   * If the cursor is only off by one line, put it at the same position as"], "readability/old_style_comment"]
["src/nvim/undo.c", ["      && curwin->w_cursor.lnum > 1) {", "    --curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/undo.c", ["#ifdef U_DEBUG", "  u_check(FALSE);", "#endif"], "readability/bool"]
["src/nvim/undo.c", ["  if (curbuf->b_ml.ml_flags & ML_EMPTY) {", "    --u_newcount;", "  }"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * \":undolist\": List the leafs of the undo tree"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  /*", "   * 1: walk the tree to find all leafs, put the info in \"ga\"."], "readability/old_style_comment"]
["src/nvim/undo.c", ["      uhp = uhp->uh_prev.ptr;", "      ++changes;", "    }"], "readability/increment"]
["src/nvim/undo.c", ["    // go to alternate branch if we haven't been there", "    else if (uhp->uh_alt_next.ptr != NULL", "             && uhp->uh_alt_next.ptr->uh_walk != nomark"], "whitespace/newline"]
["src/nvim/undo.c", ["      uhp = uhp->uh_next.ptr;", "      --changes;", "    } else {"], "readability/increment"]
["src/nvim/undo.c", ["        uhp = uhp->uh_next.ptr;", "        --changes;", "      }"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * \":undojoin\": continue adding to the last entry list"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Called after writing or reloading the file and setting b_changed to FALSE."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * After reloading a buffer which was saved for 'undoreload': Find the first"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Increase the write count, store it in the last undo header, what would be"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "  ++buf->b_u_save_nr_last;", "  buf->b_u_save_nr_cur = buf->b_u_save_nr_last;"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * Get pointer to last added entry."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * u_getbot(): compute the line number of the previous u_save"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  if (uep != NULL) {", "    /*", "     * the new ue_bot is computed from the number of lines that has been"], "readability/old_style_comment"]
["src/nvim/undo.c", ["  xfree((char_u *)uhp);", "  --buf->b_u_numhead;", "}"], "readability/increment"]
["src/nvim/undo.c", ["", "/*", " * free entry 'uep' and 'n' lines in uep->ue_array[]"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * invalidate the undo buffer; called when storage has already been released"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * save the line \"lnum\" for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * clear the line saved for the \"U\" command"], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Implementation of the \"U\" command."], "readability/old_style_comment"]
["src/nvim/undo.c", ["", "/*", " * Free all allocated memory blocks for the buffer 'buf'."], "readability/old_style_comment"]

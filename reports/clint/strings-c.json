["src/nvim/strings.c", ["  // and expect the remainder to be zeroed out.", "  return (char_u *)strncpy(xmallocz(len), (char *)string, len);", "}"], "runtime/printf"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave(), but any characters found in esc_chars are preceded"], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Same as vim_strsave_escaped(), but when \"bsl\" is true also escape"], "readability/old_style_comment"]
["src/nvim/strings.c", ["{", "  /*", "   * First count the number of backslashes required."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++length;                           // count an ordinary char", "  }"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Escape \"string\" for use as a shell argument with system()."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "  /* Only csh and similar shells expand '!' within single quotes.  For sh and", "   * the like we must not put a backslash before it, it will be taken"], "readability/old_style_comment"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["        || (*p == '!' && (csh_like || do_special))) {", "      ++length;                         // insert backslash", "      if (csh_like && do_special) {"], "readability/increment"]
["src/nvim/strings.c", ["      if (csh_like && do_special) {", "        ++length;                       // insert backslash", "      }"], "readability/increment"]
["src/nvim/strings.c", ["    if (do_special && find_cmdline_var(p, &l) >= 0) {", "      ++length;                         // insert backslash", "      p += l - 1;"], "readability/increment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      }", "    } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["      *d++ = '\\'';", "      ++p;", "      continue;"], "readability/increment"]
["src/nvim/strings.c", ["    *d++ = '\"';", "  } else", "#endif"], "readability/braces"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Like vim_strnsave(), but make all characters uppercase."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * ASCII lower-to-upper case translation, language independent."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * delete spaces at the end of a string"], "readability/old_style_comment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRCASECMP) && !defined(HAVE_STRICMP))", "/*", " * Compare two strings, ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["#if (!defined(HAVE_STRNCASECMP) && !defined(HAVE_STRNICMP))", "/*", " * Compare two strings, for length \"len\", ignoring case, using current locale."], "readability/old_style_comment"]
["src/nvim/strings.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/strings.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Sort an array of strings."], "readability/old_style_comment"]
["src/nvim/strings.c", ["", "/*", " * Return true if string \"s\" contains a non-ASCII character (128 or higher)."], "readability/old_style_comment"]
["src/nvim/strings.c", ["  if (s != NULL) {", "    for (p = s; *p != NUL; ++p) {", "      if (*p >= 128) {"], "readability/increment"]
["src/nvim/strings.c", ["", "/*", " * Concatenate two strings and return the result in allocated memory."], "readability/old_style_comment"]
["src/nvim/strings.c", ["        case '0':", "          zero_padding = 1; p++; continue;", "        case '-':"], "whitespace/newline"]
["src/nvim/strings.c", ["        case '-':", "          justify_left = 1; p++; continue;", "        // if both '0' and '-' flags appear, '0' should be ignored"], "whitespace/newline"]
["src/nvim/strings.c", ["        case '\\'':", "          p++; continue;", "        default:"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'i':", "        fmt_spec = 'd'; break;", "      case 'D':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'D':", "        fmt_spec = 'd'; length_modifier = 'l'; break;", "      case 'U':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'U':", "        fmt_spec = 'u'; length_modifier = 'l'; break;", "      case 'O':"], "whitespace/newline"]
["src/nvim/strings.c", ["      case 'O':", "        fmt_spec = 'o'; length_modifier = 'l'; break;", "      default:"], "whitespace/newline"]
["src/nvim/strings.c", ["            arg = (", "                   tvs", "                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                   tvs", "                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)", "                    : va_arg(ap, long long));  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                    ? (long long)tv_nr(tvs, &arg_idx)  // NOLINT (runtime/int)", "                    : va_arg(ap, long long));  // NOLINT (runtime/int)", "            break;"], "whitespace/indent"]
["src/nvim/strings.c", ["            arg = (tvs", "                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                       ? (ptrdiff_t)tv_nr(tvs, &arg_idx)", "                       : va_arg(ap, ptrdiff_t));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (unsigned int)(tvs", "                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                      ? tv_nr(tvs, &arg_idx)", "                                      : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (uint16_t)(tvs", "                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                                  ? tv_nr(tvs, &arg_idx)", "                                  : va_arg(ap, unsigned int));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (unsigned long)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, unsigned long));", "            break;"], "whitespace/alignment"]
["src/nvim/strings.c", ["            uarg = (uintmax_t)(unsigned long long)(  // NOLINT (runtime/int)", "                                                     tvs", "                    ? ((unsigned long long)  // NOLINT (runtime/int)"], "whitespace/indent"]
["src/nvim/strings.c", ["                                                     tvs", "                    ? ((unsigned long long)  // NOLINT (runtime/int)", "                       tv_nr(tvs, &arg_idx))"], "whitespace/indent"]
["src/nvim/strings.c", ["                       tv_nr(tvs, &arg_idx))", "                    : va_arg(ap, unsigned long long));  // NOLINT (runtime/int)", "            break;"], "whitespace/indent"]
["src/nvim/strings.c", ["            uarg = (tvs", "                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));"], "whitespace/alignment"]
["src/nvim/strings.c", ["                        ? (size_t)tv_nr(tvs, &arg_idx)", "                        : va_arg(ap, size_t));", "            break;"], "whitespace/alignment"]

["src/nvim/normal.c", ["                            // NV_NCH_NOP is set and no operator is pending, get a second char", "                            ((flags & NV_NCH_NOP) == NV_NCH_NOP && !pending_op)", "                            // NV_NCH_ALW is set, always get a second char"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // NV_NCH_ALW is set, always get a second char", "                            || (flags & NV_NCH_ALW) == NV_NCH_ALW", "                            // 'q' without a pending operator, recording or executing a register,"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // - q: => open command-line window", "                            || (cmdchar == 'q'", "                                && !pending_op"], "whitespace/indent"]
["src/nvim/normal.c", ["                            // separate state that \"inherits\" from normal state.", "                            || ((cmdchar == 'a' || cmdchar == 'i')", "                                && (pending_op || VIsual_active)));"], "whitespace/indent"]
["src/nvim/normal.c", ["          // 'showmode' is set and messages can be printed", "          ((p_smd && msg_silent == 0", "            // must restart insert mode(ctrl+o or ctrl+l) or we just entered visual"], "whitespace/indent"]
["src/nvim/normal.c", ["          // no register was used", "          && s->oa.regname == 0", "          && !(s->ca.retval & CA_COMMAND_BUSY)"], "whitespace/indent"]
["src/nvim/normal.c", ["          && s->oa.regname == 0", "          && !(s->ca.retval & CA_COMMAND_BUSY)", "          && stuff_empty()"], "whitespace/indent"]
["src/nvim/normal.c", ["          && !(s->ca.retval & CA_COMMAND_BUSY)", "          && stuff_empty()", "          && typebuf_typed()"], "whitespace/indent"]
["src/nvim/normal.c", ["          && stuff_empty()", "          && typebuf_typed()", "          && emsg_silent == 0"], "whitespace/indent"]
["src/nvim/normal.c", ["          && typebuf_typed()", "          && emsg_silent == 0", "          && !did_wait_return"], "whitespace/indent"]
["src/nvim/normal.c", ["          && emsg_silent == 0", "          && !did_wait_return", "          && s->oa.op_type == OP_NOP);"], "whitespace/indent"]
["src/nvim/normal.c", ["          && !did_wait_return", "          && s->oa.op_type == OP_NOP);", "}"], "whitespace/indent"]
["src/nvim/normal.c", ["  case 'l':", "    s->ca.cmdchar = 'h'; break;", "  case K_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_RIGHT:", "    s->ca.cmdchar = K_LEFT; break;", "  case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_RIGHT:", "    s->ca.cmdchar = K_S_LEFT; break;", "  case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_C_RIGHT:", "    s->ca.cmdchar = K_C_LEFT; break;", "  case 'h':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case 'h':", "    s->ca.cmdchar = 'l'; break;", "  case K_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_LEFT:", "    s->ca.cmdchar = K_RIGHT; break;", "  case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_LEFT:", "    s->ca.cmdchar = K_S_RIGHT; break;", "  case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_C_LEFT:", "    s->ca.cmdchar = K_C_RIGHT; break;", "  case '>':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case '>':", "    s->ca.cmdchar = '<'; break;", "  case '<':"], "whitespace/newline"]
["src/nvim/normal.c", ["  case '<':", "    s->ca.cmdchar = '>'; break;", "  }"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_RIGHT:", "    cap->cmdchar = K_RIGHT; break;", "  case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_LEFT:", "    cap->cmdchar = K_LEFT; break;", "  case K_S_UP:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_UP:", "    cap->cmdchar = K_UP; break;", "  case K_S_DOWN:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_DOWN:", "    cap->cmdchar = K_DOWN; break;", "  case K_S_HOME:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_HOME:", "    cap->cmdchar = K_HOME; break;", "  case K_S_END:"], "whitespace/newline"]
["src/nvim/normal.c", ["  case K_S_END:", "    cap->cmdchar = K_END; break;", "  }"], "whitespace/newline"]
["src/nvim/normal.c", ["      if (bytes == chars) {", "        sprintf((char *)showcmd_buf, \"%d\", chars);", "      } else {"], "runtime/printf"]
["src/nvim/normal.c", ["      } else {", "        sprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);", "      }"], "runtime/printf"]
["src/nvim/normal.c", ["  assert(len <= INT_MAX);", "  sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",", "          (int)len, ptr);"], "runtime/printf"]

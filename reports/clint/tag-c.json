["src/nvim/tag.c", ["", "/*", " * Code to handle tags and the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold pointers to various items in a tag line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Structure to hold info about the tag pattern being used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Tag for preview window is remembered separately, to avoid messing up the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["            || type == DT_CSCOPE", "            )) {", "      if (g_do_tagpreview != 0) {"], "whitespace/parens"]
["src/nvim/tag.c", ["      } else {", "        /*", "         * If the last used entry is not at the top, delete all tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (saved_fmark.fnum != curbuf->b_fnum) {", "          /*", "           * Jump to other file. If this fails (e.g. because the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if ((tagstackidx += count - 1) >= tagstacklen) {", "            /*", "             * Beyond the last one, just give an error message and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        case DT_FIRST:", "          cur_match = count - 1; break;", "        case DT_SELECT:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_LAST:", "          cur_match = MAXCOL - 1; break;", "        case DT_NEXT:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_NEXT:", "          cur_match += count; break;", "        case DT_PREV:"], "whitespace/newline"]
["src/nvim/tag.c", ["        case DT_PREV:", "          cur_match -= count; break;", "        }"], "whitespace/newline"]
["src/nvim/tag.c", ["    } else {", "      /*", "       * For \":tag [arg]\" or \":tselect\" remember position before the jump."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Repeat searching for tags, when a file has not been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["        flags = TAG_REGEXP;", "        ++name;", "      } else {"], "readability/increment"]
["src/nvim/tag.c", ["          parse_match(matches[j], &tagp);", "          for (i = idx; i < new_num_matches; ++i) {", "            parse_match(new_matches[i], &tagp2);"], "readability/increment"]
["src/nvim/tag.c", ["", "      /*", "       * Only when going to try the next match, report that the previous"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      /*", "       * Jump to the desired match."], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (use_tagstack) {", "            --tagstackidx;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["          if (type == DT_PREV) {", "            --cur_match;", "          } else {"], "readability/increment"]
["src/nvim/tag.c", ["            type = DT_NEXT;", "            ++cur_match;", "          }"], "readability/increment"]
["src/nvim/tag.c", ["    if (!new_tag && (", "                     (g_do_tagpreview != 0", "                      && i == ptag_entry.cur_match)"], "whitespace/indent"]
["src/nvim/tag.c", ["                      && i == ptag_entry.cur_match)", "                     || (use_tagstack", "                         && i == tagstack[tagstackidx].cur_match))) {"], "whitespace/indent"]
["src/nvim/tag.c", ["", "/*", " * Free cached tags."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Print the tag stack"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  msg_puts_title(_(\"\\n  # TO tag         FROM line  in file/text\"));", "  for (i = 0; i < tagstacklen; ++i) {", "    if (tagstack[i].tagname != NULL) {"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Compare two strings, for length \"len\", ignoring case the ASCII way."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    }", "    ++s1;", "    ++s2;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s1;", "    ++s2;", "    --len;"], "readability/increment"]
["src/nvim/tag.c", ["    ++s2;", "    --len;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Extract info from the tag search pattern \"pats->pat\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int noic = (flags & TAG_NOIC);", "  int get_it_again = FALSE;", "  int use_cscope = (flags & TAG_CSCOPE);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Allocate memory for the buffers that are used"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Initialize a few variables"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  save_emsg_off = emsg_off;", "  emsg_off = TRUE;    // don't want error for invalid RE here", "  prepare_pats(&orgpat, has_re);"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * When finding a specified number of matches, first try with matching"], "readability/old_style_comment"]
["src/nvim/tag.c", ["                           && (findall || orgpat.headlen == 0 || !p_tbs));", "  for (round = 1; round <= 2; ++round) {", "    linear = (orgpat.headlen == 0 || !p_tbs || round == 2);"], "readability/increment"]
["src/nvim/tag.c", ["            help_pri = 1;", "            for (s = p_hlg; *s != NUL; ++s) {", "              if (STRNICMP(s, help_lang, 2) == 0) {"], "readability/increment"]
["src/nvim/tag.c", ["              if (STRICMP(help_lang, \"en\") != 0) {", "                ++help_pri;", "              }"], "readability/increment"]
["src/nvim/tag.c", ["", "      /*", "       * Read and parse the lines in the file one by one"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * For binary search: compute the next offset to use."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * When jumping around in the file, first read a line to find the"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        }", "        /*", "         * Not jumping around in the file: Read the next line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        else {", "          // skip empty and blank lines"], "whitespace/newline"]
["src/nvim/tag.c", ["         */", "        else {", "          // skip empty and blank lines"], "readability/braces"]
["src/nvim/tag.c", ["", "        /*", "         * When still at the start of the file, check for Emacs tags file"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Read header line."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * When there is no tag head, or ignoring case, need to do a"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "          /*", "           * Skip this line if the length of the tag is different and"], "readability/old_style_comment"]
["src/nvim/tag.c", ["          if (state == TS_BINARY) {", "            /*", "             * Simplistic check for unsorted tags file."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * Compare the current tag with the searched tag."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "            /*", "             * A match with a shorter tag means to search forward."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "        /*", "         * First try matching with the pattern literally (also when it is"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        if (orgpat.len != cmplen) {", "          match = FALSE;", "        } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * Has a regexp: Also find tags matching regexp."], "readability/old_style_comment"]
["src/nvim/tag.c", ["         */", "        match_re = FALSE;", "        if (!match && orgpat.regmatch.regprog != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["            if (orgpat.regmatch.rm_ic) {", "              orgpat.regmatch.rm_ic = FALSE;", "              match_no_ic = vim_regexec(&orgpat.regmatch, tagp.tagname,"], "readability/bool"]
["src/nvim/tag.c", ["                                        (colnr_T)0);", "              orgpat.regmatch.rm_ic = TRUE;", "            }"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Stop searching if sufficient tags have been found."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    }", "    orgpat.regmatch.rm_ic = TRUE;       // try another time while ignoring case", "  }"], "readability/bool"]
["src/nvim/tag.c", ["", "  /*", "   * Move the matches from the ga_match[] arrays into one list of"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Callback function for finding all \"tags\" and \"tags-??\" files in"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (curbuf->b_help) {", "    /*", "     * For help files it's done in a completely different way:"], "readability/old_style_comment"]
["src/nvim/tag.c", ["      }", "      ++tnp->tn_hf_idx;", "      STRCPY(buf, p_hf);"], "readability/increment"]
["src/nvim/tag.c", ["    tnp->tn_tags = vim_strsave((*curbuf->b_p_tags != NUL)", "        ? curbuf->b_p_tags : p_tags);", "    tnp->tn_np = tnp->tn_tags;"], "whitespace/alignment"]
["src/nvim/tag.c", ["", "  /*", "   * Loop until we have found a file name that can be used."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "      tnp->tn_did_filefind_init = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Copy next file name into buf."], "readability/old_style_comment"]
["src/nvim/tag.c", ["                                             r_ptr, 100,", "                                             FALSE,                   // don't free visited list", "                                             FINDFILE_FILE,           // we search for a file"], "readability/bool"]
["src/nvim/tag.c", ["                                             FINDFILE_FILE,           // we search for a file", "                                             tnp->tn_search_ctx, TRUE, curbuf->b_ffname);", "      if (tnp->tn_search_ctx != NULL) {"], "readability/bool"]
["src/nvim/tag.c", ["      if (tnp->tn_search_ctx != NULL) {", "        tnp->tn_did_filefind_init = TRUE;", "      }"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Free the contents of a tagname_T that was filled by get_tagfname()."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  if (*p != NUL) {", "    ++p;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["  if (*p != NUL) {", "    ++p;", "  }"], "readability/increment"]
["src/nvim/tag.c", ["", "/*", " * Check if tagname is a static tag"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (STRNCMP(p, \"file:\", 5) == 0) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Find out the actual file name of a tag.  Concatenate the tags file name"], "readability/old_style_comment"]
["src/nvim/tag.c", ["  {", "    /*", "     * Remove the \"<Tab>fieldname:value\" stuff; we don't need it here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name, when needed (for environment variables)."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Check if the file with the tag exists before abandoning the current"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  ++RedrawingDisabled;", ""], "readability/increment"]
["src/nvim/tag.c", ["", "    /*", "     * If we are reusing a window, we may change dir when"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (!curwin->w_p_pvw) {", "      full_fname = (char_u *)FullName_save((char *)fname, FALSE);", "      fname = full_fname;"], "readability/bool"]
["src/nvim/tag.c", ["", "      /*", "       * Make the preview window the current window."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If 'cpoptions' contains 't', store the search pattern for the \"n\""], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "    /*", "     * If the command is a search, try here."], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (pbuf[0] == '/' || pbuf[0] == '?') {", "      str = skip_regexp(pbuf + 1, pbuf[0], FALSE, NULL) + 1;", "    }"], "readability/bool"]
["src/nvim/tag.c", ["      p_ws = true;              // need 'wrapscan' for backward searches", "      p_ic = FALSE;             // don't ignore case now", "      p_scs = FALSE;"], "readability/bool"]
["src/nvim/tag.c", ["      p_ic = FALSE;             // don't ignore case now", "      p_scs = FALSE;", "      save_lnum = curwin->w_cursor.lnum;"], "readability/bool"]
["src/nvim/tag.c", ["", "        /*", "         * try again, ignore case now"], "readability/old_style_comment"]
["src/nvim/tag.c", ["        } else {", "          /*", "           * Only give a message when really guessed, not when 'ic'"], "readability/old_style_comment"]
["src/nvim/tag.c", ["    if (retval == OK) {", "      /*", "       * For a help buffer: Put the cursor line at the top of the window,"], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "  /*", "   * Expand file name (for environment variables) when needed."], "readability/old_style_comment"]
["src/nvim/tag.c", ["            MAXPATHL - (p - tag_fname));", "    /*", "     * Translate names like \"src/a/../b/file.c\" into \"src/b/file.c\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["", "/*", " * Check if we have a tag for the buffer with name \"buf_ffname\"."], "readability/old_style_comment"]
["src/nvim/tag.c", ["  int c;", "  int retval = FALSE;", "  char_u *fullname;"], "readability/bool"]
["src/nvim/tag.c", ["", "/*", " * Find the end of the tagaddress."], "readability/old_style_comment"]
["src/nvim/tag.c", ["      while (end > start && (end[-1] == '\\r' || end[-1] == '\\n')) {", "        --end;", "      }"], "readability/increment"]
["src/nvim/tag.c", ["  if (ret == OK && num_matches > 0) {", "    for (i = 0; i < num_matches; ++i) {", "      int parse_result = parse_match(matches[i], &tp);"], "readability/increment"]
["src/nvim/tag.c", ["            while (*p != NUL && *p >= ' ' && *p < 127 && *p != ':') {", "              ++p;", "            }"], "readability/increment"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ') {", "                ++p;", "              }"], "readability/increment"]
["src/nvim/tag.c", ["              while (*p != NUL && *p >= ' ') {", "                ++p;", "              }"], "readability/increment"]

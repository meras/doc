["src/nvim/syntax.c", ["", "/*", " * syntax.c: code for syntax highlighting"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * For the current state we need to remember more than just the idx."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Struct to reduce the number of arguments to get_syn_options(), it's used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Flags for b_syn_sync_flags:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The attributes of the syntax item that has been recognized."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Methods of combining two clusters"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Syntax group IDs have different types:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Annoying Hack(TM):  \":syn include\" needs this pointer to pass to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Another Annoying Hack(TM):  To prevent rules from other \":syn include\"'d"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * In a hashtable item \"hi_key\" points to \"keyword\" in a keyentry."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * To reduce the time spent in keepend(), remember at which level in the state"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The next possible match in the current line for any pattern is remembered,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * A state stack is an array of integers or stateitem_T, stored in a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * The current state (within the line) of the recognition engine."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Start the syntax recognition for a line.  This function is normally called"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * After switching buffers, invalidate current_state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Allocate syntax stack when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the state of the end of the previous line is useful, store it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (!current_state_stored) {", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the current_lnum is now the same as \"lnum\", keep the current"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Try to synchronize from a saved state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If \"lnum\" is before or far beyond a line with a saved state, need to"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Advance from the sync point or saved state until the current line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * We cannot simply discard growarrays full of state_items or buf_states; we"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Cleanup the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try to find a synchronisation point for line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Clear any current state that might be hanging around."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Start at least \"minlines\" back.  Default starting point for parsing is"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * 1. Search backwards for the end of a C-style comment."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Skip lines that end in a backslash."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["     */", "    for (; start_lnum > 1; --start_lnum) {", "      line = ml_get(start_lnum - 1);"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the line is inside a comment, need to find the syntax item that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  /*", "   * 2. Search backwards for given sync patterns."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  else if (syn_block->b_syn_sync_flags & SF_MATCH) {", "    if (syn_block->b_syn_sync_maxlines != 0"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "      /*", "       * Check if the previous line has the line-continuation pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Start with nothing on the state stack"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      for (current_lnum = lnum; current_lnum < end_lnum; ++current_lnum) {", "        syn_start_line();"], "readability/increment"]
["src/nvim/syntax.c", ["            found_m_endpos = cur_si->si_m_endpos;", "            /*", "             * Continue after the match (be aware of a zero-length"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["            } else {", "              ++current_col;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["            if (syn_getcurline()[current_col] != NUL) {", "              ++current_col;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * If a sync point was encountered, break here."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (found_flags) {", "        /*", "         * Put the item that was specified by the sync point on the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * When using \"grouphere\", continue from the sync point"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return TRUE if the line-continuation pattern matches in line \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Prepare the current state for the start of a line."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        cur_si->si_h_endpos = cur_si->si_m_endpos;", "        cur_si->si_ends = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Need to update the end of a start/skip/end that continues from the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (keepend_level >= 0) {", "    for (; i > keepend_level; --i) {", "      if (CUR_STATE(i).si_flags & HL_EXTEND) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * EXPLANATION OF THE SYNTAX STATE STACK CACHE"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["}", "/*", " * Free b_sst_array[] for buffer \"buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Allocate the syntax state stack for syn_buf when needed."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           from = from->sst_next) {", "        ++to;", "        *to = *from;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Check for changes in a buffer to affect stored syntax states.  Uses the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to find the \"tick\" for the oldest entry that can"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Go through the list to make the entries for the oldest tick at an"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Free the allocated memory for a syn_state item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  block->b_sst_firstfree = p;", "  ++block->b_sst_freecount;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Find an entry in the list of state stacks at or before \"lnum\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Try saving the current state in b_sst_array[]."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the current state contains a start or end pattern that continues"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i >= 0; --i) {", "    cur_si = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else if (sp == NULL || sp->sst_lnum != current_lnum) {", "    /*", "     * Add a new entry"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      syn_block->b_sst_firstfree = p->sst_next;", "      --syn_block->b_sst_freecount;", "      if (sp == NULL) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    for (i = 0; i < sp->sst_stacksize; ++i) {", "      bp[i].bs_idx = CUR_STATE(i).si_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Copy a state stack from \"from\" in b_sst_array[] to current_state;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (i = 0; i < from->sst_stacksize; ++i) {", "      CUR_STATE(i).si_idx = bp[i].bs_idx;"], "readability/increment"]
["src/nvim/syntax.c", ["      }", "      CUR_STATE(i).si_ends = FALSE;", "      CUR_STATE(i).si_m_lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * We stop parsing syntax above line \"lnum\".  If the stored state at or below"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * End of handling of the state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check the state stack when:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (sp != NULL && sp->sst_lnum == lnum) {", "      /*", "       * finish the previous line (needed when not all of the line was"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Compare the current state with the previously saved state of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * Store the current state in b_sst_array[] for later use."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["       */", "      ++current_lnum;", "      (void)store_current_state();"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Skip from the current column to \"col\", get the attributes for \"col\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * No character, no attributes!  Past end of line?"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (line[current_col] == NUL && current_col != 0) {", "    /*", "     * If we found a match after the last column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * When in the previous column there was a match but it could not be used"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Repeat matching keywords and patterns, to find contained items at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * 1. Check for a current state."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        || cur_si->si_cont_list != NULL) {", "      /*", "       * 2. Check for keywords, if on a keyword char after a non-keyword"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              cur_si->si_h_endpos.col = endcol;", "              cur_si->si_ends = TRUE;", "              cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "      /*", "       * 3. Check for patterns (only if no keyword found)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (syn_id == 0 && syn_block->b_syn_patterns.ga_len) {", "        /*", "         * If we didn't check for a match yet, or we are past it, check"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (next_match_idx < 0 || next_match_col < (int)current_col) {", "          /*", "           * Check all relevant patterns for a match at this"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                && (current_next_list != NULL", "                           ? in_id_list(NULL, current_next_list,", "                                        &spp->sp_syn, 0)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["                                        &spp->sp_syn, 0)", "                           : (cur_si == NULL", "                              ? !(spp->sp_flags & HL_CONTAINED)"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "              /*", "               * Compute the first column of the match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If a previously found match starts at a lower"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * If we matched this pattern at this position"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * Grab the external submatches before they get"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * For a \"oneline\" the end must be found in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["              }", "              /*", "               * For a \"match\" the size must be > 0 after the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["               */", "              else if (spp->sp_type == SPTYPE_MATCH) {", "                syn_add_end_off(&hl_endpos, &regmatch, spp,"], "whitespace/newline"]
["src/nvim/syntax.c", ["                    && (int)endpos.col + syncing < startcol) {", "                  /*", "                   * If an empty string is matched, may need"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "              /*", "               * keep the best match so far in next_match_*"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "        /*", "         * If we found a match at the current column, use it."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Handle searching for nextgroup match."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (current_next_list != NULL && !keep_next_list) {", "      /*", "       * If a nextgroup was not found, continue looking for one if:"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "      /*", "       * If a nextgroup was found: Use it, and continue looking for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Use attributes from the current state, if within its highlighting."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (cur_si != NULL) {", "    for (int idx = current_state.ga_len - 1; idx >= 0; --idx) {", "      sip = &CUR_STATE(idx);"], "readability/increment"]
["src/nvim/syntax.c", ["", "      /*", "       * set \"can_spell\" to TRUE if spell checking is supposed to be"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Check for end of current state (and the states before it) at the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["          && syn_getcurline()[current_col] != NUL) {", "        ++current_col;", "        check_state_ends();"], "readability/increment"]
["src/nvim/syntax.c", ["        check_state_ends();", "        --current_col;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Push the next match onto the stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Push the item in current_state stack;"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  {", "    /*", "     * If it's a start-skip-end type that crosses lines, figure out how"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_h_endpos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_flags |= next_match_flags;"], "readability/bool"]
["src/nvim/syntax.c", ["    save_flags = cur_si->si_flags & (HL_CONCEAL | HL_CONCEALENDS);", "    /*", "     * If the start pattern has another highlight group, push another item"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      cur_si->si_h_endpos = next_match_eos_pos;", "      cur_si->si_ends = TRUE;", "      cur_si->si_end_idx = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Check for end of current state (and the states before it)."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["                && cur_si->si_m_endpos.col <= current_col))) {", "      /*", "       * If there is an end pattern group ID, highlight the end pattern"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Update an entry in the current_state stack for a match or region.  This"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * For transparent items, take attr from outer item."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Check the current stack for patterns with \"keepend\" flag."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * This check can consume a lot of time; only do it from the level where"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the last index of an \"extend\" item.  \"keepend\" items before that"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (i = current_state.ga_len - 1; i > keepend_level; --i) {", "    if (CUR_STATE(i).si_flags & HL_EXTEND) {"], "readability/increment"]
["src/nvim/syntax.c", ["  maxpos_h.col = 0;", "  for (; i < current_state.ga_len; ++i) {", "    sip = &CUR_STATE(i);"], "readability/increment"]
["src/nvim/syntax.c", ["      limit_pos_zero(&sip->si_eoe_pos, &maxpos);", "      sip->si_ends = TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * We need to find the end of the region.  It may continue in the next"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      // a \"oneline\" never continues in the next line", "      sip->si_ends = TRUE;", "      sip->si_m_endpos.lnum = current_lnum;"], "readability/bool"]
["src/nvim/syntax.c", ["      // continues in the next line", "      sip->si_ends = FALSE;", "      sip->si_m_endpos.lnum = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["    sip->si_eoe_pos = end_endpos;", "    sip->si_ends = TRUE;", "    sip->si_end_idx = end_idx;"], "readability/bool"]
["src/nvim/syntax.c", ["", "/*", " * Add a new state to the current state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove a state from the current_state stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    unref_extmatch(CUR_STATE(current_state.ga_len - 1).si_extmatch);", "    --current_state.ga_len;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for being called with a START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Find the SKIP or first END pattern after the last START pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    ++idx;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   *    Lookup the SKIP pattern (if present)"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    spp_skip = spp;", "    ++idx;", "  } else {"], "readability/increment"]
["src/nvim/syntax.c", ["  for (;;) {", "    /*", "     * Find end pattern that matches first after \"matchcol\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    best_idx = -1;", "    for (idx = start_idx; idx < syn_block->b_syn_patterns.ga_len; ++idx) {", "      int lc_col = matchcol;"], "readability/increment"]
["src/nvim/syntax.c", ["", "    /*", "     * If all end patterns have been tried, and there is no match, the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the skip pattern matches before the end pattern,"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Match from start pattern to end pattern."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * If the end group is highlighted differently, adjust the pointers."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Limit \"pos\" not to be after \"limit\", unless pos->lnum is zero."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get current line in syntax buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Call vim_regexec() to find a match with \"rmp\" in \"syn_buf\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    ++st->count;", "    if (r > 0) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (r > 0) {", "      ++st->match;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["    rmp->endpos[0].lnum += lnum;", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["          : (cur_si == NULL", "            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,"], "whitespace/alignment"]
["src/nvim/syntax.c", ["            ? !(kp->flags & HL_CONTAINED)", "            : in_id_list(cur_si, cur_si->si_cont_list,", "                         &kp->k_syn, kp->flags & HL_CONTAINED))) {"], "whitespace/alignment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax conceal\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax case\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    case SYNFLD_START:", "      msg(\"syntax foldlevel start\");   break;", "    case SYNFLD_MINIMUM:"], "whitespace/newline"]
["src/nvim/syntax.c", ["    case SYNFLD_MINIMUM:", "      msg(\"syntax foldlevel minimum\"); break;", "    default:"], "whitespace/newline"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax spell\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear all syntax info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get rid of ownsyntax for window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear syncing info for one buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Remove one pattern from the buffer's pattern list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (spp->sp_flags & HL_FOLD) {", "    --block->b_syn_folditems;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["          sizeof(synpat_T) * (block->b_syn_patterns.ga_len - idx - 1));", "  --block->b_syn_patterns.ga_len;", "}"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax pattern.  When clearing all, must be called from"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear and free one syntax cluster."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax clear\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * We have to disable this within \":syn include @group filename\","], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: Clear all syntax items."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * Clear the group IDs that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear one syntax group for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax on\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax reset\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax manual\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax off\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg)) {", "    /*", "     * No argument: List all group IDs and all syntax clusters."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    }", "    for (int id = 0; id < curwin->w_s->b_syn_clusters.ga_len && !got_int; ++id) {", "      syn_list_cluster(id);"], "readability/increment"]
["src/nvim/syntax.c", ["  } else {", "    /*", "     * List the group IDs and syntax clusters that are in the argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  static struct name_list namelist1[] =", "  {", "    { HL_DISPLAY, \"display\" },"], "whitespace/braces"]
["src/nvim/syntax.c", ["  static struct name_list namelist2[] =", "  {", "    { HL_SKIPWHITE, \"skipwhite\" },"], "whitespace/braces"]
["src/nvim/syntax.c", ["      }", "      --idx;", "      msg_putchar(' ');"], "readability/increment"]
["src/nvim/syntax.c", ["", "  for (i = 0; nlist[i].flag != 0; ++i) {", "    if (flags & nlist[i].flag) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * List one syntax cluster, for \":syntax\" or \"syntax list syntax_name\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    }", "    --todo;", "    kp_prev = NULL;"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Clear a whole keyword table."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  todo = (int)ht->ht_used;", "  for (hi = ht->ht_array; todo > 0; ++hi) {", "    if (!HASHITEM_EMPTY(hi)) {"], "readability/increment"]
["src/nvim/syntax.c", ["    if (!HASHITEM_EMPTY(hi)) {", "      --todo;", "      for (kp = HI2KE(hi); kp != NULL; kp = kp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["  if (cont_in_list != NULL) {", "    curwin->w_s->b_syn_containedin = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check if there are enough arguments.  The first argument may be a"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  for (;;) {", "    /*", "     * This is used very often when a large number of keywords is defined."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Adjustments to syntax item when declared in a \":syn include\"'d file."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax include [@{group-name}] filename\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (arg[0] == '@') {", "    ++arg;", "    rest = get_group_name(arg, &group_name_end);"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Everything that's left, up to the next command, should be the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Save and restore the existing top-level grouplist id and \":syn"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax keyword {group-name} [{option}] keyword ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {           // all arguments are valid", "    /*", "     * Check for trailing command and illegal trailing arguments."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the pattern in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.cont_in_list != NULL) {", "          curwin->w_s->b_syn_containedin = TRUE;", "        }"], "readability/bool"]
["src/nvim/syntax.c", ["        if (syn_opt_arg.flags & HL_FOLD) {", "          ++curwin->w_s->b_syn_folditems;", "        }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Something failed, free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*key_end && !ascii_iswhite(*key_end) && *key_end != '=') {", "      ++key_end;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["    } else {", "      /*", "       * Allocate room for a syn_pattern, and link it in the list of"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (rest != NULL) {", "    /*", "     * Check for trailing garbage or command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        syn_incl_toplevel(syn_id, &syn_opt_arg.flags);", "        /*", "         * Store the start/skip/end in the syn_items list"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["        int idx = curwin->w_s->b_syn_patterns.ga_len;", "        for (item = ITEM_START; item <= ITEM_END; ++item) {", "          for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp->pp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["              if (syn_opt_arg.cont_in_list != NULL) {", "                curwin->w_s->b_syn_containedin = TRUE;", "              }"], "readability/bool"]
["src/nvim/syntax.c", ["            }", "            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;"], "readability/increment"]
["src/nvim/syntax.c", ["            ++curwin->w_s->b_syn_patterns.ga_len;", "            ++idx;", "            if (syn_opt_arg.flags & HL_FOLD) {"], "readability/increment"]
["src/nvim/syntax.c", ["            if (syn_opt_arg.flags & HL_FOLD) {", "              ++curwin->w_s->b_syn_folditems;", "            }"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Free the allocated memory."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  for (item = ITEM_START; item <= ITEM_END; ++item) {", "    for (ppp = pat_ptrs[item]; ppp != NULL; ppp = ppp_next) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "  /*", "   * Handle degenerate cases."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * First, loop through the lists until one of them is empty."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    while (*g1 && *g2) {", "      /*", "       * We always want to add from the first list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      }", "      /*", "       * We only want to add from the second list if we're adding the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "    /*", "     * Now add the leftovers from whichever list didn't get finished"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["    if (round == 1) {", "      /*", "       * If the group ended up empty, we don't need to allocate any"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * Finally, put the new list in place."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Like syn_scl_name2id(), but take a pointer + length argument."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["{", "  /*", "   * First call for this growarray: init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax cluster {cluster-name} [contains={groupname},..]"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * On first call for current buffer: Init growing array."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get one pattern for a \":syntax match\" or \":syntax region\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  end = skip_regexp(arg + 1, *arg, TRUE, NULL);", "  if (*end != *arg) {                       // end delimiter not found"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Check for a match, highlight or region offset."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["   */", "  ++end;", "  do {"], "readability/increment"]
["src/nvim/syntax.c", ["        case 'e':", "          idx += SPO_COUNT; break;", "        default:"], "whitespace/newline"]
["src/nvim/syntax.c", ["        default:", "          idx = -1; break;", "        }"], "whitespace/newline"]
["src/nvim/syntax.c", ["        }", "        ++end;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Handle \":syntax sync ..\" command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  char_u *next_arg;", "  int illegal = FALSE;", "  int finished = FALSE;"], "readability/bool"]
["src/nvim/syntax.c", ["  int illegal = FALSE;", "  int finished = FALSE;", "  long n;"], "readability/bool"]
["src/nvim/syntax.c", ["  if (ends_excmd(*arg_start)) {", "    syn_cmd_list(eap, TRUE);", "    return;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (arg_end[-1] != '=' || !ascii_isdigit(*arg_end)) {", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["        emsg(_(\"E403: syntax sync: line continuations pattern specified twice\"));", "        finished = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      arg_end = skip_regexp(next_arg + 1, *next_arg, TRUE, NULL);", "      if (*arg_end != *next_arg) {          // end delimiter not found"], "readability/bool"]
["src/nvim/syntax.c", ["      if (*arg_end != *next_arg) {          // end delimiter not found", "        illegal = TRUE;", "        break;"], "readability/bool"]
["src/nvim/syntax.c", ["      if (STRCMP(key, \"MATCH\") == 0) {", "        syn_cmd_match(eap, TRUE);", "      } else if (STRCMP(key, \"REGION\") == 0) {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else if (STRCMP(key, \"REGION\") == 0) {", "        syn_cmd_region(eap, TRUE);", "      } else if (STRCMP(key, \"CLEAR\") == 0) {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else if (STRCMP(key, \"CLEAR\") == 0) {", "        syn_cmd_clear(eap, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/syntax.c", ["      } else {", "        illegal = TRUE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      }", "      finished = TRUE;", "      break;"], "readability/bool"]
["src/nvim/syntax.c", ["      } else {", "        /*", "         * Handle full group name."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "          regmatch.rm_ic = TRUE;", "          id = 0;"], "readability/bool"]
["src/nvim/syntax.c", ["        }", "        ++count;", "      }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Make a copy of an ID list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["           && cur_si > (stateitem_T *)(current_state.ga_data)) {", "      --cur_si;", "    }"], "readability/increment"]
["src/nvim/syntax.c", ["                                          HL_CONTAINED)) {", "      return TRUE;", "    }"], "readability/bool"]
["src/nvim/syntax.c", ["  if (list == NULL) {", "    return FALSE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * If list is ID_LIST_ALL, we are in a transparent item that isn't"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "  /*", "   * If the first item is \"ALLBUT\", return TRUE if \"id\" is NOT in the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (item - SYNID_ALLBUT != ssp->inc_tag) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_TOP != ssp->inc_tag || contained) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["      if (item - SYNID_CONTAINED != ssp->inc_tag || !contained) {", "        return FALSE;", "      }"], "readability/bool"]
["src/nvim/syntax.c", ["    item = *++list;", "    retval = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/syntax.c", ["  } else {", "    retval = TRUE;", "  }"], "readability/bool"]
["src/nvim/syntax.c", ["", "  /*", "   * Return \"retval\" if id is in the contains list."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["      if (scl_list != NULL && depth < 30) {", "        ++depth;", "        r = in_id_list(NULL, scl_list, ssp, contained);"], "readability/increment"]
["src/nvim/syntax.c", ["        r = in_id_list(NULL, scl_list, ssp, contained);", "        --depth;", "        if (r) {"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntax\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  if (eap->skip) {", "    --emsg_skip;", "  }"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Reset include_link, include_default, include_none to 0."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :match and :echohl command: Add \"None\""], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Handle command line completion for :syntax command."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the list syntax names for"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Get extra information about the syntax item.  Must be called right after"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return conceal substitution character"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Return the syntax ID at position \"i\" in the current stack."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Function called to get folding level for line \"lnum\" in window \"wp\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * \":syntime\"."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  }", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["", "/*", " * Function given to ExpandGeneric() to obtain the possible arguments of the"], "readability/old_style_comment"]
["src/nvim/syntax.c", ["", "/*", " * Clear the syntax timing for the current buffer."], "readability/old_style_comment"]
["src/nvim/syntax.c", ["  time_entry_T *p;", "  for (int idx = 0; idx < curwin->w_s->b_syn_patterns.ga_len; ++idx) {", "    synpat_T *spp = &(SYN_ITEMS(curwin->w_s)[idx]);"], "readability/increment"]
["src/nvim/syntax.c", ["  msg_puts(\"\\n\");", "  for (int idx = 0; idx < ga.ga_len && !got_int; ++idx) {", "    p = ((time_entry_T *)ga.ga_data) + idx;"], "readability/increment"]

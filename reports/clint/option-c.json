["src/nvim/option.c", ["", "/*", " * The options that are local to a window or buffer have \"indir\" set to one of"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Options local to a window have a value local to a buffer and global to all"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * These are the global values for options which are also local to a buffer."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * Flags"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "/*", " * options[] is initialized here."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Find default value for 'shell' option."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Set the default for 'backupskip' to include environment variables for"], "readability/old_style_comment"]
["src/nvim/option.c", ["        mustfree = false;", "      } else", "#endif"], "readability/braces"]
["src/nvim/option.c", ["", "  /*", "   * Set all the options (except the terminal options) to their default"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expand environment variables and things like \"~\" for the defaults."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * 'window' is only for backwards compatibility with Vi."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * If GUI is (going to be) used, we can always set the window title and"], "readability/old_style_comment"]
["src/nvim/option.c", ["        && !(opt_flags & OPT_MODELINE)) {", "      /*", "       * \":set all\"  show all options."], "readability/old_style_comment"]
["src/nvim/option.c", ["              && !(flags & P_BOOL))) {", "        /*", "         * print value"], "readability/old_style_comment"]
["src/nvim/option.c", ["              option_last_set_msg(curwin->w_p_script_ctx[", "                                                         (int)options[opt_idx].indir & PV_MASK]);", "            } else if ((int)options[opt_idx].indir & PV_BUF) {"], "whitespace/indent"]
["src/nvim/option.c", ["              option_last_set_msg(curbuf->b_p_script_ctx[", "                                                         (int)options[opt_idx].indir & PV_MASK]);", "            }"], "whitespace/indent"]
["src/nvim/option.c", ["", "          /*", "           * \":set opt!\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["          } else {", "            /*", "             * \":set invopt\": invert"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Set 'keywordprg' to \":help\" if an empty"], "readability/old_style_comment"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'backspace' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_bs", "                       && ascii_isdigit(**(char_u **)varp)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Convert 'whichwrap' number to string, for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (varp == (char_u *)&p_ww", "                       && ascii_isdigit(*arg)) {"], "whitespace/newline"]
["src/nvim/option.c", ["              }", "              /*", "               * Remove '>' before 'dir' and 'bdir', for"], "readability/old_style_comment"]
["src/nvim/option.c", ["               */", "              else if (*arg == '>'", "                       && (varp == (char_u *)&p_dir"], "whitespace/newline"]
["src/nvim/option.c", ["", "              /*", "               * Copy the new string into allocated memory."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Copy the string, skip over escaped chars."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "              /*", "               * Expand environment variables and ~."], "readability/old_style_comment"]
["src/nvim/option.c", ["skip:", "      /*", "       * Advance to next argument."], "readability/old_style_comment"]
["src/nvim/option.c", ["{", "  /*", "   * The option values that are changed when 'bin' changes are"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Expanding this with NameBuff, expand_env() must not be passed IObuff."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /* When setting both values of a global option with a local value,", "    * make the local value empty, so that the global value is used. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                                              ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "       ? (((int)options[opt_idx].indir & PV_BOTH)", "          ? OPT_GLOBAL : OPT_LOCAL)"], "whitespace/alignment"]
["src/nvim/option.c", ["          ? OPT_GLOBAL : OPT_LOCAL)", "          : opt_flags));", "  char *const oldval = *varp;"], "whitespace/alignment"]
["src/nvim/option.c", ["                                              ((opt_flags & (OPT_LOCAL | OPT_GLOBAL)) == 0", "       ? (((int)options[opt_idx].indir & PV_BOTH)", "          ? OPT_GLOBAL : OPT_LOCAL)"], "whitespace/alignment"]
["src/nvim/option.c", ["          ? OPT_GLOBAL : OPT_LOCAL)", "          : opt_flags));", "  char *const oldval = *varp;"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /* Get the global option to compare with, otherwise we would have to check", "   * two values for all local options. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["      ml_setflags(curbuf);", "      /* Redraw needed when switching to/from \"mac\": a CR in the text", "       * will be displayed differently. */"], "readability/old_style_comment"]
["src/nvim/option.c", ["                  : shada_idx)", "                  : opt_idx);", "    // Update free_oldval now that we have the opt_idx for 'shada', otherwise"], "whitespace/alignment"]
["src/nvim/option.c", ["", "  /*", "   * If error detected, restore the previous value."], "readability/old_style_comment"]
["src/nvim/option.c", ["    *varp = oldval;", "    /*", "     * When resetting some values, need to act on it."], "readability/old_style_comment"]
["src/nvim/option.c", ["        && ((int)options[opt_idx].indir & PV_BOTH)) {", "      /* global option with local value set to use global value; free", "       * the local value and make it empty */"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * Trigger the autocommand only after setting the flags."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Source the spell/LANG.vim in 'runtimepath'."], "readability/old_style_comment"]
["src/nvim/option.c", ["    wp->w_p_cc_cols = xmalloc(sizeof(int) * (count + 1));", "    /* sort the columns for faster usage on screen redraw inside", "     * win_line() */"], "readability/old_style_comment"]
["src/nvim/option.c", ["#ifdef BACKSLASH_IN_FILENAME", "  else if ((int *)varp == &p_ssl) {", "    if (p_ssl) {"], "readability/braces"]
["src/nvim/option.c", ["#endif", "  else if ((int *)varp == &curwin->w_p_wrap) {", "    // If 'wrap' is set, set w_leftcol to zero."], "readability/braces"]
["src/nvim/option.c", ["    if (curwin->w_p_arab) {", "      /*", "       * 'arabic' is set, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["    } else {", "      /*", "       * 'arabic' is reset, handle various sub-settings."], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * End of handling side effects for bool options."], "readability/old_style_comment"]
["src/nvim/option.c", ["    p = options[0].fullname;", "    for (short int i = 1; (s = options[i].fullname) != NULL; i++) {", "      if (s[0] != p[0]) {"], "runtime/int"]
["src/nvim/option.c", ["  } else {", "    *numval = (long)*(int *)varp;  // NOLINT(whitespace/cast)", "  }"], "whitespace/operators"]
["src/nvim/option.c", ["", "    /*", "     * display the items"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * Some options are never written:"], "readability/old_style_comment"]
["src/nvim/option.c", ["  switch ((int)p->indir)", "  {", "  // global option with local value: use local value if it's been set"], "whitespace/braces"]
["src/nvim/option.c", ["", "  /*", "   * Skip this when the option defaults have not been set yet.  Happens when"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "      /*", "       * Don't copy the options set by ex_help(), use the saved values,"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "    /*", "     * When the options should be copied (ignoring BCO_ALWAYS), set the"], "readability/old_style_comment"]
["src/nvim/option.c", ["", "  /*", "   * For a terminal key code expand_option_idx is < 0."], "readability/old_style_comment"]
["src/nvim/option.c", ["               \"%\" PRId64,", "               (int64_t)*(long *)varp);", "    }"], "whitespace/operators"]
["src/nvim/option.c", ["  if (p_paste) {", "    /*", "     * Paste switched from off to on."], "readability/old_style_comment"]
["src/nvim/option.c", ["  char_u *p = wp->w_p_briopt;", "  while (*p != NUL)", "  {"], "readability/braces"]
["src/nvim/option.c", ["  while (*p != NUL)", "  {", "    if (STRNCMP(p, \"shift:\", 6) == 0"], "whitespace/braces"]
["src/nvim/option.c", ["  } else {", "    type = \"\"; def = NIL;", "  }"], "whitespace/newline"]

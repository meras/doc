["src/nvim/lib/kbtree.h", ["// marker so line numbers and indices both start at 1", "/*-", " * Copyright 1997-1999, 2001, John-Mark Gurney."], "readability/old_style_comment"]
["src/nvim/lib/kbtree.h", ["    bool is_internal; \\", "    key_t key[2*T - 1]; \\", "    kbnode_##name##_t *ptr[]; \\"], "whitespace/operators"]
["src/nvim/lib/kbtree.h", ["   x = *--top; \\", "   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\", "   if (__KB_PTR(b, x)[i]) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["   if (x->is_internal == 0) { XFREE_CLEAR(x); continue; } \\", "   for (i = 0; i <= x->n; ++i) \\", "   if (__KB_PTR(b, x)[i]) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    int tr, *rr, begin = 0, end = x->n; \\", "    if (x->n == 0) return -1; \\", "    rr = r? r : &tr; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      int mid = (begin + end) >> 1; \\", "      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (__cmp(__KB_KEY(key_t, x)[mid], *k) < 0) begin = mid + 1; \\", "      else end = mid; \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    } \\", "    if (begin == x->n) { *rr = 1; return x->n - 1; } \\", "    if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    if (begin == x->n) { *rr = 1; return x->n - 1; } \\", "    if ((*rr = __cmp(*k, __KB_KEY(key_t, x)[begin])) < 0) --begin; \\", "    return begin; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = __kb_getp_aux_##name(x, k, &r); \\", "      if (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i]; \\", "      if (x->is_internal == 0) return 0; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0 && r == 0) return &__KB_KEY(key_t, x)[i]; \\", "      if (x->is_internal == 0) return 0; \\", "      x = __KB_PTR(b, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      } \\", "      if (i >= 0) *lower = &__KB_KEY(key_t, x)[i]; \\", "      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0) *lower = &__KB_KEY(key_t, x)[i]; \\", "      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\", "      if (x->is_internal == 0) return; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i < x->n - 1) *upper = &__KB_KEY(key_t, x)[i + 1]; \\", "      if (x->is_internal == 0) return; \\", "      x = __KB_PTR(b, x)[i + 1]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    z = (kbnode_t *)xcalloc(1, y->is_internal? ILEN : sizeof(kbnode_##name##_t)); \\", "    ++b->n_nodes; \\", "    z->is_internal = y->is_internal; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    memcpy(__KB_KEY(key_t, z), &__KB_KEY(key_t, y)[T], sizeof(key_t) * (T - 1)); \\", "    if (y->is_internal) memcpy(__KB_PTR(b, z), &__KB_PTR(b, y)[T], sizeof(void *) * T); \\", "    y->n = T - 1; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[T - 1]; \\", "    ++x->n; \\", "  } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      i = __kb_getp_aux_##name(x, k, 0); \\", "      if (i != x->n - 1) \\", "      memmove(&__KB_KEY(key_t, x)[i + 2], &__KB_KEY(key_t, \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      *ret = *k; \\", "      ++x->n; \\", "    } else { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        __kb_split_##name(b, x, i, __KB_PTR(b, x)[i]); \\", "        if (__cmp(*k, __KB_KEY(key_t, x)[i]) > 0) ++i; \\", "      } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      b->root = (kbnode_t *)xcalloc(1, ILEN); \\", "      ++b->n_nodes; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    kbnode_t *r, *s; \\", "    ++b->n_keys; \\", "    r = b->root; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    if (r->n == 2 * T - 1) { \\", "      ++b->n_nodes; \\", "      s = (kbnode_t *)xcalloc(1, ILEN); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      s = (kbnode_t *)xcalloc(1, ILEN); \\", "      b->root = s; s->is_internal = 1; s->n = 0; \\", "      __KB_PTR(b, s)[0] = r; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    key_t kp; \\", "    if (x == 0) return *k; \\", "    if (s) {  /* s can only be 0, 1 or 2 */ \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = s == 1? x->n - 1 : -1; \\", "    } else i = __kb_getp_aux_##name(x, k, &r); \\", "    if (x->is_internal == 0) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      i = s == 1? x->n - 1 : -1; \\", "    } else i = __kb_getp_aux_##name(x, k, &r); \\", "    if (x->is_internal == 0) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["    if (x->is_internal == 0) { \\", "      if (s == 2) ++i; \\", "      kp = __KB_KEY(key_t, x)[i]; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["              (unsigned int)(x->n - i - 1) * sizeof(key_t)); \\", "      --x->n; \\", "      return kp; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } else if (yn == T - 1 && zn == T - 1) { \\", "        y = __KB_PTR(b, x)[i]; z = __KB_PTR(b, x)[i + 1]; \\", "        __KB_KEY(key_t, y)[y->n++] = *k; \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["        memmove(&__KB_KEY(key_t, y)[y->n], __KB_KEY(key_t, z), (unsigned int)z->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, \\", "                                                                    z), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)(x->n - i - 1) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(z); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    } \\", "    ++i; \\", "    if ((xp = __KB_PTR(b, x)[i])->n == T - 1) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        memmove(&__KB_KEY(key_t, xp)[1], __KB_KEY(key_t, xp), (unsigned int)xp->n * sizeof(key_t)); \\", "        if (xp->is_internal) memmove(&__KB_PTR(b, xp)[1], __KB_PTR(b, \\", "                                                                   xp), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        __KB_KEY(key_t, x)[i - 1] = __KB_KEY(key_t, y)[y->n - 1]; \\", "        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\", "      } else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[0] = __KB_PTR(b, y)[y->n]; \\", "        --y->n; ++xp->n; \\", "      } else if (i < x->n && (y = __KB_PTR(b, x)[i + 1])->n >= T) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        __KB_KEY(key_t, x)[i] = __KB_KEY(key_t, y)[0]; \\", "        if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "        --y->n; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        if (xp->is_internal) __KB_PTR(b, xp)[xp->n] = __KB_PTR(b, y)[0]; \\", "        --y->n; \\", "        memmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        memmove(__KB_KEY(key_t, y), &__KB_KEY(key_t, y)[1], (unsigned int)y->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(__KB_PTR(b, y), &__KB_PTR(b, \\", "                                                              y)[1], \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)xp->n * sizeof(key_t)); \\", "        if (y->is_internal) memmove(&__KB_PTR(b, y)[y->n], __KB_PTR(b, \\", "                                                                    xp), \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                                              x)[i + 1], (unsigned int)(x->n - i) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(xp); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)y->n * sizeof(key_t)); \\", "        if (xp->is_internal) memmove(&__KB_PTR(b, xp)[xp->n], __KB_PTR(b, y), \\", "                                     (unsigned int)(y->n + 1) * sizeof(void *)); \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["                (unsigned int)(x->n - i - 1) * sizeof(void *)); \\", "        --x->n; \\", "        XFREE_CLEAR(y); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    ret = __kb_delp_aux_##name(b, b->root, k, 0); \\", "    --b->n_keys; \\", "    if (b->root->n == 0 && b->root->is_internal) { \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    if (b->root->n == 0 && b->root->is_internal) { \\", "      --b->n_nodes; \\", "      x = b->root; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["    itr->p = NULL; \\", "    if (b->n_keys == 0) return; \\", "    itr->p = itr->stack; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    itr->p = itr->stack; \\", "    itr->p->x = b->root; itr->p->i = 0; \\", "    while (itr->p->x->is_internal && __KB_PTR(b, itr->p->x)[0] != 0) { \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["      kbnode_t *x = itr->p->x; \\", "      ++itr->p; \\", "      itr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      ++itr->p; \\", "      itr->p->x = __KB_PTR(b, x)[0]; itr->p->i = 0; \\", "    } \\"], "whitespace/newline"]
["src/nvim/lib/kbtree.h", ["  { \\", "    if (itr->p == NULL) return 0; \\", "    for (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["    for (;;) { \\", "      ++itr->p->i; \\", "      assert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["        itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[itr->p->i] : 0; \\", "        ++itr->p; \\", "      } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } \\", "      --itr->p; \\", "      if (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p; \\", "      if (itr->p->x && itr->p->i < itr->p->x->n) return 1; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["  { \\", "    if (itr->p == NULL) return 0; \\", "    for (;;) { \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["        itr->p[1].i = itr->p[1].x ? itr->p[1].x->n : -1; \\", "        ++itr->p; \\", "      } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      } \\", "      --itr->p; \\", "      --itr->p->i; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p; \\", "      --itr->p->i; \\", "      if (itr->p->x && itr->p->i >= 0) return 1; \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      --itr->p->i; \\", "      if (itr->p->x && itr->p->i >= 0) return 1; \\", "    } \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      itr->p->i = i; \\", "      if (i >= 0 && r == 0) return 1; \\", "      ++itr->p->i; \\"], "readability/braces"]
["src/nvim/lib/kbtree.h", ["      if (i >= 0 && r == 0) return 1; \\", "      ++itr->p->i; \\", "      assert(itr->p->i <= 21); \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["      itr->p[1].x = itr->p->x->is_internal? __KB_PTR(b, itr->p->x)[i + 1] : 0; \\", "      ++itr->p; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/kbtree.h", ["  KBTREE_INIT_IMPL(name, key_t, kbnode_##name##_t, __cmp, T, \\", "                   (sizeof(kbnode_##name##_t) + (2*T)*sizeof(void *)))", ""], "whitespace/operators"]

["src/nvim/ex_eval.c", ["", "/*", " * When several errors appear in a row, setting \"force_abort\" is delayed until"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", [" */", "static int cause_abort = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Do nothing when displaying the interrupt message or reporting an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If emsg() has not been called previously, temporarily reset"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    cause_abort = force_abort;", "    force_abort = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * If no try conditional is active and no exception is being thrown and"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ignore an interrupt message when inside a try conditional or when an"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  cause_abort = TRUE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * When an exception is being thrown, some commands (like conditionals) are"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (!THROW_ON_ERROR) {", "    /*", "     * Print error message immediately without searching for a matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  {", "    /*", "     * Prepare the throw of an error exception, so that everything will"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["{", "  /*", "   * Ensure that all commands in nested function calls and sourced files"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (cause_abort) {", "    cause_abort = FALSE;", "    force_abort = TRUE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    cause_abort = FALSE;", "    force_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    } else {", "      need_rethrow = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Disallow faking Interrupt or error exceptions as user exceptions.  They"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    --no_wait_return;", "    if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    smsg(was_finished ? _(\"Exception finished: %s\")", "                      : _(\"Exception discarded: %s\"),", "         excp->value);"], "whitespace/alignment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0) {", "      msg_silent = FALSE;               // display messages", "    } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    ++no_wait_return;", "    if (debug_break_level > 0 || *p_vfile == NUL) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (debug_break_level > 0 || *p_vfile == NUL) {", "      msg_scroll = TRUE;            // always scroll up, don't overwrite", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["    }", "    --no_wait_return;", "    if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "/*", " * Flags specifying the message displayed by report_pending."], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  if (debug_break_level > 0) {", "    msg_silent = FALSE;         // display messages", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  ++no_wait_return;", "  msg_scroll = TRUE;            // always scroll up, don't overwrite"], "readability/increment"]
["src/nvim/ex_eval.c", ["  ++no_wait_return;", "  msg_scroll = TRUE;            // always scroll up, don't overwrite", "  smsg(mesg, s);"], "readability/bool"]
["src/nvim/ex_eval.c", ["  cmdline_row = msg_row;", "  --no_wait_return;", "  if (debug_break_level > 0) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["  } else {", "    ++cstack->cs_idx;", "    cstack->cs_flags[cstack->cs_idx] = 0;"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "    --eap->cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["  } else {", "    /*", "     * The loop flag is set when we have jumped back from the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if ((cstack->cs_lflags & CSL_HAD_LOOP) == 0) {", "      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["      ++cstack->cs_idx;", "      ++cstack->cs_looplevel;", "      cstack->cs_line[cstack->cs_idx] = -1;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (eap->cmdidx == CMD_while) {", "      /*", "       * \":while bool-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":for var in list-expr\""], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        fi = cstack->cs_forinfo[cstack->cs_idx];", "        error = FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_eval.c", ["      } else {", "        result = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If this cstack entry was just initialised and is active, set the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_CONT, so do_cmdline() will jump back to the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      // Try to find the matching \":while\" and report what's missing.", "      for (idx = cstack->cs_idx; idx > 0; --idx) {", "        fl =  cstack->cs_flags[idx];"], "readability/increment"]
["src/nvim/ex_eval.c", ["      // Cleanup and rewind all contained (and unclosed) conditionals.", "      (void)cleanup_conditionals(cstack, CSF_WHILE | CSF_FOR, FALSE);", "      rewind_conditionals(cstack, idx, CSF_TRY, &cstack->cs_trylevel);"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Set loop flag, so do_cmdline() will jump back to the matching"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  int idx;", "  int inactivate_try = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (did_emsg && !THROW_ON_ERROR) {", "    inactivate_try = TRUE;", "    did_emsg = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (got_int && !THROW_ON_INTERRUPT) {", "    inactivate_try = TRUE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["    inactivate_try = TRUE;", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  if (idx >= 0) {", "    /*", "     * If this try conditional is active and we are before its first"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["  } else {", "    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;"], "readability/increment"]
["src/nvim/ex_eval.c", ["    ++cstack->cs_idx;", "    ++cstack->cs_trylevel;", "    cstack->cs_flags[cstack->cs_idx] = CSF_TRY;"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * \":silent!\", even when used in a try conditional, disables"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    }", "    for (idx = cstack->cs_idx; idx > 0; --idx) {", "      if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["  if (!give_up) {", "    /*", "     * Don't do something when no exception has been thrown or when the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Check for a match only if an exception is thrown but not caught by"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    } else {", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, TRUE);", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int idx;", "  int skip = FALSE;", "  int pending = CSTP_NONE;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      eap->errmsg = get_end_emsg(cstack);", "      for (idx = cstack->cs_idx - 1; idx > 0; --idx) {", "        if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Don't do something when the corresponding try block never got active"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If there is a preceding catch clause and it caught the exception,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["       */", "      cleanup_conditionals(cstack, CSF_TRY, FALSE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Make did_emsg, got_int, current_exception pending.  If set, they"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Set CSL_HAD_FINA, so do_cmdline() will reset did_emsg,"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If an exception is being thrown, discard it to prevent it from"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * If we stopped with the exception currently being thrown at this"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * If a \":return\" is pending, we need to resume it after closing the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "    /*", "     * Discard anything pending on an error, interrupt, or throw in the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["     */", "    (void)cleanup_conditionals(cstack, CSF_TRY | CSF_SILENT, TRUE);", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_RETURN:", "        do_return(eap, FALSE, FALSE, rettv);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["      case CSTP_FINISH:", "        do_finish(eap, FALSE);", "        break;"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "/*", " * enter_cleanup() and leave_cleanup()"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "  /*", "   * Postpone did_emsg, got_int, current_exception.  The pending values will be"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["        force_abort |= cause_abort;", "        cause_abort = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  /*", "   * If there was no new error, interrupt, or throw between the calls"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "whitespace/newline"]
["src/nvim/ex_eval.c", ["   */", "  else {", "    /*"], "readability/braces"]
["src/nvim/ex_eval.c", ["  else {", "    /*", "     * If there was an exception being thrown when enter_cleanup() was"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["      cause_abort = force_abort;", "      force_abort = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  int idx;", "  int stop = FALSE;", ""], "readability/bool"]
["src/nvim/ex_eval.c", ["", "  for (idx = cstack->cs_idx; idx >= 0; --idx) {", "    if (cstack->cs_flags[idx] & CSF_TRY) {"], "readability/increment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[idx] & CSF_TRY) {", "      /*", "       * Discard anything pending in a finally clause and continue the"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["", "      /*", "       * Stop at a try conditional not in its finally clause.  If this try"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["          }", "          stop = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_eval.c", ["      }", "      stop = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_eval.c", ["", "    /*", "     * When leaving a try conditional that reset \"emsg_silent\" on its"], "readability/old_style_comment"]
["src/nvim/ex_eval.c", ["    if (cstack->cs_flags[cstack->cs_idx] & cond_type) {", "      --*cond_level;", "    }"], "readability/increment"]
["src/nvim/ex_eval.c", ["    }", "    --cstack->cs_idx;", "  }"], "readability/increment"]
["src/nvim/ex_eval.c", ["    while (*p == ' ' || *p == '\\t' || *p == ':') {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_eval.c", ["      || (p[0] == 'f' && p[1] == 'o' && p[2] == 'r')) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_eval.c", ["  }", "  return FALSE;", "}"], "readability/bool"]

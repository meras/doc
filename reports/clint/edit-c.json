["src/nvim/edit.c", ["", "/*", " * edit.c: functions for Insert mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Structure used to store one match for insert completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * All the current matches are stored in a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* After using a cursor key <Enter> selects a match in the popup menu,", " * otherwise it inserts a line break. */"], "readability/old_style_comment"]
["src/nvim/edit.c", [" * otherwise it inserts a line break. */", "static int compl_enter_selects = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/* When \"compl_leader\" is not NULL only matches that start with this string", " * are used. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_insert = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert"], "readability/bool"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                                   TRUE: noinsert */", "static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */"], "readability/bool"]
["src/nvim/edit.c", ["static int compl_no_select = FALSE;             /* FALSE: select & insert", "                                                   TRUE: noselect */", ""], "readability/bool"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "static int compl_was_interrupted = FALSE;         /* didn't finish finding", "                                                     completions. */"], "readability/bool"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["static pos_T compl_startpos;", "static colnr_T compl_col = 0;               /* column where the text starts", "                                             * that is being completed */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u *compl_orig_text = NULL;  /* text as it was before", "                                         * completion started */"], "readability/multiline_comment"]
["src/nvim/edit.c", ["                                             * that is being completed */", "static char_u *compl_orig_text = NULL;  /* text as it was before", "                                         * completion started */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else if (hasFolding(curwin->w_topline, NULL, &s->old_topline)) {"], "readability/increment"]
["src/nvim/edit.c", ["    case K_LEFT:", "      s->c = K_RIGHT; break;", "    case K_S_LEFT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_S_LEFT:", "      s->c = K_S_RIGHT; break;", "    case K_C_LEFT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_C_LEFT:", "      s->c = K_C_RIGHT; break;", "    case K_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_RIGHT:", "      s->c = K_LEFT; break;", "    case K_S_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_S_RIGHT:", "      s->c = K_S_LEFT; break;", "    case K_C_RIGHT:"], "whitespace/newline"]
["src/nvim/edit.c", ["    case K_C_RIGHT:", "      s->c = K_C_LEFT; break;", "    }"], "whitespace/newline"]
["src/nvim/edit.c", ["", "/*", " * Handle a CTRL-V or CTRL-Q typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character directly onto the screen.  It's not stored in a buffer."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Undo the previous edit_putchar()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when p_dollar is set: display a '$' at the end of the changed text"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Call this function before moving the cursor from the normal insert position"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  save_p_list = curwin->w_p_list;", "  curwin->w_p_list = FALSE;", "  vc = getvcol_nolist(&curwin->w_cursor);"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * For Replace mode we need to fix the replace stack later, which is only"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the cursor is in the indent, compute how many screen columns the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Set the new indent.  The cursor will be put on the first non-blank."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Try to put cursor on same character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (new_cursor_col >= 0) {", "    /*", "     * When changing the indent while the cursor is touching it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else {", "    /*", "     * Compute the screen column where the cursor should be."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Advance the cursor until we reach the right screen column."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * May need to insert spaces to be able to position the cursor on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * When changing the indent while the cursor is in it, reset"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  }", "  curwin->w_set_curswant = TRUE;", "  changed_cline_bef_curs();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * May have to adjust the start of the insert."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      }", "      ++start_col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-X pressed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* \"actual_len\" may be smaller than \"actual_compl_length\" when using", "     * thesaurus, only use the minimum when comparing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Rule 2: No lower case, 2nd consecutive letter converted to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * If the same match is already present, don't add it."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Allocate a new match structure."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Link the new match structure in the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find the longest common string if still doing that."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Reduce the longest common string for match \"match\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    ins_bytes(compl_leader + ins_compl_len());", "    ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "    /* When the match isn't there (to avoid matching itself) remove it", "     * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      ins_bytes(compl_leader + ins_compl_len());", "      ins_redraw(FALSE);", ""], "readability/bool"]
["src/nvim/edit.c", ["", "      /* When the match isn't there (to avoid matching itself) remove it", "       * again after redrawing. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add an array of matches to the list of matches."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* Make the completion list cyclic.", " * Return the number of matches (excluding the original)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_first_match != NULL) {", "    /*", "     * Find the end of the list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      match = match->cp_next;", "      ++count;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Start completion for the complete() function."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/* \"compl_match_array\" points the currently displayed list of entries in the", " * popup menu.  It is NULL when there is no popup menu. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Remove any popup menu."], "readability/old_style_comment"]
["src/nvim/edit.c", ["          if (compl == compl_shown_match || did_find_shown_match) {", "            /* This item is the shown match or this is the", "             * first displayed item after the shown match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        /* When the original text is the shown match don't set", "         * compl_shown_match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (!shown_match_ok && shown_compl != NULL) {", "          /* The shown match isn't displayed, set it to the", "           * previously displayed match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (*dict == NUL) {", "    /* When 'dictionary' is empty and spell checking is enabled use", "     * \"spell\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (curbuf->b_p_inf) {", "    p_scs = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /* When invoked to match whole lines for CTRL-X CTRL-L adjust the pattern", "   * to only match at the start of a line.  Otherwise just match the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /* Expand wildcards in the dictionary name, but do not allow", "       * backticks (for security, the 'dict' option may have been set in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    if (count == -1) {", "      /* Complete from active spelling.  Skip \"\\<\" in the pattern, we", "       * don't use it as a RE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * Read dictionary file line by line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "          /*", "           * Add the other matches on the line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["          while (!got_int) {", "            /* Find start of the next word.  Skip white", "             * space and punctuation. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the start of the next word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the word.  Assumes it starts inside a word."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Find the end of the line, omitting CR and NL at the end."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  while (s > ptr && (s[-1] == CAR || s[-1] == NL)) {", "    --s;", "  }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Free the list of completions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Delete one character before the cursor and show the subset of the matches"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Deleted more than what was used to find matches or didn't finish", "   * finding all matches: need to look for matches all over again. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called after changing \"compl_leader\"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Don't let Enter select the original text when there is no popup menu.", "   * Don't let Enter select when use user function and refresh_always is set */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_match_array == NULL || ins_compl_need_restart()) {", "    compl_enter_selects = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Return the length of the completion, from the completion start column to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Setup for finding completions again without leaving CTRL-X mode.  Used when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["{", "  /* update screen before restart.", "   * so if complete is blocked,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Set the first match, the original text."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Append one character to the match leader.  May reduce the number of"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Forget any previous 'special' messages if this is actually", "   * a ^X mode key - bar ^R, in which case we wait to see what it gives us."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET) {", "    /*", "     * We have just typed CTRL-X and aren't quite sure which CTRL-X mode"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case Ctrl_N:", "      /* ^X^P means LOCAL expansion if nothing interrupted (eg we", "       * just started ^X mode, or there were enough ^X's to cancel"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    default:", "      /* If we have typed at least 2 ^X's... for modes != 0, we set", "       * compl_cont_status = 0 (eg, as if we had just started ^X"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_started || ctrl_x_mode == CTRL_X_FINISHED) {", "    /* Show error message from attempted keyword completion (probably", "     * 'Pattern not found') until another key is hit, then go back to"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        || ctrl_x_mode == CTRL_X_FINISHED) {", "      /* Get here when we have finished typing a sequence of ^N and", "       * ^P or other completion characters in CTRL-X mode.  Free up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match != NULL || compl_leader != NULL || c == Ctrl_E) {", "        /*", "         * If any of the original typed text has been changed, eg when"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /*", "       * Indent now if a key was typed that is in 'cinkeys'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else if (ctrl_x_mode == CTRL_X_LOCAL_MSG) {", "    /* Trigger the CompleteDone event to give scripts a chance to act", "     * upon the (possibly failed) completion. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* reset continue_* if we left expansion-mode, if we stay they'll be", "   * (re)set properly in ins_complete() */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Fix the redo buffer for the completion leader replacing some of the typed"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Loops through the list of windows, loaded-buffers or non-loaded-buffers"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  } else {", "    /* 'b' (just loaded buffers), 'u' (just non-loaded buffers) or 'U'", "     * (unlisted buffers)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a list."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Add completions from a dict."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      find_pattern_in_path(compl_pattern, compl_direction,", "                           STRLEN(compl_pattern), FALSE, FALSE,", "                           ((type == CTRL_X_PATH_DEFINES"], "readability/bool"]
["src/nvim/edit.c", ["      if (ins_buf->b_p_inf) {", "        p_scs = FALSE;", "      }"], "readability/bool"]
["src/nvim/edit.c", ["              // compl_length, so the next STRNCPY always works -- Acevedo", "              STRNCPY(IObuff, ptr, len);", "              ptr = ml_get_buf(ins_buf, pos->lnum + 1, false);"], "runtime/printf"]
["src/nvim/edit.c", ["", "  /* When user complete function return -1 for findstart which is next", "   * time of 'always', compl_shown_match become NULL. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If we didn't find it searching forward, and compl_shows_dir is", "     * backward, find the last match. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Repeat this for when <PageUp> or <PageDown> is typed.  But don't wrap", "   * around. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (compl_shows_dir == BACKWARD) {", "          --compl_pending;", "        } else {"], "readability/increment"]
["src/nvim/edit.c", ["        } else {", "          ++compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_next;", "          --compl_pending;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["          compl_shown_match = compl_shown_match->cp_prev;", "          ++compl_pending;", "        } else {"], "readability/increment"]
["src/nvim/edit.c", ["", "  /* Enter will select a match when the match wasn't inserted and the popup", "   * menu is visible. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (compl_no_insert && !started) {", "    compl_enter_selects = TRUE;", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * Show the file name for the match (if any)"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Check for a typed key.  Do use mappings, otherwise vim_is_ctrl_x_key()", "   * can't do its work correctly. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /* Need to get the character to have KeyTyped set.  We'll put it", "       * back with vungetc() below.  But skip K_IGNORE. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (c != K_IGNORE) {", "        /* Don't interrupt completion when the character wasn't typed,", "         * e.g., when doing @q to replay keys. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (c != Ctrl_R && KeyTyped) {", "          compl_interrupted = TRUE;", "        }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Decide the direction of Insert mode complete from the key typed."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Decide the number of completions to move forward."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Do Insert mode completion."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If this same ctrl_x_mode has been interrupted use the text from", "     * \"compl_startpos\" to the cursor as a pattern to add a new word"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        && compl_cont_mode == ctrl_x_mode) {", "      /*", "       * it is a continued search"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          /* S_IPOS was set when we inserted a word that was at the", "           * beginning of the line, which means that we'll go to SOL"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        compl_length = curwin->w_cursor.col - (int)compl_col;", "        /* IObuff is used to add a \"word from the next line\" would we", "         * have enough space?  just being paranoid */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/indent"]
["src/nvim/edit.c", ["                    vim_iswordp(mb_prevptr(line, line + compl_col))", "                    ))) {", "          prefix = (char_u *)\"\";"], "whitespace/parens"]
["src/nvim/edit.c", ["        if (compl_length == 1) {", "          /* Only match word with at least two chars -- webb", "           * there's no need to call quote_meta,"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Return value -2 means the user complete function wants to", "       * cancel the complete without an error."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* Setup variables for completion.  Need to obtain \"line\" again,", "       * it may have become invalid. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* If any of the original typed text has been changed we need to fix", "     * the redo buffer. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /* showmode might reset the internal line pointers, so it must", "     * be called before line = ml_get(), or when this address is no"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Find next match (and following matches)."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /* Eat the ESC that vgetc() returns after a CTRL-C to avoid leaving Insert", "   * mode. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    (void)vgetc();", "    got_int = FALSE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["    edit_submode_highl = HLF_E;", "    /* remove N_ADDS flag, so next ^X<> won't try to go to ADDING mode,", "     * because we couldn't expand anything at first place, but if we used"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      /* The match should always have a sequence number now, this is", "       * just a safety check. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (compl_curr_match->cp_number != -1) {", "        /* Space for 10 text chars. + 2x10-digit no.s = 31.", "         * Translations may need more than twice that. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  compl_was_interrupted = compl_interrupted;", "  compl_interrupted = FALSE;", ""], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Looks in the first \"len\" chars. of \"src\" for search-metachars."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "      ++i;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "  --no_mapping;", "  if (nc) {"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Special characters in this context are those that need processing other"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Need to remove existing (middle) comment leader and insert end"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * When 'ai' is off we don't want a space under the cursor to be"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Repeat breaking lines, until the current line is not too long."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Find position to break at."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * adjust startcol for spaces that will be deleted and"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Split the line just before the margin."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    } else {", "      /*", "       * Check if cursor is not past the NUL off the line, cindent"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * May start formatting in a previous line, so that after \"x\" a word is"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  if (prev_line && !paragraph_start(curwin->w_cursor.lnum)) {", "    --curwin->w_cursor.lnum;", "    if (u_save_cursor() == FAIL) {"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * Do the formatting and restore the cursor position.  \"saved_cursor\" will"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Put a character in the redo buffer, for when just after a CTRL-V."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If we skipped highlighting word at cursor, do it now."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Called when starting CTRL_X_SPELL mode: Move backwards to a previous badly"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * stop_arrow() is called before a change is made in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * Save the inserted text for later redo with ^@ and CTRL-A."], "readability/old_style_comment"]
["src/nvim/edit.c", ["        }", "        /* If the cursor is still at the same character, also keep", "         * the \"coladd\". */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (gchar_cursor() == NUL && curwin->w_cursor.col > 0) {", "          --curwin->w_cursor.col;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["        if (cc != NUL && gchar_pos(&tpos) == NUL) {", "          ++curwin->w_cursor.col;         // put cursor back on the NUL", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Set the last inserted text to a single character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * move cursor to start of line"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      for (ptr = get_cursor_line_ptr(); ascii_iswhite(*ptr)", "           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr) {", "        ++curwin->w_cursor.col;"], "readability/increment"]
["src/nvim/edit.c", ["           && !((flags & BL_FIX) && ptr[1] == NUL); ++ptr) {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["    }", "    curwin->w_set_curswant = TRUE;", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * oneright oneleft cursor_down cursor_up"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "    curwin->w_set_curswant = TRUE;", "    return OK;"], "readability/bool"]
["src/nvim/edit.c", ["", "  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;"], "readability/bool"]
["src/nvim/edit.c", ["  curwin->w_set_curswant = TRUE;", "  --curwin->w_cursor.col;", ""], "readability/increment"]
["src/nvim/edit.c", ["    } else if (hasAnyFolding(curwin)) {", "      /*", "       * Count each sequence of folded lines as one logical line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["        } else {", "          ++lnum;", "        }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Get last inserted string, and remove trailing <Esc>."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * replace-stack functions"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  *p = (char_u)c;", "  ++replace_stack_nr;", "}"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Push a character onto the replace stack.  Handles a multi-byte character in"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  for (j = l - 1; j >= 0; --j) {", "    replace_push(p[j]);"], "readability/increment"]
["src/nvim/edit.c", ["    if (replace_stack[i] == NUL && off-- <= 0) {", "      --replace_stack_nr;", "      memmove(replace_stack + i, replace_stack + i + 1,"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * Insert bytes popped from the replace stack. \"cc\" is the first byte.  If it"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * make the replace stack empty"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle doing a BS for one character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Re-indent the current line, based on the current contents of it and the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["  while (*look) {", "    /*", "     * Find out if we want to try a match with this key, depending on"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case '*':", "      try_match = (*look == '*'); break;", "    case '!':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case '!':", "      try_match = (*look == '!'); break;", "    default:"], "whitespace/newline"]
["src/nvim/edit.c", ["    default:", "      try_match = (*look != '*'); break;", "    }"], "whitespace/newline"]
["src/nvim/edit.c", ["    }", "    /*", "     * Is it a word: \"=word\"?"], "readability/old_style_comment"]
["src/nvim/edit.c", ["     */", "    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;"], "whitespace/newline"]
["src/nvim/edit.c", ["    else if (*look == '=' && look[1] != ',' && look[1] != NUL) {", "      ++look;", "      if (*look == '~') {"], "readability/increment"]
["src/nvim/edit.c", ["", "          /* Just completed a word, check if it starts with \"look\".", "           * search back for the start of a word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["        if (match && try_match_word && !try_match) {", "          /* \"0=word\": Check if there are only blanks before the", "           * word. */"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Skip over \", \"."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Map Hebrew keyboard when in hkmap mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    case ',':", "      c = '{'; break;", "    case '.':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case '.':", "      c = 'v'; break;", "    case ';':"], "whitespace/newline"]
["src/nvim/edit.c", ["    case ';':", "      c = 't'; break;", "    default: {"], "whitespace/newline"]
["src/nvim/edit.c", ["", "  /*", "   * If we are going to wait for a character, show a '\"'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["  regname = plain_vgetc();", "  LANGMAP_ADJUST(regname, TRUE);", "  if (regname == Ctrl_R || regname == Ctrl_O || regname == Ctrl_P) {"], "readability/bool"]
["src/nvim/edit.c", ["    regname = plain_vgetc();", "    LANGMAP_ADJUST(regname, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * CTRL-G commands in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-^ in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "    /*", "     * Repeating insert may take a long time.  Check for"], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    stop_insert(&curwin->w_cursor, TRUE, nomove);", "    undisplay_dollar();"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * The cursor should end up on the last inserted character."], "readability/old_style_comment"]
["src/nvim/edit.c", ["              && !VIsual_active", "              ))", "      && !revins_on) {"], "whitespace/parens"]
["src/nvim/edit.c", ["", "/*", " * Toggle language: hkmap and revins_on."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (gchar_cursor() != NUL && revins_chars--) {", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["", "/*", " * <Insert> key in Insert mode: toggle insert/replace mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Pressed CTRL-O in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * If the cursor is on an indent, ^T/^D insert/delete one"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * 0^D and ^^D: remove all indent."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    change_indent(INDENT_SET, 0, TRUE, 0, TRUE);", "  } else {"], "readability/bool"]
["src/nvim/edit.c", ["  } else {", "    change_indent(c == Ctrl_D ? INDENT_DEC : INDENT_INC, 0, TRUE, 0, TRUE);", "  }"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Delete one character for ins_bs()."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    }", "    /*", "     * In replace mode:"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "        do_join(2, FALSE, FALSE, FALSE, false);", "        if (temp == NUL && gchar_cursor() != NUL) {"], "readability/bool"]
["src/nvim/edit.c", ["", "    /*", "     * Handle deleting one 'shiftwidth' or 'softtabstop'."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  curwin->w_redr_status = TRUE;", ""], "readability/bool"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_up(1L, TRUE) == OK) {", "    if (startcol) {"], "readability/bool"]
["src/nvim/edit.c", ["  tpos = curwin->w_cursor;", "  if (cursor_down(1L, TRUE) == OK) {", "    if (startcol) {"], "readability/bool"]
["src/nvim/edit.c", ["      && !(", "           p_sta", "           && ind"], "whitespace/indent"]
["src/nvim/edit.c", ["           p_sta", "           && ind", "           // These five lines mean 'tabstop' != 'shiftwidth'"], "whitespace/indent"]
["src/nvim/edit.c", ["           // These five lines mean 'tabstop' != 'shiftwidth'", "           && ((tabstop_count(curbuf->b_p_vts_array) > 1)", "               || (tabstop_count(curbuf->b_p_vts_array) == 1"], "whitespace/indent"]
["src/nvim/edit.c", ["      && !(", "           p_sta", "           && ind"], "whitespace/indent"]
["src/nvim/edit.c", ["           p_sta", "           && ind", "           // These five lines mean 'tabstop' != 'shiftwidth'"], "whitespace/indent"]
["src/nvim/edit.c", ["           // These five lines mean 'tabstop' != 'shiftwidth'", "           && ((tabstop_count(curbuf->b_p_vts_array) > 1)", "               || (tabstop_count(curbuf->b_p_vts_array) == 1"], "whitespace/indent"]
["src/nvim/edit.c", ["", "  /*", "   * When 'expandtab' not set: Replace spaces by TABs where possible."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    while (fpos.col > 0 && ascii_iswhite(ptr[-1])) {", "      --fpos.col;", "      --ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      --fpos.col;", "      --ptr;", "    }"], "readability/increment"]
["src/nvim/edit.c", ["      }", "      ++fpos.col;", "      ++ptr;"], "readability/increment"]
["src/nvim/edit.c", ["      ++fpos.col;", "      ++ptr;", "      vcol += i;"], "readability/increment"]
["src/nvim/edit.c", ["        vcol += lbr_chartabsize(line, ptr, vcol);", "        ++ptr;", "        ++repl_off;"], "readability/increment"]
["src/nvim/edit.c", ["        ++ptr;", "        ++repl_off;", "      }"], "readability/increment"]
["src/nvim/edit.c", ["", "  /*", "   * Strange Vi behaviour: In Replace mode, typing a NL will not delete the"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle digraph in insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["    clear_showcmd();", "    insert_special(c, TRUE, FALSE);", "    return NUL;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Handle CTRL-E and CTRL-Y in Insert mode: copy char from other line."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * CTRL-Y or CTRL-E typed in Insert mode."], "readability/old_style_comment"]
["src/nvim/edit.c", ["      curbuf->b_p_tw = -1;", "      insert_special(c, TRUE, FALSE);", "      curbuf->b_p_tw = tw_save;"], "readability/bool"]
["src/nvim/edit.c", ["", "/*", " * Try to do some very smart auto-indenting."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "  /*", "   * do some very smart indenting when entering '{' or '}'"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      old_pos = curwin->w_cursor;", "      /*", "       * If the matching '{' has a ')' immediately before it (ignoring"], "readability/old_style_comment"]
["src/nvim/edit.c", ["      if (State & VREPLACE_FLAG) {", "        change_indent(INDENT_SET, i, FALSE, NUL, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/edit.c", ["      if (temp) {", "        shift_line(TRUE, FALSE, 1, TRUE);", "      }"], "readability/bool"]
["src/nvim/edit.c", ["", "  /*", "   * set indent of '#' always to 0"], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Get the value that w_virtcol would have when 'list' is off."], "readability/old_style_comment"]
["src/nvim/edit.c", ["", "/*", " * Handle the InsertCharPre autocommand."], "readability/old_style_comment"]

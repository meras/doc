["src/nvim/search.c", ["", "/*", " * search.c: code for normal mode searching commands"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Type used by find_pattern_in_path() to remember which included files have"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * If no pattern given, use a previously defined pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Save the currently used pattern in the appropriate place,"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Get search pattern used by search_regcomp()."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Save the search patterns, so they can be restored later."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Return TRUE when case should be ignored for search pattern \"pat\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["{", "  return last_t_cmd == TRUE;", "}"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Reset search direction to forward.  For \"gd\" and \"gD\" commands."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Set the last search pattern.  For \":let @/ =\" and ShaDa file."], "readability/old_style_comment"]
["src/nvim/search.c", ["  set_vv_searchforward();", "  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["  spats[idx].off.line = FALSE;", "  spats[idx].off.end = FALSE;", "  spats[idx].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * Get a regexp program for the last used search pattern."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  ++emsg_off;           // So it doesn't beep if bad expr", "  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);"], "readability/increment"]
["src/nvim/search.c", ["  (void)search_regcomp((char_u *)\"\", 0, last_idx, SEARCH_KEEP, regmatch);", "  --emsg_off;", "}"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * find the string"], "readability/old_style_comment"]
["src/nvim/search.c", ["   */", "  called_emsg = FALSE;", "  do {  // loop for count"], "readability/bool"]
["src/nvim/search.c", ["    found = 0;                  // default: not found", "    at_first_line = TRUE;       // default: start in first line", "    if (pos->lnum == 0) {       // correct lnum for when starting in line 0"], "readability/bool"]
["src/nvim/search.c", ["      pos->col = 0;", "      at_first_line = FALSE;        // not in first line now", "    }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Start searching in current line, unless searching backwards and"], "readability/old_style_comment"]
["src/nvim/search.c", ["      lnum = pos->lnum - 1;", "      at_first_line = FALSE;", "    } else {"], "readability/bool"]
["src/nvim/search.c", ["", "    for (loop = 0; loop <= 1; ++loop) {     // loop twice if 'wrapscan' set", "      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;"], "readability/increment"]
["src/nvim/search.c", ["      for (; lnum > 0 && lnum <= buf->b_ml.ml_line_count;", "           lnum += dir, at_first_line = FALSE) {", "        // Stop after checking \"stop_lnum\", if it's set."], "readability/bool"]
["src/nvim/search.c", ["", "          /*", "           * Forward search in the first line: match should be after"], "readability/old_style_comment"]
["src/nvim/search.c", ["                          < (int)start_pos.col + extra_col))) {", "              /*", "               * If vi-compatible searching, continue at the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["          if (dir == BACKWARD) {", "            /*", "             * Now, if there are multiple matches on this line,"], "readability/old_style_comment"]
["src/nvim/search.c", ["                  || (nmatched =", "                        vim_regexec_multi(&regmatch, win, buf, lnum + matchpos.lnum, matchcol,", "                                          tm, timed_out)) == 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["                  || (nmatched =", "                        vim_regexec_multi(&regmatch, win, buf, lnum + matchpos.lnum, matchcol,", "                                          tm, timed_out)) == 0) {"], "whitespace/alignment"]
["src/nvim/search.c", ["", "            /*", "             * If there is only a match after the cursor, skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      at_first_line = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  for (submatch = 1;; ++submatch) {", "    if (rp->startpos[submatch].lnum >= 0) {"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * A line offset is not remembered, this is vi compatible."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Save the values for when (options & SEARCH_KEEP) is used."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Find out the direction of the search."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Turn 'hlsearch' highlighting back on."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (pat != NULL && *pat != NUL) {   // look for (new) offset", "      /*", "       * Find end of regular expression."], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;"], "readability/bool"]
["src/nvim/search.c", ["      spats[0].off.line = FALSE;", "      spats[0].off.end = FALSE;", "      spats[0].off.off = 0;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        ++p;", "        while (ascii_isdigit(*p)) {  // skip number"], "readability/increment"]
["src/nvim/search.c", ["        while (ascii_isdigit(*p)) {  // skip number", "          ++p;", "        }"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * If there is a character offset, subtract it from the current"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (spats[0].off.off > 0) {", "        for (c = spats[0].off.off; c; --c) {", "          if (decl(&pos) == -1) {"], "readability/increment"]
["src/nvim/search.c", ["      } else {", "        for (c = spats[0].off.off; c; ++c) {", "          if (incl(&pos) == -1) {"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * Add character and/or line offset"], "readability/old_style_comment"]
["src/nvim/search.c", ["        // to the left, check for start of file", "        else {", "          while (c++ < 0) {"], "whitespace/newline"]
["src/nvim/search.c", ["        // to the left, check for start of file", "        else {", "          while (c++ < 0) {"], "readability/braces"]
["src/nvim/search.c", ["    }", "    ++pat;", "  }"], "readability/increment"]
["src/nvim/search.c", ["  curwin->w_cursor = pos;", "  curwin->w_set_curswant = TRUE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * search_for_exact_line(buf, pos, dir, pat)"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if ((p_ic ? mb_strnicmp(p, pat, (size_t)compl_length)", "                : STRNCMP(p, pat, compl_length)) == 0) {", "        return OK;"], "whitespace/alignment"]
["src/nvim/search.c", ["", "/*", " * Character Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * \"Other\" Searches"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatch - find the matching paren or brace"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Raw string start is found at linep[startpos.col - 1]."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * findmatchlimit -- find the matching paren or brace, if it exists within"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * if initc given, look in the table for the matching character"], "readability/old_style_comment"]
["src/nvim/search.c", ["  } else {", "    /*", "     * Either initc is '#', or no initc was given and we need to look"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * initc was not given, must look for something to match under"], "readability/old_style_comment"]
["src/nvim/search.c", ["        // Are we on a comment?", "        else if (linep[pos.col] == '/') {", "          if (linep[pos.col + 1] == '*') {"], "whitespace/newline"]
["src/nvim/search.c", ["", "      /*", "       * If we are not on a comment or the # at the start of a line, then"], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (!hash_dir && !comment_dir) {", "        /*", "         * Find the brace under or after the cursor."], "readability/old_style_comment"]
["src/nvim/search.c", ["        if (linep[pos.col] == NUL && pos.col) {", "          --pos.col;", "        }"], "readability/increment"]
["src/nvim/search.c", ["    if (hash_dir) {", "      /*", "       * Look for matching #if, #else, #elif, or #endif"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (!got_int) {", "    /*", "     * Go to the next position, forward or backward. We could use"], "readability/old_style_comment"]
["src/nvim/search.c", ["        }", "        --pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["        }", "        ++pos.lnum;", ""], "readability/increment"]
["src/nvim/search.c", ["      // Note: comments do not nest, and we ignore quotes in them", "      // TODO: ignore comment brackets inside strings", "      if (comment_dir == FORWARD) {"], "readability/todo"]
["src/nvim/search.c", ["      } else {    // Searching backwards", "        /*", "         * A comment may contain / * or / /, it may also start or end"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'), braces inside"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else if (do_quotes == -1) {", "      /*", "       * Count the number of quotes in the line, skipping \\\" and '\"'."], "readability/old_style_comment"]
["src/nvim/search.c", ["      at_start = do_quotes;", "      for (ptr = linep; *ptr; ++ptr) {", "        if (ptr == linep + pos.col + backwards) {"], "readability/increment"]
["src/nvim/search.c", ["            && (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\'')) {", "          ++do_quotes;", "        }"], "readability/increment"]
["src/nvim/search.c", ["        if (*ptr == '\\\\' && ptr[1] != NUL) {", "          ++ptr;", "        }"], "readability/increment"]
["src/nvim/search.c", ["", "      /*", "       * If we find an uneven count, check current line and previous"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If 'smartmatch' is set:"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "        for (col = pos.col - 1; col >= 0; --col) {", "          if (linep[col] != '\\\\') {"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * If smart matching ('cpoptions' does not contain '%'):"], "readability/old_style_comment"]
["src/nvim/search.c", ["    default:", "      /*", "       * For Lisp skip over backslashed (), {} and []."], "readability/old_style_comment"]
["src/nvim/search.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Only show match for chars in the 'matchpairs' option."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * brief pause, unless 'm' is present in 'cpo' and a character is"], "readability/old_style_comment"]
["src/nvim/search.c", ["      c = gchar_pos(&pos);", "      if (c == NUL || (pos.col == 0 && startPS(pos.lnum, NUL, FALSE))) {", "        if (dir == BACKWARD && pos.lnum != startlnum) {"], "readability/bool"]
["src/nvim/search.c", ["        if (dir == BACKWARD && pos.lnum != startlnum) {", "          ++pos.lnum;", "        }"], "readability/increment"]
["src/nvim/search.c", ["  if (both && *ml_get(curr) == '}') {   // include line with '}'", "    ++curr;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "/*", " * check if the string 's' is a nroff macro that is in option 'opt'"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    ++macro;", "    if (macro[0] == NUL) {"], "readability/increment"]
["src/nvim/search.c", ["", "/*", " * startPS: return TRUE if line 'lnum' is the start of a section or paragraph."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * The following routines do the word searches performed by the 'w', 'W',"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * To perform these searches, characters are placed into one of three"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * cls() - returns the class of character at curwin->w_cursor"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * We always move at least one character, unless on the last"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Go one char past end of current word (if any)"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * go to next non-white"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (cls() == 0) {", "      /*", "       * We'll stop if we land on a blank line"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * bck_word() - move backward 'count' words"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the first char of the", "     * first line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (!stop || sclass == cls() || sclass == 0) {", "      /*", "       * Skip white space before the word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move backward to start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "/*", " * end_word() - move to the end of the word"], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (--count >= 0) {", "    /* When inside a range of folded lines, move to the last char of the", "     * last line. */"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If we're in the middle of a word, we just have to move to the end"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (cls() == sclass && sclass != 0) {", "      /*", "       * Move forward to end of the current word"], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else if (!stop || sclass == 0) {", "      /*", "       * We were at the end of a word. Go to the end of the next word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Move forward to the end of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["finished:", "    stop = FALSE;                       // we move only one word less", "  }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to before the start of this word."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * Move backward to end of the previous word"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Go back to the start of the word or the start of white space"], "readability/old_style_comment"]
["src/nvim/search.c", ["  bool inclusive = true;", "  int include_white = FALSE;", ""], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * When Visual mode is not active, or when the VIsual area is only one"], "readability/old_style_comment"]
["src/nvim/search.c", ["  if (!VIsual_active || equalpos(curwin->w_cursor, VIsual)) {", "    /*", "     * Go to start of current word or white space."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "    /*", "     * If the start is on white space, and white space should be included"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if ((cls() == 0) == include) {", "      if (end_word(1L, bigword, TRUE, TRUE) == FAIL) {", "        return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * If the start is not on white space, and white space should be"], "readability/old_style_comment"]
["src/nvim/search.c", ["       */", "      fwd_word(1L, bigword, TRUE);", "      if (curwin->w_cursor.col == 0) {"], "readability/bool"]
["src/nvim/search.c", ["      if (include) {", "        include_white = TRUE;", "      }"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * When count is still > 0, extend with more objects."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (VIsual_active && lt(curwin->w_cursor, VIsual)) {", "      /*", "       * In Visual mode, with cursor at start: move cursor back."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (include != (cls() != 0)) {", "        if (bck_word(1L, bigword, TRUE) == FAIL) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Move cursor forward one word and/or white area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (include != (cls() == 0)) {", "        if (fwd_word(1L, bigword, TRUE) == FAIL && count > 1) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["        }", "        /*", "         * If end is just past a new-line, we don't want to include"], "readability/old_style_comment"]
["src/nvim/search.c", ["      } else {", "        if (end_word(1L, bigword, TRUE, TRUE) == FAIL) {", "          return FAIL;"], "readability/bool"]
["src/nvim/search.c", ["    }", "    --count;", "  }"], "readability/increment"]
["src/nvim/search.c", ["                        || (curwin->w_cursor.col == 0 && !inclusive))) {", "    /*", "     * If we don't include white space at the end, move the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "/*", " * Find sentence(s) under the cursor, cursor at end."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * When the Visual area is bigger than one character: Extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (lt(start_pos, VIsual)) {", "      /*", "       * Cursor at start of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Cursor at end of Visual area."], "readability/old_style_comment"]
["src/nvim/search.c", ["      if (*p_sel == 'e') {", "        ++curwin->w_cursor.col;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If the cursor started on a blank, check if it is just before the start"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (start_blank) {", "      --ncount;", "    }"], "readability/increment"]
["src/nvim/search.c", ["  if (include) {", "    /*", "     * If the blank in front of the sentence is included, exclude the"], "readability/old_style_comment"]
["src/nvim/search.c", ["    if (*p_sel == 'e') {", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If we start on '(', '{', ')', '}', etc., use the whole block inclusive."], "readability/old_style_comment"]
["src/nvim/search.c", ["      // cursor on '(' or '{', move cursor just after it", "      ++curwin->w_cursor.col;", "    }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching ')', '}', etc."], "readability/old_style_comment"]
["src/nvim/search.c", ["  }", "  /*", "   * If we start on \"<aaa>\" select that block."], "readability/old_style_comment"]
["src/nvim/search.c", ["again:", "  /*", "   * Search backwards for unclosed \"<aaa>\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["", "  /*", "   * Search for matching \"</aaa>\".  First isolate the \"aaa\"."], "readability/old_style_comment"]
["src/nvim/search.c", ["  int retval = OK;", "  int do_white = FALSE;", "  int t;"], "readability/bool"]
["src/nvim/search.c", ["", "  /*", "   * When visual area is more than one line: extend it."], "readability/old_style_comment"]
["src/nvim/search.c", ["      prev_start_is_white = -1;", "      for (t = 0; t < 2; ++t) {", "        start_lnum += dir;"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * First move back to the start_lnum of the paragraph or white lines"], "readability/old_style_comment"]
["src/nvim/search.c", ["    }", "    --start_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * Move past the end of any white lines."], "readability/old_style_comment"]
["src/nvim/search.c", ["  while (end_lnum <= curbuf->b_ml.ml_line_count && linewhite(end_lnum)) {", "    ++end_lnum;", "  }"], "readability/increment"]
["src/nvim/search.c", ["", "  --end_lnum;", "  i = count;"], "readability/increment"]
["src/nvim/search.c", ["  if (!include && white_in_front) {", "    --i;", "  }"], "readability/increment"]
["src/nvim/search.c", ["    if (include || !do_white) {", "      ++end_lnum;", "      /*"], "readability/increment"]
["src/nvim/search.c", ["      ++end_lnum;", "      /*", "       * skip to end of paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["             && !startPS(end_lnum + 1, 0, 0)) {", "        ++end_lnum;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "    /*", "     * skip to end of white lines after paragraph"], "readability/old_style_comment"]
["src/nvim/search.c", ["             && linewhite(end_lnum + 1)) {", "        ++end_lnum;", "      }"], "readability/increment"]
["src/nvim/search.c", ["", "  /*", "   * If there are no empty lines at the end, try to find some empty lines at"], "readability/old_style_comment"]
["src/nvim/search.c", ["    while (start_lnum > 1 && linewhite(start_lnum - 1)) {", "      --start_lnum;", "    }"], "readability/increment"]
["src/nvim/search.c", ["                                             line[col_start - n - 1]) != NULL) {", "        ++n;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      while (ascii_iswhite(line[col_end + 1])) {", "        ++col_end;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      while (col_start > 0 && ascii_iswhite(line[col_start - 1])) {", "        --col_start;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      && (vis_empty || !inside_quotes)) {", "    ++col_start;", "  }"], "readability/increment"]
["src/nvim/search.c", ["       || (!vis_empty && inside_quotes)", "       ) && inc_cursor() == 2) {", "    inclusive = true;"], "whitespace/parens"]
["src/nvim/search.c", ["", "/*", " * return TRUE if line 'lnum' is empty or has white chars only."], "readability/old_style_comment"]
["src/nvim/search.c", ["    assert(len <= INT_MAX);", "    sprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", (int)len, ptr);", "    // ignore case according to p_ic, p_scs and pat"], "runtime/printf"]
["src/nvim/search.c", ["    }", "    incl_regmatch.rm_ic = FALSE;        // don't ignore case in incl. pat.", "  }"], "readability/bool"]
["src/nvim/search.c", ["    }", "    def_regmatch.rm_ic = FALSE;         // don't ignore case in define pat.", "  }"], "readability/bool"]
["src/nvim/search.c", ["      }", "      already_searched = FALSE;", "      if (new_fname != NULL) {"], "readability/bool"]
["src/nvim/search.c", ["        while (depth_displayed < depth && !got_int) {", "          ++depth_displayed;", "          for (i = 0; i < depth_displayed; i++) {"], "readability/increment"]
["src/nvim/search.c", ["          } else {", "            /*", "             * Isolate the file name."], "readability/old_style_comment"]
["src/nvim/search.c", ["              if (p[-1] == '\"' || p[-1] == '<') {", "                --p;", "                ++i;"], "readability/increment"]
["src/nvim/search.c", ["                --p;", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["              if (p[i] == '\"' || p[i] == '>') {", "                ++i;", "              }"], "readability/increment"]
["src/nvim/search.c", ["            bigger[i].lnum = 0;", "            bigger[i].matched = FALSE;", "          }"], "readability/bool"]
["src/nvim/search.c", ["            xfree(files[old_files].name);", "            ++old_files;", "          }"], "readability/increment"]
["src/nvim/search.c", ["          files[depth].lnum = 0;", "          files[depth].matched = FALSE;", "          if (action == ACTION_EXPAND) {"], "readability/bool"]
["src/nvim/search.c", ["    } else {", "      /*", "       * Check if the line is a define (type == FIND_DEFINE)"], "readability/old_style_comment"]
["src/nvim/search.c", ["          && vim_regexec(&def_regmatch, line, (colnr_T)0)) {", "        /*", "         * Pattern must be first identifier after 'define', so skip"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "      /*", "       * Look for a match.  Don't do this if we are looking for a"], "readability/old_style_comment"]
["src/nvim/search.c", ["", "            /*", "             * Also check for a \"/ *\" or \"/ /\" before the match."], "readability/old_style_comment"]
["src/nvim/search.c", ["                || (p[0] == '/' && p[1] == '*') || p[0] == '*') {", "              for (p = line; *p && p < startp; ++p) {", "                if (matched"], "readability/increment"]
["src/nvim/search.c", ["          // IOSIZE > compl_length, so the STRNCPY works", "          STRNCPY(IObuff, aux, i);", ""], "runtime/printf"]
["src/nvim/search.c", ["            }", "            STRNCPY(IObuff + i, aux, p - aux);", "            i += (int)(p - aux);"], "runtime/printf"]
["src/nvim/search.c", ["          curwin->w_cursor.col = (colnr_T)(startp - line);", "          curwin->w_set_curswant = TRUE;", "        }"], "readability/bool"]
["src/nvim/search.c", ["", "    /*", "     * Read the next line.  When reading an included file and encountering"], "readability/old_style_comment"]
["src/nvim/search.c", ["      fclose(files[depth].fp);", "      --old_files;", "      files[old_files].name = files[depth].name;"], "readability/increment"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\n') {", "        --p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["      if (p >= line && *p == '\\r') {", "        --p;", "      }"], "readability/increment"]
["src/nvim/search.c", ["    }", "    msg_prt_line(line, FALSE);", "    ui_flush();                        // show one line at a time"], "readability/bool"]
["src/nvim/search.c", ["      }", "      ++*lnum;", "    } else {"], "readability/increment"]

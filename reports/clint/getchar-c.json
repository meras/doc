["src/nvim/getchar.c", ["", "/*", " * getchar.c"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * when block_redo is TRUE redo buffer will not be changed"], "readability/old_style_comment"]
["src/nvim/getchar.c", [" */", "static int block_redo = FALSE;", ""], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * List used for abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Variables used by vgetorpeek() and flush_buffers()"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free and clear a buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  p = get_buffcont(&recordbuff, TRUE);", "  free_buff(&recordbuff);"], "readability/bool"]
["src/nvim/getchar.c", ["", "  /*", "   * Remove the characters that were added the last time, these must be the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * When stopping recording from Insert mode with CTRL-O q, also remove the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  return get_buffcont(&redobuff, FALSE);", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Prepare the read buffers for reading (if they contain something)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if the stuff buffer is empty."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if readbuf1 is empty.  There may still be redo characters in"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Set a typeahead character that won't be flushed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Remove the contents of the stuff buffer and the mapped characters in the"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * The previous contents of the redo buffer is kept in old_redobuffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Discard the contents of the redo buffer and restore the previous redo"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the redo buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Append a number to the stuff buffer."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Repeat the last insert (R, o, O, a, A, i or I command) by stuffing"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["{", "  block_redo = FALSE;", "}"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Initialize typebuf.tb_buf to point to typebuf_init."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Adjust typebuf.tb_noremap[] for the new characters:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  }", "  for (i = 0; i < addlen; ++i) {", "    typebuf.tb_noremap[typebuf.tb_off + i + offset] ="], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE if there are no characters in the typeahead buffer that have"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Return the number of characters that are mapped (or not typed)."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * remove \"len\" characters from typebuf.tb_buf[typebuf.tb_off + offset]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Easy case: Just increase typebuf.tb_off."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  }", "  /*", "   * Have to move the characters in typebuf.tb_buf[] and typebuf.tb_noremap[]"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "whitespace/newline"]
["src/nvim/getchar.c", ["   */", "  else {", "    i = typebuf.tb_off + offset;"], "readability/braces"]
["src/nvim/getchar.c", ["    i = typebuf.tb_off + offset;", "    /*", "     * Leave some extra room at the end to avoid reallocation."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Write typed characters to script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Sync undo.  Called when typed characters are obtained from the typeahead"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Make \"typebuf\" empty and allocate new buffers."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Free the buffers of \"typebuf\"."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * When doing \":so! file\", the current typeahead needs to be saved, and"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Save all three kinds of typeahead, so that the user must type at a prompt."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Restore the typeahead to what it was before calling save_typeahead()."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * Execute the commands from the file right now when using \":source!\""], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Close the currently active input script."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["  if (curscript > 0) {", "    --curscript;", "  }"], "readability/increment"]
["src/nvim/getchar.c", ["", "/*", " * Return TRUE when reading keys from a script file."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * If a character was put back with vungetc, it was already processed."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      case K_KPLUS:", "        c = '+'; break;", "      case K_KMINUS:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KMINUS:", "        c = '-'; break;", "      case K_KDIVIDE:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KDIVIDE:", "        c = '/'; break;", "      case K_KMULTIPLY:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KMULTIPLY:", "        c = '*'; break;", "      case K_KENTER:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KENTER:", "        c = CAR; break;", "      case K_KPOINT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KPOINT:", "        c = '.'; break;", "      case K_KCOMMA:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KCOMMA:", "        c = ','; break;", "      case K_KEQUAL:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_KEQUAL:", "        c = '='; break;", "      case K_K0:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K0:", "        c = '0'; break;", "      case K_K1:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K1:", "        c = '1'; break;", "      case K_K2:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K2:", "        c = '2'; break;", "      case K_K3:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K3:", "        c = '3'; break;", "      case K_K4:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K4:", "        c = '4'; break;", "      case K_K5:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K5:", "        c = '5'; break;", "      case K_K6:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K6:", "        c = '6'; break;", "      case K_K7:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K7:", "        c = '7'; break;", "      case K_K8:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K8:", "        c = '8'; break;", "      case K_K9:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_K9:", "        c = '9'; break;", ""], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XUP:", "        c = K_UP; break;", "      case K_XDOWN:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XDOWN:", "        c = K_DOWN; break;", "      case K_XLEFT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XLEFT:", "        c = K_LEFT; break;", "      case K_XRIGHT:"], "whitespace/newline"]
["src/nvim/getchar.c", ["      case K_XRIGHT:", "        c = K_RIGHT; break;", "      }"], "whitespace/newline"]
["src/nvim/getchar.c", ["", "  /*", "   * In the main loop \"may_garbage_collect\" can be set to do garbage"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like vgetc(), but never return a NUL when called recursively, get a key"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Like safe_vgetc(), but loop to handle K_IGNORE."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if a character is available, such that vgetc() will not block."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Check if any character is available, also half an escape sequence."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Call vpeekc() without causing anything to be mapped."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  ++vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["  if (advance) {", "    KeyStuffed = FALSE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["              } else {", "                --curwin->w_wcol;", "                col = curwin->w_cursor.col - 1;"], "readability/increment"]
["src/nvim/getchar.c", ["", "  --vgetc_busy;", ""], "readability/increment"]
["src/nvim/getchar.c", ["", "  /*", "   * Don't reset these when at the hit-return prompt, otherwise an endless"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Delete one entry from the abbrlist or maphash[]."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Initialize maphash[] for first use."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["    memset(maphash, 0, sizeof(maphash));", "    maphash_valid = TRUE;", "  }"], "readability/bool"]
["src/nvim/getchar.c", ["", "/*", " * Get the mapping mode from the command name."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Clear all mappings or abbreviations."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (hash = 0; hash < 256; ++hash) {", "    if (abbr) {"], "readability/increment"]
["src/nvim/getchar.c", ["        }", "        /*", "         * May need to put this entry into another hash list."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /* Use FALSE below if we only want things like <Up> to show up as such on", "   * the rhs, and not M-x etc, TRUE gets both -- webb */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "/*", " * Used below when expanding mapping/abbreviation names."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  /*", "   * round == 1: Count the matches."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["   */", "  for (round = 1; round <= 2; ++round) {", "    count = 0;"], "readability/increment"]
["src/nvim/getchar.c", ["        if (round == 1) {", "          ++count;", "        } else {"], "readability/increment"]
["src/nvim/getchar.c", ["", "    for (hash = 0; hash < 256; ++hash) {", "      if (expand_isabbrev) {"], "readability/increment"]
["src/nvim/getchar.c", ["            if (round == 1) {", "              ++count;", "            } else {"], "readability/increment"]
["src/nvim/getchar.c", ["      }", "      ++clen;", "    }"], "readability/increment"]
["src/nvim/getchar.c", ["    if (mp != NULL) {", "      /*", "       * Found a match:"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      }", "      --str;", "      continue;"], "readability/increment"]
["src/nvim/getchar.c", ["    c = *str;", "    /*", "     * Special key codes have to be translated to be able to make sense"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * A '\\n' in a map command should be written as <NL>."], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "    /*", "     * Some characters have to be escaped with CTRL-V to"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["      for (; mp != NULL; mp = mp->m_next) {", "        /* skip entries with wrong mode, wrong length and not matching", "         * ones */"], "readability/old_style_comment"]
["src/nvim/getchar.c", ["", "  for (; *str; ++str) {", "    int c = *str;"], "readability/increment"]

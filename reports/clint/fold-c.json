["src/nvim/fold.c", ["", "/*", " * fold.c: code for folding"], "readability/old_style_comment"]
["src/nvim/fold.c", ["// typedef fold_T {{{2", "/*", " * The toplevel folds for each window are stored in the w_folds growarray."], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * While updating the folds lines between invalid_top and invalid_bot have an"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "/*", " * When using 'foldexpr' we sometimes get the level of the next line, which"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (cache) {", "    /*", "     * First look in cached info for displayed lines.  This is probably"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  if (first == 0) {", "    /*", "     * Recursively search for a fold that contains \"lnum\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["      lnum_rel -= fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  if (foldmethodIsDiff(curwin) && curwin->w_p_scb) {", "    /*", "     * Set the same foldlevel in other windows in diff mode."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    fp = (fold_T *)wp->w_folds.ga_data;", "    for (int i = 0; i < wp->w_folds.ga_len; ++i) {", "      fp[i].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["  fold_T *fp;", "  int retval = FALSE;", ""], "readability/bool"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    // Only manually opened folds may need to be closed."], "readability/increment"]
["src/nvim/fold.c", ["        fp[i].fd_flags = FD_LEVEL;", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/fold.c", ["  if (foldmethodIsManual(curwin) || foldmethodIsMarker(curwin)) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/fold.c", ["  int cont;", "  int use_level = FALSE;", "  int closed = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int closed = FALSE;", "  int level = 0;"], "readability/bool"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["    if (found_ga == NULL) {", "      ++lnum;", "    } else {"], "readability/increment"]
["src/nvim/fold.c", ["    // reset got_int here, otherwise it won't work", "    got_int = FALSE;", "    foldUpdateIEMS(wp, top, bot);"], "readability/bool"]
["src/nvim/fold.c", ["          }", "          --fp;", "        } else {"], "readability/increment"]
["src/nvim/fold.c", ["      lnum_off += fp->fd_top;", "      ++level;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["", "  for (i = 0; i < win->w_lines_valid; ++i) {", "    if (win->w_lines[i].wl_valid) {"], "readability/increment"]
["src/nvim/fold.c", ["    cloneFoldGrowArray(&from_p->fd_nested, &to_p->fd_nested);", "    ++to->ga_len;", "    ++from_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++to->ga_len;", "    ++from_p;", "    ++to_p;"], "readability/increment"]
["src/nvim/fold.c", ["    ++from_p;", "    ++to_p;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * Perform a binary search."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    lnum_rel -= fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["", "  for (n = 0; n < count; ++n) {", "    done = DONE_NOTHING;"], "readability/increment"]
["src/nvim/fold.c", ["", "    /*", "     * Do the same operation in other windows in diff mode.  Calculate the"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  int level = 0;", "  int use_level = FALSE;", "  int found_fold = FALSE;"], "readability/bool"]
["src/nvim/fold.c", ["  int use_level = FALSE;", "  int found_fold = FALSE;", "  garray_T *gap;"], "readability/bool"]
["src/nvim/fold.c", ["", "  /*", "   * Find the fold, open or close it."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    // lnum is inside this fold", "    found_fold = TRUE;", ""], "readability/bool"]
["src/nvim/fold.c", ["    if (use_level || fp->fd_flags == FD_LEVEL) {", "      use_level = TRUE;", "      if (level >= wp->w_p_fdl) {"], "readability/bool"]
["src/nvim/fold.c", ["      fp2 = (fold_T *)fp->fd_nested.ga_data;", "      for (j = 0; j < fp->fd_nested.ga_len; ++j) {", "        fp2[j].fd_flags = FD_LEVEL;"], "readability/increment"]
["src/nvim/fold.c", ["    off += fp->fd_top;", "    ++level;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["  fp = (fold_T *)fpr->fd_nested.ga_data;", "  for (int i = 0; i < fpr->fd_nested.ga_len; ++i) {", "    foldOpenNested(&fp[i]);"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * Adjust all folds below \"line1\" that are affected."], "readability/old_style_comment"]
["src/nvim/fold.c", ["   */", "  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*"], "readability/increment"]
["src/nvim/fold.c", ["  for (int i = (int)(fp - (fold_T *)gap->ga_data); i < gap->ga_len; ++i, ++fp) {", "    /*", "     * Check for these situations:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["  fp = (fold_T *)gap->ga_data;", "  for (int i = 0; i < gap->ga_len; ++i) {", "    level = getDeepestNestingRecurse(&fp[i].fd_nested) + 1;"], "readability/increment"]
["src/nvim/fold.c", ["    if (ascii_isdigit(p[len])) {", "      ++len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  // an error occurred when evaluating 'fdt' setting", "  static int got_fdt_error = FALSE;", "  int save_did_emsg = did_emsg;"], "readability/bool"]
["src/nvim/fold.c", ["    // window changed, try evaluating foldtext setting once again", "    got_fdt_error = FALSE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["    // a previous error should not abort evaluating 'foldexpr'", "    did_emsg = FALSE;", "  }"], "readability/bool"]
["src/nvim/fold.c", ["      if (text == NULL || did_emsg) {", "        got_fdt_error = TRUE;", "      }"], "readability/bool"]
["src/nvim/fold.c", ["  while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1])) {", "    --cms_slen;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["    while (cms_slen > 0 && ascii_iswhite(cms_start[cms_slen - 1])) {", "      --cms_slen;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["      if (ascii_isdigit(s[len])) {", "        ++len;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["      while (ascii_iswhite(s[len])) {", "        ++len;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * If folding is defined by the syntax, it is possible that a change in"], "readability/old_style_comment"]
["src/nvim/fold.c", ["      }", "      ++current_fdl;", ""], "readability/increment"]
["src/nvim/fold.c", ["      }", "      ++fline.lnum;", "      fline.lvl = fline.lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["", "  /*", "   * If using the marker method, the start line is not the start of a fold"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Loop over all lines in this fold, or until \"bot\" is hit."], "readability/old_style_comment"]
["src/nvim/fold.c", ["        while (foldFind(&fp2->fd_nested, ll, &fp2)) {", "          ++i;", "          ll -= fp2->fd_top;"], "readability/increment"]
["src/nvim/fold.c", ["            || flp->lnum == linecount)) {", "      /*", "       * Remove or update folds that have lines between startlnum and"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    if (lvl < level || flp->lnum > linecount) {", "      /*", "       * Found a line with a lower foldlevel, this fold ends just above"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "    /*", "     * The fold includes the line \"flp->lnum\" and \"flp->lnum_save\"."], "readability/old_style_comment"]
["src/nvim/fold.c", ["    } else {", "      /*", "       * Get the level of the next line, then continue the loop to check"], "readability/old_style_comment"]
["src/nvim/fold.c", ["", "  /*", "   * Get here when:"], "readability/old_style_comment"]
["src/nvim/fold.c", ["    ga_grow(gap1, gap2->ga_len);", "    for (idx = 0; idx < gap2->ga_len; ++idx) {", "      ((fold_T *)gap1->ga_data)[gap1->ga_len]"], "readability/increment"]
["src/nvim/fold.c", ["      ((fold_T *)gap1->ga_data)[gap1->ga_len].fd_top += fp1->fd_len;", "      ++gap1->ga_len;", "    }"], "readability/increment"]
["src/nvim/fold.c", ["  cstart = *startmarker;", "  ++startmarker;", "  cend = *foldendmarker;"], "readability/increment"]
["src/nvim/fold.c", ["      } else {", "        ++flp->lvl;", "        ++flp->lvl_next;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl;", "        ++flp->lvl_next;", "        ++flp->start;"], "readability/increment"]
["src/nvim/fold.c", ["        ++flp->lvl_next;", "        ++flp->start;", "      }"], "readability/increment"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]
["src/nvim/fold.c", ["    }", "    ++fp;", "  }"], "readability/increment"]

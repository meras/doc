["src/nvim/move.c", ["", "/*", " * move.c: Functions for moving the cursor and scrolling text."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_botline for the current wp->w_topline.  Can be called after"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If w_cline_row is valid, start there."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline and redraw if necessary."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update curwin->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If the cursor is below the bottom of the window, scroll the window"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Need to redraw when topline changed."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Update win->w_topline to move the cursor onto the screen."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the scrolljump value to use for the current window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true when there are not 'scrolloff' lines above the cursor for the"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Check if the cursor has moved.  Set the w_valid flag accordingly."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when some window settings have changed, which require"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set wp->w_topline to a certain number."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of the cursor line (in screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Call this function when the length of a line (in screen characters) above"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Make sure the value of curwin->w_botline is valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Mark curwin->w_botline as invalid (because of some change in the buffer)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return true if curwin->w_wrow and curwin->w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate cursor position.  Makes sure w_wrow and w_wcol are valid."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute wp->w_cline_row and wp->w_cline_height, based on the current value"], "readability/old_style_comment"]
["src/nvim/move.c", ["  wp->w_cline_row = 0;", "  for (linenr_T lnum = wp->w_topline; lnum < wp->w_cursor.lnum; ++i) {", "    bool valid = false;"], "readability/increment"]
["src/nvim/move.c", ["      } else if (wp->w_lines[i].wl_lnum > lnum) {", "        --i;                            // hold at inserted lines", "      }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate wp->w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate curwin->w_cline_height only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Validate w_wcol and w_virtcol only."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Compute offset of a window, occupied by absolute or relative line number,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Return the difference in column offset for the second screen line of a"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * First make sure that w_topline is valid (after moving the cursor)."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the number of virtual columns."], "readability/old_style_comment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["           && (plines =", "                 plines_win_nofill(wp, wp->w_cursor.lnum, false)) - 1", "           >= wp->w_height_inner))"], "whitespace/alignment"]
["src/nvim/move.c", ["      }", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["      if (hasFolding(curwin->w_topline, &first, NULL)) {", "        ++done;", "        if (!byfold) {"], "readability/increment"]
["src/nvim/move.c", ["    }", "    --curwin->w_botline;                // approximate w_botline", "    invalidate_botline();"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Compute the row number of the last row of the cursor line"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (hasFolding(curwin->w_cursor.lnum, &first, NULL)) {", "      --wrow;", "      if (first == 1) {"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_topfill > 0) {", "        --curwin->w_topfill;", "      } else {"], "readability/increment"]
["src/nvim/move.c", ["      if (down && wp->w_topline > 1) {", "        --wp->w_topline;", "        wp->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Use as many filler lines as possible for w_topline.  Make sure w_topline"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line down, but don't do it if it would move the"], "readability/old_style_comment"]
["src/nvim/move.c", ["    if (can_fill) {", "      ++curwin->w_topfill;", "      check_topfill(curwin, true);"], "readability/increment"]
["src/nvim/move.c", ["    } else {", "      --curwin->w_topline;", "      curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["    (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);", "    --curwin->w_botline;            // approximate w_botline", "    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Scroll the screen one line up, but don't do it if it would move the cursor"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Add one line above \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    --lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Add one line below \"lp->lnum\".  This can be a filler line, a closed fold or"], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    ++lp->lnum;", "    lp->fill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines below lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Switch from including filler lines above lp->lnum to including filler"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the top of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Decrease topline until:"], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (hasFolding(curwin->w_cursor.lnum, &top, &bot)) {", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  } else {"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Check if the lines from \"top\" to \"bot\" fit in the window.  If they do,"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "    /*", "     * If scrolling is needed, scroll at least 'sj' lines."], "readability/old_style_comment"]
["src/nvim/move.c", ["    new_topline = top;", "    --top;", "    ++bot;"], "readability/increment"]
["src/nvim/move.c", ["    --top;", "    ++bot;", "  }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * If we don't have enough space, put cursor in the middle."], "readability/old_style_comment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * If \"always\" is false, only adjust topline to a lower value, higher"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Set w_empty_rows and w_filler_rows for window \"wp\", having used up \"used\""], "readability/old_style_comment"]
["src/nvim/move.c", ["", "/*", " * Recompute topline to put the cursor at the bottom of the window."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Stop counting lines to scroll when"], "readability/old_style_comment"]
["src/nvim/move.c", ["      i += boff.height;", "      ++line_count;", "    }"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * Scroll up if the cursor is off the bottom of the screen a bit."], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If topline didn't change we need to restore w_botline and w_empty_rows"], "readability/old_style_comment"]
["src/nvim/move.c", ["      } else {", "        ++below;                    // count a \"~\" line", "        if (atend) {"], "readability/increment"]
["src/nvim/move.c", ["        if (atend) {", "          ++used;", "        }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Correct the cursor position so that it is in a part of the screen at least"], "readability/old_style_comment"]
["src/nvim/move.c", ["{", "  /*", "   * How many lines we would like to have above/below the cursor depends on"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * If there are sufficient file-lines above and below the cursor, we can"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * Narrow down the area where the cursor can be put by taking lines from"], "readability/old_style_comment"]
["src/nvim/move.c", ["      }", "      ++topline;", "    }"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * move screen 'count' pages up or down and update screen"], "readability/old_style_comment"]
["src/nvim/move.c", ["        if (p_window <= 2) {", "          ++curwin->w_topline;", "        } else {"], "readability/increment"]
["src/nvim/move.c", ["        if (p_window <= 2) {", "          --curwin->w_topline;", "        } else {"], "readability/increment"]
["src/nvim/move.c", ["          if (curwin->w_topfill == loff.fill) {", "            --curwin->w_topline;", "            curwin->w_topfill = 0;"], "readability/increment"]
["src/nvim/move.c", ["", "/*", " * Decide how much overlap to use for page-up or page-down scrolling."], "readability/old_style_comment"]
["src/nvim/move.c", ["  if (flag) {", "    /*", "     * scroll the text up"], "readability/old_style_comment"]
["src/nvim/move.c", ["        if (curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count) {", "          ++curwin->w_cursor.lnum;", "          curwin->w_valid &="], "readability/increment"]
["src/nvim/move.c", ["                           &curwin->w_cursor.lnum);", "          ++curwin->w_cursor.lnum;", "        }"], "readability/increment"]
["src/nvim/move.c", ["  } else {", "    /*", "     * scroll the text down"], "readability/old_style_comment"]
["src/nvim/move.c", ["        }", "        --curwin->w_topline;", "        (void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);"], "readability/increment"]
["src/nvim/move.c", ["      if (curwin->w_cursor.lnum > 1) {", "        --curwin->w_cursor.lnum;", "        curwin->w_valid &= ~(VALID_VIRTCOL|VALID_CHEIGHT|VALID_WCOL);"], "readability/increment"]
["src/nvim/move.c", ["        while (--n >= 0 && curwin->w_cursor.lnum > 1) {", "          --curwin->w_cursor.lnum;", "          (void)hasFolding(curwin->w_cursor.lnum,"], "readability/increment"]
["src/nvim/move.c", ["", "  /*", "   * loop through the cursorbound windows"], "readability/old_style_comment"]
["src/nvim/move.c", ["", "  /*", "   * reset current-window"], "readability/old_style_comment"]

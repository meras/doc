["src/nvim/viml/parser/expressions.c", ["      ret.data.var.autoload = (", "                               memchr(pline.data + 2, AUTOLOAD_CHAR, ret.len - 2)", "                               != NULL);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                               memchr(pline.data + 2, AUTOLOAD_CHAR, ret.len - 2)", "                               != NULL);", "      // Previous CHARREG stopped at autoload character in order to make it"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    ret.data.cmp.type = ((ret.data.cmp.inv ^ haseqsign)", "                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                           ? kExprCmpGreaterOrEqual", "                           : kExprCmpGreater);", "    break;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["  const ExprOpAssociativity bop_node_ass = (", "                                            (bop_node->type == kExprNodeCall", "                                             || bop_node->type == kExprNodeSubscript)"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    const bool is_concat_or_subscript = (", "                                         want_node == kENodeValue", "                                         && kv_size(ast_stack) > 1"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                         want_node == kENodeValue", "                                         && kv_size(ast_stack) > 1", "                                         && (*kv_Z(ast_stack,"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                         && kv_size(ast_stack) > 1", "                                         && (*kv_Z(ast_stack,", "                                                   1))->type == kExprNodeConcatOrSubscript);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["    const int lexer_additional_flags = (", "                                        kELFlagPeek", "                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                        kELFlagPeek", "                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)", "                                        | ((want_node == kENodeValue"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                        | ((flags & kExprFlagsDisallowEOC) ? kELFlagForbidEOC : 0)", "                                        | ((want_node == kENodeValue", "                                            && (kv_size(ast_stack) == 1"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                                        != kExprNodeConcatOrSubscript))))", "           ? kELFlagAllowFloat", "           : 0));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["           ? kELFlagAllowFloat", "           : 0));", "    LexExprToken cur_token = viml_pexpr_next_token(pstate,"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["    const bool node_is_key = (", "                              is_concat_or_subscript", "                              && (cur_token.type == kExprLexPlainIdentifier"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              is_concat_or_subscript", "                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);", "    if (is_concat_or_subscript && !node_is_key) {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                              && (cur_token.type == kExprLexPlainIdentifier", "            ? (!cur_token.data.var.autoload", "               && cur_token.data.var.scope == kExprVarScopeMissing)"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["               && cur_token.data.var.scope == kExprVarScopeMissing)", "            : (cur_token.type == kExprLexNumber))", "                              && prev_token.type != kExprLexSpacing);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        cur_node->data.opt.ident = (", "                                    pline.data + cur_token.start.col + cur_token.len);", "        cur_node->data.opt.ident_len = 0;"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["        cur_node->data.opt.scope = (", "                                    cur_token.len == 3", "              ? (ExprOptScope)pline.data[cur_token.start.col + 1]"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                                    cur_token.len == 3", "              ? (ExprOptScope)pline.data[cur_token.start.col + 1]", "              : kExprOptScopeUnspecified);"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["              ? (ExprOptScope)pline.data[cur_token.start.col + 1]", "              : kExprOptScopeUnspecified);", "      } else {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["      const size_t scope_shift = (", "                                  cur_token.data.opt.scope == kExprOptScopeUnspecified ? 0 : 2);", "      if (scope_shift) {"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                   new_top_node->data.fig.opening_hl_idx).group = (", "                                                                   HL(FigureBrace));", "            }"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["                   new_top_node->data.fig.opening_hl_idx).group = (", "                                                                   HL(FigureBrace));", "            }"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["      const ExprVarScope scope = (cur_token.type == kExprLexInvalid", "                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                    ? kExprVarScopeMissing", "                                    : cur_token.data.var.scope);", "      if (want_node == kENodeValue) {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? kExprNodePlainKey", "                                 : kExprNodePlainIdentifier));", "        cur_node->data.var.scope = scope;"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                              (node_is_key", "                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                                 ? HL(IdentifierKey)", "                                 : HL(IdentifierName)));", "      } else {"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["        const uint8_t prefix_length = base_to_prefix_length[", "                                                            cur_token.data.num.base];", "        viml_parser_highlight(pstate, cur_token.start, prefix_length,"], "whitespace/indent"]
["src/nvim/viml/parser/expressions.c", ["        ERROR_FROM_TOKEN_AND_MSG(cur_token, (is_double", "                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                          ? _(\"E114: Missing double quote: %.*s\")", "                          : _(\"E115: Missing single quote: %.*s\")));", "      }"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["      NEW_NODE_WITH_CUR_POS(cur_node, (is_double", "                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));"], "whitespace/alignment"]
["src/nvim/viml/parser/expressions.c", ["                       ? kExprNodeDoubleQuotedString", "                       : kExprNodeSingleQuotedString));", "      *top_node_p = cur_node;"], "whitespace/alignment"]

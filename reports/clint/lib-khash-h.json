["src/nvim/lib/khash.h", ["// marker so line numbers and indices both start at 1", "/* The MIT License", ""], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "   Example:"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*", "   2013-05-02 (0.2.8):"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "   @header"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#else", "typedef unsigned long long khint64_t;", "#endif"], "runtime/int"]
["src/nvim/lib/khash.h", ["", "#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isempty(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&2)", "#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_isdel(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&1)", "#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_iseither(flag, i) ((flag[i>>4]>>((i&0xfU)<<1))&3)", "#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isdel_false(flag, i) (flag[i>>4]&=~(khint_t)(1ul<<((i&0xfU)<<1)))", "#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isempty_false(flag, i) (flag[i>>4]&=~(khint_t)(2ul<<((i&0xfU)<<1)))", "#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define __ac_set_isboth_false(flag, i) (flag[i>>4]&=~(khint_t)(3ul<<((i&0xfU)<<1)))", "#define __ac_set_isdel_true(flag, i) (flag[i>>4]|=(khint_t)1ul<<((i&0xfU)<<1))", ""], "whitespace/operators"]
["src/nvim/lib/khash.h", ["# define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, \\", "                        ++(x))", "#endif"], "readability/increment"]
["src/nvim/lib/khash.h", ["      mask = h->n_buckets - 1; \\", "      k = __hash_func(key); i = k & mask; \\", "      last = i; \\"], "whitespace/newline"]
["src/nvim/lib/khash.h", ["    if (j) {  /* rehashing is needed */ \\", "      for (j = 0; j != h->n_buckets; ++j) { \\", "        if (__ac_iseither(h->flags, j) == 0) { \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["      __ac_set_isdel_true(h->flags, x); \\", "      --h->size; \\", "    } \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_func(key) (khint32_t)(key)", "/*! @function", "   @abstract     Integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int_hash_equal(a, b) ((a) == (b))", "/*! @function", "   @abstract     64-bit integer hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", [" */", "#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_func(key) (khint32_t)((key)>>33^(key)^(key)<<11)", "/*! @function", "   @abstract     64-bit integer comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_int64_hash_equal(a, b) ((a) == (b))", "/*! @function", "   @abstract     const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["{", "  khint_t h = (khint_t)*s;", "  if (h) {"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["  if (h) {", "    for (++s; *s; ++s) { h = (h << 5) - h + (uint8_t)*s; }", "  }"], "whitespace/operators"]
["src/nvim/lib/khash.h", ["  if (h) {", "    for (++s; *s; ++s) { h = (h << 5) - h + (uint8_t)*s; }", "  }"], "readability/increment"]
["src/nvim/lib/khash.h", ["}", "/*! @function", "   @abstract     Another interface to const char* hash function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_str_hash_func(key) __ac_X31_hash_string(key)", "/*! @function", "   @abstract     Const char* comparison function"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*!", "   @abstract Type of the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Initiate a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Destroy a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Free memory referenced directly inside a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Reset a hash table without deallocating memory."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Resize a hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Insert a key to the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Retrieve a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Remove a key from the hash table."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Test whether a bucket contains data."], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get key given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get value given an iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Alias of kh_val()"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the start iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the end iterator"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the number of elements in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Get the number of buckets in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the entries in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_foreach(h, kvar, vvar, code) { khint_t __i; \\", "                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\", "                                            (kvar) = kh_key(h, __i); \\"], "readability/braces"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the values in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["#define kh_foreach_value(h, vvar, code) { khint_t __i; \\", "                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\"], "readability/increment"]
["src/nvim/lib/khash.h", ["                                          for (__i = kh_begin(h); __i != kh_end(h); ++__i) { \\", "                                            if (!kh_exist(h, __i)) continue; \\", "                                            (vvar) = kh_val(h, __i); \\"], "readability/braces"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Iterate over the keys in the hash table"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash set containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing 64-bit integer keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["typedef const char *kh_cstr_t;", "/*! @function", "   @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Instantiate a hash map containing const char* keys"], "readability/old_style_comment"]
["src/nvim/lib/khash.h", ["", "/*! @function", "   @abstract     Return a literal for an empty hash table."], "readability/old_style_comment"]

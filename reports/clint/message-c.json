["src/nvim/message.c", ["", "/*", " * message.c: functions for displaying messages on the command line"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * To be able to scroll back at the \"more\" and \"hit-enter\" prompts we need to"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "static int confirm_msg_used = FALSE;            // displaying confirm_msg", "#ifdef INCLUDE_GENERATED_DECLARATIONS"], "readability/bool"]
["src/nvim/message.c", ["static FILE *verbose_fd = NULL;", "static int verbose_did_open = FALSE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "/*", " * When writing messages to the screen, there are many different situations."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * It is possible that displaying a messages causes a problem (e.g.,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (entered >= 3) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  ++entered;", ""], "readability/increment"]
["src/nvim/message.c", ["  msg_start();", "  buf = msg_strtrunc((char_u *)s, FALSE);", "  if (buf != NULL) {"], "readability/bool"]
["src/nvim/message.c", ["  xfree(buf);", "  --entered;", "  return retval;"], "readability/increment"]
["src/nvim/message.c", ["  // First part: Start of the string.", "  for (e = 0; len < half && e < buflen; ++e) {", "    if (s[e] == NUL) {"], "readability/increment"]
["src/nvim/message.c", ["", "/*", " * Note: Caller of smsg() and smsg_attr() must check the resulting string is"], "readability/old_style_comment"]
["src/nvim/message.c", ["", "/*", " * Remember the last sourcing name/lnum used in an error message, so that it"], "readability/old_style_comment"]
["src/nvim/message.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["  }", "  --no_wait_return;", "}"], "readability/increment"]
["src/nvim/message.c", ["      || emsg_skip > 0) {", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["", "    /*", "     * When using \":silent! cmd\" ignore error messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Display name and line number for the source of the error."], "readability/old_style_comment"]
["src/nvim/message.c", ["  while (len > 0 && *s == '\\n') {", "    ++s;", "    --len;"], "readability/increment"]
["src/nvim/message.c", ["    ++s;", "    --len;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  xfree(p);", "  --msg_hist_len;", "  return OK;"], "readability/increment"]
["src/nvim/message.c", ["", "  /*", "   * When inside vgetc(), we can't wait for a typed character at all."], "readability/old_style_comment"]
["src/nvim/message.c", ["    c = CAR;                    // just pretend CR was hit", "    quit_more = FALSE;", "    got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["    quit_more = FALSE;", "    got_int = FALSE;", "  } else if (exmode_active) {"], "readability/bool"]
["src/nvim/message.c", ["    c = CAR;                    // no need for a return in ex mode", "    got_int = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/message.c", ["", "      /*", "       * Allow scrolling back in the messages."], "readability/old_style_comment"]
["src/nvim/message.c", ["            c = CAR;                            // just pretend CR was hit", "            quit_more = FALSE;", "            got_int = FALSE;"], "readability/bool"]
["src/nvim/message.c", ["            quit_more = FALSE;", "            got_int = FALSE;", "          } else if (c != K_IGNORE) {"], "readability/bool"]
["src/nvim/message.c", ["    os_breakcheck();", "    /*", "     * Avoid that the mouse-up event causes visual mode to start."], "readability/old_style_comment"]
["src/nvim/message.c", ["", "  /*", "   * Go over the string.  Special characters are translated and printed."], "readability/old_style_comment"]
["src/nvim/message.c", ["    msg_putchar('\\n');", "    for (i = 0; rs[i]; ++i) {", "      msg_putchar(rs[i] - 3);"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["", "      /*", "       * If screen is completely filled and 'more' is set then wait"], "readability/old_style_comment"]
["src/nvim/message.c", ["      if (lines_left > 0) {", "        --lines_left;", "      }"], "readability/increment"]
["src/nvim/message.c", ["      if (msg_col) {", "        --msg_col;", "      }"], "readability/increment"]
["src/nvim/message.c", ["    }", "    ++s;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  } else if (finish && last_msgchunk != NULL) {", "    last_msgchunk->sb_eol = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    do_more_prompt('G');", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["  if (last_msgchunk != NULL) {", "    last_msgchunk->sb_eol = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["    if (*p == '\\n') {       // don't display the line break", "      ++p;", "    }"], "readability/increment"]
["src/nvim/message.c", ["    }", "    msg_puts_display(p, -1, mp->sb_attr, TRUE);", "    if (mp->sb_eol || mp->sb_next == NULL) {"], "readability/bool"]
["src/nvim/message.c", ["    msg_col = 0;", "    ++msg_row;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  int c;", "  int retval = FALSE;", "  int toscroll;"], "readability/bool"]
["src/nvim/message.c", ["    for (i = 0; i < Rows - 2 && mp_last != NULL", "         && mp_last->sb_prev != NULL; ++i) {", "      mp_last = msg_sb_start(mp_last->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["  if (typed_char == NUL) {", "    msg_moremsg(FALSE);", "  }"], "readability/bool"]
["src/nvim/message.c", ["  for (;;) {", "    /*", "     * Get a typed character directly from the user."], "readability/old_style_comment"]
["src/nvim/message.c", ["        // Jump to the choices of the dialog.", "        retval = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/message.c", ["      } else {", "        got_int = TRUE;", "        quit_more = TRUE;"], "readability/bool"]
["src/nvim/message.c", ["        got_int = TRUE;", "        quit_more = TRUE;", "      }"], "readability/bool"]
["src/nvim/message.c", ["    default:                    // no valid response", "      msg_moremsg(TRUE);", "      continue;"], "readability/bool"]
["src/nvim/message.c", ["        for (i = 0; i < Rows - 2 && mp != NULL && mp->sb_prev != NULL;", "             ++i) {", "          mp = msg_sb_start(mp->sb_prev);"], "readability/increment"]
["src/nvim/message.c", ["              mp = disp_sb_line(i, mp);", "              ++msg_scrolled;", "            }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = Columns;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["      msg_col = 0;", "      ++msg_row;", "    }"], "readability/increment"]
["src/nvim/message.c", ["{", "  /*", "   * If the string is larger than the window,"], "readability/old_style_comment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    ++msg_silent;", "  }"], "readability/increment"]
["src/nvim/message.c", ["  if (*p_vfile != NUL) {", "    ++msg_silent;", "  } else {"], "readability/increment"]
["src/nvim/message.c", ["    // always scroll up, don't overwrite", "    msg_scroll = TRUE;", "  }"], "readability/bool"]
["src/nvim/message.c", ["  }", "  verbose_did_open = FALSE;", "}"], "readability/bool"]
["src/nvim/message.c", ["    // Only give the error message once.", "    verbose_did_open = TRUE;", ""], "readability/bool"]
["src/nvim/message.c", ["", "  /*", "   * Since we wait for a keypress, don't make the"], "readability/old_style_comment"]
["src/nvim/message.c", ["   */", "  ++no_wait_return;", "  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);"], "readability/increment"]
["src/nvim/message.c", ["  setmouse();", "  --no_wait_return;", "  msg_end_prompt();"], "readability/increment"]
["src/nvim/message.c", ["      if (*r == DLG_HOTKEY_CHAR) {", "        ++r;", "      }"], "readability/increment"]
["src/nvim/message.c", ["                message,", "                (char_u *)_(\"&Yes\\n&No\"), dflt, NULL, FALSE) == 1) {", "    return VIM_YES;"], "readability/bool"]
["src/nvim/message.c", ["                    message,", "                    (char_u *)_(\"&Yes\\n&No\\n&Cancel\"), dflt, NULL, FALSE)) {", "  case 1:"], "readability/bool"]
["src/nvim/message.c", ["                    (char_u *)_(\"&Yes\\n&No\\nSave &All\\n&Discard All\\n&Cancel\"),", "                    dflt, NULL, FALSE)) {", "  case 1:"], "readability/bool"]

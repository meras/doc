["src/nvim/ex_docmd.c", ["", "/*", " * Structure used to store info for line position in a while or for loop."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "/*", " * Declare cmdnames[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["{", "  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->trylevel       = trylevel;             trylevel = 0;", "  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  dsp->force_abort    = force_abort;          force_abort = FALSE;", "  dsp->caught_stack   = caught_stack;         caught_stack = NULL;", "  dsp->vv_exception   = v_exception(NULL);"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  // Necessary for debugging an inactive \":catch\", \":finally\", \":endtry\".", "  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->did_emsg       = did_emsg;             did_emsg     = false;", "  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->got_int        = got_int;              got_int      = false;", "  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->need_rethrow   = need_rethrow;         need_rethrow = false;", "  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  dsp->check_cstack   = check_cstack;         check_cstack = false;", "  dsp->current_exception = current_exception; current_exception = NULL;", "}"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["        msg_col = 0;", "        print_line_no_prefix(curwin->w_cursor.lnum, FALSE, FALSE);", "        msg_clr_eos();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  int count = 0;                        // line number count", "  int did_inc = FALSE;                  // incremented RedrawingDisabled", "  int retval = OK;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  if (getline_is_func && ex_nesting_level == func_level(real_cookie)) {", "    ++ex_nesting_level;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Initialize \"force_abort\"  and \"suppress_errthrow\" at the top level."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Continue executing command lines:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 1. If repeating a line in a loop, get a line from lines_ga."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (next_cmdline == NULL) {", "      /*", "       * Need to set msg_didout for the first line after an \":if\","], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * Keep the first typed line.  Clear it when more lines are typed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Save the current line when inside a \":while\" or \":for\", and when"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (count++ == 0) {", "      /*", "       * All output from the commands is put below each other, without"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        msg_start();", "        msg_scroll = TRUE;          // put messages below each other", "        ++no_wait_return;           // don't wait for return until finished"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        msg_scroll = TRUE;          // put messages below each other", "        ++no_wait_return;           // don't wait for return until finished", "        ++RedrawingDisabled;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++no_wait_return;           // don't wait for return until finished", "        ++RedrawingDisabled;", "        did_inc = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++RedrawingDisabled;", "        did_inc = TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * 2. Execute one '|' separated command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        && !func_has_abort(real_cookie)) {", "      did_emsg = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (cstack.cs_looplevel > 0) {", "      ++current_line;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * An \":endwhile\", \":endfor\" and \":continue\" is handled here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /*", "       * For a \":while\" or \":for\" we need to remember the line number."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       */", "      else if (cstack.cs_lflags & CSL_HAD_LOOP) {", "        cstack.cs_lflags &= ~CSL_HAD_LOOP;"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When not inside any \":while\" loop, clear remembered lines."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * A \":finally\" makes did_emsg, got_int and current_exception pending for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Continue executing command lines when:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["   */", "  while (!((got_int || (did_emsg && force_abort) || current_exception)", "           && cstack.cs_trylevel == 0)"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  if (cstack.cs_idx >= 0) {", "    /*", "     * If a sourced file or executed function ran to its end, report the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Reset \"trylevel\" in case of a \":finish\" or \":return\" or a missing"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    do {", "      int idx = cleanup_conditionals(&cstack, 0, TRUE);", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["      if (idx >= 0) {", "        --idx;              // remove try block not in its finally clause", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "      /*", "       * If the uncaught exception is a user exception, report it as an"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (getline_equal(fgetline, cookie, get_func_line)) {", "      --ex_nesting_level;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Go to debug mode when returning from a function in which we are"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      do_debug(getline_equal(fgetline, cookie, getsourceline)", "          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["          ? (char_u *)_(\"End of sourced file\")", "          : (char_u *)_(\"End of function\"));", "    }"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Restore the exception environment (done after returning from the"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If there was too much output to fit on the command line, ask the user to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (did_inc) {", "    --RedrawingDisabled;", "    --no_wait_return;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --RedrawingDisabled;", "    --no_wait_return;", "    msg_scroll = FALSE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    --no_wait_return;", "    msg_scroll = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * When just finished an \":if\"-\":else\" which was typed, no need to"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (need_wait_return) {", "      /*", "       * The msg_start() above clears msg_didout. The wait_return we do"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      msg_didout |= msg_didout_before_start;", "      wait_return(FALSE);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      store_loop_line(cp->lines_gap, line);", "      ++cp->current_line;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {", "    ++nr;", "    if (wp == win) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  FOR_ALL_TABS(tp) {", "    ++nr;", "    if (tp == tab) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["                        getnextac)) {", "    --quitmore;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Reset browse, confirm, etc..  They are restored when returning, for"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (!ea.skip && got_int) {", "    ea.skip = TRUE;", "    (void)do_intthrow(cstack);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. Parse the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip ':' and any white space"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If we got a line, but no command, then go to the line."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALNUM(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't complain about the range if it is not used"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * For the \":make\" and \":grep\" commands we insert the 'makeprg'/'grepprg'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip to start of argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"++opt=val\" argument."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!' && ea.cmdidx == CMD_write) {  // :w !filter", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    if (ea.forceit) {", "      ea.usefilter = TRUE;                      // :r! filter if ea.forceit", "      ea.forceit = FALSE;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      ea.usefilter = TRUE;                      // :r! filter if ea.forceit", "      ea.forceit = FALSE;", "    } else if (*ea.arg == '!') {              // :r !filter"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    } else if (*ea.arg == '!') {              // :r !filter", "      ++ea.arg;", "      ea.usefilter = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      ++ea.arg;", "      ea.usefilter = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for \"+command\" argument, before checking for next command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for flags: 'l', 'p' and '#'."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip the command when it's not going to be executed."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Accept buffer name.  Cannot be used at the same time with a buffer"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      && !IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * :bdelete, :bwipeout and :bunload take several arguments, separated"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  if (IS_USER_CMDIDX(ea.cmdidx)) {", "    /*", "     * Execute a user-defined command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  } else {", "    /*", "     * Call the function to execute the command."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * If the command just executed called do_cmdline(), any throw or \":return\""], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (source_finished(fgetline, cookie)) {", "      do_finish(&ea, TRUE);", "    } else if (getline_equal(fgetline, cookie, get_func_line)"], "readability/bool"]
["src/nvim/ex_docmd.c", ["               && current_func_returned()) {", "      do_return(&ea, TRUE, FALSE, NULL);", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  }", "  need_rethrow = check_cstack = FALSE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  --ex_nesting_level;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_k;", "    ++p;", "  } else if (p[0] == 's'"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    eap->cmdidx = CMD_substitute;", "    ++p;", "  } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    while (ASCII_ISALPHA(*p)) {", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p)) {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (i == len - 1) {", "        --len;", "        if (p[-1] == 'l') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["            && cmdnames[(int)eap->cmdidx].cmd_name[len] == NUL) {", "          *full = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      while (ASCII_ISALNUM(*p)) {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (k == len || (*np == NUL && ascii_isdigit(eap->cmd[k]))) {", "        /* If finding a second match, the command is ambiguous.  But", "         * not if a buffer-local command wasn't a full match and a"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (!found || (k == len && *np == NUL)) {", "          /* If we matched up to a digit, then there could", "           * be another command including the digit that we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["          }", "          /* Do not search for further abbreviations", "           * if this is an exact match. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["            if (full != NULL) {", "              *full = TRUE;", "            }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* The match we found may be followed immediately by a number.  Move \"p\"", "   * back to point to it. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 3. parse a range specifier of the form: addr [,addr] [;addr] .."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 4. parse command"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  /*", "   * Isolate the command and search for it in the command table."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 5. parse arguments"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check for '|' to separate commands and '\"' to start comments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Allow spaces within back-quotes to count as part of the argument"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      }", "      /* An argument can contain just about everything, except", "       * characters that end the command and white space. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["       * characters that end the command and white space. */", "      else if (c == '|'", "               || c == '\\n'"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * If we are still inside the quotes, and we passed a space, just"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifndef BACKSLASH_IN_FILENAME", "      xp->xp_shell = TRUE;", "#endif"], "readability/bool"]
["src/nvim/ex_docmd.c", ["        xp->xp_context = EXPAND_USER;", "        ++xp->xp_pattern;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * 6. switch on command name"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /* Command modifiers: return the argument.", "   * Also for commands with an argument that is a command. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * All completion for the +cmdline_compl feature goes here."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        if (*cmd++ == '\\\\' && *cmd != NUL) {", "          ++cmd;", "        }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*cmd != NUL) {", "      ++cmd;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '.':                               // '.' - Cursor position", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '$':                               // '$' - last line", "      ++cmd;", "      switch (addr_type) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (skip) {", "        ++cmd;", "      } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        fp = getmark(*cmd, to_other_file && cmd[1] == NUL);", "        ++cmd;", "        if (fp == (pos_T *)-1) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        if (*cmd == c) {", "          ++cmd;", "        }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case '\\\\':                      // \"\\?\", \"\\/\" or \"\\&\", repeat search", "      ++cmd;", "      if (addr_type != ADDR_LINES) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      }", "      ++cmd;", "      break;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Don't do it when \":vimgrep\" is used for \":grep\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Decide to expand wildcards *before* replacing '%', '#', etc.  If"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (*p == '`') {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    }", "    /*", "     * Quick check if this cannot be the start of a special string."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Try to find a match at this position."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * One file argument: Expand wildcards."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    if (has_wildcards) {", "      /*", "       * May expand environment variables.  This"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Halve the number of backslashes (this is Vi compatible)."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["#ifdef UNIX", "    if (!has_wildcards)", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * The new command line is build in new_cmdline[]."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Copy the stuff before the expanded part."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["               // :redir @\" doesn't either.", "               (*p == '\"'", "                && !(eap->argt & EX_NOTRLCOM)"], "whitespace/indent"]
["src/nvim/ex_docmd.c", ["  if (*arg == '+') {        // +[command]", "    ++arg;", "    if (ascii_isspace(*arg) || *arg == '\\0') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      command = arg;", "      arg = skip_cmd_arg(command, TRUE);", "      if (*arg != NUL) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        ++p;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (!unaccept_arg0 && relative == -1) {", "        --tab_number;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, TRUE);          // almost the same as mapping", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  /*", "   * If we are sourcing .exrc or .vimrc in current directory we"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["{", "  do_exmap(eap, FALSE);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  // Search for the command in the already defined commands.", "  for (i = 0; i < gap->ga_len; ++i) {", "    size_t len;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    ++gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "/*", " * List of names for completion for \":command\" with the EXPAND_ flag."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  --gap->ga_len;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /* When specified there is a single argument don't split it.", "     * Works for \":Cmd %\" when % is \"a b c\". */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "    sprintf(num_buf, \"%\" PRId64, (int64_t)num);", "    num_len = STRLEN(num_buf);"], "runtime/printf"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Replace <> in the command by the arguments."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      // Include the '>'", "      ++end;", ""], "readability/increment"]
["src/nvim/ex_docmd.c", ["  // Look for any argument part - which is the part after any ','", "  for (i = 0; i < vallen; ++i) {", "    if (value[i] == ',') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  }", "  close_others(TRUE, eap->forceit);", "}"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /* Don't use 'suffixes' here.  This should work like the shell did the", "   * expansion.  Also, the vimrc file isn't read yet, thus the user"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  old_arg_files = xmalloc(sizeof(*old_arg_files) * GARGCOUNT);", "  for (i = 0; i < GARGCOUNT; ++i) {", "    old_arg_files[i] = vim_strsave(GARGLIST[i].ae_fname);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    alist_set(&global_alist, new_arg_file_count, new_arg_files,", "              TRUE, fnum_list, fnum_len);", "    FreeWild(old_arg_count, old_arg_files);"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  {", "    for (i = 0; i < count; ++i) {", "      if (got_int) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (got_int) {", "        /* When adding many buffers this can take a long time.  Allow", "         * interrupting here. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "      /* May set buffer name of a buffer previously used for the", "       * argument list, so that it's re-used by alist_add. */"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  }", "  ++al->al_ga.ga_len;", "}"], "readability/increment"]
["src/nvim/ex_docmd.c", ["{", "  for (int i = 0; i < GARGCOUNT; ++i) {", "    if (GARGLIST[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (wp->w_alist != &global_alist) {", "      for (int i = 0; i < WARGCOUNT(wp); ++i) {", "        if (WARGLIST(wp)[i].ae_fname != NULL) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Either open new tab page or split the window."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["  msg_start();", "  msg_scroll = TRUE;", ""], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * \":vi\" command ends Ex mode."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * if \":split file\" worked, set alternate file name in old window to new"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * determine max topline"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Set all scrollbind windows to the same topline."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["      if (y > 0) {", "        scrollup(y, TRUE);", "      } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        scrolldown(-y, TRUE);", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      cursor_correct();", "      curwin->w_redr_status = TRUE;", "    }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    ex_pwd(NULL);", "  } else", "#endif"], "readability/braces"]
["src/nvim/ex_docmd.c", ["  case NUL:", "    len *= 1000L; break;", "  default:"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["  default:", "    semsg(_(e_invarg2), eap->arg); return;", "  }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    }", "    op_shift(&oa, FALSE, eap->amount);", "    break;"], "readability/bool"]
["src/nvim/ex_docmd.c", ["    eap->line2 = 1;", "    eap->forceit = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * move or copy lines from 'eap->line1'-'eap->line2' to below line 'n'"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    }", "    ++eap->line2;", "  }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["", "    /*", "     * Execute from the typeahead buffer."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["    case 's':", "      ++p; sec = true; break;", "    case 'm':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 's':", "      ++p; sec = true; break;", "    case 'm':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'm':", "      ++p; sec = true; count *= 60; break;", "    case 'h':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'm':", "      ++p; sec = true; count *= 60; break;", "    case 'h':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'h':", "      ++p; sec = true; count *= 60 * 60; break;", "    case 'd':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'h':", "      ++p; sec = true; count *= 60 * 60; break;", "    case 'd':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'd':", "      ++p; sec = true; count *= 24 * 60 * 60; break;", "    case 'f':"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'd':", "      ++p; sec = true; count *= 24 * 60 * 60; break;", "    case 'f':"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 'f':", "      ++p; file = true; break;", "    }"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case 'f':", "      ++p; file = true; break;", "    }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (*arg == '>') {", "      ++arg;", "      if (*arg == '>') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        mode = \"a\";"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      close_redir();", "      ++arg;", "      if (valid_yank_reg(*arg, true) && *arg != '_') {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["      if (*arg == '>') {", "        ++arg;", "        append = TRUE;"], "readability/increment"]
["src/nvim/ex_docmd.c", ["        ++arg;", "        append = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["      } else {", "        append = FALSE;", "      }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  validate_cursor();"], "readability/bool"]
["src/nvim/ex_docmd.c", ["  update_screen(eap->forceit ? NOT_VALID", "                             : VIsual_active ? INVERTED : 0);", "  if (need_maketitle) {"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["  RedrawingDisabled = 0;", "  p_lz = FALSE;", "  if (eap->forceit) {"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  for (size_t i = 0; i < ARRAY_SIZE(spec_str); ++i) {", "    len = STRLEN(spec_str[i]);"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  if (escaped != NULL) {", "    *escaped = FALSE;", "  }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Check if there is something to do."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Skip when preceded with a backslash \"\\%\" and \"\\#\"."], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * word or WORD under cursor"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["                                        spec_idx == SPEC_CWORD", "        ? (FIND_IDENT | FIND_STRING)", "        : (spec_idx == SPEC_CEXPR"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        ? (FIND_IDENT | FIND_STRING)", "        : (spec_idx == SPEC_CEXPR", "           ? (FIND_IDENT | FIND_STRING | FIND_EVAL)"], "whitespace/alignment"]
["src/nvim/ex_docmd.c", ["        if (escaped != NULL) {", "          *escaped = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_docmd.c", ["", "  /*", "   * Do this loop two times:"], "readability/old_style_comment"]
["src/nvim/ex_docmd.c", ["        }", "        ++len;", "      }"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    if (STRNCMP(p, \"<sfile>\", 7) != 0) {", "      ++p;", "    } else {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["  // First set the marks for all lines closed/open.", "  for (linenr_T lnum = eap->line1; lnum <= eap->line2; ++lnum) {", "    if (hasFolding(lnum, NULL, NULL) == (eap->cmdidx == CMD_folddoclosed)) {"], "readability/increment"]
["src/nvim/ex_docmd.c", ["    case 0:", "      arg[0] = '0'; break;", "    case (EX_EXTRA):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA):", "      arg[0] = '*'; break;", "    case (EX_EXTRA | EX_NOSPC):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NOSPC):", "      arg[0] = '?'; break;", "    case (EX_EXTRA | EX_NEEDARG):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NEEDARG):", "      arg[0] = '+'; break;", "    case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):"], "whitespace/newline"]
["src/nvim/ex_docmd.c", ["    case (EX_EXTRA | EX_NOSPC | EX_NEEDARG):", "      arg[0] = '1'; break;", "    }"], "whitespace/newline"]

["src/nvim/ex_cmds.c", ["", "/*", " * ex_cmds.c: some functions for command line commands"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Oct %o, Digr %s\")", "                          : _(\"> %d, Hex %08x, Oct %o, Digr %s\")),", "                                  c, c, c, dig));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["      iobuff_len += (", "                     vim_snprintf((char *)IObuff + iobuff_len,", "                                  sizeof(IObuff) - iobuff_len,"], "whitespace/indent"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                                  (c < 0x10000", "                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["                          ? _(\"> %d, Hex %04x, Octal %o\")", "                          : _(\"> %d, Hex %08x, Octal %o\")),", "                                  c, c, c));"], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["  } else {", "    /*", "     * if 'textwidth' set, use it"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  for (curwin->w_cursor.lnum = eap->line1;", "       curwin->w_cursor.lnum <= eap->line2; ++curwin->w_cursor.lnum) {", "    if (eap->cmdidx == CMD_left) {              // left align"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    } else {", "      has_tab = FALSE;          // avoid uninit warnings", "      len = linelen(eap->cmdidx == CMD_right ? &has_tab"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      len = linelen(eap->cmdidx == CMD_right ? &has_tab", "                                             : NULL) - get_indent();", ""], "whitespace/alignment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Make sure that embedded TABs don't make the text go too far"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (linelen(NULL) <= width) {", "              /*", "               * Now try to move the line as much as possible to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            }", "            --new_indent;", "          }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  if (got_int) {", "    sort_abort = TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (i == count) {", "    for (i = 0; i < count; ++i) {", "      ml_delete(eap->line1, false);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * First we copy the old text to its new location -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we must be careful adjusting our marks so that we don't overlap our"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Now we delete the original text -- webb"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Leave the cursor on the last of the moved lines."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * there are three situations:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    ++line1;", "    if (curwin->w_cursor.lnum < line1) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line1) {", "      ++line1;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (curwin->w_cursor.lnum < line2) {", "      ++line2;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    }", "    ++curwin->w_cursor.lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  if (addr_count == 0) {                // :!", "    msg_scroll = FALSE;             // don't scroll here", "    autowrite_all();"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Try to find an embedded bang, like in :!<cmd> ! [args]"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Scan the rest of the argument for '!', which is replaced by the"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      ++p;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * Add quotes around the command, for shells that need them."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * When using temp files:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * The writing and reading of temp files will not be shown."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  did_check_timestamps = FALSE;", "  need_check_timestamps = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["  os_breakcheck();", "  got_int = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Put cursor on first filtered line for \":range!cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    } else {", "      /*", "       * Put cursor on last new line for \":r !cmd\"."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    beginline(BL_WHITE | BL_FIX);           // cursor on first non-blank", "    --no_wait_return;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["    curwin->w_cursor = cursor_save;", "    --no_wait_return;", "    wait_return(FALSE);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    --no_wait_return;", "    wait_return(FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * For autocommands we want to get the output on the current screen, to"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  msg_start();", "  silent_mode = FALSE;", "  info_message = true;  // use mch_msg(), not mch_errmsg()"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  }", "  /*", "   * The name of the current buffer will be changed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    }", "    other = FALSE;", "  } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we have a new file, put its name in the list of alternate file names."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (!alt_buf->b_p_bl) {", "        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        alt_buf->b_p_bl = TRUE;", "        apply_autocmds(EVENT_BUFADD, NULL, NULL, FALSE, alt_buf);", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      if (retval == OK) {", "        curbuf->b_p_ro = FALSE;", "        redraw_tabline = true;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * write to other file or b_flags set or not writing the whole file:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        eap->forceit = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["          }", "          eap->forceit = TRUE;", "        } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    /*", "     * Check if there is a reason the buffer cannot be written:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (not_writing()) {", "      ++error;", "      break;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        // Set forceit, to force the writing of a readonly file", "        *forceit = TRUE;", "        return FALSE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        *forceit = TRUE;", "        return FALSE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      } else {", "        return TRUE;", "      }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    }", "    return TRUE;", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  return FALSE;", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (other) {", "    --no_wait_return;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * End Visual mode before switching to another buffer, so the text can be"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we are starting to edit another file, open a (new) buffer."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Make the (new) buffer the one used by the current window."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          curbuf = buf;", "          ++curbuf->b_nwindows;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["          if (!oldbuf && eap != NULL) {", "            set_file_options(TRUE, eap);", "            set_forced_fenc(eap);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["    // CTRL-O to go back to a help file.", "    set_buflisted(TRUE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * other_file oldbuf"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * If we get here we are sure to start editing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if we are editing the w_arg_idx file in the argument list."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (!auto_buf) {", "    /*", "     * Set cursor and init window before reading the file and executing"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Careful: open_buffer() and apply_autocmds() may change the current"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open the buffer and read the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      apply_autocmds_retval(EVENT_BUFENTER, NULL, NULL, FALSE, curbuf,", "                            &retval);"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.coladd = 0;", "        curwin->w_set_curswant = TRUE;", "      } else {"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Did not read the file, need to show some info about the file."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (shortmess(SHM_OVERALL) && !exiting && p_verbose == 0) {", "      msg_scroll = FALSE;", "    }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  if (eap->cmdidx != CMD_append) {", "    --lnum;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    vcol = 0;", "    for (p = theline; indent > vcol; ++p) {", "      if (*p == ' ') {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      if (*p == ' ') {", "        ++vcol;", "      } else if (*p == TAB) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    xfree(theline);", "    ++lnum;", ""], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  for (lnum = eap->line2; lnum >= eap->line1; --lnum) {", "    if (curbuf->b_ml.ml_flags & ML_EMPTY) {         // nothing to delete"], "readability/increment"]
["src/nvim/ex_cmds.c", ["      || *kind == '^' || *kind == '.') {", "    ++x;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["  while (*x == '-' || *x == '+') {", "    ++x;", "  }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    } else if (eap->addr_count == 0) {", "      ++start;", "    }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["    if (joined_lines_count > 1) {", "      do_join(joined_lines_count, FALSE, TRUE, FALSE, true);", "      sub_nsubs = joined_lines_count - 1;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "    /*", "     * Small incompatibility: vi sees '\\n' as end of the command, but in"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * check for trailing command or garbage"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * The new text is build up step by step, to avoid too much"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Loop until nothing more to replace in this line."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        curwin->w_cursor.lnum = lnum;", "        do_again = FALSE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * 1. Match empty string does not count, except for first"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * Loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                                    + len_change;", "              highlight_match = TRUE;", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["                        _(\"replace with %s (y/n/a/q/l/^E/^Y)?\"), sub);", "              msg_no_more = FALSE;", "              msg_scroll = i;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace the line in the buffer when needed.  This is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (new_start != NULL) {", "            /*", "             * Copy the rest of the line, that didn't match."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["            if (nmatch_tl > 0) {", "              /*", "               * Matched lines have now been substituted and are"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["               */", "              ++lnum;", "              if (u_savedel(lnum, nmatch_tl) != OK) {"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "          /*", "           * 5. break if there isn't another match in this line"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * Only report substitutions when:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * undocumented vi feature:"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["{", "  /*", "   * If there is already a preview window open, use that one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    if (!found_win) {", "      /*", "       * There is no preview window open yet.  Create one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["      }", "      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_pvw = TRUE;", "      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'"], "readability/bool"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/multiline_comment"]
["src/nvim/ex_cmds.c", ["      curwin->w_p_wfh = TRUE;", "      RESET_BINDING(curwin);                /* don't take over 'scrollbind'", "                                               and 'cursorbind' */"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["  if (eap != NULL) {", "    /*", "     * A \":help\" command ends at the first LF, or at a '|' that is"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Check if there is a match for the argument."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["    // Find first item with the requested language.", "    for (i = 0; i < num_matches; ++i) {", "      len = (int)STRLEN(matches[i]);"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Re-use an existing help window or open a new one."], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "      /*", "       * Open help file (do_ecmd() will set b_help flag, readfile() will"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                    NULL                  // buffer is still open, don't store info", "                    );", "      if (!cmdmod.keepalt) {"], "whitespace/parens"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Multiply the number of letters by 100 to give it a much bigger"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["", "        /*", "         * Replace \"^x\" by \"CTRL-X\". Don't do this for \"^_\" to make"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["        }", "        /*", "         * Insert a backslash before a backslash after a slash, for search"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["         */", "        else if (s[0] == '\\\\' && s[1] != '\\\\'", "                 && *arg == '/' && s == arg + 1) {"], "whitespace/newline"]
["src/nvim/ex_cmds.c", ["    check_buf_options(curbuf);", "    (void)buf_init_chartab(curbuf, FALSE);", "  }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ts = 8;         // 'tabstop' is 8.", "  curwin->w_p_list = FALSE;   // No list mode.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curbuf->b_p_ma = FALSE;     // Not modifiable.", "  curbuf->b_p_bin = FALSE;    // Reset 'bin' before reading file.", "  curwin->w_p_nu = 0;         // No line numbers."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  RESET_BINDING(curwin);      // No scroll or cursor binding.", "  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_arab = FALSE;   // No arabic mode.", "  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_rl  = FALSE;    // Help window is left-to-right.", "  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_fen = FALSE;    // No folding in the help window.", "  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking."], "readability/bool"]
["src/nvim/ex_cmds.c", ["  curwin->w_p_diff = FALSE;   // No 'diff'.", "  curwin->w_p_spell = FALSE;  // No spell checking.", ""], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  set_buflisted(FALSE);", "}"], "readability/bool"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * In the \"help.txt\" and \"help.abx\" file, add the locally added help"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["          if (!add_pathsep((char *)NameBuff)", "              || STRLCAT(NameBuff, \"doc/*.??[tx]\",", "                         sizeof(NameBuff)) >= MAXPATHL) {"], "readability/old_style_comment"]
["src/nvim/ex_cmds.c", ["                  }", "                  ++s;", "                }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["          mix = !got_int;", "          got_int = TRUE;", "        }"], "readability/bool"]
["src/nvim/ex_cmds.c", ["        }", "        ++p1;", "        ++p2;"], "readability/increment"]
["src/nvim/ex_cmds.c", ["        ++p1;", "        ++p2;", "      }"], "readability/increment"]
["src/nvim/ex_cmds.c", ["", "  /*", "   * Loop over the found languages to generate a tags file for each one."], "readability/old_style_comment"]

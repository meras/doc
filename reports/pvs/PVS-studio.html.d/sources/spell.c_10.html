
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spell.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">// spell.c: code for spell checking</a>
<a name="ln5">//</a>
<a name="ln6">// See spellfile.c for the Vim spell file format.</a>
<a name="ln7">//</a>
<a name="ln8">// The spell checking mechanism uses a tree (aka trie).  Each node in the tree</a>
<a name="ln9">// has a list of bytes that can appear (siblings).  For each byte there is a</a>
<a name="ln10">// pointer to the node with the byte that follows in the word (child).</a>
<a name="ln11">//</a>
<a name="ln12">// A NUL byte is used where the word may end.  The bytes are sorted, so that</a>
<a name="ln13">// binary searching can be used and the NUL bytes are at the start.  The</a>
<a name="ln14">// number of possible bytes is stored before the list of bytes.</a>
<a name="ln15">//</a>
<a name="ln16">// The tree uses two arrays: &quot;byts&quot; stores the characters, &quot;idxs&quot; stores</a>
<a name="ln17">// either the next index or flags.  The tree starts at index 0.  For example,</a>
<a name="ln18">// to lookup &quot;vi&quot; this sequence is followed:</a>
<a name="ln19">//      i = 0</a>
<a name="ln20">//      len = byts[i]</a>
<a name="ln21">//      n = where &quot;v&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln22">//      i = idxs[n]</a>
<a name="ln23">//      len = byts[i]</a>
<a name="ln24">//      n = where &quot;i&quot; appears in byts[i + 1] to byts[i + len]</a>
<a name="ln25">//      i = idxs[n]</a>
<a name="ln26">//      len = byts[i]</a>
<a name="ln27">//      find that byts[i + 1] is 0, idxs[i + 1] has flags for &quot;vi&quot;.</a>
<a name="ln28">//</a>
<a name="ln29">// There are two word trees: one with case-folded words and one with words in</a>
<a name="ln30">// original case.  The second one is only used for keep-case words and is</a>
<a name="ln31">// usually small.</a>
<a name="ln32">//</a>
<a name="ln33">// There is one additional tree for when not all prefixes are applied when</a>
<a name="ln34">// generating the .spl file.  This tree stores all the possible prefixes, as</a>
<a name="ln35">// if they were words.  At each word (prefix) end the prefix nr is stored, the</a>
<a name="ln36">// following word must support this prefix nr.  And the condition nr is</a>
<a name="ln37">// stored, used to lookup the condition that the word must match with.</a>
<a name="ln38">//</a>
<a name="ln39">// Thanks to Olaf Seibert for providing an example implementation of this tree</a>
<a name="ln40">// and the compression mechanism.</a>
<a name="ln41">// LZ trie ideas:</a>
<a name="ln42">//      http://www.irb.hr/hr/home/ristov/papers/RistovLZtrieRevision1.pdf</a>
<a name="ln43">// More papers: http://www-igm.univ-mlv.fr/~laporte/publi_en.html</a>
<a name="ln44">//</a>
<a name="ln45">// Matching involves checking the caps type: Onecap ALLCAP KeepCap.</a>
<a name="ln46">//</a>
<a name="ln47">// Why doesn't Vim use aspell/ispell/myspell/etc.?</a>
<a name="ln48">// See &quot;:help develop-spell&quot;.</a>
<a name="ln49"> </a>
<a name="ln50">// Use SPELL_PRINTTREE for debugging: dump the word tree after adding a word.</a>
<a name="ln51">// Only use it for small word lists!</a>
<a name="ln52"> </a>
<a name="ln53">// Use SPELL_COMPRESS_ALLWAYS for debugging: compress the word tree after</a>
<a name="ln54">// adding a word.  Only use it for small word lists!</a>
<a name="ln55"> </a>
<a name="ln56">// Use DEBUG_TRIEWALK to print the changes made in suggest_trie_walk() for a</a>
<a name="ln57">// specific word.</a>
<a name="ln58"> </a>
<a name="ln59">// Use this to adjust the score after finding suggestions, based on the</a>
<a name="ln60">// suggested word sounding like the bad word.  This is much faster than doing</a>
<a name="ln61">// it for every possible suggestion.</a>
<a name="ln62">// Disadvantage: When &quot;the&quot; is typed as &quot;hte&quot; it sounds quite different (&quot;@&quot;</a>
<a name="ln63">// vs &quot;ht&quot;) and goes down in the list.</a>
<a name="ln64">// Used when 'spellsuggest' is set to &quot;best&quot;.</a>
<a name="ln65">#define RESCORE(word_score, sound_score) ((3 * (word_score) + (sound_score)) / 4)</a>
<a name="ln66"> </a>
<a name="ln67">// Do the opposite: based on a maximum end score and a known sound score,</a>
<a name="ln68">// compute the maximum word score that can be used.</a>
<a name="ln69">#define MAXSCORE(word_score, sound_score) ((4 * (word_score) - (sound_score)) / 3)</a>
<a name="ln70"> </a>
<a name="ln71">#include &lt;assert.h&gt;</a>
<a name="ln72">#include &lt;inttypes.h&gt;</a>
<a name="ln73">#include &lt;limits.h&gt;</a>
<a name="ln74">#include &lt;stdbool.h&gt;</a>
<a name="ln75">#include &lt;stdlib.h&gt;</a>
<a name="ln76">#include &lt;string.h&gt;</a>
<a name="ln77">#include &lt;wctype.h&gt;</a>
<a name="ln78"> </a>
<a name="ln79">// for offsetof()</a>
<a name="ln80">#include &lt;stddef.h&gt;</a>
<a name="ln81"> </a>
<a name="ln82">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln83">#include &quot;nvim/buffer.h&quot;</a>
<a name="ln84">#include &quot;nvim/change.h&quot;</a>
<a name="ln85">#include &quot;nvim/charset.h&quot;</a>
<a name="ln86">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln87">#include &quot;nvim/edit.h&quot;</a>
<a name="ln88">#include &quot;nvim/eval.h&quot;</a>
<a name="ln89">#include &quot;nvim/ex_cmds.h&quot;</a>
<a name="ln90">#include &quot;nvim/ex_cmds2.h&quot;</a>
<a name="ln91">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln92">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln93">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln94">#include &quot;nvim/garray.h&quot;</a>
<a name="ln95">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln96">#include &quot;nvim/hashtab.h&quot;</a>
<a name="ln97">#include &quot;nvim/input.h&quot;</a>
<a name="ln98">#include &quot;nvim/mark.h&quot;</a>
<a name="ln99">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln100">#include &quot;nvim/memline.h&quot;</a>
<a name="ln101">#include &quot;nvim/memory.h&quot;</a>
<a name="ln102">#include &quot;nvim/message.h&quot;</a>
<a name="ln103">#include &quot;nvim/normal.h&quot;</a>
<a name="ln104">#include &quot;nvim/option.h&quot;</a>
<a name="ln105">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln106">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln107">#include &quot;nvim/os_unix.h&quot;</a>
<a name="ln108">#include &quot;nvim/path.h&quot;</a>
<a name="ln109">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln110">#include &quot;nvim/screen.h&quot;</a>
<a name="ln111">#include &quot;nvim/search.h&quot;</a>
<a name="ln112">#include &quot;nvim/spell.h&quot;</a>
<a name="ln113">#include &quot;nvim/spellfile.h&quot;</a>
<a name="ln114">#include &quot;nvim/strings.h&quot;</a>
<a name="ln115">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln116">#include &quot;nvim/ui.h&quot;</a>
<a name="ln117">#include &quot;nvim/undo.h&quot;</a>
<a name="ln118"> </a>
<a name="ln119">// only used for su_badflags</a>
<a name="ln120">#define WF_MIXCAP   0x20        // mix of upper and lower case: macaRONI</a>
<a name="ln121"> </a>
<a name="ln122">#define WF_CAPMASK (WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</a>
<a name="ln123"> </a>
<a name="ln124">// Result values.  Lower number is accepted over higher one.</a>
<a name="ln125">#define SP_BANNED       (-1)</a>
<a name="ln126">#define SP_RARE         0</a>
<a name="ln127">#define SP_OK           1</a>
<a name="ln128">#define SP_LOCAL        2</a>
<a name="ln129">#define SP_BAD          3</a>
<a name="ln130"> </a>
<a name="ln131">// First language that is loaded, start of the linked list of loaded</a>
<a name="ln132">// languages.</a>
<a name="ln133">slang_T *first_lang = NULL;</a>
<a name="ln134"> </a>
<a name="ln135">// file used for &quot;zG&quot; and &quot;zW&quot;</a>
<a name="ln136">char_u *int_wordlist = NULL;</a>
<a name="ln137"> </a>
<a name="ln138">typedef struct wordcount_S {</a>
<a name="ln139">  uint16_t wc_count;                // nr of times word was seen</a>
<a name="ln140">  char_u wc_word[1];                // word, actually longer</a>
<a name="ln141">} wordcount_T;</a>
<a name="ln142"> </a>
<a name="ln143">#define WC_KEY_OFF   offsetof(wordcount_T, wc_word)</a>
<a name="ln144">#define HI2WC(hi)    ((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</a>
<a name="ln145">#define MAXWORDCOUNT 0xffff</a>
<a name="ln146"> </a>
<a name="ln147">// Information used when looking for suggestions.</a>
<a name="ln148">typedef struct suginfo_S {</a>
<a name="ln149">  garray_T su_ga;                   // suggestions, contains &quot;suggest_T&quot;</a>
<a name="ln150">  int su_maxcount;                  // max. number of suggestions displayed</a>
<a name="ln151">  int su_maxscore;                  // maximum score for adding to su_ga</a>
<a name="ln152">  int su_sfmaxscore;                // idem, for when doing soundfold words</a>
<a name="ln153">  garray_T su_sga;                  // like su_ga, sound-folded scoring</a>
<a name="ln154">  char_u *su_badptr;           // start of bad word in line</a>
<a name="ln155">  int su_badlen;                    // length of detected bad word in line</a>
<a name="ln156">  int su_badflags;                  // caps flags for bad word</a>
<a name="ln157">  char_u su_badword[MAXWLEN];       // bad word truncated at su_badlen</a>
<a name="ln158">  char_u su_fbadword[MAXWLEN];      // su_badword case-folded</a>
<a name="ln159">  char_u su_sal_badword[MAXWLEN];   // su_badword soundfolded</a>
<a name="ln160">  hashtab_T su_banned;              // table with banned words</a>
<a name="ln161">  slang_T *su_sallang;          // default language for sound folding</a>
<a name="ln162">} suginfo_T;</a>
<a name="ln163"> </a>
<a name="ln164">// One word suggestion.  Used in &quot;si_ga&quot;.</a>
<a name="ln165">typedef struct {</a>
<a name="ln166">  char_u *st_word;         // suggested word, allocated string</a>
<a name="ln167">  int st_wordlen;               // STRLEN(st_word)</a>
<a name="ln168">  int st_orglen;                // length of replaced text</a>
<a name="ln169">  int st_score;                 // lower is better</a>
<a name="ln170">  int st_altscore;              // used when st_score compares equal</a>
<a name="ln171">  bool st_salscore;             // st_score is for soundalike</a>
<a name="ln172">  bool st_had_bonus;            // bonus already included in score</a>
<a name="ln173">  slang_T *st_slang;        // language used for sound folding</a>
<a name="ln174">} suggest_T;</a>
<a name="ln175"> </a>
<a name="ln176">#define SUG(ga, i) (((suggest_T *)(ga).ga_data)[i])</a>
<a name="ln177"> </a>
<a name="ln178">// True if a word appears in the list of banned words.</a>
<a name="ln179">#define WAS_BANNED(su, word) (!HASHITEM_EMPTY(hash_find(&amp;(su)-&gt;su_banned, word)))</a>
<a name="ln180"> </a>
<a name="ln181">// Number of suggestions kept when cleaning up.  We need to keep more than</a>
<a name="ln182">// what is displayed, because when rescore_suggestions() is called the score</a>
<a name="ln183">// may change and wrong suggestions may be removed later.</a>
<a name="ln184">#define SUG_CLEAN_COUNT(su)    ((su)-&gt;su_maxcount &lt; \</a>
<a name="ln185">                                130 ? 150 : (su)-&gt;su_maxcount + 20)</a>
<a name="ln186"> </a>
<a name="ln187">// Threshold for sorting and cleaning up suggestions.  Don't want to keep lots</a>
<a name="ln188">// of suggestions that are not going to be displayed.</a>
<a name="ln189">#define SUG_MAX_COUNT(su)       (SUG_CLEAN_COUNT(su) + 50)</a>
<a name="ln190"> </a>
<a name="ln191">// score for various changes</a>
<a name="ln192">#define SCORE_SPLIT     149     // split bad word</a>
<a name="ln193">#define SCORE_SPLIT_NO  249     // split bad word with NOSPLITSUGS</a>
<a name="ln194">#define SCORE_ICASE     52      // slightly different case</a>
<a name="ln195">#define SCORE_REGION    200     // word is for different region</a>
<a name="ln196">#define SCORE_RARE      180     // rare word</a>
<a name="ln197">#define SCORE_SWAP      75      // swap two characters</a>
<a name="ln198">#define SCORE_SWAP3     110     // swap two characters in three</a>
<a name="ln199">#define SCORE_REP       65      // REP replacement</a>
<a name="ln200">#define SCORE_SUBST     93      // substitute a character</a>
<a name="ln201">#define SCORE_SIMILAR   33      // substitute a similar character</a>
<a name="ln202">#define SCORE_SUBCOMP   33      // substitute a composing character</a>
<a name="ln203">#define SCORE_DEL       94      // delete a character</a>
<a name="ln204">#define SCORE_DELDUP    66      // delete a duplicated character</a>
<a name="ln205">#define SCORE_DELCOMP   28      // delete a composing character</a>
<a name="ln206">#define SCORE_INS       96      // insert a character</a>
<a name="ln207">#define SCORE_INSDUP    67      // insert a duplicate character</a>
<a name="ln208">#define SCORE_INSCOMP   30      // insert a composing character</a>
<a name="ln209">#define SCORE_NONWORD   103     // change non-word to word char</a>
<a name="ln210"> </a>
<a name="ln211">#define SCORE_FILE      30      // suggestion from a file</a>
<a name="ln212">#define SCORE_MAXINIT   350     // Initial maximum score: higher == slower.</a>
<a name="ln213">                                // 350 allows for about three changes.</a>
<a name="ln214"> </a>
<a name="ln215">#define SCORE_COMMON1   30      // subtracted for words seen before</a>
<a name="ln216">#define SCORE_COMMON2   40      // subtracted for words often seen</a>
<a name="ln217">#define SCORE_COMMON3   50      // subtracted for words very often seen</a>
<a name="ln218">#define SCORE_THRES2    10      // word count threshold for COMMON2</a>
<a name="ln219">#define SCORE_THRES3    100     // word count threshold for COMMON3</a>
<a name="ln220"> </a>
<a name="ln221">// When trying changed soundfold words it becomes slow when trying more than</a>
<a name="ln222">// two changes.  With less than two changes it's slightly faster but we miss a</a>
<a name="ln223">// few good suggestions.  In rare cases we need to try three of four changes.</a>
<a name="ln224">#define SCORE_SFMAX1    200     // maximum score for first try</a>
<a name="ln225">#define SCORE_SFMAX2    300     // maximum score for second try</a>
<a name="ln226">#define SCORE_SFMAX3    400     // maximum score for third try</a>
<a name="ln227"> </a>
<a name="ln228">#define SCORE_BIG       (SCORE_INS * 3)  // big difference</a>
<a name="ln229">#define SCORE_MAXMAX    999999          // accept any score</a>
<a name="ln230">#define SCORE_LIMITMAX  350             // for spell_edit_score_limit()</a>
<a name="ln231"> </a>
<a name="ln232">// for spell_edit_score_limit() we need to know the minimum value of</a>
<a name="ln233">// SCORE_ICASE, SCORE_SWAP, SCORE_DEL, SCORE_SIMILAR and SCORE_INS</a>
<a name="ln234">#define SCORE_EDIT_MIN  SCORE_SIMILAR</a>
<a name="ln235"> </a>
<a name="ln236">// Structure to store info for word matching.</a>
<a name="ln237">typedef struct matchinf_S {</a>
<a name="ln238">  langp_T *mi_lp;                   // info for language and region</a>
<a name="ln239"> </a>
<a name="ln240">  // pointers to original text to be checked</a>
<a name="ln241">  char_u *mi_word;                 // start of word being checked</a>
<a name="ln242">  char_u *mi_end;                  // end of matching word so far</a>
<a name="ln243">  char_u *mi_fend;                 // next char to be added to mi_fword</a>
<a name="ln244">  char_u *mi_cend;                 // char after what was used for</a>
<a name="ln245">                                   // mi_capflags</a>
<a name="ln246"> </a>
<a name="ln247">  // case-folded text</a>
<a name="ln248">  char_u mi_fword[MAXWLEN + 1];         // mi_word case-folded</a>
<a name="ln249">  int mi_fwordlen;                      // nr of valid bytes in mi_fword</a>
<a name="ln250"> </a>
<a name="ln251">  // for when checking word after a prefix</a>
<a name="ln252">  int mi_prefarridx;                    // index in sl_pidxs with list of</a>
<a name="ln253">                                        // affixID/condition</a>
<a name="ln254">  int mi_prefcnt;                       // number of entries at mi_prefarridx</a>
<a name="ln255">  int mi_prefixlen;                     // byte length of prefix</a>
<a name="ln256">  int mi_cprefixlen;                    // byte length of prefix in original</a>
<a name="ln257">                                        // case</a>
<a name="ln258"> </a>
<a name="ln259">  // for when checking a compound word</a>
<a name="ln260">  int mi_compoff;                       // start of following word offset</a>
<a name="ln261">  char_u mi_compflags[MAXWLEN];         // flags for compound words used</a>
<a name="ln262">  int mi_complen;                       // nr of compound words used</a>
<a name="ln263">  int mi_compextra;                     // nr of COMPOUNDROOT words</a>
<a name="ln264"> </a>
<a name="ln265">  // others</a>
<a name="ln266">  int mi_result;                        // result so far: SP_BAD, SP_OK, etc.</a>
<a name="ln267">  int mi_capflags;                      // WF_ONECAP WF_ALLCAP WF_KEEPCAP</a>
<a name="ln268">  win_T *mi_win;                  // buffer being checked</a>
<a name="ln269"> </a>
<a name="ln270">  // for NOBREAK</a>
<a name="ln271">  int mi_result2;                       // &quot;mi_resul&quot; without following word</a>
<a name="ln272">  char_u *mi_end2;                 // &quot;mi_end&quot; without following word</a>
<a name="ln273">} matchinf_T;</a>
<a name="ln274"> </a>
<a name="ln275">// Structure used for the cookie argument of do_in_runtimepath().</a>
<a name="ln276">typedef struct spelload_S {</a>
<a name="ln277">  char_u sl_lang[MAXWLEN + 1];          // language name</a>
<a name="ln278">  slang_T *sl_slang;                    // resulting slang_T struct</a>
<a name="ln279">  int sl_nobreak;                       // NOBREAK language found</a>
<a name="ln280">} spelload_T;</a>
<a name="ln281"> </a>
<a name="ln282">#define SY_MAXLEN   30</a>
<a name="ln283">typedef struct syl_item_S {</a>
<a name="ln284">  char_u sy_chars[SY_MAXLEN];               // the sequence of chars</a>
<a name="ln285">  int sy_len;</a>
<a name="ln286">} syl_item_T;</a>
<a name="ln287"> </a>
<a name="ln288">spelltab_T spelltab;</a>
<a name="ln289">int did_set_spelltab;</a>
<a name="ln290"> </a>
<a name="ln291">// structure used to store soundfolded words that add_sound_suggest() has</a>
<a name="ln292">// handled already.</a>
<a name="ln293">typedef struct {</a>
<a name="ln294">  short sft_score;              // lowest score used</a>
<a name="ln295">  char_u sft_word[1];           // soundfolded word, actually longer</a>
<a name="ln296">} sftword_T;</a>
<a name="ln297"> </a>
<a name="ln298">typedef struct {</a>
<a name="ln299">  int badi;</a>
<a name="ln300">  int goodi;</a>
<a name="ln301">  int score;</a>
<a name="ln302">} limitscore_T;</a>
<a name="ln303"> </a>
<a name="ln304">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln305"># include &quot;spell.c.generated.h&quot;</a>
<a name="ln306">#endif</a>
<a name="ln307"> </a>
<a name="ln308">// values for ts_isdiff</a>
<a name="ln309">#define DIFF_NONE       0       // no different byte (yet)</a>
<a name="ln310">#define DIFF_YES        1       // different byte found</a>
<a name="ln311">#define DIFF_INSERT     2       // inserting character</a>
<a name="ln312"> </a>
<a name="ln313">// values for ts_flags</a>
<a name="ln314">#define TSF_PREFIXOK    1       // already checked that prefix is OK</a>
<a name="ln315">#define TSF_DIDSPLIT    2       // tried split at this point</a>
<a name="ln316">#define TSF_DIDDEL      4       // did a delete, &quot;ts_delidx&quot; has index</a>
<a name="ln317"> </a>
<a name="ln318">// special values ts_prefixdepth</a>
<a name="ln319">#define PFD_NOPREFIX    0xff    // not using prefixes</a>
<a name="ln320">#define PFD_PREFIXTREE  0xfe    // walking through the prefix tree</a>
<a name="ln321">#define PFD_NOTSPECIAL  0xfd    // highest value that's not special</a>
<a name="ln322"> </a>
<a name="ln323">// mode values for find_word</a>
<a name="ln324">#define FIND_FOLDWORD       0   // find word case-folded</a>
<a name="ln325">#define FIND_KEEPWORD       1   // find keep-case word</a>
<a name="ln326">#define FIND_PREFIX         2   // find word after prefix</a>
<a name="ln327">#define FIND_COMPOUND       3   // find case-folded compound word</a>
<a name="ln328">#define FIND_KEEPCOMPOUND   4   // find keep-case compound word</a>
<a name="ln329"> </a>
<a name="ln330">char *e_format = N_(&quot;E759: Format error in spell file&quot;);</a>
<a name="ln331"> </a>
<a name="ln332">// Remember what &quot;z?&quot; replaced.</a>
<a name="ln333">static char_u *repl_from = NULL;</a>
<a name="ln334">static char_u *repl_to = NULL;</a>
<a name="ln335"> </a>
<a name="ln336">/// Main spell-checking function.</a>
<a name="ln337">/// &quot;ptr&quot; points to a character that could be the start of a word.</a>
<a name="ln338">/// &quot;*attrp&quot; is set to the highlight index for a badly spelled word.  For a</a>
<a name="ln339">/// non-word or when it's OK it remains unchanged.</a>
<a name="ln340">/// This must only be called when 'spelllang' is not empty.</a>
<a name="ln341">///</a>
<a name="ln342">/// &quot;capcol&quot; is used to check for a Capitalised word after the end of a</a>
<a name="ln343">/// sentence.  If it's zero then perform the check.  Return the column where to</a>
<a name="ln344">/// check next, or -1 when no sentence end was found.  If it's NULL then don't</a>
<a name="ln345">/// worry.</a>
<a name="ln346">///</a>
<a name="ln347">/// @param wp  current window</a>
<a name="ln348">/// @param capcol  column to check for Capital</a>
<a name="ln349">/// @param docount  count good words</a>
<a name="ln350">///</a>
<a name="ln351">/// @return  the length of the word in bytes, also when it's OK, so that the</a>
<a name="ln352">/// caller can skip over the word.</a>
<a name="ln353">size_t spell_check(win_T *wp, char_u *ptr, hlf_T *attrp, int *capcol, bool docount)</a>
<a name="ln354">{</a>
<a name="ln355">  matchinf_T mi;              // Most things are put in &quot;mi&quot; so that it can</a>
<a name="ln356">                              // be passed to functions quickly.</a>
<a name="ln357">  size_t nrlen = 0;              // found a number first</a>
<a name="ln358">  int c;</a>
<a name="ln359">  size_t wrongcaplen = 0;</a>
<a name="ln360">  int lpi;</a>
<a name="ln361">  bool count_word = docount;</a>
<a name="ln362">  bool use_camel_case = *wp-&gt;w_s-&gt;b_p_spo != NUL;</a>
<a name="ln363">  bool camel_case = false;</a>
<a name="ln364"> </a>
<a name="ln365">  // A word never starts at a space or a control character. Return quickly</a>
<a name="ln366">  // then, skipping over the character.</a>
<a name="ln367">  if (*ptr &lt;= ' ') {</a>
<a name="ln368">    return 1;</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  // Return here when loading language files failed.</a>
<a name="ln372">  if (GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln373">    return 1;</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  memset(&amp;mi, 0, sizeof(matchinf_T));</a>
<a name="ln377"> </a>
<a name="ln378">  // A number is always OK.  Also skip hexadecimal numbers 0xFF99 and</a>
<a name="ln379">  // 0X99FF.  But always do check spelling to find &quot;3GPP&quot; and &quot;11</a>
<a name="ln380">  // julifeest&quot;.</a>
<a name="ln381">  if (*ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9') {</a>
<a name="ln382">    if (*ptr == '0' &amp;&amp; (ptr[1] == 'b' || ptr[1] == 'B')) {</a>
<a name="ln383">      mi.mi_end = (char_u *)skipbin((char *)ptr + 2);</a>
<a name="ln384">    } else if (*ptr == '0' &amp;&amp; (ptr[1] == 'x' || ptr[1] == 'X')) {</a>
<a name="ln385">      mi.mi_end = skiphex(ptr + 2);</a>
<a name="ln386">    } else {</a>
<a name="ln387">      mi.mi_end = (char_u *)skipdigits((char *)ptr);</a>
<a name="ln388">    }</a>
<a name="ln389">    nrlen = (size_t)(mi.mi_end - ptr);</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  // Find the normal end of the word (until the next non-word character).</a>
<a name="ln393">  mi.mi_word = ptr;</a>
<a name="ln394">  mi.mi_fend = ptr;</a>
<a name="ln395">  if (spell_iswordp(mi.mi_fend, wp)) {</a>
<a name="ln396">    bool this_upper = false;  // init for gcc</a>
<a name="ln397"> </a>
<a name="ln398">    if (use_camel_case) {</a>
<a name="ln399">      c = utf_ptr2char((char *)mi.mi_fend);</a>
<a name="ln400">      this_upper = SPELL_ISUPPER(c);</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    do {</a>
<a name="ln404">      MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln405">      if (use_camel_case) {</a>
<a name="ln406">        const bool prev_upper = this_upper;</a>
<a name="ln407">        c = utf_ptr2char((char *)mi.mi_fend);</a>
<a name="ln408">        this_upper = SPELL_ISUPPER(c);</a>
<a name="ln409">        camel_case = !prev_upper &amp;&amp; this_upper;</a>
<a name="ln410">      }</a>
<a name="ln411">    } while (*mi.mi_fend != NUL &amp;&amp; spell_iswordp(mi.mi_fend, wp)</a>
<a name="ln412">             &amp;&amp; !camel_case);</a>
<a name="ln413"> </a>
<a name="ln414">    if (capcol != NULL &amp;&amp; *capcol == 0 &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln415">      // Check word starting with capital letter.</a>
<a name="ln416">      c = utf_ptr2char((char *)ptr);</a>
<a name="ln417">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln418">        wrongcaplen = (size_t)(mi.mi_fend - ptr);</a>
<a name="ln419">      }</a>
<a name="ln420">    }</a>
<a name="ln421">  }</a>
<a name="ln422">  if (capcol != NULL) {</a>
<a name="ln423">    *capcol = -1;</a>
<a name="ln424">  }</a>
<a name="ln425"> </a>
<a name="ln426">  // We always use the characters up to the next non-word character,</a>
<a name="ln427">  // also for bad words.</a>
<a name="ln428">  mi.mi_end = mi.mi_fend;</a>
<a name="ln429"> </a>
<a name="ln430">  // Check caps type later.</a>
<a name="ln431">  mi.mi_capflags = 0;</a>
<a name="ln432">  mi.mi_cend = NULL;</a>
<a name="ln433">  mi.mi_win = wp;</a>
<a name="ln434"> </a>
<a name="ln435">  // case-fold the word with one non-word character, so that we can check</a>
<a name="ln436">  // for the word end.</a>
<a name="ln437">  if (*mi.mi_fend != NUL) {</a>
<a name="ln438">    MB_PTR_ADV(mi.mi_fend);</a>
<a name="ln439">  }</a>
<a name="ln440"> </a>
<a name="ln441">  (void)spell_casefold(wp, ptr, (int)(mi.mi_fend - ptr), mi.mi_fword,</a>
<a name="ln442">                       MAXWLEN + 1);</a>
<a name="ln443">  mi.mi_fwordlen = (int)STRLEN(mi.mi_fword);</a>
<a name="ln444"> </a>
<a name="ln445">  if (camel_case &amp;&amp; mi.mi_fwordlen &gt; 0) {</a>
<a name="ln446">    // introduce a fake word end space into the folded word.</a>
<a name="ln447">    mi.mi_fword[mi.mi_fwordlen - 1] = ' ';</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  // The word is bad unless we recognize it.</a>
<a name="ln451">  mi.mi_result = SP_BAD;</a>
<a name="ln452">  mi.mi_result2 = SP_BAD;</a>
<a name="ln453"> </a>
<a name="ln454">  // Loop over the languages specified in 'spelllang'.</a>
<a name="ln455">  // We check them all, because a word may be matched longer in another</a>
<a name="ln456">  // language.</a>
<a name="ln457">  for (lpi = 0; lpi &lt; wp-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln458">    mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln459"> </a>
<a name="ln460">    // If reloading fails the language is still in the list but everything</a>
<a name="ln461">    // has been cleared.</a>
<a name="ln462">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL) {</a>
<a name="ln463">      continue;</a>
<a name="ln464">    }</a>
<a name="ln465"> </a>
<a name="ln466">    // Check for a matching word in case-folded words.</a>
<a name="ln467">    find_word(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln468"> </a>
<a name="ln469">    // Check for a matching word in keep-case words.</a>
<a name="ln470">    find_word(&amp;mi, FIND_KEEPWORD);</a>
<a name="ln471"> </a>
<a name="ln472">    // Check for matching prefixes.</a>
<a name="ln473">    find_prefix(&amp;mi, FIND_FOLDWORD);</a>
<a name="ln474"> </a>
<a name="ln475">    // For a NOBREAK language, may want to use a word without a following</a>
<a name="ln476">    // word as a backup.</a>
<a name="ln477">    if (mi.mi_lp-&gt;lp_slang-&gt;sl_nobreak &amp;&amp; mi.mi_result == SP_BAD</a>
<a name="ln478">        &amp;&amp; mi.mi_result2 != SP_BAD) {</a>
<a name="ln479">      mi.mi_result = mi.mi_result2;</a>
<a name="ln480">      mi.mi_end = mi.mi_end2;</a>
<a name="ln481">    }</a>
<a name="ln482"> </a>
<a name="ln483">    // Count the word in the first language where it's found to be OK.</a>
<a name="ln484">    if (count_word &amp;&amp; mi.mi_result == SP_OK) {</a>
<a name="ln485">      count_common_word(mi.mi_lp-&gt;lp_slang, ptr,</a>
<a name="ln486">                        (int)(mi.mi_end - ptr), 1);</a>
<a name="ln487">      count_word = false;</a>
<a name="ln488">    }</a>
<a name="ln489">  }</a>
<a name="ln490"> </a>
<a name="ln491">  if (mi.mi_result != SP_OK) {</a>
<a name="ln492">    // If we found a number skip over it.  Allows for &quot;42nd&quot;.  Do flag</a>
<a name="ln493">    // rare and local words, e.g., &quot;3GPP&quot;.</a>
<a name="ln494">    if (nrlen &gt; 0) {</a>
<a name="ln495">      if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln496">        return nrlen;</a>
<a name="ln497">      }</a>
<a name="ln498">    } else if (!spell_iswordp_nmw(ptr, wp)) {</a>
<a name="ln499">      // When we are at a non-word character there is no error, just</a>
<a name="ln500">      // skip over the character (try looking for a word after it).</a>
<a name="ln501">      if (capcol != NULL &amp;&amp; wp-&gt;w_s-&gt;b_cap_prog != NULL) {</a>
<a name="ln502">        regmatch_T regmatch;</a>
<a name="ln503"> </a>
<a name="ln504">        // Check for end of sentence.</a>
<a name="ln505">        regmatch.regprog = wp-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln506">        regmatch.rm_ic = false;</a>
<a name="ln507">        int r = vim_regexec(&amp;regmatch, ptr, 0);</a>
<a name="ln508">        wp-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln509">        if (r) {</a>
<a name="ln510">          *capcol = (int)(regmatch.endp[0] - ptr);</a>
<a name="ln511">        }</a>
<a name="ln512">      }</a>
<a name="ln513"> </a>
<a name="ln514">      return (size_t)(utfc_ptr2len((char *)ptr));</a>
<a name="ln515">    } else if (mi.mi_end == ptr) {</a>
<a name="ln516">      // Always include at least one character.  Required for when there</a>
<a name="ln517">      // is a mixup in &quot;midword&quot;.</a>
<a name="ln518">      MB_PTR_ADV(mi.mi_end);</a>
<a name="ln519">    } else if (mi.mi_result == SP_BAD</a>
<a name="ln520">               &amp;&amp; LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0)-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln521">      char_u *p, *fp;</a>
<a name="ln522">      int save_result = mi.mi_result;</a>
<a name="ln523"> </a>
<a name="ln524">      // First language in 'spelllang' is NOBREAK.  Find first position</a>
<a name="ln525">      // at which any word would be valid.</a>
<a name="ln526">      mi.mi_lp = LANGP_ENTRY(wp-&gt;w_s-&gt;b_langp, 0);</a>
<a name="ln527">      if (mi.mi_lp-&gt;lp_slang-&gt;sl_fidxs != NULL) {</a>
<a name="ln528">        p = mi.mi_word;</a>
<a name="ln529">        fp = mi.mi_fword;</a>
<a name="ln530">        for (;;) {</a>
<a name="ln531">          MB_PTR_ADV(p);</a>
<a name="ln532">          MB_PTR_ADV(fp);</a>
<a name="ln533">          if (p &gt;= mi.mi_end) {</a>
<a name="ln534">            break;</a>
<a name="ln535">          }</a>
<a name="ln536">          mi.mi_compoff = (int)(fp - mi.mi_fword);</a>
<a name="ln537">          find_word(&amp;mi, FIND_COMPOUND);</a>
<a name="ln538">          if (mi.mi_result != SP_BAD) {</a>
<a name="ln539">            mi.mi_end = p;</a>
<a name="ln540">            break;</a>
<a name="ln541">          }</a>
<a name="ln542">        }</a>
<a name="ln543">        mi.mi_result = save_result;</a>
<a name="ln544">      }</a>
<a name="ln545">    }</a>
<a name="ln546"> </a>
<a name="ln547">    if (mi.mi_result == SP_BAD || mi.mi_result == SP_BANNED) {</a>
<a name="ln548">      *attrp = HLF_SPB;</a>
<a name="ln549">    } else if (mi.mi_result == SP_RARE) {</a>
<a name="ln550">      *attrp = HLF_SPR;</a>
<a name="ln551">    } else {</a>
<a name="ln552">      *attrp = HLF_SPL;</a>
<a name="ln553">    }</a>
<a name="ln554">  }</a>
<a name="ln555"> </a>
<a name="ln556">  if (wrongcaplen &gt; 0 &amp;&amp; (mi.mi_result == SP_OK || mi.mi_result == SP_RARE)) {</a>
<a name="ln557">    // Report SpellCap only when the word isn't badly spelled.</a>
<a name="ln558">    *attrp = HLF_SPC;</a>
<a name="ln559">    return wrongcaplen;</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  return (size_t)(mi.mi_end - ptr);</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">// Check if the word at &quot;mip-&gt;mi_word&quot; is in the tree.</a>
<a name="ln566">// When &quot;mode&quot; is FIND_FOLDWORD check in fold-case word tree.</a>
<a name="ln567">// When &quot;mode&quot; is FIND_KEEPWORD check in keep-case word tree.</a>
<a name="ln568">// When &quot;mode&quot; is FIND_PREFIX check for word after prefix in fold-case word</a>
<a name="ln569">// tree.</a>
<a name="ln570">//</a>
<a name="ln571">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln572">static void find_word(matchinf_T *mip, int mode)</a>
<a name="ln573">{</a>
<a name="ln574">  int wlen = 0;</a>
<a name="ln575">  int flen;</a>
<a name="ln576">  char_u *ptr;</a>
<a name="ln577">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln578">  char_u *byts;</a>
<a name="ln579">  idx_T *idxs;</a>
<a name="ln580"> </a>
<a name="ln581">  if (mode == FIND_KEEPWORD || mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln582">    // Check for word with matching case in keep-case tree.</a>
<a name="ln583">    ptr = mip-&gt;mi_word;</a>
<a name="ln584">    flen = 9999;                    // no case folding, always enough bytes</a>
<a name="ln585">    byts = slang-&gt;sl_kbyts;</a>
<a name="ln586">    idxs = slang-&gt;sl_kidxs;</a>
<a name="ln587"> </a>
<a name="ln588">    if (mode == FIND_KEEPCOMPOUND) {</a>
<a name="ln589">      // Skip over the previously found word(s).</a>
<a name="ln590">      wlen += mip-&gt;mi_compoff;</a>
<a name="ln591">    }</a>
<a name="ln592">  } else {</a>
<a name="ln593">    // Check for case-folded in case-folded tree.</a>
<a name="ln594">    ptr = mip-&gt;mi_fword;</a>
<a name="ln595">    flen = mip-&gt;mi_fwordlen;        // available case-folded bytes</a>
<a name="ln596">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln597">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln598"> </a>
<a name="ln599">    if (mode == FIND_PREFIX) {</a>
<a name="ln600">      // Skip over the prefix.</a>
<a name="ln601">      wlen = mip-&gt;mi_prefixlen;</a>
<a name="ln602">      flen -= mip-&gt;mi_prefixlen;</a>
<a name="ln603">    } else if (mode == FIND_COMPOUND) {</a>
<a name="ln604">      // Skip over the previously found word(s).</a>
<a name="ln605">      wlen = mip-&gt;mi_compoff;</a>
<a name="ln606">      flen -= mip-&gt;mi_compoff;</a>
<a name="ln607">    }</a>
<a name="ln608">  }</a>
<a name="ln609"> </a>
<a name="ln610">  if (byts == NULL) {</a>
<a name="ln611">    return;                     // array is empty</a>
<a name="ln612">  }</a>
<a name="ln613">  idx_T arridx = 0;</a>
<a name="ln614">  int endlen[MAXWLEN];              // length at possible word endings</a>
<a name="ln615">  idx_T endidx[MAXWLEN];            // possible word endings</a>
<a name="ln616">  int endidxcnt = 0;</a>
<a name="ln617">  int len;</a>
<a name="ln618">  int c;</a>
<a name="ln619"> </a>
<a name="ln620">  // Repeat advancing in the tree until:</a>
<a name="ln621">  // - there is a byte that doesn't match,</a>
<a name="ln622">  // - we reach the end of the tree,</a>
<a name="ln623">  // - or we reach the end of the line.</a>
<a name="ln624">  for (;;) {</a>
<a name="ln625">    if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln626">      flen = fold_more(mip);</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    len = byts[arridx++];</a>
<a name="ln630"> </a>
<a name="ln631">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln632">    // Remember this index, we first check for the longest word.</a>
<a name="ln633">    if (byts[arridx] == 0) {</a>
<a name="ln634">      if (endidxcnt == MAXWLEN) {</a>
<a name="ln635">        // Must be a corrupted spell file.</a>
<a name="ln636">        emsg(_(e_format));</a>
<a name="ln637">        return;</a>
<a name="ln638">      }</a>
<a name="ln639">      endlen[endidxcnt] = wlen;</a>
<a name="ln640">      endidx[endidxcnt++] = arridx++;</a>
<a name="ln641">      --len;</a>
<a name="ln642"> </a>
<a name="ln643">      // Skip over the zeros, there can be several flag/region</a>
<a name="ln644">      // combinations.</a>
<a name="ln645">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln646">        ++arridx;</a>
<a name="ln647">        --len;</a>
<a name="ln648">      }</a>
<a name="ln649">      if (len == 0) {</a>
<a name="ln650">        break;              // no children, word must end here</a>
<a name="ln651">      }</a>
<a name="ln652">    }</a>
<a name="ln653"> </a>
<a name="ln654">    // Stop looking at end of the line.</a>
<a name="ln655">    if (ptr[wlen] == NUL) {</a>
<a name="ln656">      break;</a>
<a name="ln657">    }</a>
<a name="ln658"> </a>
<a name="ln659">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln660">    c = ptr[wlen];</a>
<a name="ln661">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln662">      c = ' ';</a>
<a name="ln663">    }</a>
<a name="ln664">    idx_T lo = arridx;</a>
<a name="ln665">    idx_T hi = arridx + len - 1;</a>
<a name="ln666">    while (lo &lt; hi) {</a>
<a name="ln667">      idx_T m = (lo + hi) / 2;</a>
<a name="ln668">      if (byts[m] &gt; c) {</a>
<a name="ln669">        hi = m - 1;</a>
<a name="ln670">      } else if (byts[m] &lt; c) {</a>
<a name="ln671">        lo = m + 1;</a>
<a name="ln672">      } else {</a>
<a name="ln673">        lo = hi = m;</a>
<a name="ln674">        break;</a>
<a name="ln675">      }</a>
<a name="ln676">    }</a>
<a name="ln677"> </a>
<a name="ln678">    // Stop if there is no matching byte.</a>
<a name="ln679">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln680">      break;</a>
<a name="ln681">    }</a>
<a name="ln682"> </a>
<a name="ln683">    // Continue at the child (if there is one).</a>
<a name="ln684">    arridx = idxs[lo];</a>
<a name="ln685">    ++wlen;</a>
<a name="ln686">    --flen;</a>
<a name="ln687"> </a>
<a name="ln688">    // One space in the good word may stand for several spaces in the</a>
<a name="ln689">    // checked word.</a>
<a name="ln690">    if (c == ' ') {</a>
<a name="ln691">      for (;;) {</a>
<a name="ln692">        if (flen &lt;= 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln693">          flen = fold_more(mip);</a>
<a name="ln694">        }</a>
<a name="ln695">        if (ptr[wlen] != ' ' &amp;&amp; ptr[wlen] != TAB) {</a>
<a name="ln696">          break;</a>
<a name="ln697">        }</a>
<a name="ln698">        ++wlen;</a>
<a name="ln699">        --flen;</a>
<a name="ln700">      }</a>
<a name="ln701">    }</a>
<a name="ln702">  }</a>
<a name="ln703"> </a>
<a name="ln704">  char_u *p;</a>
<a name="ln705">  bool word_ends;</a>
<a name="ln706"> </a>
<a name="ln707">  // Verify that one of the possible endings is valid.  Try the longest</a>
<a name="ln708">  // first.</a>
<a name="ln709">  while (endidxcnt &gt; 0) {</a>
<a name="ln710">    --endidxcnt;</a>
<a name="ln711">    arridx = endidx[endidxcnt];</a>
<a name="ln712">    wlen = endlen[endidxcnt];</a>
<a name="ln713"> </a>
<a name="ln714">    if (utf_head_off(ptr, ptr + wlen) &gt; 0) {</a>
<a name="ln715">      continue;             // not at first byte of character</a>
<a name="ln716">    }</a>
<a name="ln717">    if (spell_iswordp(ptr + wlen, mip-&gt;mi_win)) {</a>
<a name="ln718">      if (slang-&gt;sl_compprog == NULL &amp;&amp; !slang-&gt;sl_nobreak) {</a>
<a name="ln719">        continue;                   // next char is a word character</a>
<a name="ln720">      }</a>
<a name="ln721">      word_ends = false;</a>
<a name="ln722">    } else {</a>
<a name="ln723">      word_ends = true;</a>
<a name="ln724">    }</a>
<a name="ln725">    // The prefix flag is before compound flags.  Once a valid prefix flag</a>
<a name="ln726">    // has been found we try compound flags.</a>
<a name="ln727">    bool prefix_found = false;</a>
<a name="ln728"> </a>
<a name="ln729">    if (mode != FIND_KEEPWORD) {</a>
<a name="ln730">      // Compute byte length in original word, length may change</a>
<a name="ln731">      // when folding case.  This can be slow, take a shortcut when the</a>
<a name="ln732">      // case-folded word is equal to the keep-case word.</a>
<a name="ln733">      p = mip-&gt;mi_word;</a>
<a name="ln734">      if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln735">        for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln736">          MB_PTR_ADV(p);</a>
<a name="ln737">        }</a>
<a name="ln738">        wlen = (int)(p - mip-&gt;mi_word);</a>
<a name="ln739">      }</a>
<a name="ln740">    }</a>
<a name="ln741"> </a>
<a name="ln742">    // Check flags and region.  For FIND_PREFIX check the condition and</a>
<a name="ln743">    // prefix ID.</a>
<a name="ln744">    // Repeat this if there are more flags/region alternatives until there</a>
<a name="ln745">    // is a match.</a>
<a name="ln746">    for (len = byts[arridx - 1]; len &gt; 0 &amp;&amp; byts[arridx] == 0;</a>
<a name="ln747">         --len, ++arridx) {</a>
<a name="ln748">      uint32_t flags = idxs[arridx];</a>
<a name="ln749"> </a>
<a name="ln750">      // For the fold-case tree check that the case of the checked word</a>
<a name="ln751">      // matches with what the word in the tree requires.</a>
<a name="ln752">      // For keep-case tree the case is always right.  For prefixes we</a>
<a name="ln753">      // don't bother to check.</a>
<a name="ln754">      if (mode == FIND_FOLDWORD) {</a>
<a name="ln755">        if (mip-&gt;mi_cend != mip-&gt;mi_word + wlen) {</a>
<a name="ln756">          // mi_capflags was set for a different word length, need</a>
<a name="ln757">          // to do it again.</a>
<a name="ln758">          mip-&gt;mi_cend = mip-&gt;mi_word + wlen;</a>
<a name="ln759">          mip-&gt;mi_capflags = captype(mip-&gt;mi_word, mip-&gt;mi_cend);</a>
<a name="ln760">        }</a>
<a name="ln761"> </a>
<a name="ln762">        if (mip-&gt;mi_capflags == WF_KEEPCAP</a>
<a name="ln763">            || !spell_valid_case(mip-&gt;mi_capflags, flags)) {</a>
<a name="ln764">          continue;</a>
<a name="ln765">        }</a>
<a name="ln766">      }</a>
<a name="ln767">      // When mode is FIND_PREFIX the word must support the prefix:</a>
<a name="ln768">      // check the prefix ID and the condition.  Do that for the list at</a>
<a name="ln769">      // mip-&gt;mi_prefarridx that find_prefix() filled.</a>
<a name="ln770">      else if (mode == FIND_PREFIX &amp;&amp; !prefix_found) {</a>
<a name="ln771">        c = valid_word_prefix(mip-&gt;mi_prefcnt, mip-&gt;mi_prefarridx,</a>
<a name="ln772">                              flags,</a>
<a name="ln773">                              mip-&gt;mi_word + mip-&gt;mi_cprefixlen, slang,</a>
<a name="ln774">                              false);</a>
<a name="ln775">        if (c == 0) {</a>
<a name="ln776">          continue;</a>
<a name="ln777">        }</a>
<a name="ln778"> </a>
<a name="ln779">        // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln780">        if (c &amp; WF_RAREPFX) {</a>
<a name="ln781">          flags |= WF_RARE;</a>
<a name="ln782">        }</a>
<a name="ln783">        prefix_found = true;</a>
<a name="ln784">      }</a>
<a name="ln785"> </a>
<a name="ln786">      if (slang-&gt;sl_nobreak) {</a>
<a name="ln787">        if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND)</a>
<a name="ln788">            &amp;&amp; (flags &amp; WF_BANNED) == 0) {</a>
<a name="ln789">          // NOBREAK: found a valid following word.  That's all we</a>
<a name="ln790">          // need to know, so return.</a>
<a name="ln791">          mip-&gt;mi_result = SP_OK;</a>
<a name="ln792">          break;</a>
<a name="ln793">        }</a>
<a name="ln794">      } else if ((mode == FIND_COMPOUND || mode == FIND_KEEPCOMPOUND</a>
<a name="ln795">                  || !word_ends)) {</a>
<a name="ln796">        // If there is no compound flag or the word is shorter than</a>
<a name="ln797">        // COMPOUNDMIN reject it quickly.</a>
<a name="ln798">        // Makes you wonder why someone puts a compound flag on a word</a>
<a name="ln799">        // that's too short...  Myspell compatibility requires this</a>
<a name="ln800">        // anyway.</a>
<a name="ln801">        if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln802">            || wlen - mip-&gt;mi_compoff &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln803">          continue;</a>
<a name="ln804">        }</a>
<a name="ln805">        // For multi-byte chars check character length against</a>
<a name="ln806">        // COMPOUNDMIN.</a>
<a name="ln807">        if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln808">            &amp;&amp; mb_charlen_len(mip-&gt;mi_word + mip-&gt;mi_compoff,</a>
<a name="ln809">                              wlen - mip-&gt;mi_compoff) &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln810">          continue;</a>
<a name="ln811">        }</a>
<a name="ln812"> </a>
<a name="ln813">        // Limit the number of compound words to COMPOUNDWORDMAX if no</a>
<a name="ln814">        // maximum for syllables is specified.</a>
<a name="ln815">        if (!word_ends &amp;&amp; mip-&gt;mi_complen + mip-&gt;mi_compextra + 2</a>
<a name="ln816">            &gt; slang-&gt;sl_compmax</a>
<a name="ln817">            &amp;&amp; slang-&gt;sl_compsylmax == MAXWLEN) {</a>
<a name="ln818">          continue;</a>
<a name="ln819">        }</a>
<a name="ln820"> </a>
<a name="ln821">        // Don't allow compounding on a side where an affix was added,</a>
<a name="ln822">        // unless COMPOUNDPERMITFLAG was used.</a>
<a name="ln823">        if (mip-&gt;mi_complen &gt; 0 &amp;&amp; (flags &amp; WF_NOCOMPBEF)) {</a>
<a name="ln824">          continue;</a>
<a name="ln825">        }</a>
<a name="ln826">        if (!word_ends &amp;&amp; (flags &amp; WF_NOCOMPAFT)) {</a>
<a name="ln827">          continue;</a>
<a name="ln828">        }</a>
<a name="ln829"> </a>
<a name="ln830">        // Quickly check if compounding is possible with this flag.</a>
<a name="ln831">        if (!byte_in_str(mip-&gt;mi_complen == 0</a>
<a name="ln832">                ? slang-&gt;sl_compstartflags</a>
<a name="ln833">                : slang-&gt;sl_compallflags,</a>
<a name="ln834">                         ((unsigned)flags &gt;&gt; 24))) {</a>
<a name="ln835">          continue;</a>
<a name="ln836">        }</a>
<a name="ln837"> </a>
<a name="ln838">        // If there is a match with a CHECKCOMPOUNDPATTERN rule</a>
<a name="ln839">        // discard the compound word.</a>
<a name="ln840">        if (match_checkcompoundpattern(ptr, wlen, &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln841">          continue;</a>
<a name="ln842">        }</a>
<a name="ln843"> </a>
<a name="ln844">        if (mode == FIND_COMPOUND) {</a>
<a name="ln845">          int capflags;</a>
<a name="ln846"> </a>
<a name="ln847">          // Need to check the caps type of the appended compound</a>
<a name="ln848">          // word.</a>
<a name="ln849">          if (STRNCMP(ptr, mip-&gt;mi_word, mip-&gt;mi_compoff) != 0) {</a>
<a name="ln850">            // case folding may have changed the length</a>
<a name="ln851">            p = mip-&gt;mi_word;</a>
<a name="ln852">            for (char_u *s = ptr; s &lt; ptr + mip-&gt;mi_compoff; MB_PTR_ADV(s)) {</a>
<a name="ln853">              MB_PTR_ADV(p);</a>
<a name="ln854">            }</a>
<a name="ln855">          } else {</a>
<a name="ln856">            p = mip-&gt;mi_word + mip-&gt;mi_compoff;</a>
<a name="ln857">          }</a>
<a name="ln858">          capflags = captype(p, mip-&gt;mi_word + wlen);</a>
<a name="ln859">          if (capflags == WF_KEEPCAP || (capflags == WF_ALLCAP</a>
<a name="ln860">                                         &amp;&amp; (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln861">            continue;</a>
<a name="ln862">          }</a>
<a name="ln863"> </a>
<a name="ln864">          if (capflags != WF_ALLCAP) {</a>
<a name="ln865">            // When the character before the word is a word</a>
<a name="ln866">            // character we do not accept a Onecap word.  We do</a>
<a name="ln867">            // accept a no-caps word, even when the dictionary</a>
<a name="ln868">            // word specifies ONECAP.</a>
<a name="ln869">            MB_PTR_BACK(mip-&gt;mi_word, p);</a>
<a name="ln870">            if (spell_iswordp_nmw(p, mip-&gt;mi_win)</a>
<a name="ln871">                ? capflags == WF_ONECAP</a>
<a name="ln872">                : (flags &amp; WF_ONECAP) != 0</a>
<a name="ln873">                &amp;&amp; capflags != WF_ONECAP) {</a>
<a name="ln874">              continue;</a>
<a name="ln875">            }</a>
<a name="ln876">          }</a>
<a name="ln877">        }</a>
<a name="ln878"> </a>
<a name="ln879">        // If the word ends the sequence of compound flags of the</a>
<a name="ln880">        // words must match with one of the COMPOUNDRULE items and</a>
<a name="ln881">        // the number of syllables must not be too large.</a>
<a name="ln882">        mip-&gt;mi_compflags[mip-&gt;mi_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln883">        mip-&gt;mi_compflags[mip-&gt;mi_complen + 1] = NUL;</a>
<a name="ln884">        if (word_ends) {</a>
<a name="ln885">          char_u fword[MAXWLEN] = { 0 };</a>
<a name="ln886"> </a>
<a name="ln887">          if (slang-&gt;sl_compsylmax &lt; MAXWLEN) {</a>
<a name="ln888">            // &quot;fword&quot; is only needed for checking syllables.</a>
<a name="ln889">            if (ptr == mip-&gt;mi_word) {</a>
<a name="ln890">              (void)spell_casefold(mip-&gt;mi_win, ptr, wlen, fword, MAXWLEN);</a>
<a name="ln891">            } else {</a>
<a name="ln892">              STRLCPY(fword, ptr, endlen[endidxcnt] + 1);</a>
<a name="ln893">            }</a>
<a name="ln894">          }</a>
<a name="ln895">          if (!can_compound(slang, fword, mip-&gt;mi_compflags)) {</a>
<a name="ln896">            continue;</a>
<a name="ln897">          }</a>
<a name="ln898">        } else if (slang-&gt;sl_comprules != NULL</a>
<a name="ln899">                   &amp;&amp; !match_compoundrule(slang, mip-&gt;mi_compflags)) {</a>
<a name="ln900">          // The compound flags collected so far do not match any</a>
<a name="ln901">          // COMPOUNDRULE, discard the compounded word.</a>
<a name="ln902">          continue;</a>
<a name="ln903">        }</a>
<a name="ln904">      }</a>
<a name="ln905">      // Check NEEDCOMPOUND: can't use word without compounding.</a>
<a name="ln906">      else if (flags &amp; WF_NEEDCOMP) {</a>
<a name="ln907">        continue;</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">      int nobreak_result = SP_OK;</a>
<a name="ln911"> </a>
<a name="ln912">      if (!word_ends) {</a>
<a name="ln913">        int save_result = mip-&gt;mi_result;</a>
<a name="ln914">        char_u *save_end = mip-&gt;mi_end;</a>
<a name="ln915">        langp_T *save_lp = mip-&gt;mi_lp;</a>
<a name="ln916"> </a>
<a name="ln917">        // Check that a valid word follows.  If there is one and we</a>
<a name="ln918">        // are compounding, it will set &quot;mi_result&quot;, thus we are</a>
<a name="ln919">        // always finished here.  For NOBREAK we only check that a</a>
<a name="ln920">        // valid word follows.</a>
<a name="ln921">        // Recursive!</a>
<a name="ln922">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln923">          mip-&gt;mi_result = SP_BAD;</a>
<a name="ln924">        }</a>
<a name="ln925"> </a>
<a name="ln926">        // Find following word in case-folded tree.</a>
<a name="ln927">        mip-&gt;mi_compoff = endlen[endidxcnt];</a>
<a name="ln928">        if (mode == FIND_KEEPWORD) {</a>
<a name="ln929">          // Compute byte length in case-folded word from &quot;wlen&quot;:</a>
<a name="ln930">          // byte length in keep-case word.  Length may change when</a>
<a name="ln931">          // folding case.  This can be slow, take a shortcut when</a>
<a name="ln932">          // the case-folded word is equal to the keep-case word.</a>
<a name="ln933">          p = mip-&gt;mi_fword;</a>
<a name="ln934">          if (STRNCMP(ptr, p, wlen) != 0) {</a>
<a name="ln935">            for (char_u *s = ptr; s &lt; ptr + wlen; MB_PTR_ADV(s)) {</a>
<a name="ln936">              MB_PTR_ADV(p);</a>
<a name="ln937">            }</a>
<a name="ln938">            mip-&gt;mi_compoff = (int)(p - mip-&gt;mi_fword);</a>
<a name="ln939">          }</a>
<a name="ln940">        }</a>
<a name="ln941">#if 0</a>
<a name="ln942">        c = mip-&gt;mi_compoff;</a>
<a name="ln943">#endif</a>
<a name="ln944">        ++mip-&gt;mi_complen;</a>
<a name="ln945">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln946">          ++mip-&gt;mi_compextra;</a>
<a name="ln947">        }</a>
<a name="ln948"> </a>
<a name="ln949">        // For NOBREAK we need to try all NOBREAK languages, at least</a>
<a name="ln950">        // to find the &quot;.add&quot; file(s).</a>
<a name="ln951">        for (int lpi = 0; lpi &lt; mip-&gt;mi_win-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln952">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln953">            mip-&gt;mi_lp = LANGP_ENTRY(mip-&gt;mi_win-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln954">            if (mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_fidxs == NULL</a>
<a name="ln955">                || !mip-&gt;mi_lp-&gt;lp_slang-&gt;sl_nobreak) {</a>
<a name="ln956">              continue;</a>
<a name="ln957">            }</a>
<a name="ln958">          }</a>
<a name="ln959"> </a>
<a name="ln960">          find_word(mip, FIND_COMPOUND);</a>
<a name="ln961"> </a>
<a name="ln962">          // When NOBREAK any word that matches is OK.  Otherwise we</a>
<a name="ln963">          // need to find the longest match, thus try with keep-case</a>
<a name="ln964">          // and prefix too.</a>
<a name="ln965">          if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln966">            // Find following word in keep-case tree.</a>
<a name="ln967">            mip-&gt;mi_compoff = wlen;</a>
<a name="ln968">            find_word(mip, FIND_KEEPCOMPOUND);</a>
<a name="ln969"> </a>
<a name="ln970">#if 0       // Disabled, a prefix must not appear halfway through a compound</a>
<a name="ln971">            // word, unless the COMPOUNDPERMITFLAG is used, in which case it</a>
<a name="ln972">            // can't be a postponed prefix.</a>
<a name="ln973">            if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD) {</a>
<a name="ln974">              // Check for following word with prefix.</a>
<a name="ln975">              mip-&gt;mi_compoff = c;</a>
<a name="ln976">              find_prefix(mip, FIND_COMPOUND);</a>
<a name="ln977">            }</a>
<a name="ln978">#endif</a>
<a name="ln979">          }</a>
<a name="ln980"> </a>
<a name="ln981">          if (!slang-&gt;sl_nobreak) {</a>
<a name="ln982">            break;</a>
<a name="ln983">          }</a>
<a name="ln984">        }</a>
<a name="ln985">        --mip-&gt;mi_complen;</a>
<a name="ln986">        if (flags &amp; WF_COMPROOT) {</a>
<a name="ln987">          --mip-&gt;mi_compextra;</a>
<a name="ln988">        }</a>
<a name="ln989">        mip-&gt;mi_lp = save_lp;</a>
<a name="ln990"> </a>
<a name="ln991">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln992">          nobreak_result = mip-&gt;mi_result;</a>
<a name="ln993">          mip-&gt;mi_result = save_result;</a>
<a name="ln994">          mip-&gt;mi_end = save_end;</a>
<a name="ln995">        } else {</a>
<a name="ln996">          if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln997">            break;</a>
<a name="ln998">          }</a>
<a name="ln999">          continue;</a>
<a name="ln1000">        }</a>
<a name="ln1001">      }</a>
<a name="ln1002"> </a>
<a name="ln1003">      int res = SP_BAD;</a>
<a name="ln1004">      if (flags &amp; WF_BANNED) {</a>
<a name="ln1005">        res = SP_BANNED;</a>
<a name="ln1006">      } else if (flags &amp; WF_REGION) {</a>
<a name="ln1007">        // Check region.</a>
<a name="ln1008">        if ((mip-&gt;mi_lp-&gt;lp_region &amp; (flags &gt;&gt; 16)) != 0) {</a>
<a name="ln1009">          res = SP_OK;</a>
<a name="ln1010">        } else {</a>
<a name="ln1011">          res = SP_LOCAL;</a>
<a name="ln1012">        }</a>
<a name="ln1013">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln1014">        res = SP_RARE;</a>
<a name="ln1015">      } else {</a>
<a name="ln1016">        res = SP_OK;</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">      // Always use the longest match and the best result.  For NOBREAK</a>
<a name="ln1020">      // we separately keep the longest match without a following good</a>
<a name="ln1021">      // word as a fall-back.</a>
<a name="ln1022">      if (nobreak_result == SP_BAD) {</a>
<a name="ln1023">        if (mip-&gt;mi_result2 &gt; res) {</a>
<a name="ln1024">          mip-&gt;mi_result2 = res;</a>
<a name="ln1025">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln1026">        } else if (mip-&gt;mi_result2 == res</a>
<a name="ln1027">                   &amp;&amp; mip-&gt;mi_end2 &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln1028">          mip-&gt;mi_end2 = mip-&gt;mi_word + wlen;</a>
<a name="ln1029">        }</a>
<a name="ln1030">      } else if (mip-&gt;mi_result &gt; res) {</a>
<a name="ln1031">        mip-&gt;mi_result = res;</a>
<a name="ln1032">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1033">      } else if (mip-&gt;mi_result == res &amp;&amp; mip-&gt;mi_end &lt; mip-&gt;mi_word + wlen) {</a>
<a name="ln1034">        mip-&gt;mi_end = mip-&gt;mi_word + wlen;</a>
<a name="ln1035">      }</a>
<a name="ln1036"> </a>
<a name="ln1037">      if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln1038">        break;</a>
<a name="ln1039">      }</a>
<a name="ln1040">    }</a>
<a name="ln1041"> </a>
<a name="ln1042">    if (mip-&gt;mi_result == SP_OK) {</a>
<a name="ln1043">      break;</a>
<a name="ln1044">    }</a>
<a name="ln1045">  }</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">/// Returns true if there is a match between the word ptr[wlen] and</a>
<a name="ln1049">/// CHECKCOMPOUNDPATTERN rules, assuming that we will concatenate with another</a>
<a name="ln1050">/// word.</a>
<a name="ln1051">/// A match means that the first part of CHECKCOMPOUNDPATTERN matches at the</a>
<a name="ln1052">/// end of ptr[wlen] and the second part matches after it.</a>
<a name="ln1053">///</a>
<a name="ln1054">/// @param gap  &amp;sl_comppat</a>
<a name="ln1055">static bool match_checkcompoundpattern(char_u *ptr, int wlen, garray_T *gap)</a>
<a name="ln1056">{</a>
<a name="ln1057">  char_u *p;</a>
<a name="ln1058">  int len;</a>
<a name="ln1059"> </a>
<a name="ln1060">  for (int i = 0; i + 1 &lt; gap-&gt;ga_len; i += 2) {</a>
<a name="ln1061">    p = ((char_u **)gap-&gt;ga_data)[i + 1];</a>
<a name="ln1062">    if (STRNCMP(ptr + wlen, p, STRLEN(p)) == 0) {</a>
<a name="ln1063">      // Second part matches at start of following compound word, now</a>
<a name="ln1064">      // check if first part matches at end of previous word.</a>
<a name="ln1065">      p = ((char_u **)gap-&gt;ga_data)[i];</a>
<a name="ln1066">      len = (int)STRLEN(p);</a>
<a name="ln1067">      if (len &lt;= wlen &amp;&amp; STRNCMP(ptr + wlen - len, p, len) == 0) {</a>
<a name="ln1068">        return true;</a>
<a name="ln1069">      }</a>
<a name="ln1070">    }</a>
<a name="ln1071">  }</a>
<a name="ln1072">  return false;</a>
<a name="ln1073">}</a>
<a name="ln1074"> </a>
<a name="ln1075">// Returns true if &quot;flags&quot; is a valid sequence of compound flags and &quot;word&quot;</a>
<a name="ln1076">// does not have too many syllables.</a>
<a name="ln1077">static bool can_compound(slang_T *slang, const char_u *word, const char_u *flags)</a>
<a name="ln1078">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1079">{</a>
<a name="ln1080">  char_u uflags[MAXWLEN * 2] = { 0 };</a>
<a name="ln1081"> </a>
<a name="ln1082">  if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln1083">    return false;</a>
<a name="ln1084">  }</a>
<a name="ln1085">  // Need to convert the single byte flags to utf8 characters.</a>
<a name="ln1086">  char_u *p = uflags;</a>
<a name="ln1087">  for (int i = 0; flags[i] != NUL; i++) {</a>
<a name="ln1088">    p += utf_char2bytes(flags[i], (char *)p);</a>
<a name="ln1089">  }</a>
<a name="ln1090">  *p = NUL;</a>
<a name="ln1091">  p = uflags;</a>
<a name="ln1092">  if (!vim_regexec_prog(&amp;slang-&gt;sl_compprog, false, p, 0)) {</a>
<a name="ln1093">    return false;</a>
<a name="ln1094">  }</a>
<a name="ln1095"> </a>
<a name="ln1096">  // Count the number of syllables.  This may be slow, do it last.  If there</a>
<a name="ln1097">  // are too many syllables AND the number of compound words is above</a>
<a name="ln1098">  // COMPOUNDWORDMAX then compounding is not allowed.</a>
<a name="ln1099">  if (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln1100">      &amp;&amp; count_syllables(slang, word) &gt; slang-&gt;sl_compsylmax) {</a>
<a name="ln1101">    return (int)STRLEN(flags) &lt; slang-&gt;sl_compmax;</a>
<a name="ln1102">  }</a>
<a name="ln1103">  return true;</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106">// Returns true when the sequence of flags in &quot;compflags&quot; plus &quot;flag&quot; can</a>
<a name="ln1107">// possibly form a valid compounded word.  This also checks the COMPOUNDRULE</a>
<a name="ln1108">// lines if they don't contain wildcards.</a>
<a name="ln1109">static bool can_be_compound(trystate_T *sp, slang_T *slang, char_u *compflags, int flag)</a>
<a name="ln1110">{</a>
<a name="ln1111">  // If the flag doesn't appear in sl_compstartflags or sl_compallflags</a>
<a name="ln1112">  // then it can't possibly compound.</a>
<a name="ln1113">  if (!byte_in_str(sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln1114">          ? slang-&gt;sl_compstartflags : slang-&gt;sl_compallflags, flag)) {</a>
<a name="ln1115">    return false;</a>
<a name="ln1116">  }</a>
<a name="ln1117"> </a>
<a name="ln1118">  // If there are no wildcards, we can check if the flags collected so far</a>
<a name="ln1119">  // possibly can form a match with COMPOUNDRULE patterns.  This only</a>
<a name="ln1120">  // makes sense when we have two or more words.</a>
<a name="ln1121">  if (slang-&gt;sl_comprules != NULL &amp;&amp; sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln1122">    compflags[sp-&gt;ts_complen] = flag;</a>
<a name="ln1123">    compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln1124">    bool v = match_compoundrule(slang, compflags + sp-&gt;ts_compsplit);</a>
<a name="ln1125">    compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln1126">    return v;</a>
<a name="ln1127">  }</a>
<a name="ln1128"> </a>
<a name="ln1129">  return true;</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">// Returns true if the compound flags in compflags[] match the start of any</a>
<a name="ln1133">// compound rule.  This is used to stop trying a compound if the flags</a>
<a name="ln1134">// collected so far can't possibly match any compound rule.</a>
<a name="ln1135">// Caller must check that slang-&gt;sl_comprules is not NULL.</a>
<a name="ln1136">static bool match_compoundrule(slang_T *slang, char_u *compflags)</a>
<a name="ln1137">{</a>
<a name="ln1138">  char_u *p;</a>
<a name="ln1139">  int i;</a>
<a name="ln1140">  int c;</a>
<a name="ln1141"> </a>
<a name="ln1142">  // loop over all the COMPOUNDRULE entries</a>
<a name="ln1143">  for (p = slang-&gt;sl_comprules; *p != NUL; ++p) {</a>
<a name="ln1144">    // loop over the flags in the compound word we have made, match</a>
<a name="ln1145">    // them against the current rule entry</a>
<a name="ln1146">    for (i = 0;; ++i) {</a>
<a name="ln1147">      c = compflags[i];</a>
<a name="ln1148">      if (c == NUL) {</a>
<a name="ln1149">        // found a rule that matches for the flags we have so far</a>
<a name="ln1150">        return true;</a>
<a name="ln1151">      }</a>
<a name="ln1152">      if (*p == '/' || *p == NUL) {</a>
<a name="ln1153">        break;          // end of rule, it's too short</a>
<a name="ln1154">      }</a>
<a name="ln1155">      if (*p == '[') {</a>
<a name="ln1156">        bool match = false;</a>
<a name="ln1157"> </a>
<a name="ln1158">        // compare against all the flags in []</a>
<a name="ln1159">        ++p;</a>
<a name="ln1160">        while (*p != ']' &amp;&amp; *p != NUL) {</a>
<a name="ln1161">          if (*p++ == c) {</a>
<a name="ln1162">            match = true;</a>
<a name="ln1163">          }</a>
<a name="ln1164">        }</a>
<a name="ln1165">        if (!match) {</a>
<a name="ln1166">          break;            // none matches</a>
<a name="ln1167">        }</a>
<a name="ln1168">      } else if (*p != c) {</a>
<a name="ln1169">        break;          // flag of word doesn't match flag in pattern</a>
<a name="ln1170">      }</a>
<a name="ln1171">      ++p;</a>
<a name="ln1172">    }</a>
<a name="ln1173"> </a>
<a name="ln1174">    // Skip to the next &quot;/&quot;, where the next pattern starts.</a>
<a name="ln1175">    p = (char_u *)vim_strchr((char *)p, '/');</a>
<a name="ln1176">    if (p == NULL) {</a>
<a name="ln1177">      break;</a>
<a name="ln1178">    }</a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  // Checked all the rules and none of them match the flags, so there</a>
<a name="ln1182">  // can't possibly be a compound starting with these flags.</a>
<a name="ln1183">  return false;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">/// Return non-zero if the prefix indicated by &quot;arridx&quot; matches with the prefix</a>
<a name="ln1187">/// ID in &quot;flags&quot; for the word &quot;word&quot;.</a>
<a name="ln1188">/// The WF_RAREPFX flag is included in the return value for a rare prefix.</a>
<a name="ln1189">///</a>
<a name="ln1190">/// @param totprefcnt  nr of prefix IDs</a>
<a name="ln1191">/// @param arridx  idx in sl_pidxs[]</a>
<a name="ln1192">/// @param cond_req  only use prefixes with a condition</a>
<a name="ln1193">static int valid_word_prefix(int totprefcnt, int arridx, int flags, char_u *word, slang_T *slang,</a>
<a name="ln1194">                             bool cond_req)</a>
<a name="ln1195">{</a>
<a name="ln1196">  int prefcnt;</a>
<a name="ln1197">  int pidx;</a>
<a name="ln1198">  int prefid;</a>
<a name="ln1199"> </a>
<a name="ln1200">  prefid = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln1201">  for (prefcnt = totprefcnt - 1; prefcnt &gt;= 0; --prefcnt) {</a>
<a name="ln1202">    pidx = slang-&gt;sl_pidxs[arridx + prefcnt];</a>
<a name="ln1203"> </a>
<a name="ln1204">    // Check the prefix ID.</a>
<a name="ln1205">    if (prefid != (pidx &amp; 0xff)) {</a>
<a name="ln1206">      continue;</a>
<a name="ln1207">    }</a>
<a name="ln1208"> </a>
<a name="ln1209">    // Check if the prefix doesn't combine and the word already has a</a>
<a name="ln1210">    // suffix.</a>
<a name="ln1211">    if ((flags &amp; WF_HAS_AFF) &amp;&amp; (pidx &amp; WF_PFX_NC)) {</a>
<a name="ln1212">      continue;</a>
<a name="ln1213">    }</a>
<a name="ln1214"> </a>
<a name="ln1215">    // Check the condition, if there is one.  The condition index is</a>
<a name="ln1216">    // stored in the two bytes above the prefix ID byte.</a>
<a name="ln1217">    regprog_T **rp = &amp;slang-&gt;sl_prefprog[((unsigned)pidx &gt;&gt; 8) &amp; 0xffff];</a>
<a name="ln1218">    if (*rp != NULL) {</a>
<a name="ln1219">      if (!vim_regexec_prog(rp, false, word, 0)) {</a>
<a name="ln1220">        continue;</a>
<a name="ln1221">      }</a>
<a name="ln1222">    } else if (cond_req) {</a>
<a name="ln1223">      continue;</a>
<a name="ln1224">    }</a>
<a name="ln1225"> </a>
<a name="ln1226">    // It's a match!  Return the WF_ flags.</a>
<a name="ln1227">    return pidx;</a>
<a name="ln1228">  }</a>
<a name="ln1229">  return 0;</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">// Check if the word at &quot;mip-&gt;mi_word&quot; has a matching prefix.</a>
<a name="ln1233">// If it does, then check the following word.</a>
<a name="ln1234">//</a>
<a name="ln1235">// If &quot;mode&quot; is &quot;FIND_COMPOUND&quot; then do the same after another word, find a</a>
<a name="ln1236">// prefix in a compound word.</a>
<a name="ln1237">//</a>
<a name="ln1238">// For a match mip-&gt;mi_result is updated.</a>
<a name="ln1239">static void find_prefix(matchinf_T *mip, int mode)</a>
<a name="ln1240">{</a>
<a name="ln1241">  idx_T arridx = 0;</a>
<a name="ln1242">  int len;</a>
<a name="ln1243">  int wlen = 0;</a>
<a name="ln1244">  int flen;</a>
<a name="ln1245">  int c;</a>
<a name="ln1246">  char_u *ptr;</a>
<a name="ln1247">  idx_T lo, hi, m;</a>
<a name="ln1248">  slang_T *slang = mip-&gt;mi_lp-&gt;lp_slang;</a>
<a name="ln1249">  char_u *byts;</a>
<a name="ln1250">  idx_T *idxs;</a>
<a name="ln1251"> </a>
<a name="ln1252">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln1253">  if (byts == NULL) {</a>
<a name="ln1254">    return;                     // array is empty</a>
<a name="ln1255">  }</a>
<a name="ln1256">  // We use the case-folded word here, since prefixes are always</a>
<a name="ln1257">  // case-folded.</a>
<a name="ln1258">  ptr = mip-&gt;mi_fword;</a>
<a name="ln1259">  flen = mip-&gt;mi_fwordlen;      // available case-folded bytes</a>
<a name="ln1260">  if (mode == FIND_COMPOUND) {</a>
<a name="ln1261">    // Skip over the previously found word(s).</a>
<a name="ln1262">    ptr += mip-&gt;mi_compoff;</a>
<a name="ln1263">    flen -= mip-&gt;mi_compoff;</a>
<a name="ln1264">  }</a>
<a name="ln1265">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln1266"> </a>
<a name="ln1267">  // Repeat advancing in the tree until:</a>
<a name="ln1268">  // - there is a byte that doesn't match,</a>
<a name="ln1269">  // - we reach the end of the tree,</a>
<a name="ln1270">  // - or we reach the end of the line.</a>
<a name="ln1271">  for (;;) {</a>
<a name="ln1272">    if (flen == 0 &amp;&amp; *mip-&gt;mi_fend != NUL) {</a>
<a name="ln1273">      flen = fold_more(mip);</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">    len = byts[arridx++];</a>
<a name="ln1277"> </a>
<a name="ln1278">    // If the first possible byte is a zero the prefix could end here.</a>
<a name="ln1279">    // Check if the following word matches and supports the prefix.</a>
<a name="ln1280">    if (byts[arridx] == 0) {</a>
<a name="ln1281">      // There can be several prefixes with different conditions.  We</a>
<a name="ln1282">      // try them all, since we don't know which one will give the</a>
<a name="ln1283">      // longest match.  The word is the same each time, pass the list</a>
<a name="ln1284">      // of possible prefixes to find_word().</a>
<a name="ln1285">      mip-&gt;mi_prefarridx = arridx;</a>
<a name="ln1286">      mip-&gt;mi_prefcnt = len;</a>
<a name="ln1287">      while (len &gt; 0 &amp;&amp; byts[arridx] == 0) {</a>
<a name="ln1288">        ++arridx;</a>
<a name="ln1289">        --len;</a>
<a name="ln1290">      }</a>
<a name="ln1291">      mip-&gt;mi_prefcnt -= len;</a>
<a name="ln1292"> </a>
<a name="ln1293">      // Find the word that comes after the prefix.</a>
<a name="ln1294">      mip-&gt;mi_prefixlen = wlen;</a>
<a name="ln1295">      if (mode == FIND_COMPOUND) {</a>
<a name="ln1296">        // Skip over the previously found word(s).</a>
<a name="ln1297">        mip-&gt;mi_prefixlen += mip-&gt;mi_compoff;</a>
<a name="ln1298">      }</a>
<a name="ln1299"> </a>
<a name="ln1300">      // Case-folded length may differ from original length.</a>
<a name="ln1301">      mip-&gt;mi_cprefixlen = nofold_len(mip-&gt;mi_fword, mip-&gt;mi_prefixlen,</a>
<a name="ln1302">                                      mip-&gt;mi_word);</a>
<a name="ln1303">      find_word(mip, FIND_PREFIX);</a>
<a name="ln1304"> </a>
<a name="ln1305">      if (len == 0) {</a>
<a name="ln1306">        break;              // no children, word must end here</a>
<a name="ln1307">      }</a>
<a name="ln1308">    }</a>
<a name="ln1309"> </a>
<a name="ln1310">    // Stop looking at end of the line.</a>
<a name="ln1311">    if (ptr[wlen] == NUL) {</a>
<a name="ln1312">      break;</a>
<a name="ln1313">    }</a>
<a name="ln1314"> </a>
<a name="ln1315">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln1316">    c = ptr[wlen];</a>
<a name="ln1317">    lo = arridx;</a>
<a name="ln1318">    hi = arridx + len - 1;</a>
<a name="ln1319">    while (lo &lt; hi) {</a>
<a name="ln1320">      m = (lo + hi) / 2;</a>
<a name="ln1321">      if (byts[m] &gt; c) {</a>
<a name="ln1322">        hi = m - 1;</a>
<a name="ln1323">      } else if (byts[m] &lt; c) {</a>
<a name="ln1324">        lo = m + 1;</a>
<a name="ln1325">      } else {</a>
<a name="ln1326">        lo = hi = m;</a>
<a name="ln1327">        break;</a>
<a name="ln1328">      }</a>
<a name="ln1329">    }</a>
<a name="ln1330"> </a>
<a name="ln1331">    // Stop if there is no matching byte.</a>
<a name="ln1332">    if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln1333">      break;</a>
<a name="ln1334">    }</a>
<a name="ln1335"> </a>
<a name="ln1336">    // Continue at the child (if there is one).</a>
<a name="ln1337">    arridx = idxs[lo];</a>
<a name="ln1338">    ++wlen;</a>
<a name="ln1339">    --flen;</a>
<a name="ln1340">  }</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">// Need to fold at least one more character.  Do until next non-word character</a>
<a name="ln1344">// for efficiency.  Include the non-word character too.</a>
<a name="ln1345">// Return the length of the folded chars in bytes.</a>
<a name="ln1346">static int fold_more(matchinf_T *mip)</a>
<a name="ln1347">{</a>
<a name="ln1348">  int flen;</a>
<a name="ln1349">  char_u *p;</a>
<a name="ln1350"> </a>
<a name="ln1351">  p = mip-&gt;mi_fend;</a>
<a name="ln1352">  do {</a>
<a name="ln1353">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1354">  } while (*mip-&gt;mi_fend != NUL &amp;&amp; spell_iswordp(mip-&gt;mi_fend, mip-&gt;mi_win));</a>
<a name="ln1355"> </a>
<a name="ln1356">  // Include the non-word character so that we can check for the word end.</a>
<a name="ln1357">  if (*mip-&gt;mi_fend != NUL) {</a>
<a name="ln1358">    MB_PTR_ADV(mip-&gt;mi_fend);</a>
<a name="ln1359">  }</a>
<a name="ln1360"> </a>
<a name="ln1361">  (void)spell_casefold(mip-&gt;mi_win, p, (int)(mip-&gt;mi_fend - p),</a>
<a name="ln1362">                       mip-&gt;mi_fword + mip-&gt;mi_fwordlen,</a>
<a name="ln1363">                       MAXWLEN - mip-&gt;mi_fwordlen);</a>
<a name="ln1364">  flen = (int)STRLEN(mip-&gt;mi_fword + mip-&gt;mi_fwordlen);</a>
<a name="ln1365">  mip-&gt;mi_fwordlen += flen;</a>
<a name="ln1366">  return flen;</a>
<a name="ln1367">}</a>
<a name="ln1368"> </a>
<a name="ln1369">/// Checks case flags for a word. Returns true, if the word has the requested</a>
<a name="ln1370">/// case.</a>
<a name="ln1371">///</a>
<a name="ln1372">/// @param wordflags Flags for the checked word.</a>
<a name="ln1373">/// @param treeflags Flags for the word in the spell tree.</a>
<a name="ln1374">static bool spell_valid_case(int wordflags, int treeflags)</a>
<a name="ln1375">{</a>
<a name="ln1376">  return (wordflags == WF_ALLCAP &amp;&amp; (treeflags &amp; WF_FIXCAP) == 0)</a>
<a name="ln1377">         || ((treeflags &amp; (WF_ALLCAP | WF_KEEPCAP)) == 0</a>
<a name="ln1378">             &amp;&amp; ((treeflags &amp; WF_ONECAP) == 0</a>
<a name="ln1379">                 || (wordflags &amp; WF_ONECAP) != 0));</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">// Returns true if spell checking is not enabled.</a>
<a name="ln1383">static bool no_spell_checking(win_T *wp)</a>
<a name="ln1384">{</a>
<a name="ln1385">  if (!wp-&gt;w_p_spell || *wp-&gt;w_s-&gt;b_p_spl == NUL</a>
<a name="ln1386">      || GA_EMPTY(&amp;wp-&gt;w_s-&gt;b_langp)) {</a>
<a name="ln1387">    emsg(_(e_no_spell));</a>
<a name="ln1388">    return true;</a>
<a name="ln1389">  }</a>
<a name="ln1390">  return false;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">/// Moves to the next spell error.</a>
<a name="ln1394">/// &quot;curline&quot; is false for &quot;[s&quot;, &quot;]s&quot;, &quot;[S&quot; and &quot;]S&quot;.</a>
<a name="ln1395">/// &quot;curline&quot; is true to find word under/after cursor in the same line.</a>
<a name="ln1396">/// For Insert mode completion &quot;dir&quot; is BACKWARD and &quot;curline&quot; is true: move</a>
<a name="ln1397">/// to after badly spelled word before the cursor.</a>
<a name="ln1398">///</a>
<a name="ln1399">/// @param dir  FORWARD or BACKWARD</a>
<a name="ln1400">/// @param allwords  true for &quot;[s&quot;/&quot;]s&quot;, false for &quot;[S&quot;/&quot;]S&quot;</a>
<a name="ln1401">/// @param attrp  return: attributes of bad word or NULL (only when &quot;dir&quot; is FORWARD)</a>
<a name="ln1402">///</a>
<a name="ln1403">/// @return  0 if not found, length of the badly spelled word otherwise.</a>
<a name="ln1404">size_t spell_move_to(win_T *wp, int dir, bool allwords, bool curline, hlf_T *attrp)</a>
<a name="ln1405">{</a>
<a name="ln1406">  linenr_T lnum;</a>
<a name="ln1407">  pos_T found_pos;</a>
<a name="ln1408">  size_t found_len = 0;</a>
<a name="ln1409">  char_u *line;</a>
<a name="ln1410">  char_u *p;</a>
<a name="ln1411">  char_u *endp;</a>
<a name="ln1412">  hlf_T attr = HLF_COUNT;</a>
<a name="ln1413">  size_t len;</a>
<a name="ln1414">  int has_syntax = syntax_present(wp);</a>
<a name="ln1415">  int col;</a>
<a name="ln1416">  bool can_spell;</a>
<a name="ln1417">  char_u *buf = NULL;</a>
<a name="ln1418">  size_t buflen = 0;</a>
<a name="ln1419">  int skip = 0;</a>
<a name="ln1420">  int capcol = -1;</a>
<a name="ln1421">  bool found_one = false;</a>
<a name="ln1422">  bool wrapped = false;</a>
<a name="ln1423"> </a>
<a name="ln1424">  if (no_spell_checking(wp)) {</a>
<a name="ln1425">    return 0;</a>
<a name="ln1426">  }</a>
<a name="ln1427"> </a>
<a name="ln1428">  // Start looking for bad word at the start of the line, because we can't</a>
<a name="ln1429">  // start halfway through a word, we don't know where it starts or ends.</a>
<a name="ln1430">  //</a>
<a name="ln1431">  // When searching backwards, we continue in the line to find the last</a>
<a name="ln1432">  // bad word (in the cursor line: before the cursor).</a>
<a name="ln1433">  //</a>
<a name="ln1434">  // We concatenate the start of the next line, so that wrapped words work</a>
<a name="ln1435">  // (e.g. &quot;et&lt;line-break&gt;cetera&quot;).  Doesn't work when searching backwards</a>
<a name="ln1436">  // though...</a>
<a name="ln1437">  lnum = wp-&gt;w_cursor.lnum;</a>
<a name="ln1438">  clearpos(&amp;found_pos);</a>
<a name="ln1439"> </a>
<a name="ln1440">  while (!got_int) {</a>
<a name="ln1441">    line = ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln1442"> </a>
<a name="ln1443">    len = STRLEN(line);</a>
<a name="ln1444">    if (buflen &lt; len + MAXWLEN + 2) {</a>
<a name="ln1445">      xfree(buf);</a>
<a name="ln1446">      buflen = len + MAXWLEN + 2;</a>
<a name="ln1447">      buf = xmalloc(buflen);</a>
<a name="ln1448">    }</a>
<a name="ln1449">    assert(buf &amp;&amp; buflen &gt;= len + MAXWLEN + 2);</a>
<a name="ln1450"> </a>
<a name="ln1451">    // In first line check first word for Capital.</a>
<a name="ln1452">    if (lnum == 1) {</a>
<a name="ln1453">      capcol = 0;</a>
<a name="ln1454">    }</a>
<a name="ln1455"> </a>
<a name="ln1456">    // For checking first word with a capital skip white space.</a>
<a name="ln1457">    if (capcol == 0) {</a>
<a name="ln1458">      capcol = (int)getwhitecols(line);</a>
<a name="ln1459">    } else if (curline &amp;&amp; wp == curwin) {</a>
<a name="ln1460">      // For spellbadword(): check if first word needs a capital.</a>
<a name="ln1461">      col = (int)getwhitecols(line);</a>
<a name="ln1462">      if (check_need_cap(lnum, col)) {</a>
<a name="ln1463">        capcol = col;</a>
<a name="ln1464">      }</a>
<a name="ln1465"> </a>
<a name="ln1466">      // Need to get the line again, may have looked at the previous</a>
<a name="ln1467">      // one.</a>
<a name="ln1468">      line = ml_get_buf(wp-&gt;w_buffer, lnum, false);</a>
<a name="ln1469">    }</a>
<a name="ln1470"> </a>
<a name="ln1471">    // Copy the line into &quot;buf&quot; and append the start of the next line if</a>
<a name="ln1472">    // possible.</a>
<a name="ln1473">    STRCPY(buf, line);</a>
<a name="ln1474">    if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1475">      spell_cat_line(buf + STRLEN(buf),</a>
<a name="ln1476">                     ml_get_buf(wp-&gt;w_buffer, lnum + 1, false),</a>
<a name="ln1477">                     MAXWLEN);</a>
<a name="ln1478">    }</a>
<a name="ln1479">    p = buf + skip;</a>
<a name="ln1480">    endp = buf + len;</a>
<a name="ln1481">    while (p &lt; endp) {</a>
<a name="ln1482">      // When searching backward don't search after the cursor.  Unless</a>
<a name="ln1483">      // we wrapped around the end of the buffer.</a>
<a name="ln1484">      if (dir == BACKWARD</a>
<a name="ln1485">          &amp;&amp; lnum == wp-&gt;w_cursor.lnum</a>
<a name="ln1486">          &amp;&amp; !wrapped</a>
<a name="ln1487">          &amp;&amp; (colnr_T)(p - buf) &gt;= wp-&gt;w_cursor.col) {</a>
<a name="ln1488">        break;</a>
<a name="ln1489">      }</a>
<a name="ln1490"> </a>
<a name="ln1491">      // start of word</a>
<a name="ln1492">      attr = HLF_COUNT;</a>
<a name="ln1493">      len = spell_check(wp, p, &amp;attr, &amp;capcol, false);</a>
<a name="ln1494"> </a>
<a name="ln1495">      if (attr != HLF_COUNT) {</a>
<a name="ln1496">        // We found a bad word.  Check the attribute.</a>
<a name="ln1497">        if (allwords || attr == HLF_SPB) {</a>
<a name="ln1498">          // When searching forward only accept a bad word after</a>
<a name="ln1499">          // the cursor.</a>
<a name="ln1500">          if (dir == BACKWARD</a>
<a name="ln1501">              || lnum != wp-&gt;w_cursor.lnum</a>
<a name="ln1502">              || wrapped</a>
<a name="ln1503">              || ((colnr_T)(curline</a>
<a name="ln1504">                            ? p - buf + (ptrdiff_t)len</a>
<a name="ln1505">                            : p - buf) &gt; wp-&gt;w_cursor.col)) {</a>
<a name="ln1506">            if (has_syntax) {</a>
<a name="ln1507">              col = (int)(p - buf);</a>
<a name="ln1508">              (void)syn_get_id(wp, lnum, (colnr_T)col,</a>
<a name="ln1509">                               FALSE, &amp;can_spell, FALSE);</a>
<a name="ln1510">              if (!can_spell) {</a>
<a name="ln1511">                attr = HLF_COUNT;</a>
<a name="ln1512">              }</a>
<a name="ln1513">            } else {</a>
<a name="ln1514">              can_spell = true;</a>
<a name="ln1515">            }</a>
<a name="ln1516"> </a>
<a name="ln1517">            if (can_spell) {</a>
<a name="ln1518">              found_one = true;</a>
<a name="ln1519">              found_pos.lnum = lnum;</a>
<a name="ln1520">              found_pos.col = (int)(p - buf);</a>
<a name="ln1521">              found_pos.coladd = 0;</a>
<a name="ln1522">              if (dir == FORWARD) {</a>
<a name="ln1523">                // No need to search further.</a>
<a name="ln1524">                wp-&gt;w_cursor = found_pos;</a>
<a name="ln1525">                xfree(buf);</a>
<a name="ln1526">                if (attrp != NULL) {</a>
<a name="ln1527">                  *attrp = attr;</a>
<a name="ln1528">                }</a>
<a name="ln1529">                return len;</a>
<a name="ln1530">              } else if (curline) {</a>
<a name="ln1531">                // Insert mode completion: put cursor after</a>
<a name="ln1532">                // the bad word.</a>
<a name="ln1533">                assert(len &lt;= INT_MAX);</a>
<a name="ln1534">                found_pos.col += (int)len;</a>
<a name="ln1535">              }</a>
<a name="ln1536">              found_len = len;</a>
<a name="ln1537">            }</a>
<a name="ln1538">          } else {</a>
<a name="ln1539">            found_one = true;</a>
<a name="ln1540">          }</a>
<a name="ln1541">        }</a>
<a name="ln1542">      }</a>
<a name="ln1543"> </a>
<a name="ln1544">      // advance to character after the word</a>
<a name="ln1545">      p += len;</a>
<a name="ln1546">      assert(len &lt;= INT_MAX);</a>
<a name="ln1547">      capcol -= (int)len;</a>
<a name="ln1548">    }</a>
<a name="ln1549"> </a>
<a name="ln1550">    if (dir == BACKWARD &amp;&amp; found_pos.lnum != 0) {</a>
<a name="ln1551">      // Use the last match in the line (before the cursor).</a>
<a name="ln1552">      wp-&gt;w_cursor = found_pos;</a>
<a name="ln1553">      xfree(buf);</a>
<a name="ln1554">      return found_len;</a>
<a name="ln1555">    }</a>
<a name="ln1556"> </a>
<a name="ln1557">    if (curline) {</a>
<a name="ln1558">      break;            // only check cursor line</a>
<a name="ln1559">    }</a>
<a name="ln1560"> </a>
<a name="ln1561">    // If we are back at the starting line and searched it again there</a>
<a name="ln1562">    // is no match, give up.</a>
<a name="ln1563">    if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; wrapped) {</a>
<a name="ln1564">      break;</a>
<a name="ln1565">    }</a>
<a name="ln1566"> </a>
<a name="ln1567">    // Advance to next line.</a>
<a name="ln1568">    if (dir == BACKWARD) {</a>
<a name="ln1569">      if (lnum &gt; 1) {</a>
<a name="ln1570">        lnum--;</a>
<a name="ln1571">      } else if (!p_ws) {</a>
<a name="ln1572">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1573">      } else {</a>
<a name="ln1574">        // Wrap around to the end of the buffer.  May search the</a>
<a name="ln1575">        // starting line again and accept the last match.</a>
<a name="ln1576">        lnum = wp-&gt;w_buffer-&gt;b_ml.ml_line_count;</a>
<a name="ln1577">        wrapped = true;</a>
<a name="ln1578">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1579">          give_warning((char_u *)_(top_bot_msg), true);</a>
<a name="ln1580">        }</a>
<a name="ln1581">      }</a>
<a name="ln1582">      capcol = -1;</a>
<a name="ln1583">    } else {</a>
<a name="ln1584">      if (lnum &lt; wp-&gt;w_buffer-&gt;b_ml.ml_line_count) {</a>
<a name="ln1585">        ++lnum;</a>
<a name="ln1586">      } else if (!p_ws) {</a>
<a name="ln1587">        break;              // at first line and 'nowrapscan'</a>
<a name="ln1588">      } else {</a>
<a name="ln1589">        // Wrap around to the start of the buffer.  May search the</a>
<a name="ln1590">        // starting line again and accept the first match.</a>
<a name="ln1591">        lnum = 1;</a>
<a name="ln1592">        wrapped = true;</a>
<a name="ln1593">        if (!shortmess(SHM_SEARCH)) {</a>
<a name="ln1594">          give_warning((char_u *)_(bot_top_msg), true);</a>
<a name="ln1595">        }</a>
<a name="ln1596">      }</a>
<a name="ln1597"> </a>
<a name="ln1598">      // If we are back at the starting line and there is no match then</a>
<a name="ln1599">      // give up.</a>
<a name="ln1600">      if (lnum == wp-&gt;w_cursor.lnum &amp;&amp; !found_one) {</a>
<a name="ln1601">        break;</a>
<a name="ln1602">      }</a>
<a name="ln1603"> </a>
<a name="ln1604">      // Skip the characters at the start of the next line that were</a>
<a name="ln1605">      // included in a match crossing line boundaries.</a>
<a name="ln1606">      if (attr == HLF_COUNT) {</a>
<a name="ln1607">        skip = (int)(p - endp);</a>
<a name="ln1608">      } else {</a>
<a name="ln1609">        skip = 0;</a>
<a name="ln1610">      }</a>
<a name="ln1611"> </a>
<a name="ln1612">      // Capcol skips over the inserted space.</a>
<a name="ln1613">      --capcol;</a>
<a name="ln1614"> </a>
<a name="ln1615">      // But after empty line check first word in next line</a>
<a name="ln1616">      if (*skipwhite((char *)line) == NUL) {</a>
<a name="ln1617">        capcol = 0;</a>
<a name="ln1618">      }</a>
<a name="ln1619">    }</a>
<a name="ln1620"> </a>
<a name="ln1621">    line_breakcheck();</a>
<a name="ln1622">  }</a>
<a name="ln1623"> </a>
<a name="ln1624">  xfree(buf);</a>
<a name="ln1625">  return 0;</a>
<a name="ln1626">}</a>
<a name="ln1627"> </a>
<a name="ln1628">// For spell checking: concatenate the start of the following line &quot;line&quot; into</a>
<a name="ln1629">// &quot;buf&quot;, blanking-out special characters.  Copy less than &quot;maxlen&quot; bytes.</a>
<a name="ln1630">// Keep the blanks at the start of the next line, this is used in win_line()</a>
<a name="ln1631">// to skip those bytes if the word was OK.</a>
<a name="ln1632">void spell_cat_line(char_u *buf, char_u *line, int maxlen)</a>
<a name="ln1633">{</a>
<a name="ln1634">  char_u *p;</a>
<a name="ln1635">  int n;</a>
<a name="ln1636"> </a>
<a name="ln1637">  p = (char_u *)skipwhite((char *)line);</a>
<a name="ln1638">  while (vim_strchr(&quot;*#/\&quot;\t&quot;, *p) != NULL) {</a>
<a name="ln1639">    p = (char_u *)skipwhite((char *)p + 1);</a>
<a name="ln1640">  }</a>
<a name="ln1641"> </a>
<a name="ln1642">  if (*p != NUL) {</a>
<a name="ln1643">    // Only worth concatenating if there is something else than spaces to</a>
<a name="ln1644">    // concatenate.</a>
<a name="ln1645">    n = (int)(p - line) + 1;</a>
<a name="ln1646">    if (n &lt; maxlen - 1) {</a>
<a name="ln1647">      memset(buf, ' ', n);</a>
<a name="ln1648">      STRLCPY(buf + n, p, maxlen - n);</a>
<a name="ln1649">    }</a>
<a name="ln1650">  }</a>
<a name="ln1651">}</a>
<a name="ln1652"> </a>
<a name="ln1653">// Load word list(s) for &quot;lang&quot; from Vim spell file(s).</a>
<a name="ln1654">// &quot;lang&quot; must be the language without the region: e.g., &quot;en&quot;.</a>
<a name="ln1655">static void spell_load_lang(char_u *lang)</a>
<a name="ln1656">{</a>
<a name="ln1657">  char fname_enc[85];</a>
<a name="ln1658">  int r;</a>
<a name="ln1659">  spelload_T sl;</a>
<a name="ln1660">  int round;</a>
<a name="ln1661"> </a>
<a name="ln1662">  // Copy the language name to pass it to spell_load_cb() as a cookie.</a>
<a name="ln1663">  // It's truncated when an error is detected.</a>
<a name="ln1664">  STRCPY(sl.sl_lang, lang);</a>
<a name="ln1665">  sl.sl_slang = NULL;</a>
<a name="ln1666">  sl.sl_nobreak = false;</a>
<a name="ln1667"> </a>
<a name="ln1668">  // We may retry when no spell file is found for the language, an</a>
<a name="ln1669">  // autocommand may load it then.</a>
<a name="ln1670">  for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln1671">    // Find the first spell file for &quot;lang&quot; in 'runtimepath' and load it.</a>
<a name="ln1672">    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1673">                 &quot;spell/%s.%s.spl&quot;, lang, spell_enc());</a>
<a name="ln1674">    r = do_in_runtimepath((char *)fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1675"> </a>
<a name="ln1676">    if (r == FAIL &amp;&amp; *sl.sl_lang != NUL) {</a>
<a name="ln1677">      // Try loading the ASCII version.</a>
<a name="ln1678">      vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,</a>
<a name="ln1679">                   &quot;spell/%s.ascii.spl&quot;, lang);</a>
<a name="ln1680">      r = do_in_runtimepath((char *)fname_enc, 0, spell_load_cb, &amp;sl);</a>
<a name="ln1681"> </a>
<a name="ln1682">      if (r == FAIL &amp;&amp; *sl.sl_lang != NUL &amp;&amp; round == 1</a>
<a name="ln1683">          &amp;&amp; apply_autocmds(EVENT_SPELLFILEMISSING, (char *)lang,</a>
<a name="ln1684">                            curbuf-&gt;b_fname, false, curbuf)) {</a>
<a name="ln1685">        continue;</a>
<a name="ln1686">      }</a>
<a name="ln1687">      break;</a>
<a name="ln1688">    }</a>
<a name="ln1689">    break;</a>
<a name="ln1690">  }</a>
<a name="ln1691"> </a>
<a name="ln1692">  if (r == FAIL) {</a>
<a name="ln1693">    if (starting) {</a>
<a name="ln1694">      // Prompt the user at VimEnter if spell files are missing. #3027</a>
<a name="ln1695">      // Plugins aren't loaded yet, so spellfile.vim cannot handle this case.</a>
<a name="ln1696">      char autocmd_buf[512] = { 0 };</a>
<a name="ln1697">      snprintf(autocmd_buf, sizeof(autocmd_buf),</a>
<a name="ln1698">               &quot;autocmd VimEnter * call spellfile#LoadFile('%s')|set spell&quot;,</a>
<a name="ln1699">               lang);</a>
<a name="ln1700">      do_cmdline_cmd(autocmd_buf);</a>
<a name="ln1701">    } else {</a>
<a name="ln1702">      smsg(_(&quot;Warning: Cannot find word list \&quot;%s.%s.spl\&quot; or \&quot;%s.ascii.spl\&quot;&quot;),</a>
<a name="ln1703">           lang, spell_enc(), lang);</a>
<a name="ln1704">    }</a>
<a name="ln1705">  } else if (sl.sl_slang != NULL) {</a>
<a name="ln1706">    // At least one file was loaded, now load ALL the additions.</a>
<a name="ln1707">    STRCPY(fname_enc + STRLEN(fname_enc) - 3, &quot;add.spl&quot;);</a>
<a name="ln1708">    do_in_runtimepath((char *)fname_enc, DIP_ALL, spell_load_cb, &amp;sl);</a>
<a name="ln1709">  }</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712">// Return the encoding used for spell checking: Use 'encoding', except that we</a>
<a name="ln1713">// use &quot;latin1&quot; for &quot;latin9&quot;.  And limit to 60 characters (just in case).</a>
<a name="ln1714">char_u *spell_enc(void)</a>
<a name="ln1715">{</a>
<a name="ln1716">  if (STRLEN(p_enc) &lt; 60 &amp;&amp; STRCMP(p_enc, &quot;iso-8859-15&quot;) != 0) {</a>
<a name="ln1717">    return p_enc;</a>
<a name="ln1718">  }</a>
<a name="ln1719">  return (char_u *)&quot;latin1&quot;;</a>
<a name="ln1720">}</a>
<a name="ln1721"> </a>
<a name="ln1722">// Get the name of the .spl file for the internal wordlist into</a>
<a name="ln1723">// &quot;fname[MAXPATHL]&quot;.</a>
<a name="ln1724">static void int_wordlist_spl(char_u *fname)</a>
<a name="ln1725">{</a>
<a name="ln1726">  vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,</a>
<a name="ln1727">               int_wordlist, spell_enc());</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">// Allocate a new slang_T for language &quot;lang&quot;.  &quot;lang&quot; can be NULL.</a>
<a name="ln1731">// Caller must fill &quot;sl_next&quot;.</a>
<a name="ln1732">slang_T *slang_alloc(char_u *lang)</a>
<a name="ln1733">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1734">{</a>
<a name="ln1735">  slang_T *lp = xcalloc(1, sizeof(slang_T));</a>
<a name="ln1736"> </a>
<a name="ln1737">  if (lang != NULL) {</a>
<a name="ln1738">    lp-&gt;sl_name = vim_strsave(lang);</a>
<a name="ln1739">  }</a>
<a name="ln1740">  ga_init(&amp;lp-&gt;sl_rep, sizeof(fromto_T), 10);</a>
<a name="ln1741">  ga_init(&amp;lp-&gt;sl_repsal, sizeof(fromto_T), 10);</a>
<a name="ln1742">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1743">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1744">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1745"> </a>
<a name="ln1746">  return lp;</a>
<a name="ln1747">}</a>
<a name="ln1748"> </a>
<a name="ln1749">// Free the contents of an slang_T and the structure itself.</a>
<a name="ln1750">void slang_free(slang_T *lp)</a>
<a name="ln1751">{</a>
<a name="ln1752">  xfree(lp-&gt;sl_name);</a>
<a name="ln1753">  xfree(lp-&gt;sl_fname);</a>
<a name="ln1754">  slang_clear(lp);</a>
<a name="ln1755">  xfree(lp);</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758">/// Frees a salitem_T</a>
<a name="ln1759">static void free_salitem(salitem_T *smp)</a>
<a name="ln1760">{</a>
<a name="ln1761">  xfree(smp-&gt;sm_lead);</a>
<a name="ln1762">  // Don't free sm_oneof and sm_rules, they point into sm_lead.</a>
<a name="ln1763">  xfree(smp-&gt;sm_to);</a>
<a name="ln1764">  xfree(smp-&gt;sm_lead_w);</a>
<a name="ln1765">  xfree(smp-&gt;sm_oneof_w);</a>
<a name="ln1766">  xfree(smp-&gt;sm_to_w);</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/// Frees a fromto_T</a>
<a name="ln1770">static void free_fromto(fromto_T *ftp)</a>
<a name="ln1771">{</a>
<a name="ln1772">  xfree(ftp-&gt;ft_from);</a>
<a name="ln1773">  xfree(ftp-&gt;ft_to);</a>
<a name="ln1774">}</a>
<a name="ln1775"> </a>
<a name="ln1776">// Clear an slang_T so that the file can be reloaded.</a>
<a name="ln1777">void slang_clear(slang_T *lp)</a>
<a name="ln1778">{</a>
<a name="ln1779">  garray_T *gap;</a>
<a name="ln1780"> </a>
<a name="ln1781">  XFREE_CLEAR(lp-&gt;sl_fbyts);</a>
<a name="ln1782">  XFREE_CLEAR(lp-&gt;sl_kbyts);</a>
<a name="ln1783">  XFREE_CLEAR(lp-&gt;sl_pbyts);</a>
<a name="ln1784"> </a>
<a name="ln1785">  XFREE_CLEAR(lp-&gt;sl_fidxs);</a>
<a name="ln1786">  XFREE_CLEAR(lp-&gt;sl_kidxs);</a>
<a name="ln1787">  XFREE_CLEAR(lp-&gt;sl_pidxs);</a>
<a name="ln1788"> </a>
<a name="ln1789">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_rep, fromto_T, free_fromto);</a>
<a name="ln1790">  GA_DEEP_CLEAR(&amp;lp-&gt;sl_repsal, fromto_T, free_fromto);</a>
<a name="ln1791"> </a>
<a name="ln1792">  gap = &amp;lp-&gt;sl_sal;</a>
<a name="ln1793">  if (lp-&gt;sl_sofo) {</a>
<a name="ln1794">    // &quot;ga_len&quot; is set to 1 without adding an item for latin1</a>
<a name="ln1795">    GA_DEEP_CLEAR_PTR(gap);</a>
<a name="ln1796">  } else {</a>
<a name="ln1797">    // SAL items: free salitem_T items</a>
<a name="ln1798">    GA_DEEP_CLEAR(gap, salitem_T, free_salitem);</a>
<a name="ln1799">  }</a>
<a name="ln1800"> </a>
<a name="ln1801">  for (int i = 0; i &lt; lp-&gt;sl_prefixcnt; ++i) {</a>
<a name="ln1802">    vim_regfree(lp-&gt;sl_prefprog[i]);</a>
<a name="ln1803">  }</a>
<a name="ln1804">  lp-&gt;sl_prefixcnt = 0;</a>
<a name="ln1805">  XFREE_CLEAR(lp-&gt;sl_prefprog);</a>
<a name="ln1806">  XFREE_CLEAR(lp-&gt;sl_info);</a>
<a name="ln1807">  XFREE_CLEAR(lp-&gt;sl_midword);</a>
<a name="ln1808"> </a>
<a name="ln1809">  vim_regfree(lp-&gt;sl_compprog);</a>
<a name="ln1810">  lp-&gt;sl_compprog = NULL;</a>
<a name="ln1811">  XFREE_CLEAR(lp-&gt;sl_comprules);</a>
<a name="ln1812">  XFREE_CLEAR(lp-&gt;sl_compstartflags);</a>
<a name="ln1813">  XFREE_CLEAR(lp-&gt;sl_compallflags);</a>
<a name="ln1814"> </a>
<a name="ln1815">  XFREE_CLEAR(lp-&gt;sl_syllable);</a>
<a name="ln1816">  ga_clear(&amp;lp-&gt;sl_syl_items);</a>
<a name="ln1817"> </a>
<a name="ln1818">  ga_clear_strings(&amp;lp-&gt;sl_comppat);</a>
<a name="ln1819"> </a>
<a name="ln1820">  hash_clear_all(&amp;lp-&gt;sl_wordcount, WC_KEY_OFF);</a>
<a name="ln1821">  hash_init(&amp;lp-&gt;sl_wordcount);</a>
<a name="ln1822"> </a>
<a name="ln1823">  hash_clear_all(&amp;lp-&gt;sl_map_hash, 0);</a>
<a name="ln1824"> </a>
<a name="ln1825">  // Clear info from .sug file.</a>
<a name="ln1826">  slang_clear_sug(lp);</a>
<a name="ln1827"> </a>
<a name="ln1828">  lp-&gt;sl_compmax = MAXWLEN;</a>
<a name="ln1829">  lp-&gt;sl_compminlen = 0;</a>
<a name="ln1830">  lp-&gt;sl_compsylmax = MAXWLEN;</a>
<a name="ln1831">  lp-&gt;sl_regions[0] = NUL;</a>
<a name="ln1832">}</a>
<a name="ln1833"> </a>
<a name="ln1834">// Clear the info from the .sug file in &quot;lp&quot;.</a>
<a name="ln1835">void slang_clear_sug(slang_T *lp)</a>
<a name="ln1836">{</a>
<a name="ln1837">  XFREE_CLEAR(lp-&gt;sl_sbyts);</a>
<a name="ln1838">  XFREE_CLEAR(lp-&gt;sl_sidxs);</a>
<a name="ln1839">  close_spellbuf(lp-&gt;sl_sugbuf);</a>
<a name="ln1840">  lp-&gt;sl_sugbuf = NULL;</a>
<a name="ln1841">  lp-&gt;sl_sugloaded = false;</a>
<a name="ln1842">  lp-&gt;sl_sugtime = 0;</a>
<a name="ln1843">}</a>
<a name="ln1844"> </a>
<a name="ln1845">// Load one spell file and store the info into a slang_T.</a>
<a name="ln1846">// Invoked through do_in_runtimepath().</a>
<a name="ln1847">static void spell_load_cb(char *fname, void *cookie)</a>
<a name="ln1848">{</a>
<a name="ln1849">  spelload_T *slp = (spelload_T *)cookie;</a>
<a name="ln1850">  slang_T *slang;</a>
<a name="ln1851"> </a>
<a name="ln1852">  slang = spell_load_file((char_u *)fname, slp-&gt;sl_lang, NULL, false);</a>
<a name="ln1853">  if (slang != NULL) {</a>
<a name="ln1854">    // When a previously loaded file has NOBREAK also use it for the</a>
<a name="ln1855">    // &quot;.add&quot; files.</a>
<a name="ln1856">    if (slp-&gt;sl_nobreak &amp;&amp; slang-&gt;sl_add) {</a>
<a name="ln1857">      slang-&gt;sl_nobreak = true;</a>
<a name="ln1858">    } else if (slang-&gt;sl_nobreak) {</a>
<a name="ln1859">      slp-&gt;sl_nobreak = true;</a>
<a name="ln1860">    }</a>
<a name="ln1861"> </a>
<a name="ln1862">    slp-&gt;sl_slang = slang;</a>
<a name="ln1863">  }</a>
<a name="ln1864">}</a>
<a name="ln1865"> </a>
<a name="ln1866">/// Add a word to the hashtable of common words.</a>
<a name="ln1867">/// If it's already there then the counter is increased.</a>
<a name="ln1868">///</a>
<a name="ln1869">/// @param[in]  lp</a>
<a name="ln1870">/// @param[in]  word  added to common words hashtable</a>
<a name="ln1871">/// @param[in]  len  length of word or -1 for NUL terminated</a>
<a name="ln1872">/// @param[in]  count  1 to count once, 10 to init</a>
<a name="ln1873">void count_common_word(slang_T *lp, char_u *word, int len, int count)</a>
<a name="ln1874">{</a>
<a name="ln1875">  hash_T hash;</a>
<a name="ln1876">  hashitem_T *hi;</a>
<a name="ln1877">  wordcount_T *wc;</a>
<a name="ln1878">  char_u buf[MAXWLEN];</a>
<a name="ln1879">  char_u *p;</a>
<a name="ln1880"> </a>
<a name="ln1881">  if (len == -1) {</a>
<a name="ln1882">    p = word;</a>
<a name="ln1883">  } else if (len &gt;= MAXWLEN) {</a>
<a name="ln1884">    return;</a>
<a name="ln1885">  } else {</a>
<a name="ln1886">    STRLCPY(buf, word, len + 1);</a>
<a name="ln1887">    p = buf;</a>
<a name="ln1888">  }</a>
<a name="ln1889"> </a>
<a name="ln1890">  hash = hash_hash(p);</a>
<a name="ln1891">  const size_t p_len = STRLEN(p);</a>
<a name="ln1892">  hi = hash_lookup(&amp;lp-&gt;sl_wordcount, (const char *)p, p_len, hash);</a>
<a name="ln1893">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln1894">    wc = xmalloc(sizeof(wordcount_T) + p_len);</a>
<a name="ln1895">    memcpy(wc-&gt;wc_word, p, p_len + 1);</a>
<a name="ln1896">    wc-&gt;wc_count = count;</a>
<a name="ln1897">    hash_add_item(&amp;lp-&gt;sl_wordcount, hi, wc-&gt;wc_word, hash);</a>
<a name="ln1898">  } else {</a>
<a name="ln1899">    wc = HI2WC(hi);</a>
<a name="ln1900">    if ((wc-&gt;wc_count += count) &lt; (unsigned)count) {    // check for overflow</a>
<a name="ln1901">      wc-&gt;wc_count = MAXWORDCOUNT;</a>
<a name="ln1902">    }</a>
<a name="ln1903">  }</a>
<a name="ln1904">}</a>
<a name="ln1905"> </a>
<a name="ln1906">/// Adjust the score of common words.</a>
<a name="ln1907">///</a>
<a name="ln1908">/// @param split  word was split, less bonus</a>
<a name="ln1909">static int score_wordcount_adj(slang_T *slang, int score, char_u *word, bool split)</a>
<a name="ln1910">{</a>
<a name="ln1911">  hashitem_T *hi;</a>
<a name="ln1912">  wordcount_T *wc;</a>
<a name="ln1913">  int bonus;</a>
<a name="ln1914">  int newscore;</a>
<a name="ln1915"> </a>
<a name="ln1916">  hi = hash_find(&amp;slang-&gt;sl_wordcount, word);</a>
<a name="ln1917">  if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln1918">    wc = HI2WC(hi);</a>
<a name="ln1919">    if (wc-&gt;wc_count &lt; SCORE_THRES2) {</a>
<a name="ln1920">      bonus = SCORE_COMMON1;</a>
<a name="ln1921">    } else if (wc-&gt;wc_count &lt; SCORE_THRES3) {</a>
<a name="ln1922">      bonus = SCORE_COMMON2;</a>
<a name="ln1923">    } else {</a>
<a name="ln1924">      bonus = SCORE_COMMON3;</a>
<a name="ln1925">    }</a>
<a name="ln1926">    if (split) {</a>
<a name="ln1927">      newscore = score - bonus / 2;</a>
<a name="ln1928">    } else {</a>
<a name="ln1929">      newscore = score - bonus;</a>
<a name="ln1930">    }</a>
<a name="ln1931">    if (newscore &lt; 0) {</a>
<a name="ln1932">      return 0;</a>
<a name="ln1933">    }</a>
<a name="ln1934">    return newscore;</a>
<a name="ln1935">  }</a>
<a name="ln1936">  return score;</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939">// Returns true if byte &quot;n&quot; appears in &quot;str&quot;.</a>
<a name="ln1940">// Like strchr() but independent of locale.</a>
<a name="ln1941">bool byte_in_str(char_u *str, int n)</a>
<a name="ln1942">{</a>
<a name="ln1943">  char_u *p;</a>
<a name="ln1944"> </a>
<a name="ln1945">  for (p = str; *p != NUL; ++p) {</a>
<a name="ln1946">    if (*p == n) {</a>
<a name="ln1947">      return true;</a>
<a name="ln1948">    }</a>
<a name="ln1949">  }</a>
<a name="ln1950">  return false;</a>
<a name="ln1951">}</a>
<a name="ln1952"> </a>
<a name="ln1953">// Truncate &quot;slang-&gt;sl_syllable&quot; at the first slash and put the following items</a>
<a name="ln1954">// in &quot;slang-&gt;sl_syl_items&quot;.</a>
<a name="ln1955">int init_syl_tab(slang_T *slang)</a>
<a name="ln1956">{</a>
<a name="ln1957">  char_u *p;</a>
<a name="ln1958">  char_u *s;</a>
<a name="ln1959">  int l;</a>
<a name="ln1960"> </a>
<a name="ln1961">  ga_init(&amp;slang-&gt;sl_syl_items, sizeof(syl_item_T), 4);</a>
<a name="ln1962">  p = (char_u *)vim_strchr((char *)slang-&gt;sl_syllable, '/');</a>
<a name="ln1963">  while (p != NULL) {</a>
<a name="ln1964">    *p++ = NUL;</a>
<a name="ln1965">    if (*p == NUL) {        // trailing slash</a>
<a name="ln1966">      break;</a>
<a name="ln1967">    }</a>
<a name="ln1968">    s = p;</a>
<a name="ln1969">    p = (char_u *)vim_strchr((char *)p, '/');</a>
<a name="ln1970">    if (p == NULL) {</a>
<a name="ln1971">      l = (int)STRLEN(s);</a>
<a name="ln1972">    } else {</a>
<a name="ln1973">      l = (int)(p - s);</a>
<a name="ln1974">    }</a>
<a name="ln1975">    if (l &gt;= SY_MAXLEN) {</a>
<a name="ln1976">      return SP_FORMERROR;</a>
<a name="ln1977">    }</a>
<a name="ln1978"> </a>
<a name="ln1979">    syl_item_T *syl = GA_APPEND_VIA_PTR(syl_item_T, &amp;slang-&gt;sl_syl_items);</a>
<a name="ln1980">    STRLCPY(syl-&gt;sy_chars, s, l + 1);</a>
<a name="ln1981">    syl-&gt;sy_len = l;</a>
<a name="ln1982">  }</a>
<a name="ln1983">  return OK;</a>
<a name="ln1984">}</a>
<a name="ln1985"> </a>
<a name="ln1986">// Count the number of syllables in &quot;word&quot;.</a>
<a name="ln1987">// When &quot;word&quot; contains spaces the syllables after the last space are counted.</a>
<a name="ln1988">// Returns zero if syllables are not defines.</a>
<a name="ln1989">static int count_syllables(slang_T *slang, const char_u *word)</a>
<a name="ln1990">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1991">{</a>
<a name="ln1992">  int cnt = 0;</a>
<a name="ln1993">  bool skip = false;</a>
<a name="ln1994">  int len;</a>
<a name="ln1995">  syl_item_T *syl;</a>
<a name="ln1996">  int c;</a>
<a name="ln1997"> </a>
<a name="ln1998">  if (slang-&gt;sl_syllable == NULL) {</a>
<a name="ln1999">    return 0;</a>
<a name="ln2000">  }</a>
<a name="ln2001"> </a>
<a name="ln2002">  for (const char_u *p = word; *p != NUL; p += len) {</a>
<a name="ln2003">    // When running into a space reset counter.</a>
<a name="ln2004">    if (*p == ' ') {</a>
<a name="ln2005">      len = 1;</a>
<a name="ln2006">      cnt = 0;</a>
<a name="ln2007">      continue;</a>
<a name="ln2008">    }</a>
<a name="ln2009"> </a>
<a name="ln2010">    // Find longest match of syllable items.</a>
<a name="ln2011">    len = 0;</a>
<a name="ln2012">    for (int i = 0; i &lt; slang-&gt;sl_syl_items.ga_len; ++i) {</a>
<a name="ln2013">      syl = ((syl_item_T *)slang-&gt;sl_syl_items.ga_data) + i;</a>
<a name="ln2014">      if (syl-&gt;sy_len &gt; len</a>
<a name="ln2015">          &amp;&amp; STRNCMP(p, syl-&gt;sy_chars, syl-&gt;sy_len) == 0) {</a>
<a name="ln2016">        len = syl-&gt;sy_len;</a>
<a name="ln2017">      }</a>
<a name="ln2018">    }</a>
<a name="ln2019">    if (len != 0) {     // found a match, count syllable</a>
<a name="ln2020">      ++cnt;</a>
<a name="ln2021">      skip = false;</a>
<a name="ln2022">    } else {</a>
<a name="ln2023">      // No recognized syllable item, at least a syllable char then?</a>
<a name="ln2024">      c = utf_ptr2char((char *)p);</a>
<a name="ln2025">      len = utfc_ptr2len((char *)p);</a>
<a name="ln2026">      if (vim_strchr((char *)slang-&gt;sl_syllable, c) == NULL) {</a>
<a name="ln2027">        skip = false;               // No, search for next syllable</a>
<a name="ln2028">      } else if (!skip) {</a>
<a name="ln2029">        ++cnt;                      // Yes, count it</a>
<a name="ln2030">        skip = true;                // don't count following syllable chars</a>
<a name="ln2031">      }</a>
<a name="ln2032">    }</a>
<a name="ln2033">  }</a>
<a name="ln2034">  return cnt;</a>
<a name="ln2035">}</a>
<a name="ln2036"> </a>
<a name="ln2037">// Parse 'spelllang' and set w_s-&gt;b_langp accordingly.</a>
<a name="ln2038">// Returns NULL if it's OK, an error message otherwise.</a>
<a name="ln2039">char *did_set_spelllang(win_T *wp)</a>
<a name="ln2040">{</a>
<a name="ln2041">  garray_T ga;</a>
<a name="ln2042">  char_u *splp;</a>
<a name="ln2043">  char_u *region;</a>
<a name="ln2044">  char_u region_cp[3];</a>
<a name="ln2045">  bool filename;</a>
<a name="ln2046">  int region_mask;</a>
<a name="ln2047">  slang_T *slang;</a>
<a name="ln2048">  int c;</a>
<a name="ln2049">  char_u lang[MAXWLEN + 1];</a>
<a name="ln2050">  char_u spf_name[MAXPATHL];</a>
<a name="ln2051">  int len;</a>
<a name="ln2052">  char_u *p;</a>
<a name="ln2053">  int round;</a>
<a name="ln2054">  char_u *spf;</a>
<a name="ln2055">  char_u *use_region = NULL;</a>
<a name="ln2056">  bool dont_use_region = false;</a>
<a name="ln2057">  bool nobreak = false;</a>
<a name="ln2058">  langp_T *lp, *lp2;</a>
<a name="ln2059">  static bool recursive = false;</a>
<a name="ln2060">  char *ret_msg = NULL;</a>
<a name="ln2061">  char_u *spl_copy;</a>
<a name="ln2062"> </a>
<a name="ln2063">  bufref_T bufref;</a>
<a name="ln2064">  set_bufref(&amp;bufref, wp-&gt;w_buffer);</a>
<a name="ln2065"> </a>
<a name="ln2066">  // We don't want to do this recursively.  May happen when a language is</a>
<a name="ln2067">  // not available and the SpellFileMissing autocommand opens a new buffer</a>
<a name="ln2068">  // in which 'spell' is set.</a>
<a name="ln2069">  if (recursive) {</a>
<a name="ln2070">    return NULL;</a>
<a name="ln2071">  }</a>
<a name="ln2072">  recursive = true;</a>
<a name="ln2073"> </a>
<a name="ln2074">  ga_init(&amp;ga, sizeof(langp_T), 2);</a>
<a name="ln2075">  clear_midword(wp);</a>
<a name="ln2076"> </a>
<a name="ln2077">  // Make a copy of 'spelllang', the SpellFileMissing autocommands may change</a>
<a name="ln2078">  // it under our fingers.</a>
<a name="ln2079">  spl_copy = vim_strsave(wp-&gt;w_s-&gt;b_p_spl);</a>
<a name="ln2080"> </a>
<a name="ln2081">  wp-&gt;w_s-&gt;b_cjk = 0;</a>
<a name="ln2082"> </a>
<a name="ln2083">  // Loop over comma separated language names.</a>
<a name="ln2084">  for (splp = spl_copy; *splp != NUL;) {</a>
<a name="ln2085">    // Get one language name.</a>
<a name="ln2086">    copy_option_part(&amp;splp, lang, MAXWLEN, &quot;,&quot;);</a>
<a name="ln2087">    region = NULL;</a>
<a name="ln2088">    len = (int)STRLEN(lang);</a>
<a name="ln2089"> </a>
<a name="ln2090">    if (!valid_spelllang(lang)) {</a>
<a name="ln2091">      continue;</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    if (STRCMP(lang, &quot;cjk&quot;) == 0) {</a>
<a name="ln2095">      wp-&gt;w_s-&gt;b_cjk = 1;</a>
<a name="ln2096">      continue;</a>
<a name="ln2097">    }</a>
<a name="ln2098"> </a>
<a name="ln2099">    // If the name ends in &quot;.spl&quot; use it as the name of the spell file.</a>
<a name="ln2100">    // If there is a region name let &quot;region&quot; point to it and remove it</a>
<a name="ln2101">    // from the name.</a>
<a name="ln2102">    if (len &gt; 4 &amp;&amp; FNAMECMP(lang + len - 4, &quot;.spl&quot;) == 0) {</a>
<a name="ln2103">      filename = true;</a>
<a name="ln2104"> </a>
<a name="ln2105">      // Locate a region and remove it from the file name.</a>
<a name="ln2106">      p = (char_u *)vim_strchr(path_tail((char *)lang), '_');</a>
<a name="ln2107">      if (p != NULL &amp;&amp; ASCII_ISALPHA(p[1]) &amp;&amp; ASCII_ISALPHA(p[2])</a>
<a name="ln2108">          &amp;&amp; !ASCII_ISALPHA(p[3])) {</a>
<a name="ln2109">        STRLCPY(region_cp, p + 1, 3);</a>
<a name="ln2110">        memmove(p, p + 3, len - (p - lang) - 2);</a>
<a name="ln2111">        region = region_cp;</a>
<a name="ln2112">      } else {</a>
<a name="ln2113">        dont_use_region = true;</a>
<a name="ln2114">      }</a>
<a name="ln2115"> </a>
<a name="ln2116">      // Check if we loaded this language before.</a>
<a name="ln2117">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2118">        if (path_full_compare(lang, slang-&gt;sl_fname, false, true)</a>
<a name="ln2119">            == kEqualFiles) {</a>
<a name="ln2120">          break;</a>
<a name="ln2121">        }</a>
<a name="ln2122">      }</a>
<a name="ln2123">    } else {</a>
<a name="ln2124">      filename = false;</a>
<a name="ln2125">      if (len &gt; 3 &amp;&amp; lang[len - 3] == '_') {</a>
<a name="ln2126">        region = lang + len - 2;</a>
<a name="ln2127">        lang[len - 3] = NUL;</a>
<a name="ln2128">      } else {</a>
<a name="ln2129">        dont_use_region = true;</a>
<a name="ln2130">      }</a>
<a name="ln2131"> </a>
<a name="ln2132">      // Check if we loaded this language before.</a>
<a name="ln2133">      for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2134">        if (STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2135">          break;</a>
<a name="ln2136">        }</a>
<a name="ln2137">      }</a>
<a name="ln2138">    }</a>
<a name="ln2139"> </a>
<a name="ln2140">    if (region != NULL) {</a>
<a name="ln2141">      // If the region differs from what was used before then don't</a>
<a name="ln2142">      // use it for 'spellfile'.</a>
<a name="ln2143">      if (use_region != NULL &amp;&amp; STRCMP(region, use_region) != 0) {</a>
<a name="ln2144">        dont_use_region = true;</a>
<a name="ln2145">      }</a>
<a name="ln2146">      use_region = region;</a>
<a name="ln2147">    }</a>
<a name="ln2148"> </a>
<a name="ln2149">    // If not found try loading the language now.</a>
<a name="ln2150">    if (slang == NULL) {</a>
<a name="ln2151">      if (filename) {</a>
<a name="ln2152">        (void)spell_load_file(lang, lang, NULL, false);</a>
<a name="ln2153">      } else {</a>
<a name="ln2154">        spell_load_lang(lang);</a>
<a name="ln2155">        // SpellFileMissing autocommands may do anything, including</a>
<a name="ln2156">        // destroying the buffer we are using...</a>
<a name="ln2157">        if (!bufref_valid(&amp;bufref)) {</a>
<a name="ln2158">          ret_msg = N_(&quot;E797: SpellFileMissing autocommand deleted buffer&quot;);</a>
<a name="ln2159">          goto theend;</a>
<a name="ln2160">        }</a>
<a name="ln2161">      }</a>
<a name="ln2162">    }</a>
<a name="ln2163"> </a>
<a name="ln2164">    // Loop over the languages, there can be several files for &quot;lang&quot;.</a>
<a name="ln2165">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2166">      if (filename</a>
<a name="ln2167">          ? path_full_compare(lang, slang-&gt;sl_fname, false, true) == kEqualFiles</a>
<a name="ln2168">          : STRICMP(lang, slang-&gt;sl_name) == 0) {</a>
<a name="ln2169">        region_mask = REGION_ALL;</a>
<a name="ln2170">        if (!filename &amp;&amp; region != NULL) {</a>
<a name="ln2171">          // find region in sl_regions</a>
<a name="ln2172">          c = find_region(slang-&gt;sl_regions, region);</a>
<a name="ln2173">          if (c == REGION_ALL) {</a>
<a name="ln2174">            if (slang-&gt;sl_add) {</a>
<a name="ln2175">              if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2176">                // This addition file is for other regions.</a>
<a name="ln2177">                region_mask = 0;</a>
<a name="ln2178">              }</a>
<a name="ln2179">            } else {</a>
<a name="ln2180">              // This is probably an error.  Give a warning and</a>
<a name="ln2181">              // accept the words anyway.</a>
<a name="ln2182">              smsg(_(&quot;Warning: region %s not supported&quot;),</a>
<a name="ln2183">                   region);</a>
<a name="ln2184">            }</a>
<a name="ln2185">          } else {</a>
<a name="ln2186">            region_mask = 1 &lt;&lt; c;</a>
<a name="ln2187">          }</a>
<a name="ln2188">        }</a>
<a name="ln2189"> </a>
<a name="ln2190">        if (region_mask != 0) {</a>
<a name="ln2191">          langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2192">          p_-&gt;lp_slang = slang;</a>
<a name="ln2193">          p_-&gt;lp_region = region_mask;</a>
<a name="ln2194"> </a>
<a name="ln2195">          use_midword(slang, wp);</a>
<a name="ln2196">          if (slang-&gt;sl_nobreak) {</a>
<a name="ln2197">            nobreak = true;</a>
<a name="ln2198">          }</a>
<a name="ln2199">        }</a>
<a name="ln2200">      }</a>
<a name="ln2201">    }</a>
<a name="ln2202">  }</a>
<a name="ln2203"> </a>
<a name="ln2204">  // round 0: load int_wordlist, if possible.</a>
<a name="ln2205">  // round 1: load first name in 'spellfile'.</a>
<a name="ln2206">  // round 2: load second name in 'spellfile.</a>
<a name="ln2207">  // etc.</a>
<a name="ln2208">  spf = curwin-&gt;w_s-&gt;b_p_spf;</a>
<a name="ln2209">  for (round = 0; round == 0 || *spf != NUL; ++round) {</a>
<a name="ln2210">    if (round == 0) {</a>
<a name="ln2211">      // Internal wordlist, if there is one.</a>
<a name="ln2212">      if (int_wordlist == NULL) {</a>
<a name="ln2213">        continue;</a>
<a name="ln2214">      }</a>
<a name="ln2215">      int_wordlist_spl(spf_name);</a>
<a name="ln2216">    } else {</a>
<a name="ln2217">      // One entry in 'spellfile'.</a>
<a name="ln2218">      copy_option_part(&amp;spf, spf_name, MAXPATHL - 5, &quot;,&quot;);</a>
<a name="ln2219">      STRCAT(spf_name, &quot;.spl&quot;);</a>
<a name="ln2220"> </a>
<a name="ln2221">      // If it was already found above then skip it.</a>
<a name="ln2222">      for (c = 0; c &lt; ga.ga_len; ++c) {</a>
<a name="ln2223">        p = LANGP_ENTRY(ga, c)-&gt;lp_slang-&gt;sl_fname;</a>
<a name="ln2224">        if (p != NULL</a>
<a name="ln2225">            &amp;&amp; path_full_compare(spf_name, p, false, true) == kEqualFiles) {</a>
<a name="ln2226">          break;</a>
<a name="ln2227">        }</a>
<a name="ln2228">      }</a>
<a name="ln2229">      if (c &lt; ga.ga_len) {</a>
<a name="ln2230">        continue;</a>
<a name="ln2231">      }</a>
<a name="ln2232">    }</a>
<a name="ln2233"> </a>
<a name="ln2234">    // Check if it was loaded already.</a>
<a name="ln2235">    for (slang = first_lang; slang != NULL; slang = slang-&gt;sl_next) {</a>
<a name="ln2236">      if (path_full_compare(spf_name, slang-&gt;sl_fname, false, true)</a>
<a name="ln2237">          == kEqualFiles) {</a>
<a name="ln2238">        break;</a>
<a name="ln2239">      }</a>
<a name="ln2240">    }</a>
<a name="ln2241">    if (slang == NULL) {</a>
<a name="ln2242">      // Not loaded, try loading it now.  The language name includes the</a>
<a name="ln2243">      // region name, the region is ignored otherwise.  for int_wordlist</a>
<a name="ln2244">      // use an arbitrary name.</a>
<a name="ln2245">      if (round == 0) {</a>
<a name="ln2246">        STRCPY(lang, &quot;internal wordlist&quot;);</a>
<a name="ln2247">      } else {</a>
<a name="ln2248">        STRLCPY(lang, path_tail((char *)spf_name), MAXWLEN + 1);</a>
<a name="ln2249">        p = (char_u *)vim_strchr((char *)lang, '.');</a>
<a name="ln2250">        if (p != NULL) {</a>
<a name="ln2251">          *p = NUL;             // truncate at &quot;.encoding.add&quot;</a>
<a name="ln2252">        }</a>
<a name="ln2253">      }</a>
<a name="ln2254">      slang = spell_load_file(spf_name, lang, NULL, true);</a>
<a name="ln2255"> </a>
<a name="ln2256">      // If one of the languages has NOBREAK we assume the addition</a>
<a name="ln2257">      // files also have this.</a>
<a name="ln2258">      if (slang != NULL &amp;&amp; nobreak) {</a>
<a name="ln2259">        slang-&gt;sl_nobreak = true;</a>
<a name="ln2260">      }</a>
<a name="ln2261">    }</a>
<a name="ln2262">    if (slang != NULL) {</a>
<a name="ln2263">      region_mask = REGION_ALL;</a>
<a name="ln2264">      if (use_region != NULL &amp;&amp; !dont_use_region) {</a>
<a name="ln2265">        // find region in sl_regions</a>
<a name="ln2266">        c = find_region(slang-&gt;sl_regions, use_region);</a>
<a name="ln2267">        if (c != REGION_ALL) {</a>
<a name="ln2268">          region_mask = 1 &lt;&lt; c;</a>
<a name="ln2269">        } else if (*slang-&gt;sl_regions != NUL) {</a>
<a name="ln2270">          // This spell file is for other regions.</a>
<a name="ln2271">          region_mask = 0;</a>
<a name="ln2272">        }</a>
<a name="ln2273">      }</a>
<a name="ln2274"> </a>
<a name="ln2275">      if (region_mask != 0) {</a>
<a name="ln2276">        langp_T *p_ = GA_APPEND_VIA_PTR(langp_T, &amp;ga);</a>
<a name="ln2277">        p_-&gt;lp_slang = slang;</a>
<a name="ln2278">        p_-&gt;lp_sallang = NULL;</a>
<a name="ln2279">        p_-&gt;lp_replang = NULL;</a>
<a name="ln2280">        p_-&gt;lp_region = region_mask;</a>
<a name="ln2281"> </a>
<a name="ln2282">        use_midword(slang, wp);</a>
<a name="ln2283">      }</a>
<a name="ln2284">    }</a>
<a name="ln2285">  }</a>
<a name="ln2286"> </a>
<a name="ln2287">  // Everything is fine, store the new b_langp value.</a>
<a name="ln2288">  ga_clear(&amp;wp-&gt;w_s-&gt;b_langp);</a>
<a name="ln2289">  wp-&gt;w_s-&gt;b_langp = ga;</a>
<a name="ln2290"> </a>
<a name="ln2291">  // For each language figure out what language to use for sound folding and</a>
<a name="ln2292">  // REP items.  If the language doesn't support it itself use another one</a>
<a name="ln2293">  // with the same name.  E.g. for &quot;en-math&quot; use &quot;en&quot;.</a>
<a name="ln2294">  for (int i = 0; i &lt; ga.ga_len; ++i) {</a>
<a name="ln2295">    lp = LANGP_ENTRY(ga, i);</a>
<a name="ln2296"> </a>
<a name="ln2297">    // sound folding</a>
<a name="ln2298">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln2299">      // language does sound folding itself</a>
<a name="ln2300">      lp-&gt;lp_sallang = lp-&gt;lp_slang;</a>
<a name="ln2301">    } else {</a>
<a name="ln2302">      // find first similar language that does sound folding</a>
<a name="ln2303">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2304">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2305">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_sal)</a>
<a name="ln2306">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2307">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2308">          lp-&gt;lp_sallang = lp2-&gt;lp_slang;</a>
<a name="ln2309">          break;</a>
<a name="ln2310">        }</a>
<a name="ln2311">      }</a>
<a name="ln2312">    }</a>
<a name="ln2313"> </a>
<a name="ln2314">    // REP items</a>
<a name="ln2315">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_rep)) {</a>
<a name="ln2316">      // language has REP items itself</a>
<a name="ln2317">      lp-&gt;lp_replang = lp-&gt;lp_slang;</a>
<a name="ln2318">    } else {</a>
<a name="ln2319">      // find first similar language that has REP items</a>
<a name="ln2320">      for (int j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln2321">        lp2 = LANGP_ENTRY(ga, j);</a>
<a name="ln2322">        if (!GA_EMPTY(&amp;lp2-&gt;lp_slang-&gt;sl_rep)</a>
<a name="ln2323">            &amp;&amp; STRNCMP(lp-&gt;lp_slang-&gt;sl_name,</a>
<a name="ln2324">                       lp2-&gt;lp_slang-&gt;sl_name, 2) == 0) {</a>
<a name="ln2325">          lp-&gt;lp_replang = lp2-&gt;lp_slang;</a>
<a name="ln2326">          break;</a>
<a name="ln2327">        }</a>
<a name="ln2328">      }</a>
<a name="ln2329">    }</a>
<a name="ln2330">  }</a>
<a name="ln2331"> </a>
<a name="ln2332">theend:</a>
<a name="ln2333">  xfree(spl_copy);</a>
<a name="ln2334">  recursive = false;</a>
<a name="ln2335">  redraw_later(wp, NOT_VALID);</a>
<a name="ln2336">  return ret_msg;</a>
<a name="ln2337">}</a>
<a name="ln2338"> </a>
<a name="ln2339">// Clear the midword characters for buffer &quot;buf&quot;.</a>
<a name="ln2340">static void clear_midword(win_T *wp)</a>
<a name="ln2341">{</a>
<a name="ln2342">  memset(wp-&gt;w_s-&gt;b_spell_ismw, 0, 256);</a>
<a name="ln2343">  XFREE_CLEAR(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2344">}</a>
<a name="ln2345"> </a>
<a name="ln2346">// Use the &quot;sl_midword&quot; field of language &quot;lp&quot; for buffer &quot;buf&quot;.</a>
<a name="ln2347">// They add up to any currently used midword characters.</a>
<a name="ln2348">static void use_midword(slang_T *lp, win_T *wp)</a>
<a name="ln2349">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2350">{</a>
<a name="ln2351">  if (lp-&gt;sl_midword == NULL) {  // there aren't any</a>
<a name="ln2352">    return;</a>
<a name="ln2353">  }</a>
<a name="ln2354"> </a>
<a name="ln2355">  for (char_u *p = lp-&gt;sl_midword; *p != NUL;) {</a>
<a name="ln2356">    const int c = utf_ptr2char((char *)p);</a>
<a name="ln2357">    const int l = utfc_ptr2len((char *)p);</a>
<a name="ln2358">    if (c &lt; 256 &amp;&amp; l &lt;= 2) {</a>
<a name="ln2359">      wp-&gt;w_s-&gt;b_spell_ismw[c] = true;</a>
<a name="ln2360">    } else if (wp-&gt;w_s-&gt;b_spell_ismw_mb == NULL) {</a>
<a name="ln2361">      // First multi-byte char in &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2362">      wp-&gt;w_s-&gt;b_spell_ismw_mb = vim_strnsave(p, l);</a>
<a name="ln2363">    } else {</a>
<a name="ln2364">      // Append multi-byte chars to &quot;b_spell_ismw_mb&quot;.</a>
<a name="ln2365">      const int n = (int)STRLEN(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2366">      char_u *bp = vim_strnsave(wp-&gt;w_s-&gt;b_spell_ismw_mb, n + l);</a>
<a name="ln2367">      xfree(wp-&gt;w_s-&gt;b_spell_ismw_mb);</a>
<a name="ln2368">      wp-&gt;w_s-&gt;b_spell_ismw_mb = bp;</a>
<a name="ln2369">      STRLCPY(bp + n, p, l + 1);</a>
<a name="ln2370">    }</a>
<a name="ln2371">    p += l;</a>
<a name="ln2372">  }</a>
<a name="ln2373">}</a>
<a name="ln2374"> </a>
<a name="ln2375">// Find the region &quot;region[2]&quot; in &quot;rp&quot; (points to &quot;sl_regions&quot;).</a>
<a name="ln2376">// Each region is simply stored as the two characters of its name.</a>
<a name="ln2377">// Returns the index if found (first is 0), REGION_ALL if not found.</a>
<a name="ln2378">static int find_region(char_u *rp, char_u *region)</a>
<a name="ln2379">{</a>
<a name="ln2380">  int i;</a>
<a name="ln2381"> </a>
<a name="ln2382">  for (i = 0;; i += 2) {</a>
<a name="ln2383">    if (rp[i] == NUL) {</a>
<a name="ln2384">      return REGION_ALL;</a>
<a name="ln2385">    }</a>
<a name="ln2386">    if (rp[i] == region[0] &amp;&amp; rp[i + 1] == region[1]) {</a>
<a name="ln2387">      break;</a>
<a name="ln2388">    }</a>
<a name="ln2389">  }</a>
<a name="ln2390">  return i / 2;</a>
<a name="ln2391">}</a>
<a name="ln2392"> </a>
<a name="ln2393">/// Return case type of word:</a>
<a name="ln2394">/// w word       0</a>
<a name="ln2395">/// Word         WF_ONECAP</a>
<a name="ln2396">/// W WORD       WF_ALLCAP</a>
<a name="ln2397">/// WoRd wOrd    WF_KEEPCAP</a>
<a name="ln2398">///</a>
<a name="ln2399">/// @param[in]  word</a>
<a name="ln2400">/// @param[in]  end  End of word or NULL for NUL delimited string</a>
<a name="ln2401">///</a>
<a name="ln2402">/// @returns  Case type of word</a>
<a name="ln2403">int captype(char_u *word, char_u *end)</a>
<a name="ln2404">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln2405">{</a>
<a name="ln2406">  char_u *p;</a>
<a name="ln2407">  int firstcap;</a>
<a name="ln2408">  bool allcap;</a>
<a name="ln2409">  bool past_second = false;              // past second word char</a>
<a name="ln2410"> </a>
<a name="ln2411">  // find first letter</a>
<a name="ln2412">  for (p = word; !spell_iswordp_nmw(p, curwin); MB_PTR_ADV(p)) {</a>
<a name="ln2413">    if (end == NULL ? *p == NUL : p &gt;= end) {</a>
<a name="ln2414">      return 0;             // only non-word characters, illegal word</a>
<a name="ln2415">    }</a>
<a name="ln2416">  }</a>
<a name="ln2417">  int c = mb_ptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2418">  firstcap = allcap = SPELL_ISUPPER(c);</a>
<a name="ln2419"> </a>
<a name="ln2420">  // Need to check all letters to find a word with mixed upper/lower.</a>
<a name="ln2421">  // But a word with an upper char only at start is a ONECAP.</a>
<a name="ln2422">  for (; end == NULL ? *p != NUL : p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2423">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2424">      c = utf_ptr2char((char *)p);</a>
<a name="ln2425">      if (!SPELL_ISUPPER(c)) {</a>
<a name="ln2426">        // UUl -&gt; KEEPCAP</a>
<a name="ln2427">        if (past_second &amp;&amp; allcap) {</a>
<a name="ln2428">          return WF_KEEPCAP;</a>
<a name="ln2429">        }</a>
<a name="ln2430">        allcap = false;</a>
<a name="ln2431">      } else if (!allcap) {</a>
<a name="ln2432">        // UlU -&gt; KEEPCAP</a>
<a name="ln2433">        return WF_KEEPCAP;</a>
<a name="ln2434">      }</a>
<a name="ln2435">      past_second = true;</a>
<a name="ln2436">    }</a>
<a name="ln2437">  }</a>
<a name="ln2438"> </a>
<a name="ln2439">  if (allcap) {</a>
<a name="ln2440">    return WF_ALLCAP;</a>
<a name="ln2441">  }</a>
<a name="ln2442">  if (firstcap) {</a>
<a name="ln2443">    return WF_ONECAP;</a>
<a name="ln2444">  }</a>
<a name="ln2445">  return 0;</a>
<a name="ln2446">}</a>
<a name="ln2447"> </a>
<a name="ln2448">// Like captype() but for a KEEPCAP word add ONECAP if the word starts with a</a>
<a name="ln2449">// capital.  So that make_case_word() can turn WOrd into Word.</a>
<a name="ln2450">// Add ALLCAP for &quot;WOrD&quot;.</a>
<a name="ln2451">static int badword_captype(char_u *word, char_u *end)</a>
<a name="ln2452">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2453">{</a>
<a name="ln2454">  int flags = captype(word, end);</a>
<a name="ln2455">  int c;</a>
<a name="ln2456">  int l, u;</a>
<a name="ln2457">  bool first;</a>
<a name="ln2458">  char_u *p;</a>
<a name="ln2459"> </a>
<a name="ln2460">  if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln2461">    // Count the number of UPPER and lower case letters.</a>
<a name="ln2462">    l = u = 0;</a>
<a name="ln2463">    first = false;</a>
<a name="ln2464">    for (p = word; p &lt; end; MB_PTR_ADV(p)) {</a>
<a name="ln2465">      c = utf_ptr2char((char *)p);</a>
<a name="ln2466">      if (SPELL_ISUPPER(c)) {</a>
<a name="ln2467">        ++u;</a>
<a name="ln2468">        if (p == word) {</a>
<a name="ln2469">          first = true;</a>
<a name="ln2470">        }</a>
<a name="ln2471">      } else {</a>
<a name="ln2472">        ++l;</a>
<a name="ln2473">      }</a>
<a name="ln2474">    }</a>
<a name="ln2475"> </a>
<a name="ln2476">    // If there are more UPPER than lower case letters suggest an</a>
<a name="ln2477">    // ALLCAP word.  Otherwise, if the first letter is UPPER then</a>
<a name="ln2478">    // suggest ONECAP.  Exception: &quot;ALl&quot; most likely should be &quot;All&quot;,</a>
<a name="ln2479">    // require three upper case letters.</a>
<a name="ln2480">    if (u &gt; l &amp;&amp; u &gt; 2) {</a>
<a name="ln2481">      flags |= WF_ALLCAP;</a>
<a name="ln2482">    } else if (first) {</a>
<a name="ln2483">      flags |= WF_ONECAP;</a>
<a name="ln2484">    }</a>
<a name="ln2485"> </a>
<a name="ln2486">    if (u &gt;= 2 &amp;&amp; l &gt;= 2) {     // maCARONI maCAroni</a>
<a name="ln2487">      flags |= WF_MIXCAP;</a>
<a name="ln2488">    }</a>
<a name="ln2489">  }</a>
<a name="ln2490">  return flags;</a>
<a name="ln2491">}</a>
<a name="ln2492"> </a>
<a name="ln2493">// Delete the internal wordlist and its .spl file.</a>
<a name="ln2494">void spell_delete_wordlist(void)</a>
<a name="ln2495">{</a>
<a name="ln2496">  char_u fname[MAXPATHL] = { 0 };</a>
<a name="ln2497"> </a>
<a name="ln2498">  if (int_wordlist != NULL) {</a>
<a name="ln2499">    os_remove((char *)int_wordlist);</a>
<a name="ln2500">    int_wordlist_spl(fname);</a>
<a name="ln2501">    os_remove((char *)fname);</a>
<a name="ln2502">    XFREE_CLEAR(int_wordlist);</a>
<a name="ln2503">  }</a>
<a name="ln2504">}</a>
<a name="ln2505"> </a>
<a name="ln2506">// Free all languages.</a>
<a name="ln2507">void spell_free_all(void)</a>
<a name="ln2508">{</a>
<a name="ln2509">  slang_T *slang;</a>
<a name="ln2510"> </a>
<a name="ln2511">  // Go through all buffers and handle 'spelllang'. &lt;VN&gt;</a>
<a name="ln2512">  FOR_ALL_BUFFERS(buf) {</a>
<a name="ln2513">    ga_clear(&amp;buf-&gt;b_s.b_langp);</a>
<a name="ln2514">  }</a>
<a name="ln2515"> </a>
<a name="ln2516">  while (first_lang != NULL) {</a>
<a name="ln2517">    slang = first_lang;</a>
<a name="ln2518">    first_lang = slang-&gt;sl_next;</a>
<a name="ln2519">    slang_free(slang);</a>
<a name="ln2520">  }</a>
<a name="ln2521"> </a>
<a name="ln2522">  spell_delete_wordlist();</a>
<a name="ln2523"> </a>
<a name="ln2524">  XFREE_CLEAR(repl_to);</a>
<a name="ln2525">  XFREE_CLEAR(repl_from);</a>
<a name="ln2526">}</a>
<a name="ln2527"> </a>
<a name="ln2528">// Clear all spelling tables and reload them.</a>
<a name="ln2529">// Used after 'encoding' is set and when &quot;:mkspell&quot; was used.</a>
<a name="ln2530">void spell_reload(void)</a>
<a name="ln2531">{</a>
<a name="ln2532">  // Initialize the table for spell_iswordp().</a>
<a name="ln2533">  init_spell_chartab();</a>
<a name="ln2534"> </a>
<a name="ln2535">  // Unload all allocated memory.</a>
<a name="ln2536">  spell_free_all();</a>
<a name="ln2537"> </a>
<a name="ln2538">  // Go through all buffers and handle 'spelllang'.</a>
<a name="ln2539">  FOR_ALL_WINDOWS_IN_TAB(wp, curtab) {</a>
<a name="ln2540">    // Only load the wordlists when 'spelllang' is set and there is a</a>
<a name="ln2541">    // window for this buffer in which 'spell' is set.</a>
<a name="ln2542">    if (*wp-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln2543">      if (wp-&gt;w_p_spell) {</a>
<a name="ln2544">        (void)did_set_spelllang(wp);</a>
<a name="ln2545">        break;</a>
<a name="ln2546">      }</a>
<a name="ln2547">    }</a>
<a name="ln2548">  }</a>
<a name="ln2549">}</a>
<a name="ln2550"> </a>
<a name="ln2551">// Opposite of offset2bytes().</a>
<a name="ln2552">// &quot;pp&quot; points to the bytes and is advanced over it.</a>
<a name="ln2553">// Returns the offset.</a>
<a name="ln2554">static int bytes2offset(char_u **pp)</a>
<a name="ln2555">{</a>
<a name="ln2556">  char_u *p = *pp;</a>
<a name="ln2557">  int nr;</a>
<a name="ln2558">  int c;</a>
<a name="ln2559"> </a>
<a name="ln2560">  c = *p++;</a>
<a name="ln2561">  if ((c &amp; 0x80) == 0x00) {             // 1 byte</a>
<a name="ln2562">    nr = c - 1;</a>
<a name="ln2563">  } else if ((c &amp; 0xc0) == 0x80) {      // 2 bytes</a>
<a name="ln2564">    nr = (c &amp; 0x3f) - 1;</a>
<a name="ln2565">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2566">  } else if ((c &amp; 0xe0) == 0xc0) {      // 3 bytes</a>
<a name="ln2567">    nr = (c &amp; 0x1f) - 1;</a>
<a name="ln2568">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2569">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2570">  } else {                              // 4 bytes</a>
<a name="ln2571">    nr = (c &amp; 0x0f) - 1;</a>
<a name="ln2572">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2573">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2574">    nr = nr * 255 + (*p++ - 1);</a>
<a name="ln2575">  }</a>
<a name="ln2576"> </a>
<a name="ln2577">  *pp = p;</a>
<a name="ln2578">  return nr;</a>
<a name="ln2579">}</a>
<a name="ln2580"> </a>
<a name="ln2581">// Open a spell buffer.  This is a nameless buffer that is not in the buffer</a>
<a name="ln2582">// list and only contains text lines.  Can use a swapfile to reduce memory</a>
<a name="ln2583">// use.</a>
<a name="ln2584">// Most other fields are invalid!  Esp. watch out for string options being</a>
<a name="ln2585">// NULL and there is no undo info.</a>
<a name="ln2586">buf_T *open_spellbuf(void)</a>
<a name="ln2587">{</a>
<a name="ln2588">  buf_T *buf = xcalloc(1, sizeof(buf_T));</a>
<a name="ln2589"> </a>
<a name="ln2590">  buf-&gt;b_spell = true;</a>
<a name="ln2591">  buf-&gt;b_p_swf = true;        // may create a swap file</a>
<a name="ln2592">  if (ml_open(buf) == FAIL) {</a>
<a name="ln2593">    ELOG(&quot;Error opening a new memline&quot;);</a>
<a name="ln2594">  }</a>
<a name="ln2595">  ml_open_file(buf);          // create swap file now</a>
<a name="ln2596"> </a>
<a name="ln2597">  return buf;</a>
<a name="ln2598">}</a>
<a name="ln2599"> </a>
<a name="ln2600">// Close the buffer used for spell info.</a>
<a name="ln2601">void close_spellbuf(buf_T *buf)</a>
<a name="ln2602">{</a>
<a name="ln2603">  if (buf != NULL) {</a>
<a name="ln2604">    ml_close(buf, TRUE);</a>
<a name="ln2605">    xfree(buf);</a>
<a name="ln2606">  }</a>
<a name="ln2607">}</a>
<a name="ln2608"> </a>
<a name="ln2609">// Init the chartab used for spelling for ASCII.</a>
<a name="ln2610">void clear_spell_chartab(spelltab_T *sp)</a>
<a name="ln2611">{</a>
<a name="ln2612">  int i;</a>
<a name="ln2613"> </a>
<a name="ln2614">  // Init everything to false.</a>
<a name="ln2615">  memset(sp-&gt;st_isw, false, sizeof(sp-&gt;st_isw));</a>
<a name="ln2616">  memset(sp-&gt;st_isu, false, sizeof(sp-&gt;st_isu));</a>
<a name="ln2617"> </a>
<a name="ln2618">  for (i = 0; i &lt; 256; ++i) {</a>
<a name="ln2619">    sp-&gt;st_fold[i] = i;</a>
<a name="ln2620">    sp-&gt;st_upper[i] = i;</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623">  // We include digits. A word shouldn't start with a digit, but handling</a>
<a name="ln2624">  // that is done separately.</a>
<a name="ln2625">  for (i = '0'; i &lt;= '9'; ++i) {</a>
<a name="ln2626">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2627">  }</a>
<a name="ln2628">  for (i = 'A'; i &lt;= 'Z'; ++i) {</a>
<a name="ln2629">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2630">    sp-&gt;st_isu[i] = true;</a>
<a name="ln2631">    sp-&gt;st_fold[i] = i + 0x20;</a>
<a name="ln2632">  }</a>
<a name="ln2633">  for (i = 'a'; i &lt;= 'z'; ++i) {</a>
<a name="ln2634">    sp-&gt;st_isw[i] = true;</a>
<a name="ln2635">    sp-&gt;st_upper[i] = i - 0x20;</a>
<a name="ln2636">  }</a>
<a name="ln2637">}</a>
<a name="ln2638"> </a>
<a name="ln2639">// Init the chartab used for spelling. Called once while starting up.</a>
<a name="ln2640">// The default is to use isalpha(), but the spell file should define the word</a>
<a name="ln2641">// characters to make it possible that 'encoding' differs from the current</a>
<a name="ln2642">// locale.  For utf-8 we don't use isalpha() but our own functions.</a>
<a name="ln2643">void init_spell_chartab(void)</a>
<a name="ln2644">{</a>
<a name="ln2645">  int i;</a>
<a name="ln2646"> </a>
<a name="ln2647">  did_set_spelltab = false;</a>
<a name="ln2648">  clear_spell_chartab(&amp;spelltab);</a>
<a name="ln2649">  for (i = 128; i &lt; 256; i++) {</a>
<a name="ln2650">    int f = utf_fold(i);</a>
<a name="ln2651">    int u = mb_toupper(i);</a>
<a name="ln2652"> </a>
<a name="ln2653">    spelltab.st_isu[i] = mb_isupper(i);</a>
<a name="ln2654">    spelltab.st_isw[i] = spelltab.st_isu[i] || mb_islower(i);</a>
<a name="ln2655">    // The folded/upper-cased value is different between latin1 and</a>
<a name="ln2656">    // utf8 for 0xb5, causing E763 for no good reason.  Use the latin1</a>
<a name="ln2657">    // value for utf-8 to avoid this.</a>
<a name="ln2658">    spelltab.st_fold[i] = (f &lt; 256) ? f : i;</a>
<a name="ln2659">    spelltab.st_upper[i] = (u &lt; 256) ? u : i;</a>
<a name="ln2660">  }</a>
<a name="ln2661">}</a>
<a name="ln2662"> </a>
<a name="ln2663">/// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2664">/// As a special case we see &quot;midword&quot; characters as word character when it is</a>
<a name="ln2665">/// followed by a word character.  This finds they'there but not 'they there'.</a>
<a name="ln2666">/// Thus this only works properly when past the first character of the word.</a>
<a name="ln2667">///</a>
<a name="ln2668">/// @param wp Buffer used.</a>
<a name="ln2669">static bool spell_iswordp(const char_u *p, const win_T *wp)</a>
<a name="ln2670">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2671">{</a>
<a name="ln2672">  int c;</a>
<a name="ln2673"> </a>
<a name="ln2674">  const int l = utfc_ptr2len((char *)p);</a>
<a name="ln2675">  const char_u *s = p;</a>
<a name="ln2676">  if (l == 1) {</a>
<a name="ln2677">    // be quick for ASCII</a>
<a name="ln2678">    if (wp-&gt;w_s-&gt;b_spell_ismw[*p]) {</a>
<a name="ln2679">      s = p + 1;                      // skip a mid-word character</a>
<a name="ln2680">    }</a>
<a name="ln2681">  } else {</a>
<a name="ln2682">    c = utf_ptr2char((char *)p);</a>
<a name="ln2683">    if (c &lt; 256</a>
<a name="ln2684">        ? wp-&gt;w_s-&gt;b_spell_ismw[c]</a>
<a name="ln2685">        : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2686">           &amp;&amp; vim_strchr((char *)wp-&gt;w_s-&gt;b_spell_ismw_mb, c) != NULL)) {</a>
<a name="ln2687">      s = p + l;</a>
<a name="ln2688">    }</a>
<a name="ln2689">  }</a>
<a name="ln2690"> </a>
<a name="ln2691">  c = utf_ptr2char((char *)s);</a>
<a name="ln2692">  if (c &gt; 255) {</a>
<a name="ln2693">    return spell_mb_isword_class(mb_get_class(s), wp);</a>
<a name="ln2694">  }</a>
<a name="ln2695">  return spelltab.st_isw[c];</a>
<a name="ln2696">}</a>
<a name="ln2697"> </a>
<a name="ln2698">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2699">// Unlike spell_iswordp() this doesn't check for &quot;midword&quot; characters.</a>
<a name="ln2700">bool spell_iswordp_nmw(const char_u *p, win_T *wp)</a>
<a name="ln2701">{</a>
<a name="ln2702">  int c = utf_ptr2char((char *)p);</a>
<a name="ln2703">  if (c &gt; 255) {</a>
<a name="ln2704">    return spell_mb_isword_class(mb_get_class(p), wp);</a>
<a name="ln2705">  }</a>
<a name="ln2706">  return spelltab.st_isw[c];</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">// Returns true if word class indicates a word character.</a>
<a name="ln2710">// Only for characters above 255.</a>
<a name="ln2711">// Unicode subscript and superscript are not considered word characters.</a>
<a name="ln2712">// See also utf_class() in mbyte.c.</a>
<a name="ln2713">static bool spell_mb_isword_class(int cl, const win_T *wp)</a>
<a name="ln2714">  FUNC_ATTR_PURE FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln2715">{</a>
<a name="ln2716">  if (wp-&gt;w_s-&gt;b_cjk) {</a>
<a name="ln2717">    // East Asian characters are not considered word characters.</a>
<a name="ln2718">    return cl == 2 || cl == 0x2800;</a>
<a name="ln2719">  }</a>
<a name="ln2720">  return cl &gt;= 2 &amp;&amp; cl != 0x2070 &amp;&amp; cl != 0x2080 &amp;&amp; cl != 3;</a>
<a name="ln2721">}</a>
<a name="ln2722"> </a>
<a name="ln2723">// Returns true if &quot;p&quot; points to a word character.</a>
<a name="ln2724">// Wide version of spell_iswordp().</a>
<a name="ln2725">static bool spell_iswordp_w(const int *p, const win_T *wp)</a>
<a name="ln2726">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2727">{</a>
<a name="ln2728">  const int *s;</a>
<a name="ln2729"> </a>
<a name="ln2730">  if (*p &lt;</a>
<a name="ln2731">      256 ? wp-&gt;w_s-&gt;b_spell_ismw[*p] : (wp-&gt;w_s-&gt;b_spell_ismw_mb != NULL</a>
<a name="ln2732">                                         &amp;&amp; vim_strchr((char *)wp-&gt;w_s-&gt;b_spell_ismw_mb,</a>
<a name="ln2733">                                                       *p) != NULL)) {</a>
<a name="ln2734">    s = p + 1;</a>
<a name="ln2735">  } else {</a>
<a name="ln2736">    s = p;</a>
<a name="ln2737">  }</a>
<a name="ln2738"> </a>
<a name="ln2739">  if (*s &gt; 255) {</a>
<a name="ln2740">    return spell_mb_isword_class(utf_class(*s), wp);</a>
<a name="ln2741">  }</a>
<a name="ln2742">  return spelltab.st_isw[*s];</a>
<a name="ln2743">}</a>
<a name="ln2744"> </a>
<a name="ln2745">// Case-fold &quot;str[len]&quot; into &quot;buf[buflen]&quot;.  The result is NUL terminated.</a>
<a name="ln2746">// Uses the character definitions from the .spl file.</a>
<a name="ln2747">// When using a multi-byte 'encoding' the length may change!</a>
<a name="ln2748">// Returns FAIL when something wrong.</a>
<a name="ln2749">int spell_casefold(const win_T *wp, char_u *str, int len, char_u *buf, int buflen)</a>
<a name="ln2750">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln2751">{</a>
<a name="ln2752">  if (len &gt;= buflen) {</a>
<a name="ln2753">    buf[0] = NUL;</a>
<a name="ln2754">    return FAIL;                // result will not fit</a>
<a name="ln2755">  }</a>
<a name="ln2756"> </a>
<a name="ln2757">  int outi = 0;</a>
<a name="ln2758"> </a>
<a name="ln2759">  // Fold one character at a time.</a>
<a name="ln2760">  for (char_u *p = str; p &lt; str + len;) {</a>
<a name="ln2761">    if (outi + MB_MAXBYTES &gt; buflen) {</a>
<a name="ln2762">      buf[outi] = NUL;</a>
<a name="ln2763">      return FAIL;</a>
<a name="ln2764">    }</a>
<a name="ln2765">    int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln2766"> </a>
<a name="ln2767">    // Exception: greek capital sigma 0x03A3 folds to 0x03C3, except</a>
<a name="ln2768">    // when it is the last character in a word, then it folds to</a>
<a name="ln2769">    // 0x03C2.</a>
<a name="ln2770">    if (c == 0x03a3 || c == 0x03c2) {</a>
<a name="ln2771">      if (p == str + len || !spell_iswordp(p, wp)) {</a>
<a name="ln2772">        c = 0x03c2;</a>
<a name="ln2773">      } else {</a>
<a name="ln2774">        c = 0x03c3;</a>
<a name="ln2775">      }</a>
<a name="ln2776">    } else {</a>
<a name="ln2777">      c = SPELL_TOFOLD(c);</a>
<a name="ln2778">    }</a>
<a name="ln2779"> </a>
<a name="ln2780">    outi += utf_char2bytes(c, (char *)buf + outi);</a>
<a name="ln2781">  }</a>
<a name="ln2782">  buf[outi] = NUL;</a>
<a name="ln2783"> </a>
<a name="ln2784">  return OK;</a>
<a name="ln2785">}</a>
<a name="ln2786"> </a>
<a name="ln2787">// values for sps_flags</a>
<a name="ln2788">#define SPS_BEST    1</a>
<a name="ln2789">#define SPS_FAST    2</a>
<a name="ln2790">#define SPS_DOUBLE  4</a>
<a name="ln2791"> </a>
<a name="ln2792">static int sps_flags = SPS_BEST;        // flags from 'spellsuggest'</a>
<a name="ln2793">static int sps_limit = 9999;            // max nr of suggestions given</a>
<a name="ln2794"> </a>
<a name="ln2795">// Check the 'spellsuggest' option.  Return FAIL if it's wrong.</a>
<a name="ln2796">// Sets &quot;sps_flags&quot; and &quot;sps_limit&quot;.</a>
<a name="ln2797">int spell_check_sps(void)</a>
<a name="ln2798">{</a>
<a name="ln2799">  char_u *p;</a>
<a name="ln2800">  char_u *s;</a>
<a name="ln2801">  char_u buf[MAXPATHL];</a>
<a name="ln2802">  int f;</a>
<a name="ln2803"> </a>
<a name="ln2804">  sps_flags = 0;</a>
<a name="ln2805">  sps_limit = 9999;</a>
<a name="ln2806"> </a>
<a name="ln2807">  for (p = p_sps; *p != NUL;) {</a>
<a name="ln2808">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln2809"> </a>
<a name="ln2810">    f = 0;</a>
<a name="ln2811">    if (ascii_isdigit(*buf)) {</a>
<a name="ln2812">      s = buf;</a>
<a name="ln2813">      sps_limit = getdigits_int(&amp;s, true, 0);</a>
<a name="ln2814">      if (*s != NUL &amp;&amp; !ascii_isdigit(*s)) {</a>
<a name="ln2815">        f = -1;</a>
<a name="ln2816">      }</a>
<a name="ln2817">    } else if (STRCMP(buf, &quot;best&quot;) == 0) {</a>
<a name="ln2818">      f = SPS_BEST;</a>
<a name="ln2819">    } else if (STRCMP(buf, &quot;fast&quot;) == 0) {</a>
<a name="ln2820">      f = SPS_FAST;</a>
<a name="ln2821">    } else if (STRCMP(buf, &quot;double&quot;) == 0) {</a>
<a name="ln2822">      f = SPS_DOUBLE;</a>
<a name="ln2823">    } else if (STRNCMP(buf, &quot;expr:&quot;, 5) != 0</a>
<a name="ln2824">               &amp;&amp; STRNCMP(buf, &quot;file:&quot;, 5) != 0) {</a>
<a name="ln2825">      f = -1;</a>
<a name="ln2826">    }</a>
<a name="ln2827"> </a>
<a name="ln2828">    if (f == -1 || (sps_flags != 0 &amp;&amp; f != 0)) {</a>
<a name="ln2829">      sps_flags = SPS_BEST;</a>
<a name="ln2830">      sps_limit = 9999;</a>
<a name="ln2831">      return FAIL;</a>
<a name="ln2832">    }</a>
<a name="ln2833">    if (f != 0) {</a>
<a name="ln2834">      sps_flags = f;</a>
<a name="ln2835">    }</a>
<a name="ln2836">  }</a>
<a name="ln2837"> </a>
<a name="ln2838">  if (sps_flags == 0) {</a>
<a name="ln2839">    sps_flags = SPS_BEST;</a>
<a name="ln2840">  }</a>
<a name="ln2841"> </a>
<a name="ln2842">  return OK;</a>
<a name="ln2843">}</a>
<a name="ln2844"> </a>
<a name="ln2845">// &quot;z=&quot;: Find badly spelled word under or after the cursor.</a>
<a name="ln2846">// Give suggestions for the properly spelled word.</a>
<a name="ln2847">// In Visual mode use the highlighted word as the bad word.</a>
<a name="ln2848">// When &quot;count&quot; is non-zero use that suggestion.</a>
<a name="ln2849">void spell_suggest(int count)</a>
<a name="ln2850">{</a>
<a name="ln2851">  char_u *line;</a>
<a name="ln2852">  pos_T prev_cursor = curwin-&gt;w_cursor;</a>
<a name="ln2853">  char_u wcopy[MAXWLEN + 2];</a>
<a name="ln2854">  char_u *p;</a>
<a name="ln2855">  int c;</a>
<a name="ln2856">  suginfo_T sug;</a>
<a name="ln2857">  suggest_T *stp;</a>
<a name="ln2858">  int mouse_used;</a>
<a name="ln2859">  int need_cap;</a>
<a name="ln2860">  int limit;</a>
<a name="ln2861">  int selected = count;</a>
<a name="ln2862">  int badlen = 0;</a>
<a name="ln2863">  int msg_scroll_save = msg_scroll;</a>
<a name="ln2864">  const int wo_spell_save = curwin-&gt;w_p_spell;</a>
<a name="ln2865"> </a>
<a name="ln2866">  if (!curwin-&gt;w_p_spell) {</a>
<a name="ln2867">    did_set_spelllang(curwin);</a>
<a name="ln2868">    curwin-&gt;w_p_spell = true;</a>
<a name="ln2869">  }</a>
<a name="ln2870"> </a>
<a name="ln2871">  if (*curwin-&gt;w_s-&gt;b_p_spl == NUL) {</a>
<a name="ln2872">    emsg(_(e_no_spell));</a>
<a name="ln2873">    return;</a>
<a name="ln2874">  }</a>
<a name="ln2875"> </a>
<a name="ln2876">  if (VIsual_active) {</a>
<a name="ln2877">    // Use the Visually selected text as the bad word.  But reject</a>
<a name="ln2878">    // a multi-line selection.</a>
<a name="ln2879">    if (curwin-&gt;w_cursor.lnum != VIsual.lnum) {</a>
<a name="ln2880">      vim_beep(BO_SPELL);</a>
<a name="ln2881">      return;</a>
<a name="ln2882">    }</a>
<a name="ln2883">    badlen = (int)curwin-&gt;w_cursor.col - (int)VIsual.col;</a>
<a name="ln2884">    if (badlen &lt; 0) {</a>
<a name="ln2885">      badlen = -badlen;</a>
<a name="ln2886">    } else {</a>
<a name="ln2887">      curwin-&gt;w_cursor.col = VIsual.col;</a>
<a name="ln2888">    }</a>
<a name="ln2889">    badlen++;</a>
<a name="ln2890">    end_visual_mode();</a>
<a name="ln2891">  } else</a>
<a name="ln2892">  // Find the start of the badly spelled word.</a>
<a name="ln2893">  if (spell_move_to(curwin, FORWARD, true, true, NULL) == 0</a>
<a name="ln2894">      || curwin-&gt;w_cursor.col &gt; prev_cursor.col) {</a>
<a name="ln2895">    // No bad word or it starts after the cursor: use the word under the</a>
<a name="ln2896">    // cursor.</a>
<a name="ln2897">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln2898">    line = get_cursor_line_ptr();</a>
<a name="ln2899">    p = line + curwin-&gt;w_cursor.col;</a>
<a name="ln2900">    // Backup to before start of word.</a>
<a name="ln2901">    while (p &gt; line &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2902">      MB_PTR_BACK(line, p);</a>
<a name="ln2903">    }</a>
<a name="ln2904">    // Forward to start of word.</a>
<a name="ln2905">    while (*p != NUL &amp;&amp; !spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln2906">      MB_PTR_ADV(p);</a>
<a name="ln2907">    }</a>
<a name="ln2908"> </a>
<a name="ln2909">    if (!spell_iswordp_nmw(p, curwin)) {                // No word found.</a>
<a name="ln2910">      beep_flush();</a>
<a name="ln2911">      return;</a>
<a name="ln2912">    }</a>
<a name="ln2913">    curwin-&gt;w_cursor.col = (colnr_T)(p - line);</a>
<a name="ln2914">  }</a>
<a name="ln2915"> </a>
<a name="ln2916">  // Get the word and its length.</a>
<a name="ln2917"> </a>
<a name="ln2918">  // Figure out if the word should be capitalised.</a>
<a name="ln2919">  need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln2920"> </a>
<a name="ln2921">  // Make a copy of current line since autocommands may free the line.</a>
<a name="ln2922">  line = vim_strsave(get_cursor_line_ptr());</a>
<a name="ln2923"> </a>
<a name="ln2924">  // Get the list of suggestions.  Limit to 'lines' - 2 or the number in</a>
<a name="ln2925">  // 'spellsuggest', whatever is smaller.</a>
<a name="ln2926">  if (sps_limit &gt; Rows - 2) {</a>
<a name="ln2927">    limit = Rows - 2;</a>
<a name="ln2928">  } else {</a>
<a name="ln2929">    limit = sps_limit;</a>
<a name="ln2930">  }</a>
<a name="ln2931">  spell_find_suggest(line + curwin-&gt;w_cursor.col, badlen, &amp;sug, limit,</a>
<a name="ln2932">                     true, need_cap, true);</a>
<a name="ln2933"> </a>
<a name="ln2934">  if (GA_EMPTY(&amp;sug.su_ga)) {</a>
<a name="ln2935">    msg(_(&quot;Sorry, no suggestions&quot;));</a>
<a name="ln2936">  } else if (count &gt; 0) {</a>
<a name="ln2937">    if (count &gt; sug.su_ga.ga_len) {</a>
<a name="ln2938">      smsg(_(&quot;Sorry, only %&quot; PRId64 &quot; suggestions&quot;),</a>
<a name="ln2939">           (int64_t)sug.su_ga.ga_len);</a>
<a name="ln2940">    }</a>
<a name="ln2941">  } else {</a>
<a name="ln2942">    // When 'rightleft' is set the list is drawn right-left.</a>
<a name="ln2943">    cmdmsg_rl = curwin-&gt;w_p_rl;</a>
<a name="ln2944">    if (cmdmsg_rl) {</a>
<a name="ln2945">      msg_col = Columns - 1;</a>
<a name="ln2946">    }</a>
<a name="ln2947"> </a>
<a name="ln2948">    // List the suggestions.</a>
<a name="ln2949">    msg_start();</a>
<a name="ln2950">    msg_row = Rows - 1;         // for when 'cmdheight' &gt; 1</a>
<a name="ln2951">    lines_left = Rows;          // avoid more prompt</a>
<a name="ln2952">    vim_snprintf((char *)IObuff, IOSIZE, _(&quot;Change \&quot;%.*s\&quot; to:&quot;),</a>
<a name="ln2953">                 sug.su_badlen, sug.su_badptr);</a>
<a name="ln2954">    if (cmdmsg_rl &amp;&amp; STRNCMP(IObuff, &quot;Change&quot;, 6) == 0) {</a>
<a name="ln2955">      // And now the rabbit from the high hat: Avoid showing the</a>
<a name="ln2956">      // untranslated message rightleft.</a>
<a name="ln2957">      vim_snprintf((char *)IObuff, IOSIZE, &quot;:ot \&quot;%.*s\&quot; egnahC&quot;,</a>
<a name="ln2958">                   sug.su_badlen, sug.su_badptr);</a>
<a name="ln2959">    }</a>
<a name="ln2960">    msg_puts((const char *)IObuff);</a>
<a name="ln2961">    msg_clr_eos();</a>
<a name="ln2962">    msg_putchar('\n');</a>
<a name="ln2963"> </a>
<a name="ln2964">    msg_scroll = TRUE;</a>
<a name="ln2965">    for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln2966">      stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln2967"> </a>
<a name="ln2968">      // The suggested word may replace only part of the bad word, add</a>
<a name="ln2969">      // the not replaced part.</a>
<a name="ln2970">      STRLCPY(wcopy, stp-&gt;st_word, MAXWLEN + 1);</a>
<a name="ln2971">      if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln2972">        STRLCPY(wcopy + stp-&gt;st_wordlen,</a>
<a name="ln2973">                sug.su_badptr + stp-&gt;st_orglen,</a>
<a name="ln2974">                sug.su_badlen - stp-&gt;st_orglen + 1);</a>
<a name="ln2975">      }</a>
<a name="ln2976">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%2d&quot;, i + 1);</a>
<a name="ln2977">      if (cmdmsg_rl) {</a>
<a name="ln2978">        rl_mirror(IObuff);</a>
<a name="ln2979">      }</a>
<a name="ln2980">      msg_puts((const char *)IObuff);</a>
<a name="ln2981"> </a>
<a name="ln2982">      vim_snprintf((char *)IObuff, IOSIZE, &quot; \&quot;%s\&quot;&quot;, wcopy);</a>
<a name="ln2983">      msg_puts((const char *)IObuff);</a>
<a name="ln2984"> </a>
<a name="ln2985">      // The word may replace more than &quot;su_badlen&quot;.</a>
<a name="ln2986">      if (sug.su_badlen &lt; stp-&gt;st_orglen) {</a>
<a name="ln2987">        vim_snprintf((char *)IObuff, IOSIZE, _(&quot; &lt; \&quot;%.*s\&quot;&quot;),</a>
<a name="ln2988">                     stp-&gt;st_orglen, sug.su_badptr);</a>
<a name="ln2989">        msg_puts((const char *)IObuff);</a>
<a name="ln2990">      }</a>
<a name="ln2991"> </a>
<a name="ln2992">      if (p_verbose &gt; 0) {</a>
<a name="ln2993">        // Add the score.</a>
<a name="ln2994">        if (sps_flags &amp; (SPS_DOUBLE | SPS_BEST)) {</a>
<a name="ln2995">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%s%d - %d)&quot;,</a>
<a name="ln2996">                       stp-&gt;st_salscore ? &quot;s &quot; : &quot;&quot;,</a>
<a name="ln2997">                       stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln2998">        } else {</a>
<a name="ln2999">          vim_snprintf((char *)IObuff, IOSIZE, &quot; (%d)&quot;,</a>
<a name="ln3000">                       stp-&gt;st_score);</a>
<a name="ln3001">        }</a>
<a name="ln3002">        if (cmdmsg_rl) {</a>
<a name="ln3003">          // Mirror the numbers, but keep the leading space.</a>
<a name="ln3004">          rl_mirror(IObuff + 1);</a>
<a name="ln3005">        }</a>
<a name="ln3006">        msg_advance(30);</a>
<a name="ln3007">        msg_puts((const char *)IObuff);</a>
<a name="ln3008">      }</a>
<a name="ln3009">      msg_putchar('\n');</a>
<a name="ln3010">    }</a>
<a name="ln3011"> </a>
<a name="ln3012">    cmdmsg_rl = FALSE;</a>
<a name="ln3013">    msg_col = 0;</a>
<a name="ln3014">    // Ask for choice.</a>
<a name="ln3015">    selected = prompt_for_number(&amp;mouse_used);</a>
<a name="ln3016"> </a>
<a name="ln3017">    if (ui_has(kUIMessages)) {</a>
<a name="ln3018">      ui_call_msg_clear();</a>
<a name="ln3019">    }</a>
<a name="ln3020"> </a>
<a name="ln3021">    if (mouse_used) {</a>
<a name="ln3022">      selected -= lines_left;</a>
<a name="ln3023">    }</a>
<a name="ln3024">    lines_left = Rows;                  // avoid more prompt</a>
<a name="ln3025">    // don't delay for 'smd' in normal_cmd()</a>
<a name="ln3026">    msg_scroll = msg_scroll_save;</a>
<a name="ln3027">  }</a>
<a name="ln3028"> </a>
<a name="ln3029">  if (selected &gt; 0 &amp;&amp; selected &lt;= sug.su_ga.ga_len &amp;&amp; u_save_cursor() == OK) {</a>
<a name="ln3030">    // Save the from and to text for :spellrepall.</a>
<a name="ln3031">    XFREE_CLEAR(repl_from);</a>
<a name="ln3032">    XFREE_CLEAR(repl_to);</a>
<a name="ln3033"> </a>
<a name="ln3034">    stp = &amp;SUG(sug.su_ga, selected - 1);</a>
<a name="ln3035">    if (sug.su_badlen &gt; stp-&gt;st_orglen) {</a>
<a name="ln3036">      // Replacing less than &quot;su_badlen&quot;, append the remainder to</a>
<a name="ln3037">      // repl_to.</a>
<a name="ln3038">      repl_from = vim_strnsave(sug.su_badptr, sug.su_badlen);</a>
<a name="ln3039">      vim_snprintf((char *)IObuff, IOSIZE, &quot;%s%.*s&quot;, stp-&gt;st_word,</a>
<a name="ln3040">                   sug.su_badlen - stp-&gt;st_orglen,</a>
<a name="ln3041">                   sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3042">      repl_to = vim_strsave(IObuff);</a>
<a name="ln3043">    } else {</a>
<a name="ln3044">      // Replacing su_badlen or more, use the whole word.</a>
<a name="ln3045">      repl_from = vim_strnsave(sug.su_badptr, stp-&gt;st_orglen);</a>
<a name="ln3046">      repl_to = vim_strsave(stp-&gt;st_word);</a>
<a name="ln3047">    }</a>
<a name="ln3048"> </a>
<a name="ln3049">    // Replace the word.</a>
<a name="ln3050">    p = xmalloc(STRLEN(line) - stp-&gt;st_orglen + stp-&gt;st_wordlen + 1);</a>
<a name="ln3051">    c = (int)(sug.su_badptr - line);</a>
<a name="ln3052">    memmove(p, line, c);</a>
<a name="ln3053">    STRCPY(p + c, stp-&gt;st_word);</a>
<a name="ln3054">    STRCAT(p, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3055"> </a>
<a name="ln3056">    // For redo we use a change-word command.</a>
<a name="ln3057">    ResetRedobuff();</a>
<a name="ln3058">    AppendToRedobuff(&quot;ciw&quot;);</a>
<a name="ln3059">    AppendToRedobuffLit((char *)p + c,</a>
<a name="ln3060">                        stp-&gt;st_wordlen + sug.su_badlen - stp-&gt;st_orglen);</a>
<a name="ln3061">    AppendCharToRedobuff(ESC);</a>
<a name="ln3062"> </a>
<a name="ln3063">    // &quot;p&quot; may be freed here</a>
<a name="ln3064">    ml_replace(curwin-&gt;w_cursor.lnum, (char *)p, false);</a>
<a name="ln3065">    curwin-&gt;w_cursor.col = c;</a>
<a name="ln3066"> </a>
<a name="ln3067">    inserted_bytes(curwin-&gt;w_cursor.lnum, c, stp-&gt;st_orglen, stp-&gt;st_wordlen);</a>
<a name="ln3068">  } else {</a>
<a name="ln3069">    curwin-&gt;w_cursor = prev_cursor;</a>
<a name="ln3070">  }</a>
<a name="ln3071"> </a>
<a name="ln3072">  spell_find_cleanup(&amp;sug);</a>
<a name="ln3073">  xfree(line);</a>
<a name="ln3074">  curwin-&gt;w_p_spell = wo_spell_save;</a>
<a name="ln3075">}</a>
<a name="ln3076"> </a>
<a name="ln3077">// Check if the word at line &quot;lnum&quot; column &quot;col&quot; is required to start with a</a>
<a name="ln3078">// capital.  This uses 'spellcapcheck' of the current buffer.</a>
<a name="ln3079">static bool check_need_cap(linenr_T lnum, colnr_T col)</a>
<a name="ln3080">{</a>
<a name="ln3081">  bool need_cap = false;</a>
<a name="ln3082">  char_u *line;</a>
<a name="ln3083">  char_u *line_copy = NULL;</a>
<a name="ln3084">  char_u *p;</a>
<a name="ln3085">  colnr_T endcol;</a>
<a name="ln3086">  regmatch_T regmatch;</a>
<a name="ln3087"> </a>
<a name="ln3088">  if (curwin-&gt;w_s-&gt;b_cap_prog == NULL) {</a>
<a name="ln3089">    return false;</a>
<a name="ln3090">  }</a>
<a name="ln3091"> </a>
<a name="ln3092">  line = get_cursor_line_ptr();</a>
<a name="ln3093">  endcol = 0;</a>
<a name="ln3094">  if (getwhitecols(line) &gt;= (int)col) {</a>
<a name="ln3095">    // At start of line, check if previous line is empty or sentence</a>
<a name="ln3096">    // ends there.</a>
<a name="ln3097">    if (lnum == 1) {</a>
<a name="ln3098">      need_cap = true;</a>
<a name="ln3099">    } else {</a>
<a name="ln3100">      line = ml_get(lnum - 1);</a>
<a name="ln3101">      if (*skipwhite((char *)line) == NUL) {</a>
<a name="ln3102">        need_cap = true;</a>
<a name="ln3103">      } else {</a>
<a name="ln3104">        // Append a space in place of the line break.</a>
<a name="ln3105">        line_copy = concat_str(line, (char_u *)&quot; &quot;);</a>
<a name="ln3106">        line = line_copy;</a>
<a name="ln3107">        endcol = (colnr_T)STRLEN(line);</a>
<a name="ln3108">      }</a>
<a name="ln3109">    }</a>
<a name="ln3110">  } else {</a>
<a name="ln3111">    endcol = col;</a>
<a name="ln3112">  }</a>
<a name="ln3113"> </a>
<a name="ln3114">  if (endcol &gt; 0) {</a>
<a name="ln3115">    // Check if sentence ends before the bad word.</a>
<a name="ln3116">    regmatch.regprog = curwin-&gt;w_s-&gt;b_cap_prog;</a>
<a name="ln3117">    regmatch.rm_ic = FALSE;</a>
<a name="ln3118">    p = line + endcol;</a>
<a name="ln3119">    for (;;) {</a>
<a name="ln3120">      MB_PTR_BACK(line, p);</a>
<a name="ln3121">      if (p == line || spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln3122">        break;</a>
<a name="ln3123">      }</a>
<a name="ln3124">      if (vim_regexec(&amp;regmatch, p, 0)</a>
<a name="ln3125">          &amp;&amp; regmatch.endp[0] == line + endcol) {</a>
<a name="ln3126">        need_cap = true;</a>
<a name="ln3127">        break;</a>
<a name="ln3128">      }</a>
<a name="ln3129">    }</a>
<a name="ln3130">    curwin-&gt;w_s-&gt;b_cap_prog = regmatch.regprog;</a>
<a name="ln3131">  }</a>
<a name="ln3132"> </a>
<a name="ln3133">  xfree(line_copy);</a>
<a name="ln3134"> </a>
<a name="ln3135">  return need_cap;</a>
<a name="ln3136">}</a>
<a name="ln3137"> </a>
<a name="ln3138">// &quot;:spellrepall&quot;</a>
<a name="ln3139">void ex_spellrepall(exarg_T *eap)</a>
<a name="ln3140">{</a>
<a name="ln3141">  pos_T pos = curwin-&gt;w_cursor;</a>
<a name="ln3142">  char_u *frompat;</a>
<a name="ln3143">  int addlen;</a>
<a name="ln3144">  char_u *line;</a>
<a name="ln3145">  char_u *p;</a>
<a name="ln3146">  bool save_ws = p_ws;</a>
<a name="ln3147">  linenr_T prev_lnum = 0;</a>
<a name="ln3148"> </a>
<a name="ln3149">  if (repl_from == NULL || repl_to == NULL) {</a>
<a name="ln3150">    emsg(_(&quot;E752: No previous spell replacement&quot;));</a>
<a name="ln3151">    return;</a>
<a name="ln3152">  }</a>
<a name="ln3153">  addlen = (int)(STRLEN(repl_to) - STRLEN(repl_from));</a>
<a name="ln3154"> </a>
<a name="ln3155">  frompat = xmalloc(STRLEN(repl_from) + 7);</a>
<a name="ln3156">  sprintf((char *)frompat, &quot;\\V\\&lt;%s\\&gt;&quot;, repl_from);</a>
<a name="ln3157">  p_ws = false;</a>
<a name="ln3158"> </a>
<a name="ln3159">  sub_nsubs = 0;</a>
<a name="ln3160">  sub_nlines = 0;</a>
<a name="ln3161">  curwin-&gt;w_cursor.lnum = 0;</a>
<a name="ln3162">  while (!got_int) {</a>
<a name="ln3163">    if (do_search(NULL, '/', '/', frompat, 1L, SEARCH_KEEP, NULL) == 0</a>
<a name="ln3164">        || u_save_cursor() == FAIL) {</a>
<a name="ln3165">      break;</a>
<a name="ln3166">    }</a>
<a name="ln3167"> </a>
<a name="ln3168">    // Only replace when the right word isn't there yet.  This happens</a>
<a name="ln3169">    // when changing &quot;etc&quot; to &quot;etc.&quot;.</a>
<a name="ln3170">    line = get_cursor_line_ptr();</a>
<a name="ln3171">    if (addlen &lt;= 0 || STRNCMP(line + curwin-&gt;w_cursor.col,</a>
<a name="ln3172">                               repl_to, STRLEN(repl_to)) != 0) {</a>
<a name="ln3173">      p = xmalloc(STRLEN(line) + addlen + 1);</a>
<a name="ln3174">      memmove(p, line, curwin-&gt;w_cursor.col);</a>
<a name="ln3175">      STRCPY(p + curwin-&gt;w_cursor.col, repl_to);</a>
<a name="ln3176">      STRCAT(p, line + curwin-&gt;w_cursor.col + STRLEN(repl_from));</a>
<a name="ln3177">      ml_replace(curwin-&gt;w_cursor.lnum, (char *)p, false);</a>
<a name="ln3178">      changed_bytes(curwin-&gt;w_cursor.lnum, curwin-&gt;w_cursor.col);</a>
<a name="ln3179"> </a>
<a name="ln3180">      if (curwin-&gt;w_cursor.lnum != prev_lnum) {</a>
<a name="ln3181">        ++sub_nlines;</a>
<a name="ln3182">        prev_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln3183">      }</a>
<a name="ln3184">      ++sub_nsubs;</a>
<a name="ln3185">    }</a>
<a name="ln3186">    curwin-&gt;w_cursor.col += (colnr_T)STRLEN(repl_to);</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189">  p_ws = save_ws;</a>
<a name="ln3190">  curwin-&gt;w_cursor = pos;</a>
<a name="ln3191">  xfree(frompat);</a>
<a name="ln3192"> </a>
<a name="ln3193">  if (sub_nsubs == 0) {</a>
<a name="ln3194">    semsg(_(&quot;E753: Not found: %s&quot;), repl_from);</a>
<a name="ln3195">  } else {</a>
<a name="ln3196">    do_sub_msg(false);</a>
<a name="ln3197">  }</a>
<a name="ln3198">}</a>
<a name="ln3199"> </a>
<a name="ln3200">/// Find spell suggestions for &quot;word&quot;.  Return them in the growarray &quot;*gap&quot; as</a>
<a name="ln3201">/// a list of allocated strings.</a>
<a name="ln3202">///</a>
<a name="ln3203">/// @param maxcount  maximum nr of suggestions</a>
<a name="ln3204">/// @param need_cap  'spellcapcheck' matched</a>
<a name="ln3205">void spell_suggest_list(garray_T *gap, char_u *word, int maxcount, bool need_cap, bool interactive)</a>
<a name="ln3206">{</a>
<a name="ln3207">  suginfo_T sug;</a>
<a name="ln3208">  suggest_T *stp;</a>
<a name="ln3209">  char_u *wcopy;</a>
<a name="ln3210"> </a>
<a name="ln3211">  spell_find_suggest(word, 0, &amp;sug, maxcount, false, need_cap, interactive);</a>
<a name="ln3212"> </a>
<a name="ln3213">  // Make room in &quot;gap&quot;.</a>
<a name="ln3214">  ga_init(gap, sizeof(char_u *), sug.su_ga.ga_len + 1);</a>
<a name="ln3215">  ga_grow(gap, sug.su_ga.ga_len);</a>
<a name="ln3216">  for (int i = 0; i &lt; sug.su_ga.ga_len; ++i) {</a>
<a name="ln3217">    stp = &amp;SUG(sug.su_ga, i);</a>
<a name="ln3218"> </a>
<a name="ln3219">    // The suggested word may replace only part of &quot;word&quot;, add the not</a>
<a name="ln3220">    // replaced part.</a>
<a name="ln3221">    wcopy = xmalloc(stp-&gt;st_wordlen</a>
<a name="ln3222">                    + STRLEN(sug.su_badptr + stp-&gt;st_orglen) + 1);</a>
<a name="ln3223">    STRCPY(wcopy, stp-&gt;st_word);</a>
<a name="ln3224">    STRCPY(wcopy + stp-&gt;st_wordlen, sug.su_badptr + stp-&gt;st_orglen);</a>
<a name="ln3225">    ((char_u **)gap-&gt;ga_data)[gap-&gt;ga_len++] = wcopy;</a>
<a name="ln3226">  }</a>
<a name="ln3227"> </a>
<a name="ln3228">  spell_find_cleanup(&amp;sug);</a>
<a name="ln3229">}</a>
<a name="ln3230"> </a>
<a name="ln3231">/// Find spell suggestions for the word at the start of &quot;badptr&quot;.</a>
<a name="ln3232">/// Return the suggestions in &quot;su-&gt;su_ga&quot;.</a>
<a name="ln3233">/// The maximum number of suggestions is &quot;maxcount&quot;.</a>
<a name="ln3234">/// Note: does use info for the current window.</a>
<a name="ln3235">/// This is based on the mechanisms of Aspell, but completely reimplemented.</a>
<a name="ln3236">///</a>
<a name="ln3237">/// @param badlen  length of bad word or 0 if unknown</a>
<a name="ln3238">/// @param banbadword  don't include badword in suggestions</a>
<a name="ln3239">/// @param need_cap  word should start with capital</a>
<a name="ln3240">static void spell_find_suggest(char_u *badptr, int badlen, suginfo_T *su, int maxcount,</a>
<a name="ln3241">                               bool banbadword, bool need_cap, bool interactive)</a>
<a name="ln3242">{</a>
<a name="ln3243">  hlf_T attr = HLF_COUNT;</a>
<a name="ln3244">  char_u buf[MAXPATHL];</a>
<a name="ln3245">  char_u *p;</a>
<a name="ln3246">  bool do_combine = false;</a>
<a name="ln3247">  char_u *sps_copy;</a>
<a name="ln3248">  static bool expr_busy = false;</a>
<a name="ln3249">  int c;</a>
<a name="ln3250">  langp_T *lp;</a>
<a name="ln3251">  bool did_intern = false;</a>
<a name="ln3252"> </a>
<a name="ln3253">  // Set the info in &quot;*su&quot;.</a>
<a name="ln3254">  memset(su, 0, sizeof(suginfo_T));</a>
<a name="ln3255">  ga_init(&amp;su-&gt;su_ga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3256">  ga_init(&amp;su-&gt;su_sga, (int)sizeof(suggest_T), 10);</a>
<a name="ln3257">  if (*badptr == NUL) {</a>
<a name="ln3258">    return;</a>
<a name="ln3259">  }</a>
<a name="ln3260">  hash_init(&amp;su-&gt;su_banned);</a>
<a name="ln3261"> </a>
<a name="ln3262">  su-&gt;su_badptr = badptr;</a>
<a name="ln3263">  if (badlen != 0) {</a>
<a name="ln3264">    su-&gt;su_badlen = badlen;</a>
<a name="ln3265">  } else {</a>
<a name="ln3266">    size_t tmplen = spell_check(curwin, su-&gt;su_badptr, &amp;attr, NULL, false);</a>
<a name="ln3267">    assert(tmplen &lt;= INT_MAX);</a>
<a name="ln3268">    su-&gt;su_badlen = (int)tmplen;</a>
<a name="ln3269">  }</a>
<a name="ln3270">  su-&gt;su_maxcount = maxcount;</a>
<a name="ln3271">  su-&gt;su_maxscore = SCORE_MAXINIT;</a>
<a name="ln3272"> </a>
<a name="ln3273">  if (su-&gt;su_badlen &gt;= MAXWLEN) {</a>
<a name="ln3274">    su-&gt;su_badlen = MAXWLEN - 1;        // just in case</a>
<a name="ln3275">  }</a>
<a name="ln3276">  STRLCPY(su-&gt;su_badword, su-&gt;su_badptr, su-&gt;su_badlen + 1);</a>
<a name="ln3277">  (void)spell_casefold(curwin, su-&gt;su_badptr, su-&gt;su_badlen, su-&gt;su_fbadword,</a>
<a name="ln3278">                       MAXWLEN);</a>
<a name="ln3279"> </a>
<a name="ln3280">  // TODO(vim): make this work if the case-folded text is longer than the</a>
<a name="ln3281">  // original text. Currently an illegal byte causes wrong pointer</a>
<a name="ln3282">  // computations.</a>
<a name="ln3283">  su-&gt;su_fbadword[su-&gt;su_badlen] = NUL;</a>
<a name="ln3284"> </a>
<a name="ln3285">  // get caps flags for bad word</a>
<a name="ln3286">  su-&gt;su_badflags = badword_captype(su-&gt;su_badptr,</a>
<a name="ln3287">                                    su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3288">  if (need_cap) {</a>
<a name="ln3289">    su-&gt;su_badflags |= WF_ONECAP;</a>
<a name="ln3290">  }</a>
<a name="ln3291"> </a>
<a name="ln3292">  // Find the default language for sound folding.  We simply use the first</a>
<a name="ln3293">  // one in 'spelllang' that supports sound folding.  That's good for when</a>
<a name="ln3294">  // using multiple files for one language, it's not that bad when mixing</a>
<a name="ln3295">  // languages (e.g., &quot;pl,en&quot;).</a>
<a name="ln3296">  for (int i = 0; i &lt; curbuf-&gt;b_s.b_langp.ga_len; ++i) {</a>
<a name="ln3297">    lp = LANGP_ENTRY(curbuf-&gt;b_s.b_langp, i);</a>
<a name="ln3298">    if (lp-&gt;lp_sallang != NULL) {</a>
<a name="ln3299">      su-&gt;su_sallang = lp-&gt;lp_sallang;</a>
<a name="ln3300">      break;</a>
<a name="ln3301">    }</a>
<a name="ln3302">  }</a>
<a name="ln3303"> </a>
<a name="ln3304">  // Soundfold the bad word with the default sound folding, so that we don't</a>
<a name="ln3305">  // have to do this many times.</a>
<a name="ln3306">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln3307">    spell_soundfold(su-&gt;su_sallang, su-&gt;su_fbadword, true,</a>
<a name="ln3308">                    su-&gt;su_sal_badword);</a>
<a name="ln3309">  }</a>
<a name="ln3310"> </a>
<a name="ln3311">  // If the word is not capitalised and spell_check() doesn't consider the</a>
<a name="ln3312">  // word to be bad then it might need to be capitalised.  Add a suggestion</a>
<a name="ln3313">  // for that.</a>
<a name="ln3314">  c = utf_ptr2char((char *)su-&gt;su_badptr);</a>
<a name="ln3315">  if (!SPELL_ISUPPER(c) &amp;&amp; attr == HLF_COUNT) {</a>
<a name="ln3316">    make_case_word(su-&gt;su_badword, buf, WF_ONECAP);</a>
<a name="ln3317">    add_suggestion(su, &amp;su-&gt;su_ga, buf, su-&gt;su_badlen, SCORE_ICASE,</a>
<a name="ln3318">                   0, true, su-&gt;su_sallang, false);</a>
<a name="ln3319">  }</a>
<a name="ln3320"> </a>
<a name="ln3321">  // Ban the bad word itself.  It may appear in another region.</a>
<a name="ln3322">  if (banbadword) {</a>
<a name="ln3323">    add_banned(su, su-&gt;su_badword);</a>
<a name="ln3324">  }</a>
<a name="ln3325"> </a>
<a name="ln3326">  // Make a copy of 'spellsuggest', because the expression may change it.</a>
<a name="ln3327">  sps_copy = vim_strsave(p_sps);</a>
<a name="ln3328"> </a>
<a name="ln3329">  // Loop over the items in 'spellsuggest'.</a>
<a name="ln3330">  for (p = sps_copy; *p != NUL;) {</a>
<a name="ln3331">    copy_option_part(&amp;p, buf, MAXPATHL, &quot;,&quot;);</a>
<a name="ln3332"> </a>
<a name="ln3333">    if (STRNCMP(buf, &quot;expr:&quot;, 5) == 0) {</a>
<a name="ln3334">      // Evaluate an expression.  Skip this when called recursively,</a>
<a name="ln3335">      // when using spellsuggest() in the expression.</a>
<a name="ln3336">      if (!expr_busy) {</a>
<a name="ln3337">        expr_busy = true;</a>
<a name="ln3338">        spell_suggest_expr(su, buf + 5);</a>
<a name="ln3339">        expr_busy = false;</a>
<a name="ln3340">      }</a>
<a name="ln3341">    } else if (STRNCMP(buf, &quot;file:&quot;, 5) == 0) {</a>
<a name="ln3342">      // Use list of suggestions in a file.</a>
<a name="ln3343">      spell_suggest_file(su, buf + 5);</a>
<a name="ln3344">    } else if (!did_intern) {</a>
<a name="ln3345">      // Use internal method once.</a>
<a name="ln3346">      spell_suggest_intern(su, interactive);</a>
<a name="ln3347">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln3348">        do_combine = true;</a>
<a name="ln3349">      }</a>
<a name="ln3350">      did_intern = true;</a>
<a name="ln3351">    }</a>
<a name="ln3352">  }</a>
<a name="ln3353"> </a>
<a name="ln3354">  xfree(sps_copy);</a>
<a name="ln3355"> </a>
<a name="ln3356">  if (do_combine) {</a>
<a name="ln3357">    // Combine the two list of suggestions.  This must be done last,</a>
<a name="ln3358">    // because sorting changes the order again.</a>
<a name="ln3359">    score_combine(su);</a>
<a name="ln3360">  }</a>
<a name="ln3361">}</a>
<a name="ln3362"> </a>
<a name="ln3363">// Find suggestions by evaluating expression &quot;expr&quot;.</a>
<a name="ln3364">static void spell_suggest_expr(suginfo_T *su, char_u *expr)</a>
<a name="ln3365">{</a>
<a name="ln3366">  int score;</a>
<a name="ln3367">  const char *p;</a>
<a name="ln3368"> </a>
<a name="ln3369">  // The work is split up in a few parts to avoid having to export</a>
<a name="ln3370">  // suginfo_T.</a>
<a name="ln3371">  // First evaluate the expression and get the resulting list.</a>
<a name="ln3372">  list_T *const list = eval_spell_expr((char *)su-&gt;su_badword, (char *)expr);</a>
<a name="ln3373">  if (list != NULL) {</a>
<a name="ln3374">    // Loop over the items in the list.</a>
<a name="ln3375">    TV_LIST_ITER(list, li, {</a>
<a name="ln3376">      if (TV_LIST_ITEM_TV(li)-&gt;v_type == VAR_LIST) {</a>
<a name="ln3377">        // Get the word and the score from the items.</a>
<a name="ln3378">        score = get_spellword(TV_LIST_ITEM_TV(li)-&gt;vval.v_list, &amp;p);</a>
<a name="ln3379">        if (score &gt;= 0 &amp;&amp; score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3380">          add_suggestion(su, &amp;su-&gt;su_ga, (const char_u *)p, su-&gt;su_badlen,</a>
<a name="ln3381">                         score, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3382">        }</a>
<a name="ln3383">      }</a>
<a name="ln3384">    });</a>
<a name="ln3385">    tv_list_unref(list);</a>
<a name="ln3386">  }</a>
<a name="ln3387"> </a>
<a name="ln3388">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3389">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3390">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3391">}</a>
<a name="ln3392"> </a>
<a name="ln3393">// Find suggestions in file &quot;fname&quot;.  Used for &quot;file:&quot; in 'spellsuggest'.</a>
<a name="ln3394">static void spell_suggest_file(suginfo_T *su, char_u *fname)</a>
<a name="ln3395">{</a>
<a name="ln3396">  FILE *fd;</a>
<a name="ln3397">  char_u line[MAXWLEN * 2];</a>
<a name="ln3398">  char_u *p;</a>
<a name="ln3399">  int len;</a>
<a name="ln3400">  char_u cword[MAXWLEN];</a>
<a name="ln3401"> </a>
<a name="ln3402">  // Open the file.</a>
<a name="ln3403">  fd = os_fopen((char *)fname, &quot;r&quot;);</a>
<a name="ln3404">  if (fd == NULL) {</a>
<a name="ln3405">    semsg(_(e_notopen), fname);</a>
<a name="ln3406">    return;</a>
<a name="ln3407">  }</a>
<a name="ln3408"> </a>
<a name="ln3409">  // Read it line by line.</a>
<a name="ln3410">  while (!vim_fgets(line, MAXWLEN * 2, fd) &amp;&amp; !got_int) {</a>
<a name="ln3411">    line_breakcheck();</a>
<a name="ln3412"> </a>
<a name="ln3413">    p = (char_u *)vim_strchr((char *)line, '/');</a>
<a name="ln3414">    if (p == NULL) {</a>
<a name="ln3415">      continue;             // No Tab found, just skip the line.</a>
<a name="ln3416">    }</a>
<a name="ln3417">    *p++ = NUL;</a>
<a name="ln3418">    if (STRICMP(su-&gt;su_badword, line) == 0) {</a>
<a name="ln3419">      // Match!  Isolate the good word, until CR or NL.</a>
<a name="ln3420">      for (len = 0; p[len] &gt;= ' '; len++) {}</a>
<a name="ln3421">      p[len] = NUL;</a>
<a name="ln3422"> </a>
<a name="ln3423">      // If the suggestion doesn't have specific case duplicate the case</a>
<a name="ln3424">      // of the bad word.</a>
<a name="ln3425">      if (captype(p, NULL) == 0) {</a>
<a name="ln3426">        make_case_word(p, cword, su-&gt;su_badflags);</a>
<a name="ln3427">        p = cword;</a>
<a name="ln3428">      }</a>
<a name="ln3429"> </a>
<a name="ln3430">      add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln3431">                     SCORE_FILE, 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3432">    }</a>
<a name="ln3433">  }</a>
<a name="ln3434"> </a>
<a name="ln3435">  fclose(fd);</a>
<a name="ln3436"> </a>
<a name="ln3437">  // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3438">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3439">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3440">}</a>
<a name="ln3441"> </a>
<a name="ln3442">// Find suggestions for the internal method indicated by &quot;sps_flags&quot;.</a>
<a name="ln3443">static void spell_suggest_intern(suginfo_T *su, bool interactive)</a>
<a name="ln3444">{</a>
<a name="ln3445">  // Load the .sug file(s) that are available and not done yet.</a>
<a name="ln3446">  suggest_load_files();</a>
<a name="ln3447"> </a>
<a name="ln3448">  // 1. Try special cases, such as repeating a word: &quot;the the&quot; -&gt; &quot;the&quot;.</a>
<a name="ln3449">  //</a>
<a name="ln3450">  // Set a maximum score to limit the combination of operations that is</a>
<a name="ln3451">  // tried.</a>
<a name="ln3452">  suggest_try_special(su);</a>
<a name="ln3453"> </a>
<a name="ln3454">  // 2. Try inserting/deleting/swapping/changing a letter, use REP entries</a>
<a name="ln3455">  //    from the .aff file and inserting a space (split the word).</a>
<a name="ln3456">  suggest_try_change(su);</a>
<a name="ln3457"> </a>
<a name="ln3458">  // For the resulting top-scorers compute the sound-a-like score.</a>
<a name="ln3459">  if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln3460">    score_comp_sal(su);</a>
<a name="ln3461">  }</a>
<a name="ln3462"> </a>
<a name="ln3463">  // 3. Try finding sound-a-like words.</a>
<a name="ln3464">  if ((sps_flags &amp; SPS_FAST) == 0) {</a>
<a name="ln3465">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln3466">      // Adjust the word score for the suggestions found so far for how</a>
<a name="ln3467">      // they sounds like.</a>
<a name="ln3468">      rescore_suggestions(su);</a>
<a name="ln3469">    }</a>
<a name="ln3470"> </a>
<a name="ln3471">    // While going through the soundfold tree &quot;su_maxscore&quot; is the score</a>
<a name="ln3472">    // for the soundfold word, limits the changes that are being tried,</a>
<a name="ln3473">    // and &quot;su_sfmaxscore&quot; the rescored score, which is set by</a>
<a name="ln3474">    // cleanup_suggestions().</a>
<a name="ln3475">    // First find words with a small edit distance, because this is much</a>
<a name="ln3476">    // faster and often already finds the top-N suggestions.  If we didn't</a>
<a name="ln3477">    // find many suggestions try again with a higher edit distance.</a>
<a name="ln3478">    // &quot;sl_sounddone&quot; is used to avoid doing the same word twice.</a>
<a name="ln3479">    suggest_try_soundalike_prep();</a>
<a name="ln3480">    su-&gt;su_maxscore = SCORE_SFMAX1;</a>
<a name="ln3481">    su-&gt;su_sfmaxscore = SCORE_MAXINIT * 3;</a>
<a name="ln3482">    suggest_try_soundalike(su);</a>
<a name="ln3483">    if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3484">      // We didn't find enough matches, try again, allowing more</a>
<a name="ln3485">      // changes to the soundfold word.</a>
<a name="ln3486">      su-&gt;su_maxscore = SCORE_SFMAX2;</a>
<a name="ln3487">      suggest_try_soundalike(su);</a>
<a name="ln3488">      if (su-&gt;su_ga.ga_len &lt; SUG_CLEAN_COUNT(su)) {</a>
<a name="ln3489">        // Still didn't find enough matches, try again, allowing even</a>
<a name="ln3490">        // more changes to the soundfold word.</a>
<a name="ln3491">        su-&gt;su_maxscore = SCORE_SFMAX3;</a>
<a name="ln3492">        suggest_try_soundalike(su);</a>
<a name="ln3493">      }</a>
<a name="ln3494">    }</a>
<a name="ln3495">    su-&gt;su_maxscore = su-&gt;su_sfmaxscore;</a>
<a name="ln3496">    suggest_try_soundalike_finish();</a>
<a name="ln3497">  }</a>
<a name="ln3498"> </a>
<a name="ln3499">  // When CTRL-C was hit while searching do show the results.  Only clear</a>
<a name="ln3500">  // got_int when using a command, not for spellsuggest().</a>
<a name="ln3501">  os_breakcheck();</a>
<a name="ln3502">  if (interactive &amp;&amp; got_int) {</a>
<a name="ln3503">    (void)vgetc();</a>
<a name="ln3504">    got_int = FALSE;</a>
<a name="ln3505">  }</a>
<a name="ln3506"> </a>
<a name="ln3507">  if ((sps_flags &amp; SPS_DOUBLE) == 0 &amp;&amp; su-&gt;su_ga.ga_len != 0) {</a>
<a name="ln3508">    if (sps_flags &amp; SPS_BEST) {</a>
<a name="ln3509">      // Adjust the word score for how it sounds like.</a>
<a name="ln3510">      rescore_suggestions(su);</a>
<a name="ln3511">    }</a>
<a name="ln3512"> </a>
<a name="ln3513">    // Remove bogus suggestions, sort and truncate at &quot;maxcount&quot;.</a>
<a name="ln3514">    check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln3515">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln3516">  }</a>
<a name="ln3517">}</a>
<a name="ln3518"> </a>
<a name="ln3519">// Free the info put in &quot;*su&quot; by spell_find_suggest().</a>
<a name="ln3520">static void spell_find_cleanup(suginfo_T *su)</a>
<a name="ln3521">{</a>
<a name="ln3522">#define FREE_SUG_WORD(sug) xfree((sug)-&gt;st_word)</a>
<a name="ln3523">  // Free the suggestions.</a>
<a name="ln3524">  GA_DEEP_CLEAR(&amp;su-&gt;su_ga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3525">  GA_DEEP_CLEAR(&amp;su-&gt;su_sga, suggest_T, FREE_SUG_WORD);</a>
<a name="ln3526"> </a>
<a name="ln3527">  // Free the banned words.</a>
<a name="ln3528">  hash_clear_all(&amp;su-&gt;su_banned, 0);</a>
<a name="ln3529">}</a>
<a name="ln3530"> </a>
<a name="ln3531">/// Make a copy of &quot;word&quot;, with the first letter upper or lower cased, to</a>
<a name="ln3532">/// &quot;wcopy[MAXWLEN]&quot;.  &quot;word&quot; must not be empty.</a>
<a name="ln3533">/// The result is NUL terminated.</a>
<a name="ln3534">///</a>
<a name="ln3535">/// @param[in]  word  source string to copy</a>
<a name="ln3536">/// @param[in,out]  wcopy  copied string, with case of first letter changed</a>
<a name="ln3537">/// @param[in]  upper  True to upper case, otherwise lower case</a>
<a name="ln3538">void onecap_copy(char_u *word, char_u *wcopy, bool upper)</a>
<a name="ln3539">{</a>
<a name="ln3540">  char_u *p = word;</a>
<a name="ln3541">  int c = mb_cptr2char_adv((const char_u **)&amp;p);</a>
<a name="ln3542">  if (upper) {</a>
<a name="ln3543">    c = SPELL_TOUPPER(c);</a>
<a name="ln3544">  } else {</a>
<a name="ln3545">    c = SPELL_TOFOLD(c);</a>
<a name="ln3546">  }</a>
<a name="ln3547">  int l = utf_char2bytes(c, (char *)wcopy);</a>
<a name="ln3548">  STRLCPY(wcopy + l, p, MAXWLEN - l);</a>
<a name="ln3549">}</a>
<a name="ln3550"> </a>
<a name="ln3551">// Make a copy of &quot;word&quot; with all the letters upper cased into</a>
<a name="ln3552">// &quot;wcopy[MAXWLEN]&quot;.  The result is NUL terminated.</a>
<a name="ln3553">static void allcap_copy(char_u *word, char_u *wcopy)</a>
<a name="ln3554">{</a>
<a name="ln3555">  char_u *d = wcopy;</a>
<a name="ln3556">  for (char_u *s = word; *s != NUL;) {</a>
<a name="ln3557">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln3558"> </a>
<a name="ln3559">    if (c == 0xdf) {</a>
<a name="ln3560">      c = 'S';</a>
<a name="ln3561">      if (d - wcopy &gt;= MAXWLEN - 1) {</a>
<a name="ln3562">        break;</a>
<a name="ln3563">      }</a>
<a name="ln3564">      *d++ = c;</a>
<a name="ln3565">    } else {</a>
<a name="ln3566">      c = SPELL_TOUPPER(c);</a>
<a name="ln3567">    }</a>
<a name="ln3568"> </a>
<a name="ln3569">    if (d - wcopy &gt;= MAXWLEN - MB_MAXBYTES) {</a>
<a name="ln3570">      break;</a>
<a name="ln3571">    }</a>
<a name="ln3572">    d += utf_char2bytes(c, (char *)d);</a>
<a name="ln3573">  }</a>
<a name="ln3574">  *d = NUL;</a>
<a name="ln3575">}</a>
<a name="ln3576"> </a>
<a name="ln3577">// Try finding suggestions by recognizing specific situations.</a>
<a name="ln3578">static void suggest_try_special(suginfo_T *su)</a>
<a name="ln3579">{</a>
<a name="ln3580">  char_u *p;</a>
<a name="ln3581">  size_t len;</a>
<a name="ln3582">  int c;</a>
<a name="ln3583">  char_u word[MAXWLEN];</a>
<a name="ln3584"> </a>
<a name="ln3585">  // Recognize a word that is repeated: &quot;the the&quot;.</a>
<a name="ln3586">  p = skiptowhite(su-&gt;su_fbadword);</a>
<a name="ln3587">  len = p - su-&gt;su_fbadword;</a>
<a name="ln3588">  p = (char_u *)skipwhite((char *)p);</a>
<a name="ln3589">  if (STRLEN(p) == len &amp;&amp; STRNCMP(su-&gt;su_fbadword, p, len) == 0) {</a>
<a name="ln3590">    // Include badflags: if the badword is onecap or allcap</a>
<a name="ln3591">    // use that for the goodword too: &quot;The the&quot; -&gt; &quot;The&quot;.</a>
<a name="ln3592">    c = su-&gt;su_fbadword[len];</a>
<a name="ln3593">    su-&gt;su_fbadword[len] = NUL;</a>
<a name="ln3594">    make_case_word(su-&gt;su_fbadword, word, su-&gt;su_badflags);</a>
<a name="ln3595">    su-&gt;su_fbadword[len] = c;</a>
<a name="ln3596"> </a>
<a name="ln3597">    // Give a soundalike score of 0, compute the score as if deleting one</a>
<a name="ln3598">    // character.</a>
<a name="ln3599">    add_suggestion(su, &amp;su-&gt;su_ga, word, su-&gt;su_badlen,</a>
<a name="ln3600">                   RESCORE(SCORE_REP, 0), 0, true, su-&gt;su_sallang, false);</a>
<a name="ln3601">  }</a>
<a name="ln3602">}</a>
<a name="ln3603"> </a>
<a name="ln3604">// Measure how much time is spent in each state.</a>
<a name="ln3605">// Output is dumped in &quot;suggestprof&quot;.</a>
<a name="ln3606"> </a>
<a name="ln3607">#ifdef SUGGEST_PROFILE</a>
<a name="ln3608">proftime_T current;</a>
<a name="ln3609">proftime_T total;</a>
<a name="ln3610">proftime_T times[STATE_FINAL + 1];</a>
<a name="ln3611">long counts[STATE_FINAL + 1];</a>
<a name="ln3612"> </a>
<a name="ln3613">static void prof_init(void)</a>
<a name="ln3614">{</a>
<a name="ln3615">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3616">    profile_zero(&amp;times[i]);</a>
<a name="ln3617">    counts[i] = 0;</a>
<a name="ln3618">  }</a>
<a name="ln3619">  profile_start(&amp;current);</a>
<a name="ln3620">  profile_start(&amp;total);</a>
<a name="ln3621">}</a>
<a name="ln3622"> </a>
<a name="ln3623">// call before changing state</a>
<a name="ln3624">static void prof_store(state_T state)</a>
<a name="ln3625">{</a>
<a name="ln3626">  profile_end(&amp;current);</a>
<a name="ln3627">  profile_add(&amp;times[state], &amp;current);</a>
<a name="ln3628">  counts[state]++;</a>
<a name="ln3629">  profile_start(&amp;current);</a>
<a name="ln3630">}</a>
<a name="ln3631"># define PROF_STORE(state) prof_store(state);</a>
<a name="ln3632"> </a>
<a name="ln3633">static void prof_report(char *name)</a>
<a name="ln3634">{</a>
<a name="ln3635">  FILE *fd = fopen(&quot;suggestprof&quot;, &quot;a&quot;);</a>
<a name="ln3636"> </a>
<a name="ln3637">  profile_end(&amp;total);</a>
<a name="ln3638">  fprintf(fd, &quot;-----------------------\n&quot;);</a>
<a name="ln3639">  fprintf(fd, &quot;%s: %s\n&quot;, name, profile_msg(&amp;total));</a>
<a name="ln3640">  for (int i = 0; i &lt;= STATE_FINAL; i++) {</a>
<a name="ln3641">    fprintf(fd, &quot;%d: %s (&quot;%&quot; PRId64)\n&quot;, i, profile_msg(&amp;times[i]), counts[i]);</a>
<a name="ln3642">  }</a>
<a name="ln3643">  fclose(fd);</a>
<a name="ln3644">}</a>
<a name="ln3645">#else</a>
<a name="ln3646"># define PROF_STORE(state)</a>
<a name="ln3647">#endif</a>
<a name="ln3648"> </a>
<a name="ln3649">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3650"> </a>
<a name="ln3651">static void suggest_try_change(suginfo_T *su)</a>
<a name="ln3652">{</a>
<a name="ln3653">  char_u fword[MAXWLEN];            // copy of the bad word, case-folded</a>
<a name="ln3654">  int n;</a>
<a name="ln3655">  char_u *p;</a>
<a name="ln3656">  langp_T *lp;</a>
<a name="ln3657"> </a>
<a name="ln3658">  // We make a copy of the case-folded bad word, so that we can modify it</a>
<a name="ln3659">  // to find matches (esp. REP items).  Append some more text, changing</a>
<a name="ln3660">  // chars after the bad word may help.</a>
<a name="ln3661">  STRCPY(fword, su-&gt;su_fbadword);</a>
<a name="ln3662">  n = (int)STRLEN(fword);</a>
<a name="ln3663">  p = su-&gt;su_badptr + su-&gt;su_badlen;</a>
<a name="ln3664">  (void)spell_casefold(curwin, p, (int)STRLEN(p), fword + n, MAXWLEN - n);</a>
<a name="ln3665"> </a>
<a name="ln3666">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln3667">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln3668"> </a>
<a name="ln3669">    // If reloading a spell file fails it's still in the list but</a>
<a name="ln3670">    // everything has been cleared.</a>
<a name="ln3671">    if (lp-&gt;lp_slang-&gt;sl_fbyts == NULL) {</a>
<a name="ln3672">      continue;</a>
<a name="ln3673">    }</a>
<a name="ln3674"> </a>
<a name="ln3675">    // Try it for this language.  Will add possible suggestions.</a>
<a name="ln3676">    //</a>
<a name="ln3677">#ifdef SUGGEST_PROFILE</a>
<a name="ln3678">    prof_init();</a>
<a name="ln3679">#endif</a>
<a name="ln3680">    suggest_trie_walk(su, lp, fword, false);</a>
<a name="ln3681">#ifdef SUGGEST_PROFILE</a>
<a name="ln3682">    prof_report(&quot;try_change&quot;);</a>
<a name="ln3683">#endif</a>
<a name="ln3684">  }</a>
<a name="ln3685">}</a>
<a name="ln3686"> </a>
<a name="ln3687">// Check the maximum score, if we go over it we won't try this change.</a>
<a name="ln3688">#define TRY_DEEPER(su, stack, depth, add) \</a>
<a name="ln3689">  ((depth) &lt; MAXWLEN - 1 &amp;&amp; (stack)[depth].ts_score + (add) &lt; (su)-&gt;su_maxscore)</a>
<a name="ln3690"> </a>
<a name="ln3691">// Try finding suggestions by adding/removing/swapping letters.</a>
<a name="ln3692">//</a>
<a name="ln3693">// This uses a state machine.  At each node in the tree we try various</a>
<a name="ln3694">// operations.  When trying if an operation works &quot;depth&quot; is increased and the</a>
<a name="ln3695">// stack[] is used to store info.  This allows combinations, thus insert one</a>
<a name="ln3696">// character, replace one and delete another.  The number of changes is</a>
<a name="ln3697">// limited by su-&gt;su_maxscore.</a>
<a name="ln3698">//</a>
<a name="ln3699">// After implementing this I noticed an article by Kemal Oflazer that</a>
<a name="ln3700">// describes something similar: &quot;Error-tolerant Finite State Recognition with</a>
<a name="ln3701">// Applications to Morphological Analysis and Spelling Correction&quot; (1996).</a>
<a name="ln3702">// The implementation in the article is simplified and requires a stack of</a>
<a name="ln3703">// unknown depth.  The implementation here only needs a stack depth equal to</a>
<a name="ln3704">// the length of the word.</a>
<a name="ln3705">//</a>
<a name="ln3706">// This is also used for the sound-folded word, &quot;soundfold&quot; is true then.</a>
<a name="ln3707">// The mechanism is the same, but we find a match with a sound-folded word</a>
<a name="ln3708">// that comes from one or more original words.  Each of these words may be</a>
<a name="ln3709">// added, this is done by add_sound_suggest().</a>
<a name="ln3710">// Don't use:</a>
<a name="ln3711">//      the prefix tree or the keep-case tree</a>
<a name="ln3712">//      &quot;su-&gt;su_badlen&quot;</a>
<a name="ln3713">//      anything to do with upper and lower case</a>
<a name="ln3714">//      anything to do with word or non-word characters (&quot;spell_iswordp()&quot;)</a>
<a name="ln3715">//      banned words</a>
<a name="ln3716">//      word flags (rare, region, compounding)</a>
<a name="ln3717">//      word splitting for now</a>
<a name="ln3718">//      &quot;similar_chars()&quot;</a>
<a name="ln3719">//      use &quot;slang-&gt;sl_repsal&quot; instead of &quot;lp-&gt;lp_replang-&gt;sl_rep&quot;</a>
<a name="ln3720">static void suggest_trie_walk(suginfo_T *su, langp_T *lp, char_u *fword, bool soundfold)</a>
<a name="ln3721">{</a>
<a name="ln3722">  char_u tword[MAXWLEN];            // good word collected so far</a>
<a name="ln3723">  trystate_T stack[MAXWLEN];</a>
<a name="ln3724">  char_u preword[MAXWLEN * 3] = { 0 };  // word found with proper case;</a>
<a name="ln3725">  // concatenation of prefix compound</a>
<a name="ln3726">  // words and split word.  NUL terminated</a>
<a name="ln3727">  // when going deeper but not when coming</a>
<a name="ln3728">  // back.</a>
<a name="ln3729">  char_u compflags[MAXWLEN];        // compound flags, one for each word</a>
<a name="ln3730">  trystate_T *sp;</a>
<a name="ln3731">  int newscore;</a>
<a name="ln3732">  int score;</a>
<a name="ln3733">  char_u *byts, *fbyts, *pbyts;</a>
<a name="ln3734">  idx_T *idxs, *fidxs, *pidxs;</a>
<a name="ln3735">  int depth;</a>
<a name="ln3736">  int c, c2, c3;</a>
<a name="ln3737">  int n = 0;</a>
<a name="ln3738">  int flags;</a>
<a name="ln3739">  garray_T *gap;</a>
<a name="ln3740">  idx_T arridx;</a>
<a name="ln3741">  int len;</a>
<a name="ln3742">  char_u *p;</a>
<a name="ln3743">  fromto_T *ftp;</a>
<a name="ln3744">  int fl = 0, tl;</a>
<a name="ln3745">  int repextra = 0;                 // extra bytes in fword[] from REP item</a>
<a name="ln3746">  slang_T *slang = lp-&gt;lp_slang;</a>
<a name="ln3747">  int fword_ends;</a>
<a name="ln3748">  bool goodword_ends;</a>
<a name="ln3749">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3750">  // Stores the name of the change made at each level.</a>
<a name="ln3751">  char_u changename[MAXWLEN][80];</a>
<a name="ln3752">#endif</a>
<a name="ln3753">  int breakcheckcount = 1000;</a>
<a name="ln3754">  bool compound_ok;</a>
<a name="ln3755"> </a>
<a name="ln3756">  // Go through the whole case-fold tree, try changes at each node.</a>
<a name="ln3757">  // &quot;tword[]&quot; contains the word collected from nodes in the tree.</a>
<a name="ln3758">  // &quot;fword[]&quot; the word we are trying to match with (initially the bad</a>
<a name="ln3759">  // word).</a>
<a name="ln3760">  depth = 0;</a>
<a name="ln3761">  sp = &amp;stack[0];</a>
<a name="ln3762">  memset(sp, 0, sizeof(trystate_T));  // -V512</a>
<a name="ln3763">  sp-&gt;ts_curi = 1;</a>
<a name="ln3764"> </a>
<a name="ln3765">  if (soundfold) {</a>
<a name="ln3766">    // Going through the soundfold tree.</a>
<a name="ln3767">    byts = fbyts = slang-&gt;sl_sbyts;</a>
<a name="ln3768">    idxs = fidxs = slang-&gt;sl_sidxs;</a>
<a name="ln3769">    pbyts = NULL;</a>
<a name="ln3770">    pidxs = NULL;</a>
<a name="ln3771">    sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3772">    sp-&gt;ts_state = STATE_START;</a>
<a name="ln3773">  } else {</a>
<a name="ln3774">    // When there are postponed prefixes we need to use these first.  At</a>
<a name="ln3775">    // the end of the prefix we continue in the case-fold tree.</a>
<a name="ln3776">    fbyts = slang-&gt;sl_fbyts;</a>
<a name="ln3777">    fidxs = slang-&gt;sl_fidxs;</a>
<a name="ln3778">    pbyts = slang-&gt;sl_pbyts;</a>
<a name="ln3779">    pidxs = slang-&gt;sl_pidxs;</a>
<a name="ln3780">    if (pbyts != NULL) {</a>
<a name="ln3781">      byts = pbyts;</a>
<a name="ln3782">      idxs = pidxs;</a>
<a name="ln3783">      sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln3784">      sp-&gt;ts_state = STATE_NOPREFIX;            // try without prefix first</a>
<a name="ln3785">    } else {</a>
<a name="ln3786">      byts = fbyts;</a>
<a name="ln3787">      idxs = fidxs;</a>
<a name="ln3788">      sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln3789">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln3790">    }</a>
<a name="ln3791">  }</a>
<a name="ln3792"> </a>
<a name="ln3793">  // The loop may take an indefinite amount of time. Break out after five</a>
<a name="ln3794">  // sectonds. TODO(vim): add an option for the time limit.</a>
<a name="ln3795">  proftime_T time_limit = profile_setlimit(5000);</a>
<a name="ln3796"> </a>
<a name="ln3797">  // Loop to find all suggestions.  At each round we either:</a>
<a name="ln3798">  // - For the current state try one operation, advance &quot;ts_curi&quot;,</a>
<a name="ln3799">  //   increase &quot;depth&quot;.</a>
<a name="ln3800">  // - When a state is done go to the next, set &quot;ts_state&quot;.</a>
<a name="ln3801">  // - When all states are tried decrease &quot;depth&quot;.</a>
<a name="ln3802">  while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln3803">    sp = &amp;stack[depth];</a>
<a name="ln3804">    switch (sp-&gt;ts_state) {</a>
<a name="ln3805">    case STATE_START:</a>
<a name="ln3806">    case STATE_NOPREFIX:</a>
<a name="ln3807">      // Start of node: Deal with NUL bytes, which means</a>
<a name="ln3808">      // tword[] may end here.</a>
<a name="ln3809">      arridx = sp-&gt;ts_arridx;               // current node in the tree</a>
<a name="ln3810">      len = byts[arridx];                   // bytes in this node</a>
<a name="ln3811">      arridx += sp-&gt;ts_curi;                // index of current byte</a>
<a name="ln3812"> </a>
<a name="ln3813">      if (sp-&gt;ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln3814">        // Skip over the NUL bytes, we use them later.</a>
<a name="ln3815">        for (n = 0; n &lt; len &amp;&amp; byts[arridx + n] == 0; n++) {}</a>
<a name="ln3816">        sp-&gt;ts_curi += n;</a>
<a name="ln3817"> </a>
<a name="ln3818">        // Always past NUL bytes now.</a>
<a name="ln3819">        n = (int)sp-&gt;ts_state;</a>
<a name="ln3820">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3821">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3822">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3823"> </a>
<a name="ln3824">        // At end of a prefix or at start of prefixtree: check for</a>
<a name="ln3825">        // following word.</a>
<a name="ln3826">        if (depth &lt; MAXWLEN - 1 &amp;&amp; (byts[arridx] == 0 || n == STATE_NOPREFIX)) {</a>
<a name="ln3827">          // Set su-&gt;su_badflags to the caps type at this position.</a>
<a name="ln3828">          // Use the caps type until here for the prefix itself.</a>
<a name="ln3829">          n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln3830">          flags = badword_captype(su-&gt;su_badptr, su-&gt;su_badptr + n);</a>
<a name="ln3831">          su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln3832">                                            su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln3833">#ifdef DEBUG_TRIEWALK</a>
<a name="ln3834">          sprintf(changename[depth], &quot;prefix&quot;);</a>
<a name="ln3835">#endif</a>
<a name="ln3836">          go_deeper(stack, depth, 0);</a>
<a name="ln3837">          ++depth;</a>
<a name="ln3838">          sp = &amp;stack[depth];</a>
<a name="ln3839">          sp-&gt;ts_prefixdepth = depth - 1;</a>
<a name="ln3840">          byts = fbyts;</a>
<a name="ln3841">          idxs = fidxs;</a>
<a name="ln3842">          sp-&gt;ts_arridx = 0;</a>
<a name="ln3843"> </a>
<a name="ln3844">          // Move the prefix to preword[] with the right case</a>
<a name="ln3845">          // and make find_keepcap_word() works.</a>
<a name="ln3846">          tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3847">          make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln3848">                         preword + sp-&gt;ts_prewordlen, flags);</a>
<a name="ln3849">          sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln3850">          sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln3851">        }</a>
<a name="ln3852">        break;</a>
<a name="ln3853">      }</a>
<a name="ln3854"> </a>
<a name="ln3855">      if (sp-&gt;ts_curi &gt; len || byts[arridx] != 0) {</a>
<a name="ln3856">        // Past bytes in node and/or past NUL bytes.</a>
<a name="ln3857">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln3858">        sp-&gt;ts_state = STATE_ENDNUL;</a>
<a name="ln3859">        sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln3860">        break;</a>
<a name="ln3861">      }</a>
<a name="ln3862"> </a>
<a name="ln3863">      // End of word in tree.</a>
<a name="ln3864">      ++sp-&gt;ts_curi;                    // eat one NUL byte</a>
<a name="ln3865"> </a>
<a name="ln3866">      flags = (int)idxs[arridx];</a>
<a name="ln3867"> </a>
<a name="ln3868">      // Skip words with the NOSUGGEST flag.</a>
<a name="ln3869">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln3870">        break;</a>
<a name="ln3871">      }</a>
<a name="ln3872"> </a>
<a name="ln3873">      fword_ends = (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln3874">                    || (soundfold</a>
<a name="ln3875">                        ? ascii_iswhite(fword[sp-&gt;ts_fidx])</a>
<a name="ln3876">                        : !spell_iswordp(fword + sp-&gt;ts_fidx, curwin)));</a>
<a name="ln3877">      tword[sp-&gt;ts_twordlen] = NUL;</a>
<a name="ln3878"> </a>
<a name="ln3879">      if (sp-&gt;ts_prefixdepth &lt;= PFD_NOTSPECIAL</a>
<a name="ln3880">          &amp;&amp; (sp-&gt;ts_flags &amp; TSF_PREFIXOK) == 0</a>
<a name="ln3881">          &amp;&amp; pbyts != NULL) {</a>
<a name="ln3882">        // There was a prefix before the word.  Check that the prefix</a>
<a name="ln3883">        // can be used with this word.</a>
<a name="ln3884">        // Count the length of the NULs in the prefix.  If there are</a>
<a name="ln3885">        // none this must be the first try without a prefix.</a>
<a name="ln3886">        n = stack[sp-&gt;ts_prefixdepth].ts_arridx;</a>
<a name="ln3887">        len = pbyts[n++];</a>
<a name="ln3888">        for (c = 0; c &lt; len &amp;&amp; pbyts[n + c] == 0; c++) {}</a>
<a name="ln3889">        if (c &gt; 0) {</a>
<a name="ln3890">          c = valid_word_prefix(c, n, flags,</a>
<a name="ln3891">                                tword + sp-&gt;ts_splitoff, slang, false);</a>
<a name="ln3892">          if (c == 0) {</a>
<a name="ln3893">            break;</a>
<a name="ln3894">          }</a>
<a name="ln3895"> </a>
<a name="ln3896">          // Use the WF_RARE flag for a rare prefix.</a>
<a name="ln3897">          if (c &amp; WF_RAREPFX) {</a>
<a name="ln3898">            flags |= WF_RARE;</a>
<a name="ln3899">          }</a>
<a name="ln3900"> </a>
<a name="ln3901">          // Tricky: when checking for both prefix and compounding</a>
<a name="ln3902">          // we run into the prefix flag first.</a>
<a name="ln3903">          // Remember that it's OK, so that we accept the prefix</a>
<a name="ln3904">          // when arriving at a compound flag.</a>
<a name="ln3905">          sp-&gt;ts_flags |= TSF_PREFIXOK;</a>
<a name="ln3906">        }</a>
<a name="ln3907">      }</a>
<a name="ln3908"> </a>
<a name="ln3909">      // Check NEEDCOMPOUND: can't use word without compounding.  Do try</a>
<a name="ln3910">      // appending another compound word below.</a>
<a name="ln3911">      if (sp-&gt;ts_complen == sp-&gt;ts_compsplit &amp;&amp; fword_ends</a>
<a name="ln3912">          &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln3913">        goodword_ends = false;</a>
<a name="ln3914">      } else {</a>
<a name="ln3915">        goodword_ends = true;</a>
<a name="ln3916">      }</a>
<a name="ln3917"> </a>
<a name="ln3918">      p = NULL;</a>
<a name="ln3919">      compound_ok = true;</a>
<a name="ln3920">      if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit) {</a>
<a name="ln3921">        if (slang-&gt;sl_nobreak) {</a>
<a name="ln3922">          // There was a word before this word.  When there was no</a>
<a name="ln3923">          // change in this word (it was correct) add the first word</a>
<a name="ln3924">          // as a suggestion.  If this word was corrected too, we</a>
<a name="ln3925">          // need to check if a correct word follows.</a>
<a name="ln3926">          if (sp-&gt;ts_fidx - sp-&gt;ts_splitfidx</a>
<a name="ln3927">              == sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3928">              &amp;&amp; STRNCMP(fword + sp-&gt;ts_splitfidx,</a>
<a name="ln3929">                         tword + sp-&gt;ts_splitoff,</a>
<a name="ln3930">                         sp-&gt;ts_fidx - sp-&gt;ts_splitfidx) == 0) {</a>
<a name="ln3931">            preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln3932">            newscore = score_wordcount_adj(slang, sp-&gt;ts_score,</a>
<a name="ln3933">                                           preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3934">                                           sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln3935">            // Add the suggestion if the score isn't too bad.</a>
<a name="ln3936">            if (newscore &lt;= su-&gt;su_maxscore) {</a>
<a name="ln3937">              add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln3938">                             sp-&gt;ts_splitfidx - repextra,</a>
<a name="ln3939">                             newscore, 0, false,</a>
<a name="ln3940">                             lp-&gt;lp_sallang, false);</a>
<a name="ln3941">            }</a>
<a name="ln3942">            break;</a>
<a name="ln3943">          }</a>
<a name="ln3944">        } else {</a>
<a name="ln3945">          // There was a compound word before this word.  If this</a>
<a name="ln3946">          // word does not support compounding then give up</a>
<a name="ln3947">          // (splitting is tried for the word without compound</a>
<a name="ln3948">          // flag).</a>
<a name="ln3949">          if (((unsigned)flags &gt;&gt; 24) == 0</a>
<a name="ln3950">              || sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln3951">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3952">            break;</a>
<a name="ln3953">          }</a>
<a name="ln3954">          // For multi-byte chars check character length against</a>
<a name="ln3955">          // COMPOUNDMIN.</a>
<a name="ln3956">          if (slang-&gt;sl_compminlen &gt; 0</a>
<a name="ln3957">              &amp;&amp; mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln3958">              &lt; slang-&gt;sl_compminlen) {</a>
<a name="ln3959">            break;</a>
<a name="ln3960">          }</a>
<a name="ln3961"> </a>
<a name="ln3962">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln3963">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln3964">          STRLCPY(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln3965">                  tword + sp-&gt;ts_splitoff,</a>
<a name="ln3966">                  sp-&gt;ts_twordlen - sp-&gt;ts_splitoff + 1);</a>
<a name="ln3967"> </a>
<a name="ln3968">          // Verify CHECKCOMPOUNDPATTERN  rules.</a>
<a name="ln3969">          if (match_checkcompoundpattern(preword,  sp-&gt;ts_prewordlen,</a>
<a name="ln3970">                                         &amp;slang-&gt;sl_comppat)) {</a>
<a name="ln3971">            compound_ok = false;</a>
<a name="ln3972">          }</a>
<a name="ln3973"> </a>
<a name="ln3974">          if (compound_ok) {</a>
<a name="ln3975">            p = preword;</a>
<a name="ln3976">            while (*skiptowhite(p) != NUL) {</a>
<a name="ln3977">              p = (char_u *)skipwhite((char *)skiptowhite(p));</a>
<a name="ln3978">            }</a>
<a name="ln3979">            if (fword_ends &amp;&amp; !can_compound(slang, p,</a>
<a name="ln3980">                                            compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln3981">              // Compound is not allowed.  But it may still be</a>
<a name="ln3982">              // possible if we add another (short) word.</a>
<a name="ln3983">              compound_ok = false;</a>
<a name="ln3984">            }</a>
<a name="ln3985">          }</a>
<a name="ln3986"> </a>
<a name="ln3987">          // Get pointer to last char of previous word.</a>
<a name="ln3988">          p = preword + sp-&gt;ts_prewordlen;</a>
<a name="ln3989">          MB_PTR_BACK(preword, p);</a>
<a name="ln3990">        }</a>
<a name="ln3991">      }</a>
<a name="ln3992"> </a>
<a name="ln3993">      // Form the word with proper case in preword.</a>
<a name="ln3994">      // If there is a word from a previous split, append.</a>
<a name="ln3995">      // For the soundfold tree don't change the case, simply append.</a>
<a name="ln3996">      if (soundfold) {</a>
<a name="ln3997">        STRCPY(preword + sp-&gt;ts_prewordlen, tword + sp-&gt;ts_splitoff);</a>
<a name="ln3998">      } else if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln3999">        // Must find the word in the keep-case tree.</a>
<a name="ln4000">        find_keepcap_word(slang, tword + sp-&gt;ts_splitoff,</a>
<a name="ln4001">                          preword + sp-&gt;ts_prewordlen);</a>
<a name="ln4002">      } else {</a>
<a name="ln4003">        // Include badflags: If the badword is onecap or allcap</a>
<a name="ln4004">        // use that for the goodword too.  But if the badword is</a>
<a name="ln4005">        // allcap and it's only one char long use onecap.</a>
<a name="ln4006">        c = su-&gt;su_badflags;</a>
<a name="ln4007">        if ((c &amp; WF_ALLCAP)</a>
<a name="ln4008">            &amp;&amp; su-&gt;su_badlen ==</a>
<a name="ln4009">            utfc_ptr2len((char *)su-&gt;su_badptr)) {</a>
<a name="ln4010">          c = WF_ONECAP;</a>
<a name="ln4011">        }</a>
<a name="ln4012">        c |= flags;</a>
<a name="ln4013"> </a>
<a name="ln4014">        // When appending a compound word after a word character don't</a>
<a name="ln4015">        // use Onecap.</a>
<a name="ln4016">        if (p != NULL &amp;&amp; spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln4017">          c &amp;= ~WF_ONECAP;</a>
<a name="ln4018">        }</a>
<a name="ln4019">        make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln4020">                       preword + sp-&gt;ts_prewordlen, c);</a>
<a name="ln4021">      }</a>
<a name="ln4022"> </a>
<a name="ln4023">      if (!soundfold) {</a>
<a name="ln4024">        // Don't use a banned word.  It may appear again as a good</a>
<a name="ln4025">        // word, thus remember it.</a>
<a name="ln4026">        if (flags &amp; WF_BANNED) {</a>
<a name="ln4027">          add_banned(su, preword + sp-&gt;ts_prewordlen);</a>
<a name="ln4028">          break;</a>
<a name="ln4029">        }</a>
<a name="ln4030">        if ((sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln4031">             &amp;&amp; WAS_BANNED(su, preword + sp-&gt;ts_prewordlen))</a>
<a name="ln4032">            || WAS_BANNED(su, preword)) {</a>
<a name="ln4033">          if (slang-&gt;sl_compprog == NULL) {</a>
<a name="ln4034">            break;</a>
<a name="ln4035">          }</a>
<a name="ln4036">          // the word so far was banned but we may try compounding</a>
<a name="ln4037">          goodword_ends = false;</a>
<a name="ln4038">        }</a>
<a name="ln4039">      }</a>
<a name="ln4040"> </a>
<a name="ln4041">      newscore = 0;</a>
<a name="ln4042">      if (!soundfold) {         // soundfold words don't have flags</a>
<a name="ln4043">        if ((flags &amp; WF_REGION)</a>
<a name="ln4044">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0) {</a>
<a name="ln4045">          newscore += SCORE_REGION;</a>
<a name="ln4046">        }</a>
<a name="ln4047">        if (flags &amp; WF_RARE) {</a>
<a name="ln4048">          newscore += SCORE_RARE;</a>
<a name="ln4049">        }</a>
<a name="ln4050"> </a>
<a name="ln4051">        if (!spell_valid_case(su-&gt;su_badflags,</a>
<a name="ln4052">                              captype(preword + sp-&gt;ts_prewordlen, NULL))) {</a>
<a name="ln4053">          newscore += SCORE_ICASE;</a>
<a name="ln4054">        }</a>
<a name="ln4055">      }</a>
<a name="ln4056"> </a>
<a name="ln4057">      // TODO: how about splitting in the soundfold tree?</a>
<a name="ln4058">      if (fword_ends</a>
<a name="ln4059">          &amp;&amp; goodword_ends</a>
<a name="ln4060">          &amp;&amp; sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln4061">          &amp;&amp; compound_ok) {</a>
<a name="ln4062">        // The badword also ends: add suggestions.</a>
<a name="ln4063">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4064">        if (soundfold &amp;&amp; STRCMP(preword, &quot;smwrd&quot;) == 0) {</a>
<a name="ln4065">          int j;</a>
<a name="ln4066"> </a>
<a name="ln4067">          // print the stack of changes that brought us here</a>
<a name="ln4068">          smsg(&quot;------ %s -------&quot;, fword);</a>
<a name="ln4069">          for (j = 0; j &lt; depth; ++j) {</a>
<a name="ln4070">            smsg(&quot;%s&quot;, changename[j]);</a>
<a name="ln4071">          }</a>
<a name="ln4072">        }</a>
<a name="ln4073">#endif</a>
<a name="ln4074">        if (soundfold) {</a>
<a name="ln4075">          // For soundfolded words we need to find the original</a>
<a name="ln4076">          // words, the edit distance and then add them.</a>
<a name="ln4077">          add_sound_suggest(su, preword, sp-&gt;ts_score, lp);</a>
<a name="ln4078">        } else if (sp-&gt;ts_fidx &gt; 0) {</a>
<a name="ln4079">          // Give a penalty when changing non-word char to word</a>
<a name="ln4080">          // char, e.g., &quot;thes,&quot; -&gt; &quot;these&quot;.</a>
<a name="ln4081">          p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4082">          MB_PTR_BACK(fword, p);</a>
<a name="ln4083">          if (!spell_iswordp(p, curwin) &amp;&amp; *preword != NUL) {</a>
<a name="ln4084">            p = preword + STRLEN(preword);</a>
<a name="ln4085">            MB_PTR_BACK(preword, p);</a>
<a name="ln4086">            if (spell_iswordp(p, curwin)) {</a>
<a name="ln4087">              newscore += SCORE_NONWORD;</a>
<a name="ln4088">            }</a>
<a name="ln4089">          }</a>
<a name="ln4090"> </a>
<a name="ln4091">          // Give a bonus to words seen before.</a>
<a name="ln4092">          score = score_wordcount_adj(slang,</a>
<a name="ln4093">                                      sp-&gt;ts_score + newscore,</a>
<a name="ln4094">                                      preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4095">                                      sp-&gt;ts_prewordlen &gt; 0);</a>
<a name="ln4096"> </a>
<a name="ln4097">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln4098">          if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln4099">            add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln4100">                           sp-&gt;ts_fidx - repextra,</a>
<a name="ln4101">                           score, 0, false, lp-&gt;lp_sallang, false);</a>
<a name="ln4102"> </a>
<a name="ln4103">            if (su-&gt;su_badflags &amp; WF_MIXCAP) {</a>
<a name="ln4104">              // We really don't know if the word should be</a>
<a name="ln4105">              // upper or lower case, add both.</a>
<a name="ln4106">              c = captype(preword, NULL);</a>
<a name="ln4107">              if (c == 0 || c == WF_ALLCAP) {</a>
<a name="ln4108">                make_case_word(tword + sp-&gt;ts_splitoff,</a>
<a name="ln4109">                               preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4110">                               c == 0 ? WF_ALLCAP : 0);</a>
<a name="ln4111"> </a>
<a name="ln4112">                add_suggestion(su, &amp;su-&gt;su_ga, preword,</a>
<a name="ln4113">                               sp-&gt;ts_fidx - repextra,</a>
<a name="ln4114">                               score + SCORE_ICASE, 0, false,</a>
<a name="ln4115">                               lp-&gt;lp_sallang, false);</a>
<a name="ln4116">              }</a>
<a name="ln4117">            }</a>
<a name="ln4118">          }</a>
<a name="ln4119">        }</a>
<a name="ln4120">      }</a>
<a name="ln4121"> </a>
<a name="ln4122">      // Try word split and/or compounding.</a>
<a name="ln4123">      if ((sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry || fword_ends)</a>
<a name="ln4124">          // Don't split in the middle of a character</a>
<a name="ln4125">          &amp;&amp; (sp-&gt;ts_tcharlen == 0)) {</a>
<a name="ln4126">        bool try_compound;</a>
<a name="ln4127">        int try_split;</a>
<a name="ln4128"> </a>
<a name="ln4129">        // If past the end of the bad word don't try a split.</a>
<a name="ln4130">        // Otherwise try changing the next word.  E.g., find</a>
<a name="ln4131">        // suggestions for &quot;the the&quot; where the second &quot;the&quot; is</a>
<a name="ln4132">        // different.  It's done like a split.</a>
<a name="ln4133">        // TODO: word split for soundfold words</a>
<a name="ln4134">        try_split = (sp-&gt;ts_fidx - repextra &lt; su-&gt;su_badlen)</a>
<a name="ln4135">                    &amp;&amp; !soundfold;</a>
<a name="ln4136"> </a>
<a name="ln4137">        // Get here in several situations:</a>
<a name="ln4138">        // 1. The word in the tree ends:</a>
<a name="ln4139">        //    If the word allows compounding try that.  Otherwise try</a>
<a name="ln4140">        //    a split by inserting a space.  For both check that a</a>
<a name="ln4141">        //    valid words starts at fword[sp-&gt;ts_fidx].</a>
<a name="ln4142">        //    For NOBREAK do like compounding to be able to check if</a>
<a name="ln4143">        //    the next word is valid.</a>
<a name="ln4144">        // 2. The badword does end, but it was due to a change (e.g.,</a>
<a name="ln4145">        //    a swap).  No need to split, but do check that the</a>
<a name="ln4146">        //    following word is valid.</a>
<a name="ln4147">        // 3. The badword and the word in the tree end.  It may still</a>
<a name="ln4148">        //    be possible to compound another (short) word.</a>
<a name="ln4149">        try_compound = false;</a>
<a name="ln4150">        if (!soundfold</a>
<a name="ln4151">            &amp;&amp; !slang-&gt;sl_nocompoundsugs</a>
<a name="ln4152">            &amp;&amp; slang-&gt;sl_compprog != NULL</a>
<a name="ln4153">            &amp;&amp; ((unsigned)flags &gt;&gt; 24) != 0</a>
<a name="ln4154">            &amp;&amp; sp-&gt;ts_twordlen - sp-&gt;ts_splitoff</a>
<a name="ln4155">            &gt;= slang-&gt;sl_compminlen</a>
<a name="ln4156">            &amp;&amp; (slang-&gt;sl_compminlen == 0</a>
<a name="ln4157">                || mb_charlen(tword + sp-&gt;ts_splitoff)</a>
<a name="ln4158">                &gt;= slang-&gt;sl_compminlen)</a>
<a name="ln4159">            &amp;&amp; (slang-&gt;sl_compsylmax &lt; MAXWLEN</a>
<a name="ln4160">                || sp-&gt;ts_complen + 1 - sp-&gt;ts_compsplit</a>
<a name="ln4161">                &lt; slang-&gt;sl_compmax)</a>
<a name="ln4162">            &amp;&amp; (can_be_compound(sp, slang,</a>
<a name="ln4163">                                compflags, ((unsigned)flags &gt;&gt; 24)))) {</a>
<a name="ln4164">          try_compound = true;</a>
<a name="ln4165">          compflags[sp-&gt;ts_complen] = ((unsigned)flags &gt;&gt; 24);</a>
<a name="ln4166">          compflags[sp-&gt;ts_complen + 1] = NUL;</a>
<a name="ln4167">        }</a>
<a name="ln4168"> </a>
<a name="ln4169">        // For NOBREAK we never try splitting, it won't make any word</a>
<a name="ln4170">        // valid.</a>
<a name="ln4171">        if (slang-&gt;sl_nobreak &amp;&amp; !slang-&gt;sl_nocompoundsugs) {</a>
<a name="ln4172">          try_compound = true;</a>
<a name="ln4173">        } else if (!fword_ends</a>
<a name="ln4174">                   &amp;&amp; try_compound</a>
<a name="ln4175">                   &amp;&amp; (sp-&gt;ts_flags &amp; TSF_DIDSPLIT) == 0) {</a>
<a name="ln4176">          // If we could add a compound word, and it's also possible to</a>
<a name="ln4177">          // split at this point, do the split first and set</a>
<a name="ln4178">          // TSF_DIDSPLIT to avoid doing it again.</a>
<a name="ln4179">          try_compound = false;</a>
<a name="ln4180">          sp-&gt;ts_flags |= TSF_DIDSPLIT;</a>
<a name="ln4181">          --sp-&gt;ts_curi;                    // do the same NUL again</a>
<a name="ln4182">          compflags[sp-&gt;ts_complen] = NUL;</a>
<a name="ln4183">        } else {</a>
<a name="ln4184">          sp-&gt;ts_flags &amp;= ~TSF_DIDSPLIT;</a>
<a name="ln4185">        }</a>
<a name="ln4186"> </a>
<a name="ln4187">        if (try_split || try_compound) {</a>
<a name="ln4188">          if (!try_compound &amp;&amp; (!fword_ends || !goodword_ends)) {</a>
<a name="ln4189">            // If we're going to split need to check that the</a>
<a name="ln4190">            // words so far are valid for compounding.  If there</a>
<a name="ln4191">            // is only one word it must not have the NEEDCOMPOUND</a>
<a name="ln4192">            // flag.</a>
<a name="ln4193">            if (sp-&gt;ts_complen == sp-&gt;ts_compsplit</a>
<a name="ln4194">                &amp;&amp; (flags &amp; WF_NEEDCOMP)) {</a>
<a name="ln4195">              break;</a>
<a name="ln4196">            }</a>
<a name="ln4197">            p = preword;</a>
<a name="ln4198">            while (*skiptowhite(p) != NUL) {</a>
<a name="ln4199">              p = (char_u *)skipwhite((char *)skiptowhite(p));</a>
<a name="ln4200">            }</a>
<a name="ln4201">            if (sp-&gt;ts_complen &gt; sp-&gt;ts_compsplit</a>
<a name="ln4202">                &amp;&amp; !can_compound(slang, p,</a>
<a name="ln4203">                                 compflags + sp-&gt;ts_compsplit)) {</a>
<a name="ln4204">              break;</a>
<a name="ln4205">            }</a>
<a name="ln4206"> </a>
<a name="ln4207">            if (slang-&gt;sl_nosplitsugs) {</a>
<a name="ln4208">              newscore += SCORE_SPLIT_NO;</a>
<a name="ln4209">            } else {</a>
<a name="ln4210">              newscore += SCORE_SPLIT;</a>
<a name="ln4211">            }</a>
<a name="ln4212"> </a>
<a name="ln4213">            // Give a bonus to words seen before.</a>
<a name="ln4214">            newscore = score_wordcount_adj(slang, newscore,</a>
<a name="ln4215">                                           preword + sp-&gt;ts_prewordlen, true);</a>
<a name="ln4216">          }</a>
<a name="ln4217"> </a>
<a name="ln4218">          if (TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4219">            go_deeper(stack, depth, newscore);</a>
<a name="ln4220">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4221">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln4222">              sprintf(changename[depth], &quot;%.*s-%s: split&quot;,</a>
<a name="ln4223">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4224">            } else {</a>
<a name="ln4225">              sprintf(changename[depth], &quot;%.*s-%s: compound&quot;,</a>
<a name="ln4226">                      sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx);</a>
<a name="ln4227">            }</a>
<a name="ln4228">#endif</a>
<a name="ln4229">            // Save things to be restored at STATE_SPLITUNDO.</a>
<a name="ln4230">            sp-&gt;ts_save_badflags = su-&gt;su_badflags;</a>
<a name="ln4231">            PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4232">            sp-&gt;ts_state = STATE_SPLITUNDO;</a>
<a name="ln4233"> </a>
<a name="ln4234">            ++depth;</a>
<a name="ln4235">            sp = &amp;stack[depth];</a>
<a name="ln4236"> </a>
<a name="ln4237">            // Append a space to preword when splitting.</a>
<a name="ln4238">            if (!try_compound &amp;&amp; !fword_ends) {</a>
<a name="ln4239">              STRCAT(preword, &quot; &quot;);</a>
<a name="ln4240">            }</a>
<a name="ln4241">            sp-&gt;ts_prewordlen = (char_u)STRLEN(preword);</a>
<a name="ln4242">            sp-&gt;ts_splitoff = sp-&gt;ts_twordlen;</a>
<a name="ln4243">            sp-&gt;ts_splitfidx = sp-&gt;ts_fidx;</a>
<a name="ln4244"> </a>
<a name="ln4245">            // If the badword has a non-word character at this</a>
<a name="ln4246">            // position skip it.  That means replacing the</a>
<a name="ln4247">            // non-word character with a space.  Always skip a</a>
<a name="ln4248">            // character when the word ends.  But only when the</a>
<a name="ln4249">            // good word can end.</a>
<a name="ln4250">            if (((!try_compound &amp;&amp; !spell_iswordp_nmw(fword</a>
<a name="ln4251">                                                      + sp-&gt;ts_fidx,</a>
<a name="ln4252">                                                      curwin))</a>
<a name="ln4253">                 || fword_ends)</a>
<a name="ln4254">                &amp;&amp; fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4255">                &amp;&amp; goodword_ends) {</a>
<a name="ln4256">              int l;</a>
<a name="ln4257"> </a>
<a name="ln4258">              l = utfc_ptr2len((char *)fword + sp-&gt;ts_fidx);</a>
<a name="ln4259">              if (fword_ends) {</a>
<a name="ln4260">                // Copy the skipped character to preword.</a>
<a name="ln4261">                memmove(preword + sp-&gt;ts_prewordlen,</a>
<a name="ln4262">                        fword + sp-&gt;ts_fidx, l);</a>
<a name="ln4263">                sp-&gt;ts_prewordlen += l;</a>
<a name="ln4264">                preword[sp-&gt;ts_prewordlen] = NUL;</a>
<a name="ln4265">              } else {</a>
<a name="ln4266">                sp-&gt;ts_score -= SCORE_SPLIT - SCORE_SUBST;</a>
<a name="ln4267">              }</a>
<a name="ln4268">              sp-&gt;ts_fidx += l;</a>
<a name="ln4269">            }</a>
<a name="ln4270"> </a>
<a name="ln4271">            // When compounding include compound flag in</a>
<a name="ln4272">            // compflags[] (already set above).  When splitting we</a>
<a name="ln4273">            // may start compounding over again.</a>
<a name="ln4274">            if (try_compound) {</a>
<a name="ln4275">              ++sp-&gt;ts_complen;</a>
<a name="ln4276">            } else {</a>
<a name="ln4277">              sp-&gt;ts_compsplit = sp-&gt;ts_complen;</a>
<a name="ln4278">            }</a>
<a name="ln4279">            sp-&gt;ts_prefixdepth = PFD_NOPREFIX;</a>
<a name="ln4280"> </a>
<a name="ln4281">            // set su-&gt;su_badflags to the caps type at this</a>
<a name="ln4282">            // position</a>
<a name="ln4283">            n = nofold_len(fword, sp-&gt;ts_fidx, su-&gt;su_badptr);</a>
<a name="ln4284">            su-&gt;su_badflags = badword_captype(su-&gt;su_badptr + n,</a>
<a name="ln4285">                                              su-&gt;su_badptr + su-&gt;su_badlen);</a>
<a name="ln4286"> </a>
<a name="ln4287">            // Restart at top of the tree.</a>
<a name="ln4288">            sp-&gt;ts_arridx = 0;</a>
<a name="ln4289"> </a>
<a name="ln4290">            // If there are postponed prefixes, try these too.</a>
<a name="ln4291">            if (pbyts != NULL) {</a>
<a name="ln4292">              byts = pbyts;</a>
<a name="ln4293">              idxs = pidxs;</a>
<a name="ln4294">              sp-&gt;ts_prefixdepth = PFD_PREFIXTREE;</a>
<a name="ln4295">              PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4296">              sp-&gt;ts_state = STATE_NOPREFIX;</a>
<a name="ln4297">            }</a>
<a name="ln4298">          }</a>
<a name="ln4299">        }</a>
<a name="ln4300">      }</a>
<a name="ln4301">      break;</a>
<a name="ln4302"> </a>
<a name="ln4303">    case STATE_SPLITUNDO:</a>
<a name="ln4304">      // Undo the changes done for word split or compound word.</a>
<a name="ln4305">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4306"> </a>
<a name="ln4307">      // Continue looking for NUL bytes.</a>
<a name="ln4308">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4309">      sp-&gt;ts_state = STATE_START;</a>
<a name="ln4310"> </a>
<a name="ln4311">      // In case we went into the prefix tree.</a>
<a name="ln4312">      byts = fbyts;</a>
<a name="ln4313">      idxs = fidxs;</a>
<a name="ln4314">      break;</a>
<a name="ln4315"> </a>
<a name="ln4316">    case STATE_ENDNUL:</a>
<a name="ln4317">      // Past the NUL bytes in the node.</a>
<a name="ln4318">      su-&gt;su_badflags = sp-&gt;ts_save_badflags;</a>
<a name="ln4319">      if (fword[sp-&gt;ts_fidx] == NUL</a>
<a name="ln4320">          &amp;&amp; sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln4321">        // The badword ends, can't use STATE_PLAIN.</a>
<a name="ln4322">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4323">        sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4324">        break;</a>
<a name="ln4325">      }</a>
<a name="ln4326">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4327">      sp-&gt;ts_state = STATE_PLAIN;</a>
<a name="ln4328">      FALLTHROUGH;</a>
<a name="ln4329"> </a>
<a name="ln4330">    case STATE_PLAIN:</a>
<a name="ln4331">      // Go over all possible bytes at this node, add each to tword[]</a>
<a name="ln4332">      // and use child node.  &quot;ts_curi&quot; is the index.</a>
<a name="ln4333">      arridx = sp-&gt;ts_arridx;</a>
<a name="ln4334">      if (sp-&gt;ts_curi &gt; byts[arridx]) {</a>
<a name="ln4335">        // Done all bytes at this node, do next state.  When still at</a>
<a name="ln4336">        // already changed bytes skip the other tricks.</a>
<a name="ln4337">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4338">        if (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry) {</a>
<a name="ln4339">          sp-&gt;ts_state = STATE_DEL;</a>
<a name="ln4340">        } else {</a>
<a name="ln4341">          sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4342">        }</a>
<a name="ln4343">      } else {</a>
<a name="ln4344">        arridx += sp-&gt;ts_curi++;</a>
<a name="ln4345">        c = byts[arridx];</a>
<a name="ln4346"> </a>
<a name="ln4347">        // Normal byte, go one level deeper.  If it's not equal to the</a>
<a name="ln4348">        // byte in the bad word adjust the score.  But don't even try</a>
<a name="ln4349">        // when the byte was already changed.  And don't try when we</a>
<a name="ln4350">        // just deleted this byte, accepting it is always cheaper than</a>
<a name="ln4351">        // delete + substitute.</a>
<a name="ln4352">        if (c == fword[sp-&gt;ts_fidx]</a>
<a name="ln4353">            || (sp-&gt;ts_tcharlen &gt; 0</a>
<a name="ln4354">                &amp;&amp; sp-&gt;ts_isdiff != DIFF_NONE)) {</a>
<a name="ln4355">          newscore = 0;</a>
<a name="ln4356">        } else {</a>
<a name="ln4357">          newscore = SCORE_SUBST;</a>
<a name="ln4358">        }</a>
<a name="ln4359">        if ((newscore == 0</a>
<a name="ln4360">             || (sp-&gt;ts_fidx &gt;= sp-&gt;ts_fidxtry</a>
<a name="ln4361">                 &amp;&amp; ((sp-&gt;ts_flags &amp; TSF_DIDDEL) == 0</a>
<a name="ln4362">                     || c != fword[sp-&gt;ts_delidx])))</a>
<a name="ln4363">            &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4364">          go_deeper(stack, depth, newscore);</a>
<a name="ln4365">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4366">          if (newscore &gt; 0) {</a>
<a name="ln4367">            sprintf(changename[depth], &quot;%.*s-%s: subst %c to %c&quot;,</a>
<a name="ln4368">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4369">                    fword[sp-&gt;ts_fidx], c);</a>
<a name="ln4370">          } else {</a>
<a name="ln4371">            sprintf(changename[depth], &quot;%.*s-%s: accept %c&quot;,</a>
<a name="ln4372">                    sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4373">                    fword[sp-&gt;ts_fidx]);</a>
<a name="ln4374">          }</a>
<a name="ln4375">#endif</a>
<a name="ln4376">          ++depth;</a>
<a name="ln4377">          sp = &amp;stack[depth];</a>
<a name="ln4378">          ++sp-&gt;ts_fidx;</a>
<a name="ln4379">          tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4380">          sp-&gt;ts_arridx = idxs[arridx];</a>
<a name="ln4381">          if (newscore == SCORE_SUBST) {</a>
<a name="ln4382">            sp-&gt;ts_isdiff = DIFF_YES;</a>
<a name="ln4383">          }</a>
<a name="ln4384">          // Multi-byte characters are a bit complicated to</a>
<a name="ln4385">          // handle: They differ when any of the bytes differ</a>
<a name="ln4386">          // and then their length may also differ.</a>
<a name="ln4387">          if (sp-&gt;ts_tcharlen == 0) {</a>
<a name="ln4388">            // First byte.</a>
<a name="ln4389">            sp-&gt;ts_tcharidx = 0;</a>
<a name="ln4390">            sp-&gt;ts_tcharlen = MB_BYTE2LEN(c);</a>
<a name="ln4391">            sp-&gt;ts_fcharstart = sp-&gt;ts_fidx - 1;</a>
<a name="ln4392">            sp-&gt;ts_isdiff = (newscore != 0)</a>
<a name="ln4393">                            ? DIFF_YES : DIFF_NONE;</a>
<a name="ln4394">          } else if (sp-&gt;ts_isdiff == DIFF_INSERT) {</a>
<a name="ln4395">            // When inserting trail bytes don't advance in the</a>
<a name="ln4396">            // bad word.</a>
<a name="ln4397">            sp-&gt;ts_fidx--;</a>
<a name="ln4398">          }</a>
<a name="ln4399">          if (++sp-&gt;ts_tcharidx == sp-&gt;ts_tcharlen) {</a>
<a name="ln4400">            // Last byte of character.</a>
<a name="ln4401">            if (sp-&gt;ts_isdiff == DIFF_YES) {</a>
<a name="ln4402">              // Correct ts_fidx for the byte length of the</a>
<a name="ln4403">              // character (we didn't check that before).</a>
<a name="ln4404">              sp-&gt;ts_fidx = sp-&gt;ts_fcharstart</a>
<a name="ln4405">                            + utfc_ptr2len((char *)fword + sp-&gt;ts_fcharstart);</a>
<a name="ln4406"> </a>
<a name="ln4407">              // For changing a composing character adjust</a>
<a name="ln4408">              // the score from SCORE_SUBST to</a>
<a name="ln4409">              // SCORE_SUBCOMP.</a>
<a name="ln4410">              if (utf_iscomposing(utf_ptr2char((char *)tword + sp-&gt;ts_twordlen</a>
<a name="ln4411">                                               - sp-&gt;ts_tcharlen))</a>
<a name="ln4412">                  &amp;&amp; utf_iscomposing(utf_ptr2char((char *)fword</a>
<a name="ln4413">                                                  + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4414">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SUBCOMP;</a>
<a name="ln4415">              } else if (!soundfold</a>
<a name="ln4416">                         &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln4417">                         &amp;&amp; similar_chars(slang,</a>
<a name="ln4418">                                          utf_ptr2char((char *)tword + sp-&gt;ts_twordlen -</a>
<a name="ln4419">                                                       sp-&gt;ts_tcharlen),</a>
<a name="ln4420">                                          utf_ptr2char((char *)fword + sp-&gt;ts_fcharstart))) {</a>
<a name="ln4421">                // For a similar character adjust score from</a>
<a name="ln4422">                // SCORE_SUBST to SCORE_SIMILAR.</a>
<a name="ln4423">                sp-&gt;ts_score -= SCORE_SUBST - SCORE_SIMILAR;</a>
<a name="ln4424">              }</a>
<a name="ln4425">            } else if (sp-&gt;ts_isdiff == DIFF_INSERT</a>
<a name="ln4426">                       &amp;&amp; sp-&gt;ts_twordlen &gt; sp-&gt;ts_tcharlen) {</a>
<a name="ln4427">              p = tword + sp-&gt;ts_twordlen - sp-&gt;ts_tcharlen;</a>
<a name="ln4428">              c = utf_ptr2char((char *)p);</a>
<a name="ln4429">              if (utf_iscomposing(c)) {</a>
<a name="ln4430">                // Inserting a composing char doesn't</a>
<a name="ln4431">                // count that much.</a>
<a name="ln4432">                sp-&gt;ts_score -= SCORE_INS - SCORE_INSCOMP;</a>
<a name="ln4433">              } else {</a>
<a name="ln4434">                // If the previous character was the same,</a>
<a name="ln4435">                // thus doubling a character, give a bonus</a>
<a name="ln4436">                // to the score.  Also for the soundfold</a>
<a name="ln4437">                // tree (might seem illogical but does</a>
<a name="ln4438">                // give better scores).</a>
<a name="ln4439">                MB_PTR_BACK(tword, p);</a>
<a name="ln4440">                if (c == utf_ptr2char((char *)p)) {</a>
<a name="ln4441">                  sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4442">                }</a>
<a name="ln4443">              }</a>
<a name="ln4444">            }</a>
<a name="ln4445"> </a>
<a name="ln4446">            // Starting a new char, reset the length.</a>
<a name="ln4447">            sp-&gt;ts_tcharlen = 0;</a>
<a name="ln4448">          }</a>
<a name="ln4449">        }</a>
<a name="ln4450">      }</a>
<a name="ln4451">      break;</a>
<a name="ln4452"> </a>
<a name="ln4453">    case STATE_DEL:</a>
<a name="ln4454">      // When past the first byte of a multi-byte char don't try</a>
<a name="ln4455">      // delete/insert/swap a character.</a>
<a name="ln4456">      if (sp-&gt;ts_tcharlen &gt; 0) {</a>
<a name="ln4457">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4458">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4459">        break;</a>
<a name="ln4460">      }</a>
<a name="ln4461">      // Try skipping one character in the bad word (delete it).</a>
<a name="ln4462">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4463">      sp-&gt;ts_state = STATE_INS_PREP;</a>
<a name="ln4464">      sp-&gt;ts_curi = 1;</a>
<a name="ln4465">      if (soundfold &amp;&amp; sp-&gt;ts_fidx == 0 &amp;&amp; fword[sp-&gt;ts_fidx] == '*') {</a>
<a name="ln4466">        // Deleting a vowel at the start of a word counts less, see</a>
<a name="ln4467">        // soundalike_score().</a>
<a name="ln4468">        newscore = 2 * SCORE_DEL / 3;</a>
<a name="ln4469">      } else {</a>
<a name="ln4470">        newscore = SCORE_DEL;</a>
<a name="ln4471">      }</a>
<a name="ln4472">      if (fword[sp-&gt;ts_fidx] != NUL</a>
<a name="ln4473">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4474">        go_deeper(stack, depth, newscore);</a>
<a name="ln4475">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4476">        sprintf(changename[depth], &quot;%.*s-%s: delete %c&quot;,</a>
<a name="ln4477">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4478">                fword[sp-&gt;ts_fidx]);</a>
<a name="ln4479">#endif</a>
<a name="ln4480">        ++depth;</a>
<a name="ln4481"> </a>
<a name="ln4482">        // Remember what character we deleted, so that we can avoid</a>
<a name="ln4483">        // inserting it again.</a>
<a name="ln4484">        stack[depth].ts_flags |= TSF_DIDDEL;</a>
<a name="ln4485">        stack[depth].ts_delidx = sp-&gt;ts_fidx;</a>
<a name="ln4486"> </a>
<a name="ln4487">        // Advance over the character in fword[].  Give a bonus to the</a>
<a name="ln4488">        // score if the same character is following &quot;nn&quot; -&gt; &quot;n&quot;.  It's</a>
<a name="ln4489">        // a bit illogical for soundfold tree but it does give better</a>
<a name="ln4490">        // results.</a>
<a name="ln4491">        c = utf_ptr2char((char *)fword + sp-&gt;ts_fidx);</a>
<a name="ln4492">        stack[depth].ts_fidx += utfc_ptr2len((char *)fword + sp-&gt;ts_fidx);</a>
<a name="ln4493">        if (utf_iscomposing(c)) {</a>
<a name="ln4494">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELCOMP;</a>
<a name="ln4495">        } else if (c == utf_ptr2char((char *)fword + stack[depth].ts_fidx)) {</a>
<a name="ln4496">          stack[depth].ts_score -= SCORE_DEL - SCORE_DELDUP;</a>
<a name="ln4497">        }</a>
<a name="ln4498"> </a>
<a name="ln4499">        break;</a>
<a name="ln4500">      }</a>
<a name="ln4501">      FALLTHROUGH;</a>
<a name="ln4502"> </a>
<a name="ln4503">    case STATE_INS_PREP:</a>
<a name="ln4504">      if (sp-&gt;ts_flags &amp; TSF_DIDDEL) {</a>
<a name="ln4505">        // If we just deleted a byte then inserting won't make sense,</a>
<a name="ln4506">        // a substitute is always cheaper.</a>
<a name="ln4507">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4508">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4509">        break;</a>
<a name="ln4510">      }</a>
<a name="ln4511"> </a>
<a name="ln4512">      // skip over NUL bytes</a>
<a name="ln4513">      n = sp-&gt;ts_arridx;</a>
<a name="ln4514">      for (;;) {</a>
<a name="ln4515">        if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4516">          // Only NUL bytes at this node, go to next state.</a>
<a name="ln4517">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4518">          sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4519">          break;</a>
<a name="ln4520">        }</a>
<a name="ln4521">        if (byts[n + sp-&gt;ts_curi] != NUL) {</a>
<a name="ln4522">          // Found a byte to insert.</a>
<a name="ln4523">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4524">          sp-&gt;ts_state = STATE_INS;</a>
<a name="ln4525">          break;</a>
<a name="ln4526">        }</a>
<a name="ln4527">        ++sp-&gt;ts_curi;</a>
<a name="ln4528">      }</a>
<a name="ln4529">      break;</a>
<a name="ln4530"> </a>
<a name="ln4531">    case STATE_INS:</a>
<a name="ln4532">      // Insert one byte.  Repeat this for each possible byte at this</a>
<a name="ln4533">      // node.</a>
<a name="ln4534">      n = sp-&gt;ts_arridx;</a>
<a name="ln4535">      if (sp-&gt;ts_curi &gt; byts[n]) {</a>
<a name="ln4536">        // Done all bytes at this node, go to next state.</a>
<a name="ln4537">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4538">        sp-&gt;ts_state = STATE_SWAP;</a>
<a name="ln4539">        break;</a>
<a name="ln4540">      }</a>
<a name="ln4541"> </a>
<a name="ln4542">      // Do one more byte at this node, but:</a>
<a name="ln4543">      // - Skip NUL bytes.</a>
<a name="ln4544">      // - Skip the byte if it's equal to the byte in the word,</a>
<a name="ln4545">      //   accepting that byte is always better.</a>
<a name="ln4546">      n += sp-&gt;ts_curi++;</a>
<a name="ln4547">      c = byts[n];</a>
<a name="ln4548">      if (soundfold &amp;&amp; sp-&gt;ts_twordlen == 0 &amp;&amp; c == '*') {</a>
<a name="ln4549">        // Inserting a vowel at the start of a word counts less,</a>
<a name="ln4550">        // see soundalike_score().</a>
<a name="ln4551">        newscore = 2 * SCORE_INS / 3;</a>
<a name="ln4552">      } else {</a>
<a name="ln4553">        newscore = SCORE_INS;</a>
<a name="ln4554">      }</a>
<a name="ln4555">      if (c != fword[sp-&gt;ts_fidx]</a>
<a name="ln4556">          &amp;&amp; TRY_DEEPER(su, stack, depth, newscore)) {</a>
<a name="ln4557">        go_deeper(stack, depth, newscore);</a>
<a name="ln4558">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4559">        sprintf(changename[depth], &quot;%.*s-%s: insert %c&quot;,</a>
<a name="ln4560">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4561">                c);</a>
<a name="ln4562">#endif</a>
<a name="ln4563">        ++depth;</a>
<a name="ln4564">        sp = &amp;stack[depth];</a>
<a name="ln4565">        tword[sp-&gt;ts_twordlen++] = c;</a>
<a name="ln4566">        sp-&gt;ts_arridx = idxs[n];</a>
<a name="ln4567">        fl = MB_BYTE2LEN(c);</a>
<a name="ln4568">        if (fl &gt; 1) {</a>
<a name="ln4569">          // There are following bytes for the same character.</a>
<a name="ln4570">          // We must find all bytes before trying</a>
<a name="ln4571">          // delete/insert/swap/etc.</a>
<a name="ln4572">          sp-&gt;ts_tcharlen = fl;</a>
<a name="ln4573">          sp-&gt;ts_tcharidx = 1;</a>
<a name="ln4574">          sp-&gt;ts_isdiff = DIFF_INSERT;</a>
<a name="ln4575">        }</a>
<a name="ln4576">        if (fl == 1) {</a>
<a name="ln4577">          // If the previous character was the same, thus doubling a</a>
<a name="ln4578">          // character, give a bonus to the score.  Also for</a>
<a name="ln4579">          // soundfold words (illogical but does give a better</a>
<a name="ln4580">          // score).</a>
<a name="ln4581">          if (sp-&gt;ts_twordlen &gt;= 2</a>
<a name="ln4582">              &amp;&amp; tword[sp-&gt;ts_twordlen - 2] == c) {</a>
<a name="ln4583">            sp-&gt;ts_score -= SCORE_INS - SCORE_INSDUP;</a>
<a name="ln4584">          }</a>
<a name="ln4585">        }</a>
<a name="ln4586">      }</a>
<a name="ln4587">      break;</a>
<a name="ln4588"> </a>
<a name="ln4589">    case STATE_SWAP:</a>
<a name="ln4590">      // Swap two bytes in the bad word: &quot;12&quot; -&gt; &quot;21&quot;.</a>
<a name="ln4591">      // We change &quot;fword&quot; here, it's changed back afterwards at</a>
<a name="ln4592">      // STATE_UNSWAP.</a>
<a name="ln4593">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4594">      c = *p;</a>
<a name="ln4595">      if (c == NUL) {</a>
<a name="ln4596">        // End of word, can't swap or replace.</a>
<a name="ln4597">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4598">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4599">        break;</a>
<a name="ln4600">      }</a>
<a name="ln4601"> </a>
<a name="ln4602">      // Don't swap if the first character is not a word character.</a>
<a name="ln4603">      // SWAP3 etc. also don't make sense then.</a>
<a name="ln4604">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4605">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4606">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4607">        break;</a>
<a name="ln4608">      }</a>
<a name="ln4609"> </a>
<a name="ln4610">      n = utf_ptr2len((char *)p);</a>
<a name="ln4611">      c = utf_ptr2char((char *)p);</a>
<a name="ln4612">      if (p[n] == NUL) {</a>
<a name="ln4613">        c2 = NUL;</a>
<a name="ln4614">      } else if (!soundfold &amp;&amp; !spell_iswordp(p + n, curwin)) {</a>
<a name="ln4615">        c2 = c;  // don't swap non-word char</a>
<a name="ln4616">      } else {</a>
<a name="ln4617">        c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln4618">      }</a>
<a name="ln4619"> </a>
<a name="ln4620">      // When the second character is NUL we can't swap.</a>
<a name="ln4621">      if (c2 == NUL) {</a>
<a name="ln4622">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4623">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4624">        break;</a>
<a name="ln4625">      }</a>
<a name="ln4626"> </a>
<a name="ln4627">      // When characters are identical, swap won't do anything.</a>
<a name="ln4628">      // Also get here if the second char is not a word character.</a>
<a name="ln4629">      if (c == c2) {</a>
<a name="ln4630">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4631">        sp-&gt;ts_state = STATE_SWAP3;</a>
<a name="ln4632">        break;</a>
<a name="ln4633">      }</a>
<a name="ln4634">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP)) {</a>
<a name="ln4635">        go_deeper(stack, depth, SCORE_SWAP);</a>
<a name="ln4636">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4637">        snprintf(changename[depth], sizeof(changename[0]),</a>
<a name="ln4638">                 &quot;%.*s-%s: swap %c and %c&quot;,</a>
<a name="ln4639">                 sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4640">                 c, c2);</a>
<a name="ln4641">#endif</a>
<a name="ln4642">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4643">        sp-&gt;ts_state = STATE_UNSWAP;</a>
<a name="ln4644">        depth++;</a>
<a name="ln4645">        fl = utf_char2len(c2);</a>
<a name="ln4646">        memmove(p, p + n, fl);</a>
<a name="ln4647">        utf_char2bytes(c, (char *)p + fl);</a>
<a name="ln4648">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4649">      } else {</a>
<a name="ln4650">        // If this swap doesn't work then SWAP3 won't either.</a>
<a name="ln4651">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4652">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4653">      }</a>
<a name="ln4654">      break;</a>
<a name="ln4655"> </a>
<a name="ln4656">    case STATE_UNSWAP:</a>
<a name="ln4657">      // Undo the STATE_SWAP swap: &quot;21&quot; -&gt; &quot;12&quot;.</a>
<a name="ln4658">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4659">      n = utfc_ptr2len((char *)p);</a>
<a name="ln4660">      c = utf_ptr2char((char *)p + n);</a>
<a name="ln4661">      memmove(p + utfc_ptr2len((char *)p + n), p, n);</a>
<a name="ln4662">      utf_char2bytes(c, (char *)p);</a>
<a name="ln4663"> </a>
<a name="ln4664">      FALLTHROUGH;</a>
<a name="ln4665"> </a>
<a name="ln4666">    case STATE_SWAP3:</a>
<a name="ln4667">      // Swap two bytes, skipping one: &quot;123&quot; -&gt; &quot;321&quot;.  We change</a>
<a name="ln4668">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNSWAP3.</a>
<a name="ln4669">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4670">      n = utf_ptr2len((char *)p);</a>
<a name="ln4671">      c = utf_ptr2char((char *)p);</a>
<a name="ln4672">      fl = utf_ptr2len((char *)p + n);</a>
<a name="ln4673">      c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln4674">      if (!soundfold &amp;&amp; !spell_iswordp(p + n + fl, curwin)) {</a>
<a name="ln4675">        c3 = c;  // don't swap non-word char</a>
<a name="ln4676">      } else {</a>
<a name="ln4677">        c3 = utf_ptr2char((char *)p + n + fl);</a>
<a name="ln4678">      }</a>
<a name="ln4679"> </a>
<a name="ln4680">      // When characters are identical: &quot;121&quot; then SWAP3 result is</a>
<a name="ln4681">      // identical, ROT3L result is same as SWAP: &quot;211&quot;, ROT3L result is</a>
<a name="ln4682">      // same as SWAP on next char: &quot;112&quot;.  Thus skip all swapping.</a>
<a name="ln4683">      // Also skip when c3 is NUL.</a>
<a name="ln4684">      // Also get here when the third character is not a word character.</a>
<a name="ln4685">      // Second character may any char: &quot;a.b&quot; -&gt; &quot;b.a&quot;</a>
<a name="ln4686">      if (c == c3 || c3 == NUL) {</a>
<a name="ln4687">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4688">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4689">        break;</a>
<a name="ln4690">      }</a>
<a name="ln4691">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4692">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4693">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4694">        sprintf(changename[depth], &quot;%.*s-%s: swap3 %c and %c&quot;,</a>
<a name="ln4695">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4696">                c, c3);</a>
<a name="ln4697">#endif</a>
<a name="ln4698">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4699">        sp-&gt;ts_state = STATE_UNSWAP3;</a>
<a name="ln4700">        depth++;</a>
<a name="ln4701">        tl = utf_char2len(c3);</a>
<a name="ln4702">        memmove(p, p + n + fl, tl);</a>
<a name="ln4703">        utf_char2bytes(c2, (char *)p + tl);</a>
<a name="ln4704">        utf_char2bytes(c, (char *)p + fl + tl);</a>
<a name="ln4705">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl + tl;</a>
<a name="ln4706">      } else {</a>
<a name="ln4707">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4708">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4709">      }</a>
<a name="ln4710">      break;</a>
<a name="ln4711"> </a>
<a name="ln4712">    case STATE_UNSWAP3:</a>
<a name="ln4713">      // Undo STATE_SWAP3: &quot;321&quot; -&gt; &quot;123&quot;</a>
<a name="ln4714">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4715">      n = utfc_ptr2len((char *)p);</a>
<a name="ln4716">      c2 = utf_ptr2char((char *)p + n);</a>
<a name="ln4717">      fl = utfc_ptr2len((char *)p + n);</a>
<a name="ln4718">      c = utf_ptr2char((char *)p + n + fl);</a>
<a name="ln4719">      tl = utfc_ptr2len((char *)p + n + fl);</a>
<a name="ln4720">      memmove(p + fl + tl, p, n);</a>
<a name="ln4721">      utf_char2bytes(c, (char *)p);</a>
<a name="ln4722">      utf_char2bytes(c2, (char *)p + tl);</a>
<a name="ln4723">      p = p + tl;</a>
<a name="ln4724"> </a>
<a name="ln4725">      if (!soundfold &amp;&amp; !spell_iswordp(p, curwin)) {</a>
<a name="ln4726">        // Middle char is not a word char, skip the rotate.  First and</a>
<a name="ln4727">        // third char were already checked at swap and swap3.</a>
<a name="ln4728">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4729">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4730">        break;</a>
<a name="ln4731">      }</a>
<a name="ln4732"> </a>
<a name="ln4733">      // Rotate three characters left: &quot;123&quot; -&gt; &quot;231&quot;.  We change</a>
<a name="ln4734">      // &quot;fword&quot; here, it's changed back afterwards at STATE_UNROT3L.</a>
<a name="ln4735">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4736">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4737">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4738">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4739">        sprintf(changename[depth], &quot;%.*s-%s: rotate left %c%c%c&quot;,</a>
<a name="ln4740">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4741">                p[0], p[1], p[2]);</a>
<a name="ln4742">#endif</a>
<a name="ln4743">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4744">        sp-&gt;ts_state = STATE_UNROT3L;</a>
<a name="ln4745">        ++depth;</a>
<a name="ln4746">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4747">        n = utf_ptr2len((char *)p);</a>
<a name="ln4748">        c = utf_ptr2char((char *)p);</a>
<a name="ln4749">        fl = utf_ptr2len((char *)p + n);</a>
<a name="ln4750">        fl += utf_ptr2len((char *)p + n + fl);</a>
<a name="ln4751">        memmove(p, p + n, fl);</a>
<a name="ln4752">        utf_char2bytes(c, (char *)p + fl);</a>
<a name="ln4753">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + fl;</a>
<a name="ln4754">      } else {</a>
<a name="ln4755">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4756">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4757">      }</a>
<a name="ln4758">      break;</a>
<a name="ln4759"> </a>
<a name="ln4760">    case STATE_UNROT3L:</a>
<a name="ln4761">      // Undo ROT3L: &quot;231&quot; -&gt; &quot;123&quot;</a>
<a name="ln4762">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4763">      n = utfc_ptr2len((char *)p);</a>
<a name="ln4764">      n += utfc_ptr2len((char *)p + n);</a>
<a name="ln4765">      c = utf_ptr2char((char *)p + n);</a>
<a name="ln4766">      tl = utfc_ptr2len((char *)p + n);</a>
<a name="ln4767">      memmove(p + tl, p, n);</a>
<a name="ln4768">      utf_char2bytes(c, (char *)p);</a>
<a name="ln4769"> </a>
<a name="ln4770">      // Rotate three bytes right: &quot;123&quot; -&gt; &quot;312&quot;.  We change &quot;fword&quot;</a>
<a name="ln4771">      // here, it's changed back afterwards at STATE_UNROT3R.</a>
<a name="ln4772">      if (TRY_DEEPER(su, stack, depth, SCORE_SWAP3)) {</a>
<a name="ln4773">        go_deeper(stack, depth, SCORE_SWAP3);</a>
<a name="ln4774">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4775">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4776">        sprintf(changename[depth], &quot;%.*s-%s: rotate right %c%c%c&quot;,</a>
<a name="ln4777">                sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4778">                p[0], p[1], p[2]);</a>
<a name="ln4779">#endif</a>
<a name="ln4780">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4781">        sp-&gt;ts_state = STATE_UNROT3R;</a>
<a name="ln4782">        ++depth;</a>
<a name="ln4783">        p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4784">        n = utf_ptr2len((char *)p);</a>
<a name="ln4785">        n += utf_ptr2len((char *)p + n);</a>
<a name="ln4786">        c = utf_ptr2char((char *)p + n);</a>
<a name="ln4787">        tl = utf_ptr2len((char *)p + n);</a>
<a name="ln4788">        memmove(p + tl, p, n);</a>
<a name="ln4789">        utf_char2bytes(c, (char *)p);</a>
<a name="ln4790">        stack[depth].ts_fidxtry = sp-&gt;ts_fidx + n + tl;</a>
<a name="ln4791">      } else {</a>
<a name="ln4792">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4793">        sp-&gt;ts_state = STATE_REP_INI;</a>
<a name="ln4794">      }</a>
<a name="ln4795">      break;</a>
<a name="ln4796"> </a>
<a name="ln4797">    case STATE_UNROT3R:</a>
<a name="ln4798">      // Undo ROT3R: &quot;312&quot; -&gt; &quot;123&quot;</a>
<a name="ln4799">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4800">      c = utf_ptr2char((char *)p);</a>
<a name="ln4801">      tl = utfc_ptr2len((char *)p);</a>
<a name="ln4802">      n = utfc_ptr2len((char *)p + tl);</a>
<a name="ln4803">      n += utfc_ptr2len((char *)p + tl + n);</a>
<a name="ln4804">      memmove(p, p + tl, n);</a>
<a name="ln4805">      utf_char2bytes(c, (char *)p + n);</a>
<a name="ln4806"> </a>
<a name="ln4807">      FALLTHROUGH;</a>
<a name="ln4808"> </a>
<a name="ln4809">    case STATE_REP_INI:</a>
<a name="ln4810">      // Check if matching with REP items from the .aff file would work.</a>
<a name="ln4811">      // Quickly skip if:</a>
<a name="ln4812">      // - there are no REP items and we are not in the soundfold trie</a>
<a name="ln4813">      // - the score is going to be too high anyway</a>
<a name="ln4814">      // - already applied a REP item or swapped here</a>
<a name="ln4815">      if ((lp-&gt;lp_replang == NULL &amp;&amp; !soundfold)</a>
<a name="ln4816">          || sp-&gt;ts_score + SCORE_REP &gt;= su-&gt;su_maxscore</a>
<a name="ln4817">          || sp-&gt;ts_fidx &lt; sp-&gt;ts_fidxtry) {</a>
<a name="ln4818">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4819">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4820">        break;</a>
<a name="ln4821">      }</a>
<a name="ln4822"> </a>
<a name="ln4823">      // Use the first byte to quickly find the first entry that may</a>
<a name="ln4824">      // match.  If the index is -1 there is none.</a>
<a name="ln4825">      if (soundfold) {</a>
<a name="ln4826">        sp-&gt;ts_curi = slang-&gt;sl_repsal_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4827">      } else {</a>
<a name="ln4828">        sp-&gt;ts_curi = lp-&gt;lp_replang-&gt;sl_rep_first[fword[sp-&gt;ts_fidx]];</a>
<a name="ln4829">      }</a>
<a name="ln4830"> </a>
<a name="ln4831">      if (sp-&gt;ts_curi &lt; 0) {</a>
<a name="ln4832">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4833">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4834">        break;</a>
<a name="ln4835">      }</a>
<a name="ln4836"> </a>
<a name="ln4837">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4838">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4839">      FALLTHROUGH;</a>
<a name="ln4840"> </a>
<a name="ln4841">    case STATE_REP:</a>
<a name="ln4842">      // Try matching with REP items from the .aff file.  For each match</a>
<a name="ln4843">      // replace the characters and check if the resulting word is</a>
<a name="ln4844">      // valid.</a>
<a name="ln4845">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4846"> </a>
<a name="ln4847">      if (soundfold) {</a>
<a name="ln4848">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4849">      } else {</a>
<a name="ln4850">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4851">      }</a>
<a name="ln4852">      while (sp-&gt;ts_curi &lt; gap-&gt;ga_len) {</a>
<a name="ln4853">        ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi++;</a>
<a name="ln4854">        if (*ftp-&gt;ft_from != *p) {</a>
<a name="ln4855">          // past possible matching entries</a>
<a name="ln4856">          sp-&gt;ts_curi = gap-&gt;ga_len;</a>
<a name="ln4857">          break;</a>
<a name="ln4858">        }</a>
<a name="ln4859">        if (STRNCMP(ftp-&gt;ft_from, p, STRLEN(ftp-&gt;ft_from)) == 0</a>
<a name="ln4860">            &amp;&amp; TRY_DEEPER(su, stack, depth, SCORE_REP)) {</a>
<a name="ln4861">          go_deeper(stack, depth, SCORE_REP);</a>
<a name="ln4862">#ifdef DEBUG_TRIEWALK</a>
<a name="ln4863">          sprintf(changename[depth], &quot;%.*s-%s: replace %s with %s&quot;,</a>
<a name="ln4864">                  sp-&gt;ts_twordlen, tword, fword + sp-&gt;ts_fidx,</a>
<a name="ln4865">                  ftp-&gt;ft_from, ftp-&gt;ft_to);</a>
<a name="ln4866">#endif</a>
<a name="ln4867">          // Need to undo this afterwards.</a>
<a name="ln4868">          PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4869">          sp-&gt;ts_state = STATE_REP_UNDO;</a>
<a name="ln4870"> </a>
<a name="ln4871">          // Change the &quot;from&quot; to the &quot;to&quot; string.</a>
<a name="ln4872">          ++depth;</a>
<a name="ln4873">          fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4874">          tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4875">          if (fl != tl) {</a>
<a name="ln4876">            STRMOVE(p + tl, p + fl);</a>
<a name="ln4877">            repextra += tl - fl;</a>
<a name="ln4878">          }</a>
<a name="ln4879">          memmove(p, ftp-&gt;ft_to, tl);</a>
<a name="ln4880">          stack[depth].ts_fidxtry = sp-&gt;ts_fidx + tl;</a>
<a name="ln4881">          stack[depth].ts_tcharlen = 0;</a>
<a name="ln4882">          break;</a>
<a name="ln4883">        }</a>
<a name="ln4884">      }</a>
<a name="ln4885"> </a>
<a name="ln4886">      if (sp-&gt;ts_curi &gt;= gap-&gt;ga_len &amp;&amp; sp-&gt;ts_state == STATE_REP) {</a>
<a name="ln4887">        // No (more) matches.</a>
<a name="ln4888">        PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4889">        sp-&gt;ts_state = STATE_FINAL;</a>
<a name="ln4890">      }</a>
<a name="ln4891"> </a>
<a name="ln4892">      break;</a>
<a name="ln4893"> </a>
<a name="ln4894">    case STATE_REP_UNDO:</a>
<a name="ln4895">      // Undo a REP replacement and continue with the next one.</a>
<a name="ln4896">      if (soundfold) {</a>
<a name="ln4897">        gap = &amp;slang-&gt;sl_repsal;</a>
<a name="ln4898">      } else {</a>
<a name="ln4899">        gap = &amp;lp-&gt;lp_replang-&gt;sl_rep;</a>
<a name="ln4900">      }</a>
<a name="ln4901">      ftp = (fromto_T *)gap-&gt;ga_data + sp-&gt;ts_curi - 1;</a>
<a name="ln4902">      fl = (int)STRLEN(ftp-&gt;ft_from);</a>
<a name="ln4903">      tl = (int)STRLEN(ftp-&gt;ft_to);</a>
<a name="ln4904">      p = fword + sp-&gt;ts_fidx;</a>
<a name="ln4905">      if (fl != tl) {</a>
<a name="ln4906">        STRMOVE(p + fl, p + tl);</a>
<a name="ln4907">        repextra -= tl - fl;</a>
<a name="ln4908">      }</a>
<a name="ln4909">      memmove(p, ftp-&gt;ft_from, fl);</a>
<a name="ln4910">      PROF_STORE(sp-&gt;ts_state)</a>
<a name="ln4911">      sp-&gt;ts_state = STATE_REP;</a>
<a name="ln4912">      break;</a>
<a name="ln4913"> </a>
<a name="ln4914">    default:</a>
<a name="ln4915">      // Did all possible states at this level, go up one level.</a>
<a name="ln4916">      --depth;</a>
<a name="ln4917"> </a>
<a name="ln4918">      if (depth &gt;= 0 &amp;&amp; stack[depth].ts_prefixdepth == PFD_PREFIXTREE) {</a>
<a name="ln4919">        // Continue in or go back to the prefix tree.</a>
<a name="ln4920">        byts = pbyts;</a>
<a name="ln4921">        idxs = pidxs;</a>
<a name="ln4922">      }</a>
<a name="ln4923"> </a>
<a name="ln4924">      // Don't check for CTRL-C too often, it takes time.</a>
<a name="ln4925">      if (--breakcheckcount == 0) {</a>
<a name="ln4926">        os_breakcheck();</a>
<a name="ln4927">        breakcheckcount = 1000;</a>
<a name="ln4928">        if (profile_passed_limit(time_limit)) {</a>
<a name="ln4929">          got_int = true;</a>
<a name="ln4930">        }</a>
<a name="ln4931">      }</a>
<a name="ln4932">    }</a>
<a name="ln4933">  }</a>
<a name="ln4934">}</a>
<a name="ln4935"> </a>
<a name="ln4936">// Go one level deeper in the tree.</a>
<a name="ln4937">static void go_deeper(trystate_T *stack, int depth, int score_add)</a>
<a name="ln4938">{</a>
<a name="ln4939">  stack[depth + 1] = stack[depth];</a>
<a name="ln4940">  stack[depth + 1].ts_state = STATE_START;</a>
<a name="ln4941">  stack[depth + 1].ts_score = stack[depth].ts_score + score_add;</a>
<a name="ln4942">  stack[depth + 1].ts_curi = 1;         // start just after length byte</a>
<a name="ln4943">  stack[depth + 1].ts_flags = 0;</a>
<a name="ln4944">}</a>
<a name="ln4945"> </a>
<a name="ln4946">// Case-folding may change the number of bytes: Count nr of chars in</a>
<a name="ln4947">// fword[flen] and return the byte length of that many chars in &quot;word&quot;.</a>
<a name="ln4948">static int nofold_len(char_u *fword, int flen, char_u *word)</a>
<a name="ln4949">{</a>
<a name="ln4950">  char_u *p;</a>
<a name="ln4951">  int i = 0;</a>
<a name="ln4952"> </a>
<a name="ln4953">  for (p = fword; p &lt; fword + flen; MB_PTR_ADV(p)) {</a>
<a name="ln4954">    i++;</a>
<a name="ln4955">  }</a>
<a name="ln4956">  for (p = word; i &gt; 0; MB_PTR_ADV(p)) {</a>
<a name="ln4957">    i--;</a>
<a name="ln4958">  }</a>
<a name="ln4959">  return (int)(p - word);</a>
<a name="ln4960">}</a>
<a name="ln4961"> </a>
<a name="ln4962">// &quot;fword&quot; is a good word with case folded.  Find the matching keep-case</a>
<a name="ln4963">// words and put it in &quot;kword&quot;.</a>
<a name="ln4964">// Theoretically there could be several keep-case words that result in the</a>
<a name="ln4965">// same case-folded word, but we only find one...</a>
<a name="ln4966">static void find_keepcap_word(slang_T *slang, char_u *fword, char_u *kword)</a>
<a name="ln4967">{</a>
<a name="ln4968">  char_u uword[MAXWLEN];                // &quot;fword&quot; in upper-case</a>
<a name="ln4969">  int depth;</a>
<a name="ln4970">  idx_T tryidx;</a>
<a name="ln4971"> </a>
<a name="ln4972">  // The following arrays are used at each depth in the tree.</a>
<a name="ln4973">  idx_T arridx[MAXWLEN];</a>
<a name="ln4974">  int round[MAXWLEN];</a>
<a name="ln4975">  int fwordidx[MAXWLEN];</a>
<a name="ln4976">  int uwordidx[MAXWLEN];</a>
<a name="ln4977">  int kwordlen[MAXWLEN];</a>
<a name="ln4978"> </a>
<a name="ln4979">  int flen, ulen;</a>
<a name="ln4980">  int l;</a>
<a name="ln4981">  int len;</a>
<a name="ln4982">  int c;</a>
<a name="ln4983">  idx_T lo, hi, m;</a>
<a name="ln4984">  char_u *p;</a>
<a name="ln4985">  char_u *byts = slang-&gt;sl_kbyts;      // array with bytes of the words</a>
<a name="ln4986">  idx_T *idxs = slang-&gt;sl_kidxs;      // array with indexes</a>
<a name="ln4987"> </a>
<a name="ln4988">  if (byts == NULL) {</a>
<a name="ln4989">    // array is empty: &quot;cannot happen&quot;</a>
<a name="ln4990">    *kword = NUL;</a>
<a name="ln4991">    return;</a>
<a name="ln4992">  }</a>
<a name="ln4993"> </a>
<a name="ln4994">  // Make an all-cap version of &quot;fword&quot;.</a>
<a name="ln4995">  allcap_copy(fword, uword);</a>
<a name="ln4996"> </a>
<a name="ln4997">  // Each character needs to be tried both case-folded and upper-case.</a>
<a name="ln4998">  // All this gets very complicated if we keep in mind that changing case</a>
<a name="ln4999">  // may change the byte length of a multi-byte character...</a>
<a name="ln5000">  depth = 0;</a>
<a name="ln5001">  arridx[0] = 0;</a>
<a name="ln5002">  round[0] = 0;</a>
<a name="ln5003">  fwordidx[0] = 0;</a>
<a name="ln5004">  uwordidx[0] = 0;</a>
<a name="ln5005">  kwordlen[0] = 0;</a>
<a name="ln5006">  while (depth &gt;= 0) {</a>
<a name="ln5007">    if (fword[fwordidx[depth]] == NUL) {</a>
<a name="ln5008">      // We are at the end of &quot;fword&quot;.  If the tree allows a word to end</a>
<a name="ln5009">      // here we have found a match.</a>
<a name="ln5010">      if (byts[arridx[depth] + 1] == 0) {</a>
<a name="ln5011">        kword[kwordlen[depth]] = NUL;</a>
<a name="ln5012">        return;</a>
<a name="ln5013">      }</a>
<a name="ln5014"> </a>
<a name="ln5015">      // kword is getting too long, continue one level up</a>
<a name="ln5016">      --depth;</a>
<a name="ln5017">    } else if (++round[depth] &gt; 2) {</a>
<a name="ln5018">      // tried both fold-case and upper-case character, continue one</a>
<a name="ln5019">      // level up</a>
<a name="ln5020">      --depth;</a>
<a name="ln5021">    } else {</a>
<a name="ln5022">      // round[depth] == 1: Try using the folded-case character.</a>
<a name="ln5023">      // round[depth] == 2: Try using the upper-case character.</a>
<a name="ln5024">      flen = utf_ptr2len((char *)fword + fwordidx[depth]);</a>
<a name="ln5025">      ulen = utf_ptr2len((char *)uword + uwordidx[depth]);</a>
<a name="ln5026">      if (round[depth] == 1) {</a>
<a name="ln5027">        p = fword + fwordidx[depth];</a>
<a name="ln5028">        l = flen;</a>
<a name="ln5029">      } else {</a>
<a name="ln5030">        p = uword + uwordidx[depth];</a>
<a name="ln5031">        l = ulen;</a>
<a name="ln5032">      }</a>
<a name="ln5033"> </a>
<a name="ln5034">      for (tryidx = arridx[depth]; l &gt; 0; --l) {</a>
<a name="ln5035">        // Perform a binary search in the list of accepted bytes.</a>
<a name="ln5036">        len = byts[tryidx++];</a>
<a name="ln5037">        c = *p++;</a>
<a name="ln5038">        lo = tryidx;</a>
<a name="ln5039">        hi = tryidx + len - 1;</a>
<a name="ln5040">        while (lo &lt; hi) {</a>
<a name="ln5041">          m = (lo + hi) / 2;</a>
<a name="ln5042">          if (byts[m] &gt; c) {</a>
<a name="ln5043">            hi = m - 1;</a>
<a name="ln5044">          } else if (byts[m] &lt; c) {</a>
<a name="ln5045">            lo = m + 1;</a>
<a name="ln5046">          } else {</a>
<a name="ln5047">            lo = hi = m;</a>
<a name="ln5048">            break;</a>
<a name="ln5049">          }</a>
<a name="ln5050">        }</a>
<a name="ln5051"> </a>
<a name="ln5052">        // Stop if there is no matching byte.</a>
<a name="ln5053">        if (hi &lt; lo || byts[lo] != c) {</a>
<a name="ln5054">          break;</a>
<a name="ln5055">        }</a>
<a name="ln5056"> </a>
<a name="ln5057">        // Continue at the child (if there is one).</a>
<a name="ln5058">        tryidx = idxs[lo];</a>
<a name="ln5059">      }</a>
<a name="ln5060"> </a>
<a name="ln5061">      if (l == 0) {</a>
<a name="ln5062">        // Found the matching char.  Copy it to &quot;kword&quot; and go a</a>
<a name="ln5063">        // level deeper.</a>
<a name="ln5064">        if (round[depth] == 1) {</a>
<a name="ln5065">          STRNCPY(kword + kwordlen[depth], fword + fwordidx[depth],</a>
<a name="ln5066">                  flen);</a>
<a name="ln5067">          kwordlen[depth + 1] = kwordlen[depth] + flen;</a>
<a name="ln5068">        } else {</a>
<a name="ln5069">          STRNCPY(kword + kwordlen[depth], uword + uwordidx[depth],</a>
<a name="ln5070">                  ulen);</a>
<a name="ln5071">          kwordlen[depth + 1] = kwordlen[depth] + ulen;</a>
<a name="ln5072">        }</a>
<a name="ln5073">        fwordidx[depth + 1] = fwordidx[depth] + flen;</a>
<a name="ln5074">        uwordidx[depth + 1] = uwordidx[depth] + ulen;</a>
<a name="ln5075"> </a>
<a name="ln5076">        ++depth;</a>
<a name="ln5077">        arridx[depth] = tryidx;</a>
<a name="ln5078">        round[depth] = 0;</a>
<a name="ln5079">      }</a>
<a name="ln5080">    }</a>
<a name="ln5081">  }</a>
<a name="ln5082"> </a>
<a name="ln5083">  // Didn't find it: &quot;cannot happen&quot;.</a>
<a name="ln5084">  *kword = NUL;</a>
<a name="ln5085">}</a>
<a name="ln5086"> </a>
<a name="ln5087">// Compute the sound-a-like score for suggestions in su-&gt;su_ga and add them to</a>
<a name="ln5088">// su-&gt;su_sga.</a>
<a name="ln5089">static void score_comp_sal(suginfo_T *su)</a>
<a name="ln5090">{</a>
<a name="ln5091">  langp_T *lp;</a>
<a name="ln5092">  char_u badsound[MAXWLEN];</a>
<a name="ln5093">  int i;</a>
<a name="ln5094">  suggest_T *stp;</a>
<a name="ln5095">  suggest_T *sstp;</a>
<a name="ln5096">  int score;</a>
<a name="ln5097"> </a>
<a name="ln5098">  ga_grow(&amp;su-&gt;su_sga, su-&gt;su_ga.ga_len);</a>
<a name="ln5099"> </a>
<a name="ln5100">  // Use the sound-folding of the first language that supports it.</a>
<a name="ln5101">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5102">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5103">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5104">      // soundfold the bad word</a>
<a name="ln5105">      spell_soundfold(lp-&gt;lp_slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln5106"> </a>
<a name="ln5107">      for (i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5108">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln5109"> </a>
<a name="ln5110">        // Case-fold the suggested word, sound-fold it and compute the</a>
<a name="ln5111">        // sound-a-like score.</a>
<a name="ln5112">        score = stp_sal_score(stp, su, lp-&gt;lp_slang, badsound);</a>
<a name="ln5113">        if (score &lt; SCORE_MAXMAX) {</a>
<a name="ln5114">          // Add the suggestion.</a>
<a name="ln5115">          sstp = &amp;SUG(su-&gt;su_sga, su-&gt;su_sga.ga_len);</a>
<a name="ln5116">          sstp-&gt;st_word = vim_strsave(stp-&gt;st_word);</a>
<a name="ln5117">          sstp-&gt;st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln5118">          sstp-&gt;st_score = score;</a>
<a name="ln5119">          sstp-&gt;st_altscore = 0;</a>
<a name="ln5120">          sstp-&gt;st_orglen = stp-&gt;st_orglen;</a>
<a name="ln5121">          ++su-&gt;su_sga.ga_len;</a>
<a name="ln5122">        }</a>
<a name="ln5123">      }</a>
<a name="ln5124">      break;</a>
<a name="ln5125">    }</a>
<a name="ln5126">  }</a>
<a name="ln5127">}</a>
<a name="ln5128"> </a>
<a name="ln5129">// Combine the list of suggestions in su-&gt;su_ga and su-&gt;su_sga.</a>
<a name="ln5130">// They are entwined.</a>
<a name="ln5131">static void score_combine(suginfo_T *su)</a>
<a name="ln5132">{</a>
<a name="ln5133">  garray_T ga;</a>
<a name="ln5134">  garray_T *gap;</a>
<a name="ln5135">  langp_T *lp;</a>
<a name="ln5136">  suggest_T *stp;</a>
<a name="ln5137">  char_u *p;</a>
<a name="ln5138">  char_u badsound[MAXWLEN];</a>
<a name="ln5139">  int round;</a>
<a name="ln5140">  slang_T *slang = NULL;</a>
<a name="ln5141"> </a>
<a name="ln5142">  // Add the alternate score to su_ga.</a>
<a name="ln5143">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5144">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5145">    if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5146">      // soundfold the bad word</a>
<a name="ln5147">      slang = lp-&gt;lp_slang;</a>
<a name="ln5148">      spell_soundfold(slang, su-&gt;su_fbadword, true, badsound);</a>
<a name="ln5149"> </a>
<a name="ln5150">      for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5151">        stp = &amp;SUG(su-&gt;su_ga, i);</a>
<a name="ln5152">        stp-&gt;st_altscore = stp_sal_score(stp, su, slang, badsound);</a>
<a name="ln5153">        if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln5154">          stp-&gt;st_score = (stp-&gt;st_score * 3 + SCORE_BIG) / 4;</a>
<a name="ln5155">        } else {</a>
<a name="ln5156">          stp-&gt;st_score = (stp-&gt;st_score * 3</a>
<a name="ln5157">                           + stp-&gt;st_altscore) / 4;</a>
<a name="ln5158">        }</a>
<a name="ln5159">        stp-&gt;st_salscore = false;</a>
<a name="ln5160">      }</a>
<a name="ln5161">      break;</a>
<a name="ln5162">    }</a>
<a name="ln5163">  }</a>
<a name="ln5164"> </a>
<a name="ln5165">  if (slang == NULL) {  // Using &quot;double&quot; without sound folding.</a>
<a name="ln5166">    (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore,</a>
<a name="ln5167">                              su-&gt;su_maxcount);</a>
<a name="ln5168">    return;</a>
<a name="ln5169">  }</a>
<a name="ln5170"> </a>
<a name="ln5171">  // Add the alternate score to su_sga.</a>
<a name="ln5172">  for (int i = 0; i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5173">    stp = &amp;SUG(su-&gt;su_sga, i);</a>
<a name="ln5174">    stp-&gt;st_altscore = spell_edit_score(slang,</a>
<a name="ln5175">                                        su-&gt;su_badword, stp-&gt;st_word);</a>
<a name="ln5176">    if (stp-&gt;st_score == SCORE_MAXMAX) {</a>
<a name="ln5177">      stp-&gt;st_score = (SCORE_BIG * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5178">    } else {</a>
<a name="ln5179">      stp-&gt;st_score = (stp-&gt;st_score * 7 + stp-&gt;st_altscore) / 8;</a>
<a name="ln5180">    }</a>
<a name="ln5181">    stp-&gt;st_salscore = true;</a>
<a name="ln5182">  }</a>
<a name="ln5183"> </a>
<a name="ln5184">  // Remove bad suggestions, sort the suggestions and truncate at &quot;maxcount&quot;</a>
<a name="ln5185">  // for both lists.</a>
<a name="ln5186">  check_suggestions(su, &amp;su-&gt;su_ga);</a>
<a name="ln5187">  (void)cleanup_suggestions(&amp;su-&gt;su_ga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5188">  check_suggestions(su, &amp;su-&gt;su_sga);</a>
<a name="ln5189">  (void)cleanup_suggestions(&amp;su-&gt;su_sga, su-&gt;su_maxscore, su-&gt;su_maxcount);</a>
<a name="ln5190"> </a>
<a name="ln5191">  ga_init(&amp;ga, (int)sizeof(suginfo_T), 1);</a>
<a name="ln5192">  ga_grow(&amp;ga, su-&gt;su_ga.ga_len + su-&gt;su_sga.ga_len);</a>
<a name="ln5193"> </a>
<a name="ln5194">  stp = &amp;SUG(ga, 0);</a>
<a name="ln5195">  for (int i = 0; i &lt; su-&gt;su_ga.ga_len || i &lt; su-&gt;su_sga.ga_len; ++i) {</a>
<a name="ln5196">    // round 1: get a suggestion from su_ga</a>
<a name="ln5197">    // round 2: get a suggestion from su_sga</a>
<a name="ln5198">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln5199">      gap = round == 1 ? &amp;su-&gt;su_ga : &amp;su-&gt;su_sga;</a>
<a name="ln5200">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln5201">        // Don't add a word if it's already there.</a>
<a name="ln5202">        p = SUG(*gap, i).st_word;</a>
<a name="ln5203">        int j;</a>
<a name="ln5204">        for (j = 0; j &lt; ga.ga_len; ++j) {</a>
<a name="ln5205">          if (STRCMP(stp[j].st_word, p) == 0) {</a>
<a name="ln5206">            break;</a>
<a name="ln5207">          }</a>
<a name="ln5208">        }</a>
<a name="ln5209">        if (j == ga.ga_len) {</a>
<a name="ln5210">          stp[ga.ga_len++] = SUG(*gap, i);</a>
<a name="ln5211">        } else {</a>
<a name="ln5212">          xfree(p);</a>
<a name="ln5213">        }</a>
<a name="ln5214">      }</a>
<a name="ln5215">    }</a>
<a name="ln5216">  }</a>
<a name="ln5217"> </a>
<a name="ln5218">  ga_clear(&amp;su-&gt;su_ga);</a>
<a name="ln5219">  ga_clear(&amp;su-&gt;su_sga);</a>
<a name="ln5220"> </a>
<a name="ln5221">  // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5222">  if (ga.ga_len &gt; su-&gt;su_maxcount) {</a>
<a name="ln5223">    for (int i = su-&gt;su_maxcount; i &lt; ga.ga_len; ++i) {</a>
<a name="ln5224">      xfree(stp[i].st_word);</a>
<a name="ln5225">    }</a>
<a name="ln5226">    ga.ga_len = su-&gt;su_maxcount;</a>
<a name="ln5227">  }</a>
<a name="ln5228"> </a>
<a name="ln5229">  su-&gt;su_ga = ga;</a>
<a name="ln5230">}</a>
<a name="ln5231"> </a>
<a name="ln5232">/// For the goodword in &quot;stp&quot; compute the soundalike score compared to the</a>
<a name="ln5233">/// badword.</a>
<a name="ln5234">///</a>
<a name="ln5235">/// @param badsound  sound-folded badword</a>
<a name="ln5236">static int stp_sal_score(suggest_T *stp, suginfo_T *su, slang_T *slang, char_u *badsound)</a>
<a name="ln5237">{</a>
<a name="ln5238">  char_u *p;</a>
<a name="ln5239">  char_u *pbad;</a>
<a name="ln5240">  char_u *pgood;</a>
<a name="ln5241">  char_u badsound2[MAXWLEN];</a>
<a name="ln5242">  char_u fword[MAXWLEN];</a>
<a name="ln5243">  char_u goodsound[MAXWLEN];</a>
<a name="ln5244">  char_u goodword[MAXWLEN];</a>
<a name="ln5245">  int lendiff;</a>
<a name="ln5246"> </a>
<a name="ln5247">  lendiff = su-&gt;su_badlen - stp-&gt;st_orglen;</a>
<a name="ln5248">  if (lendiff &gt;= 0) {</a>
<a name="ln5249">    pbad = badsound;</a>
<a name="ln5250">  } else {</a>
<a name="ln5251">    // soundfold the bad word with more characters following</a>
<a name="ln5252">    (void)spell_casefold(curwin, su-&gt;su_badptr, stp-&gt;st_orglen, fword, MAXWLEN);</a>
<a name="ln5253"> </a>
<a name="ln5254">    // When joining two words the sound often changes a lot.  E.g., &quot;t he&quot;</a>
<a name="ln5255">    // sounds like &quot;t h&quot; while &quot;the&quot; sounds like &quot;@&quot;.  Avoid that by</a>
<a name="ln5256">    // removing the space.  Don't do it when the good word also contains a</a>
<a name="ln5257">    // space.</a>
<a name="ln5258">    if (ascii_iswhite(su-&gt;su_badptr[su-&gt;su_badlen])</a>
<a name="ln5259">        &amp;&amp; *skiptowhite(stp-&gt;st_word) == NUL) {</a>
<a name="ln5260">      for (p = fword; *(p = skiptowhite(p)) != NUL;) {</a>
<a name="ln5261">        STRMOVE(p, p + 1);</a>
<a name="ln5262">      }</a>
<a name="ln5263">    }</a>
<a name="ln5264"> </a>
<a name="ln5265">    spell_soundfold(slang, fword, true, badsound2);</a>
<a name="ln5266">    pbad = badsound2;</a>
<a name="ln5267">  }</a>
<a name="ln5268"> </a>
<a name="ln5269">  if (lendiff &gt; 0 &amp;&amp; stp-&gt;st_wordlen + lendiff &lt; MAXWLEN) {</a>
<a name="ln5270">    // Add part of the bad word to the good word, so that we soundfold</a>
<a name="ln5271">    // what replaces the bad word.</a>
<a name="ln5272">    STRCPY(goodword, stp-&gt;st_word);</a>
<a name="ln5273">    STRLCPY(goodword + stp-&gt;st_wordlen,</a>
<a name="ln5274">            su-&gt;su_badptr + su-&gt;su_badlen - lendiff, lendiff + 1);</a>
<a name="ln5275">    pgood = goodword;</a>
<a name="ln5276">  } else {</a>
<a name="ln5277">    pgood = stp-&gt;st_word;</a>
<a name="ln5278">  }</a>
<a name="ln5279"> </a>
<a name="ln5280">  // Sound-fold the word and compute the score for the difference.</a>
<a name="ln5281">  spell_soundfold(slang, pgood, false, goodsound);</a>
<a name="ln5282"> </a>
<a name="ln5283">  return soundalike_score(goodsound, pbad);</a>
<a name="ln5284">}</a>
<a name="ln5285"> </a>
<a name="ln5286">static sftword_T dumsft;</a>
<a name="ln5287">#define HIKEY2SFT(p)  ((sftword_T *)((p) - (dumsft.sft_word - (char_u *)&amp;dumsft)))</a>
<a name="ln5288">#define HI2SFT(hi)     HIKEY2SFT((hi)-&gt;hi_key)</a>
<a name="ln5289"> </a>
<a name="ln5290">// Prepare for calling suggest_try_soundalike().</a>
<a name="ln5291">static void suggest_try_soundalike_prep(void)</a>
<a name="ln5292">{</a>
<a name="ln5293">  langp_T *lp;</a>
<a name="ln5294">  slang_T *slang;</a>
<a name="ln5295"> </a>
<a name="ln5296">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5297">  // .sug file has been loaded.</a>
<a name="ln5298">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5299">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5300">    slang = lp-&gt;lp_slang;</a>
<a name="ln5301">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5302">      // prepare the hashtable used by add_sound_suggest()</a>
<a name="ln5303">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5304">    }</a>
<a name="ln5305">  }</a>
<a name="ln5306">}</a>
<a name="ln5307"> </a>
<a name="ln5308">// Find suggestions by comparing the word in a sound-a-like form.</a>
<a name="ln5309">// Note: This doesn't support postponed prefixes.</a>
<a name="ln5310">static void suggest_try_soundalike(suginfo_T *su)</a>
<a name="ln5311">{</a>
<a name="ln5312">  char_u salword[MAXWLEN];</a>
<a name="ln5313">  langp_T *lp;</a>
<a name="ln5314">  slang_T *slang;</a>
<a name="ln5315"> </a>
<a name="ln5316">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5317">  // .sug file has been loaded.</a>
<a name="ln5318">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5319">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5320">    slang = lp-&gt;lp_slang;</a>
<a name="ln5321">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5322">      // soundfold the bad word</a>
<a name="ln5323">      spell_soundfold(slang, su-&gt;su_fbadword, true, salword);</a>
<a name="ln5324"> </a>
<a name="ln5325">      // try all kinds of inserts/deletes/swaps/etc.</a>
<a name="ln5326">      // TODO: also soundfold the next words, so that we can try joining</a>
<a name="ln5327">      // and splitting</a>
<a name="ln5328">#ifdef SUGGEST_PROFILE</a>
<a name="ln5329">      prof_init();</a>
<a name="ln5330">#endif</a>
<a name="ln5331">      suggest_trie_walk(su, lp, salword, true);</a>
<a name="ln5332">#ifdef SUGGEST_PROFILE</a>
<a name="ln5333">      prof_report(&quot;soundalike&quot;);</a>
<a name="ln5334">#endif</a>
<a name="ln5335">    }</a>
<a name="ln5336">  }</a>
<a name="ln5337">}</a>
<a name="ln5338"> </a>
<a name="ln5339">// Finish up after calling suggest_try_soundalike().</a>
<a name="ln5340">static void suggest_try_soundalike_finish(void)</a>
<a name="ln5341">{</a>
<a name="ln5342">  langp_T *lp;</a>
<a name="ln5343">  slang_T *slang;</a>
<a name="ln5344">  int todo;</a>
<a name="ln5345">  hashitem_T *hi;</a>
<a name="ln5346"> </a>
<a name="ln5347">  // Do this for all languages that support sound folding and for which a</a>
<a name="ln5348">  // .sug file has been loaded.</a>
<a name="ln5349">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln5350">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5351">    slang = lp-&gt;lp_slang;</a>
<a name="ln5352">    if (!GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; slang-&gt;sl_sbyts != NULL) {</a>
<a name="ln5353">      // Free the info about handled words.</a>
<a name="ln5354">      todo = (int)slang-&gt;sl_sounddone.ht_used;</a>
<a name="ln5355">      for (hi = slang-&gt;sl_sounddone.ht_array; todo &gt; 0; ++hi) {</a>
<a name="ln5356">        if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln5357">          xfree(HI2SFT(hi));</a>
<a name="ln5358">          --todo;</a>
<a name="ln5359">        }</a>
<a name="ln5360">      }</a>
<a name="ln5361"> </a>
<a name="ln5362">      // Clear the hashtable, it may also be used by another region.</a>
<a name="ln5363">      hash_clear(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5364">      hash_init(&amp;slang-&gt;sl_sounddone);</a>
<a name="ln5365">    }</a>
<a name="ln5366">  }</a>
<a name="ln5367">}</a>
<a name="ln5368"> </a>
<a name="ln5369">/// A match with a soundfolded word is found.  Add the good word(s) that</a>
<a name="ln5370">/// produce this soundfolded word.</a>
<a name="ln5371">///</a>
<a name="ln5372">/// @param score  soundfold score</a>
<a name="ln5373">static void add_sound_suggest(suginfo_T *su, char_u *goodword, int score, langp_T *lp)</a>
<a name="ln5374">{</a>
<a name="ln5375">  slang_T *slang = lp-&gt;lp_slang;    // language for sound folding</a>
<a name="ln5376">  int sfwordnr;</a>
<a name="ln5377">  char_u *nrline;</a>
<a name="ln5378">  int orgnr;</a>
<a name="ln5379">  char_u theword[MAXWLEN];</a>
<a name="ln5380">  int i;</a>
<a name="ln5381">  int wlen;</a>
<a name="ln5382">  char_u *byts;</a>
<a name="ln5383">  idx_T *idxs;</a>
<a name="ln5384">  int n;</a>
<a name="ln5385">  int wordcount;</a>
<a name="ln5386">  int wc;</a>
<a name="ln5387">  int goodscore;</a>
<a name="ln5388">  hash_T hash;</a>
<a name="ln5389">  hashitem_T *hi;</a>
<a name="ln5390">  sftword_T *sft;</a>
<a name="ln5391">  int bc, gc;</a>
<a name="ln5392">  int limit;</a>
<a name="ln5393"> </a>
<a name="ln5394">  // It's very well possible that the same soundfold word is found several</a>
<a name="ln5395">  // times with different scores.  Since the following is quite slow only do</a>
<a name="ln5396">  // the words that have a better score than before.  Use a hashtable to</a>
<a name="ln5397">  // remember the words that have been done.</a>
<a name="ln5398">  hash = hash_hash(goodword);</a>
<a name="ln5399">  const size_t goodword_len = STRLEN(goodword);</a>
<a name="ln5400">  hi = hash_lookup(&amp;slang-&gt;sl_sounddone, (const char *)goodword, goodword_len,</a>
<a name="ln5401">                   hash);</a>
<a name="ln5402">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5403">    sft = xmalloc(sizeof(sftword_T) + goodword_len);</a>
<a name="ln5404">    sft-&gt;sft_score = score;</a>
<a name="ln5405">    memcpy(sft-&gt;sft_word, goodword, goodword_len + 1);</a>
<a name="ln5406">    hash_add_item(&amp;slang-&gt;sl_sounddone, hi, sft-&gt;sft_word, hash);</a>
<a name="ln5407">  } else {</a>
<a name="ln5408">    sft = HI2SFT(hi);</a>
<a name="ln5409">    if (score &gt;= sft-&gt;sft_score) {</a>
<a name="ln5410">      return;</a>
<a name="ln5411">    }</a>
<a name="ln5412">    sft-&gt;sft_score = score;</a>
<a name="ln5413">  }</a>
<a name="ln5414"> </a>
<a name="ln5415">  // Find the word nr in the soundfold tree.</a>
<a name="ln5416">  sfwordnr = soundfold_find(slang, goodword);</a>
<a name="ln5417">  if (sfwordnr &lt; 0) {</a>
<a name="ln5418">    internal_error(&quot;add_sound_suggest()&quot;);</a>
<a name="ln5419">    return;</a>
<a name="ln5420">  }</a>
<a name="ln5421"> </a>
<a name="ln5422">  // Go over the list of good words that produce this soundfold word</a>
<a name="ln5423">  nrline = ml_get_buf(slang-&gt;sl_sugbuf, (linenr_T)sfwordnr + 1, false);</a>
<a name="ln5424">  orgnr = 0;</a>
<a name="ln5425">  while (*nrline != NUL) {</a>
<a name="ln5426">    // The wordnr was stored in a minimal nr of bytes as an offset to the</a>
<a name="ln5427">    // previous wordnr.</a>
<a name="ln5428">    orgnr += bytes2offset(&amp;nrline);</a>
<a name="ln5429"> </a>
<a name="ln5430">    byts = slang-&gt;sl_fbyts;</a>
<a name="ln5431">    idxs = slang-&gt;sl_fidxs;</a>
<a name="ln5432"> </a>
<a name="ln5433">    // Lookup the word &quot;orgnr&quot; one of the two tries.</a>
<a name="ln5434">    n = 0;</a>
<a name="ln5435">    wordcount = 0;</a>
<a name="ln5436">    for (wlen = 0; wlen &lt; MAXWLEN - 3; ++wlen) {</a>
<a name="ln5437">      i = 1;</a>
<a name="ln5438">      if (wordcount == orgnr &amp;&amp; byts[n + 1] == NUL) {</a>
<a name="ln5439">        break;          // found end of word</a>
<a name="ln5440">      }</a>
<a name="ln5441">      if (byts[n + 1] == NUL) {</a>
<a name="ln5442">        ++wordcount;</a>
<a name="ln5443">      }</a>
<a name="ln5444"> </a>
<a name="ln5445">      // skip over the NUL bytes</a>
<a name="ln5446">      for (; byts[n + i] == NUL; ++i) {</a>
<a name="ln5447">        if (i &gt; byts[n]) {              // safety check</a>
<a name="ln5448">          STRCPY(theword + wlen, &quot;BAD&quot;);</a>
<a name="ln5449">          wlen += 3;</a>
<a name="ln5450">          goto badword;</a>
<a name="ln5451">        }</a>
<a name="ln5452">      }</a>
<a name="ln5453"> </a>
<a name="ln5454">      // One of the siblings must have the word.</a>
<a name="ln5455">      for (; i &lt; byts[n]; ++i) {</a>
<a name="ln5456">        wc = idxs[idxs[n + i]];         // nr of words under this byte</a>
<a name="ln5457">        if (wordcount + wc &gt; orgnr) {</a>
<a name="ln5458">          break;</a>
<a name="ln5459">        }</a>
<a name="ln5460">        wordcount += wc;</a>
<a name="ln5461">      }</a>
<a name="ln5462"> </a>
<a name="ln5463">      theword[wlen] = byts[n + i];</a>
<a name="ln5464">      n = idxs[n + i];</a>
<a name="ln5465">    }</a>
<a name="ln5466">badword:</a>
<a name="ln5467">    theword[wlen] = NUL;</a>
<a name="ln5468"> </a>
<a name="ln5469">    // Go over the possible flags and regions.</a>
<a name="ln5470">    for (; i &lt;= byts[n] &amp;&amp; byts[n + i] == NUL; ++i) {</a>
<a name="ln5471">      char_u cword[MAXWLEN];</a>
<a name="ln5472">      char_u *p;</a>
<a name="ln5473">      int flags = (int)idxs[n + i];</a>
<a name="ln5474"> </a>
<a name="ln5475">      // Skip words with the NOSUGGEST flag</a>
<a name="ln5476">      if (flags &amp; WF_NOSUGGEST) {</a>
<a name="ln5477">        continue;</a>
<a name="ln5478">      }</a>
<a name="ln5479"> </a>
<a name="ln5480">      if (flags &amp; WF_KEEPCAP) {</a>
<a name="ln5481">        // Must find the word in the keep-case tree.</a>
<a name="ln5482">        find_keepcap_word(slang, theword, cword);</a>
<a name="ln5483">        p = cword;</a>
<a name="ln5484">      } else {</a>
<a name="ln5485">        flags |= su-&gt;su_badflags;</a>
<a name="ln5486">        if ((flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln5487">          // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln5488">          make_case_word(theword, cword, flags);</a>
<a name="ln5489">          p = cword;</a>
<a name="ln5490">        } else {</a>
<a name="ln5491">          p = theword;</a>
<a name="ln5492">        }</a>
<a name="ln5493">      }</a>
<a name="ln5494"> </a>
<a name="ln5495">      // Add the suggestion.</a>
<a name="ln5496">      if (sps_flags &amp; SPS_DOUBLE) {</a>
<a name="ln5497">        // Add the suggestion if the score isn't too bad.</a>
<a name="ln5498">        if (score &lt;= su-&gt;su_maxscore) {</a>
<a name="ln5499">          add_suggestion(su, &amp;su-&gt;su_sga, p, su-&gt;su_badlen,</a>
<a name="ln5500">                         score, 0, false, slang, false);</a>
<a name="ln5501">        }</a>
<a name="ln5502">      } else {</a>
<a name="ln5503">        // Add a penalty for words in another region.</a>
<a name="ln5504">        if ((flags &amp; WF_REGION)</a>
<a name="ln5505">            &amp;&amp; (((unsigned)flags &gt;&gt; 16) &amp; lp-&gt;lp_region) == 0) {</a>
<a name="ln5506">          goodscore = SCORE_REGION;</a>
<a name="ln5507">        } else {</a>
<a name="ln5508">          goodscore = 0;</a>
<a name="ln5509">        }</a>
<a name="ln5510"> </a>
<a name="ln5511">        // Add a small penalty for changing the first letter from</a>
<a name="ln5512">        // lower to upper case.  Helps for &quot;tath&quot; -&gt; &quot;Kath&quot;, which is</a>
<a name="ln5513">        // less common than &quot;tath&quot; -&gt; &quot;path&quot;.  Don't do it when the</a>
<a name="ln5514">        // letter is the same, that has already been counted.</a>
<a name="ln5515">        gc = utf_ptr2char((char *)p);</a>
<a name="ln5516">        if (SPELL_ISUPPER(gc)) {</a>
<a name="ln5517">          bc = utf_ptr2char((char *)su-&gt;su_badword);</a>
<a name="ln5518">          if (!SPELL_ISUPPER(bc)</a>
<a name="ln5519">              &amp;&amp; SPELL_TOFOLD(bc) != SPELL_TOFOLD(gc)) {</a>
<a name="ln5520">            goodscore += SCORE_ICASE / 2;</a>
<a name="ln5521">          }</a>
<a name="ln5522">        }</a>
<a name="ln5523"> </a>
<a name="ln5524">        // Compute the score for the good word.  This only does letter</a>
<a name="ln5525">        // insert/delete/swap/replace.  REP items are not considered,</a>
<a name="ln5526">        // which may make the score a bit higher.</a>
<a name="ln5527">        // Use a limit for the score to make it work faster.  Use</a>
<a name="ln5528">        // MAXSCORE(), because RESCORE() will change the score.</a>
<a name="ln5529">        // If the limit is very high then the iterative method is</a>
<a name="ln5530">        // inefficient, using an array is quicker.</a>
<a name="ln5531">        limit = MAXSCORE(su-&gt;su_sfmaxscore - goodscore, score);</a>
<a name="ln5532">        if (limit &gt; SCORE_LIMITMAX) {</a>
<a name="ln5533">          goodscore += spell_edit_score(slang, su-&gt;su_badword, p);</a>
<a name="ln5534">        } else {</a>
<a name="ln5535">          goodscore += spell_edit_score_limit(slang, su-&gt;su_badword,</a>
<a name="ln5536">                                              p, limit);</a>
<a name="ln5537">        }</a>
<a name="ln5538"> </a>
<a name="ln5539">        // When going over the limit don't bother to do the rest.</a>
<a name="ln5540">        if (goodscore &lt; SCORE_MAXMAX) {</a>
<a name="ln5541">          // Give a bonus to words seen before.</a>
<a name="ln5542">          goodscore = score_wordcount_adj(slang, goodscore, p, false);</a>
<a name="ln5543"> </a>
<a name="ln5544">          // Add the suggestion if the score isn't too bad.</a>
<a name="ln5545">          goodscore = RESCORE(goodscore, score);</a>
<a name="ln5546">          if (goodscore &lt;= su-&gt;su_sfmaxscore) {</a>
<a name="ln5547">            add_suggestion(su, &amp;su-&gt;su_ga, p, su-&gt;su_badlen,</a>
<a name="ln5548">                           goodscore, score, true, slang, true);</a>
<a name="ln5549">          }</a>
<a name="ln5550">        }</a>
<a name="ln5551">      }</a>
<a name="ln5552">    }</a>
<a name="ln5553">  }</a>
<a name="ln5554">}</a>
<a name="ln5555"> </a>
<a name="ln5556">// Find word &quot;word&quot; in fold-case tree for &quot;slang&quot; and return the word number.</a>
<a name="ln5557">static int soundfold_find(slang_T *slang, char_u *word)</a>
<a name="ln5558">{</a>
<a name="ln5559">  idx_T arridx = 0;</a>
<a name="ln5560">  int len;</a>
<a name="ln5561">  int wlen = 0;</a>
<a name="ln5562">  int c;</a>
<a name="ln5563">  char_u *ptr = word;</a>
<a name="ln5564">  char_u *byts;</a>
<a name="ln5565">  idx_T *idxs;</a>
<a name="ln5566">  int wordnr = 0;</a>
<a name="ln5567"> </a>
<a name="ln5568">  byts = slang-&gt;sl_sbyts;</a>
<a name="ln5569">  idxs = slang-&gt;sl_sidxs;</a>
<a name="ln5570"> </a>
<a name="ln5571">  for (;;) {</a>
<a name="ln5572">    // First byte is the number of possible bytes.</a>
<a name="ln5573">    len = byts[arridx++];</a>
<a name="ln5574"> </a>
<a name="ln5575">    // If the first possible byte is a zero the word could end here.</a>
<a name="ln5576">    // If the word ends we found the word.  If not skip the NUL bytes.</a>
<a name="ln5577">    c = ptr[wlen];</a>
<a name="ln5578">    if (byts[arridx] == NUL) {</a>
<a name="ln5579">      if (c == NUL) {</a>
<a name="ln5580">        break;</a>
<a name="ln5581">      }</a>
<a name="ln5582"> </a>
<a name="ln5583">      // Skip over the zeros, there can be several.</a>
<a name="ln5584">      while (len &gt; 0 &amp;&amp; byts[arridx] == NUL) {</a>
<a name="ln5585">        ++arridx;</a>
<a name="ln5586">        --len;</a>
<a name="ln5587">      }</a>
<a name="ln5588">      if (len == 0) {</a>
<a name="ln5589">        return -1;            // no children, word should have ended here</a>
<a name="ln5590">      }</a>
<a name="ln5591">      ++wordnr;</a>
<a name="ln5592">    }</a>
<a name="ln5593"> </a>
<a name="ln5594">    // If the word ends we didn't find it.</a>
<a name="ln5595">    if (c == NUL) {</a>
<a name="ln5596">      return -1;</a>
<a name="ln5597">    }</a>
<a name="ln5598"> </a>
<a name="ln5599">    // Perform a binary search in the list of accepted bytes.</a>
<a name="ln5600">    if (c == TAB) {         // &lt;Tab&gt; is handled like &lt;Space&gt;</a>
<a name="ln5601">      c = ' ';</a>
<a name="ln5602">    }</a>
<a name="ln5603">    while (byts[arridx] &lt; c) {</a>
<a name="ln5604">      // The word count is in the first idxs[] entry of the child.</a>
<a name="ln5605">      wordnr += idxs[idxs[arridx]];</a>
<a name="ln5606">      ++arridx;</a>
<a name="ln5607">      if (--len == 0) {         // end of the bytes, didn't find it</a>
<a name="ln5608">        return -1;</a>
<a name="ln5609">      }</a>
<a name="ln5610">    }</a>
<a name="ln5611">    if (byts[arridx] != c) {    // didn't find the byte</a>
<a name="ln5612">      return -1;</a>
<a name="ln5613">    }</a>
<a name="ln5614"> </a>
<a name="ln5615">    // Continue at the child (if there is one).</a>
<a name="ln5616">    arridx = idxs[arridx];</a>
<a name="ln5617">    ++wlen;</a>
<a name="ln5618"> </a>
<a name="ln5619">    // One space in the good word may stand for several spaces in the</a>
<a name="ln5620">    // checked word.</a>
<a name="ln5621">    if (c == ' ') {</a>
<a name="ln5622">      while (ptr[wlen] == ' ' || ptr[wlen] == TAB) {</a>
<a name="ln5623">        ++wlen;</a>
<a name="ln5624">      }</a>
<a name="ln5625">    }</a>
<a name="ln5626">  }</a>
<a name="ln5627"> </a>
<a name="ln5628">  return wordnr;</a>
<a name="ln5629">}</a>
<a name="ln5630"> </a>
<a name="ln5631">// Copy &quot;fword&quot; to &quot;cword&quot;, fixing case according to &quot;flags&quot;.</a>
<a name="ln5632">static void make_case_word(char_u *fword, char_u *cword, int flags)</a>
<a name="ln5633">{</a>
<a name="ln5634">  if (flags &amp; WF_ALLCAP) {</a>
<a name="ln5635">    // Make it all upper-case</a>
<a name="ln5636">    allcap_copy(fword, cword);</a>
<a name="ln5637">  } else if (flags &amp; WF_ONECAP) {</a>
<a name="ln5638">    // Make the first letter upper-case</a>
<a name="ln5639">    onecap_copy(fword, cword, true);</a>
<a name="ln5640">  } else {</a>
<a name="ln5641">    // Use goodword as-is.</a>
<a name="ln5642">    STRCPY(cword, fword);</a>
<a name="ln5643">  }</a>
<a name="ln5644">}</a>
<a name="ln5645"> </a>
<a name="ln5646">// Returns true if &quot;c1&quot; and &quot;c2&quot; are similar characters according to the MAP</a>
<a name="ln5647">// lines in the .aff file.</a>
<a name="ln5648">static bool similar_chars(slang_T *slang, int c1, int c2)</a>
<a name="ln5649">{</a>
<a name="ln5650">  int m1, m2;</a>
<a name="ln5651">  char buf[MB_MAXBYTES + 1];</a>
<a name="ln5652">  hashitem_T *hi;</a>
<a name="ln5653"> </a>
<a name="ln5654">  if (c1 &gt;= 256) {</a>
<a name="ln5655">    buf[utf_char2bytes(c1, (char *)buf)] = 0;</a>
<a name="ln5656">    hi = hash_find(&amp;slang-&gt;sl_map_hash, (char_u *)buf);</a>
<a name="ln5657">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5658">      m1 = 0;</a>
<a name="ln5659">    } else {</a>
<a name="ln5660">      m1 = utf_ptr2char((char *)hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5661">    }</a>
<a name="ln5662">  } else {</a>
<a name="ln5663">    m1 = slang-&gt;sl_map_array[c1];</a>
<a name="ln5664">  }</a>
<a name="ln5665">  if (m1 == 0) {</a>
<a name="ln5666">    return false;</a>
<a name="ln5667">  }</a>
<a name="ln5668"> </a>
<a name="ln5669">  if (c2 &gt;= 256) {</a>
<a name="ln5670">    buf[utf_char2bytes(c2, (char *)buf)] = 0;</a>
<a name="ln5671">    hi = hash_find(&amp;slang-&gt;sl_map_hash, (char_u *)buf);</a>
<a name="ln5672">    if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5673">      m2 = 0;</a>
<a name="ln5674">    } else {</a>
<a name="ln5675">      m2 = utf_ptr2char((char *)hi-&gt;hi_key + STRLEN(hi-&gt;hi_key) + 1);</a>
<a name="ln5676">    }</a>
<a name="ln5677">  } else {</a>
<a name="ln5678">    m2 = slang-&gt;sl_map_array[c2];</a>
<a name="ln5679">  }</a>
<a name="ln5680"> </a>
<a name="ln5681">  return m1 == m2;</a>
<a name="ln5682">}</a>
<a name="ln5683"> </a>
<a name="ln5684">/// Adds a suggestion to the list of suggestions.</a>
<a name="ln5685">/// For a suggestion that is already in the list the lowest score is remembered.</a>
<a name="ln5686">///</a>
<a name="ln5687">/// @param gap  either su_ga or su_sga</a>
<a name="ln5688">/// @param badlenarg  len of bad word replaced with &quot;goodword&quot;</a>
<a name="ln5689">/// @param had_bonus  value for st_had_bonus</a>
<a name="ln5690">/// @param slang  language for sound folding</a>
<a name="ln5691">/// @param maxsf  su_maxscore applies to soundfold score, su_sfmaxscore to the total score.</a>
<a name="ln5692">static void add_suggestion(suginfo_T *su, garray_T *gap, const char_u *goodword, int badlenarg,</a>
<a name="ln5693">                           int score, int altscore, bool had_bonus, slang_T *slang, bool maxsf)</a>
<a name="ln5694">{</a>
<a name="ln5695">  int goodlen;                  // len of goodword changed</a>
<a name="ln5696">  int badlen;                   // len of bad word changed</a>
<a name="ln5697">  suggest_T *stp;</a>
<a name="ln5698">  suggest_T new_sug;</a>
<a name="ln5699"> </a>
<a name="ln5700">  // Minimize &quot;badlen&quot; for consistency.  Avoids that changing &quot;the the&quot; to</a>
<a name="ln5701">  // &quot;thee the&quot; is added next to changing the first &quot;the&quot; the &quot;thee&quot;.</a>
<a name="ln5702">  const char_u *pgood = goodword + STRLEN(goodword);</a>
<a name="ln5703">  char_u *pbad = su-&gt;su_badptr + badlenarg;</a>
<a name="ln5704">  for (;;) {</a>
<a name="ln5705">    goodlen = (int)(pgood - goodword);</a>
<a name="ln5706">    badlen = (int)(pbad - su-&gt;su_badptr);</a>
<a name="ln5707">    if (goodlen &lt;= 0 || badlen &lt;= 0) {</a>
<a name="ln5708">      break;</a>
<a name="ln5709">    }</a>
<a name="ln5710">    MB_PTR_BACK(goodword, pgood);</a>
<a name="ln5711">    MB_PTR_BACK(su-&gt;su_badptr, pbad);</a>
<a name="ln5712">    if (utf_ptr2char((char *)pgood) != utf_ptr2char((char *)pbad)) {</a>
<a name="ln5713">      break;</a>
<a name="ln5714">    }</a>
<a name="ln5715">  }</a>
<a name="ln5716"> </a>
<a name="ln5717">  if (badlen == 0 &amp;&amp; goodlen == 0) {</a>
<a name="ln5718">    // goodword doesn't change anything; may happen for &quot;the the&quot; changing</a>
<a name="ln5719">    // the first &quot;the&quot; to itself.</a>
<a name="ln5720">    return;</a>
<a name="ln5721">  }</a>
<a name="ln5722"> </a>
<a name="ln5723">  int i;</a>
<a name="ln5724">  if (GA_EMPTY(gap)) {</a>
<a name="ln5725">    i = -1;</a>
<a name="ln5726">  } else {</a>
<a name="ln5727">    // Check if the word is already there.  Also check the length that is</a>
<a name="ln5728">    // being replaced &quot;thes,&quot; -&gt; &quot;these&quot; is a different suggestion from</a>
<a name="ln5729">    // &quot;thes&quot; -&gt; &quot;these&quot;.</a>
<a name="ln5730">    stp = &amp;SUG(*gap, 0);</a>
<a name="ln5731">    for (i = gap-&gt;ga_len; --i &gt;= 0; ++stp) {</a>
<a name="ln5732">      if (stp-&gt;st_wordlen == goodlen</a>
<a name="ln5733">          &amp;&amp; stp-&gt;st_orglen == badlen</a>
<a name="ln5734">          &amp;&amp; STRNCMP(stp-&gt;st_word, goodword, goodlen) == 0) {</a>
<a name="ln5735">        // Found it.  Remember the word with the lowest score.</a>
<a name="ln5736">        if (stp-&gt;st_slang == NULL) {</a>
<a name="ln5737">          stp-&gt;st_slang = slang;</a>
<a name="ln5738">        }</a>
<a name="ln5739"> </a>
<a name="ln5740">        new_sug.st_score = score;</a>
<a name="ln5741">        new_sug.st_altscore = altscore;</a>
<a name="ln5742">        new_sug.st_had_bonus = had_bonus;</a>
<a name="ln5743"> </a>
<a name="ln5744">        if (stp-&gt;st_had_bonus != had_bonus) {</a>
<a name="ln5745">          // Only one of the two had the soundalike score computed.</a>
<a name="ln5746">          // Need to do that for the other one now, otherwise the</a>
<a name="ln5747">          // scores can't be compared.  This happens because</a>
<a name="ln5748">          // suggest_try_change() doesn't compute the soundalike</a>
<a name="ln5749">          // word to keep it fast, while some special methods set</a>
<a name="ln5750">          // the soundalike score to zero.</a>
<a name="ln5751">          if (had_bonus) {</a>
<a name="ln5752">            rescore_one(su, stp);</a>
<a name="ln5753">          } else {</a>
<a name="ln5754">            new_sug.st_word = stp-&gt;st_word;</a>
<a name="ln5755">            new_sug.st_wordlen = stp-&gt;st_wordlen;</a>
<a name="ln5756">            new_sug.st_slang = stp-&gt;st_slang;</a>
<a name="ln5757">            new_sug.st_orglen = badlen;</a>
<a name="ln5758">            rescore_one(su, &amp;new_sug);</a>
<a name="ln5759">          }</a>
<a name="ln5760">        }</a>
<a name="ln5761"> </a>
<a name="ln5762">        if (stp-&gt;st_score &gt; new_sug.st_score) {</a>
<a name="ln5763">          stp-&gt;st_score = new_sug.st_score;</a>
<a name="ln5764">          stp-&gt;st_altscore = new_sug.st_altscore;</a>
<a name="ln5765">          stp-&gt;st_had_bonus = new_sug.st_had_bonus;</a>
<a name="ln5766">        }</a>
<a name="ln5767">        break;</a>
<a name="ln5768">      }</a>
<a name="ln5769">    }</a>
<a name="ln5770">  }</a>
<a name="ln5771"> </a>
<a name="ln5772">  if (i &lt; 0) {</a>
<a name="ln5773">    // Add a suggestion.</a>
<a name="ln5774">    stp = GA_APPEND_VIA_PTR(suggest_T, gap);</a>
<a name="ln5775">    stp-&gt;st_word = vim_strnsave(goodword, goodlen);</a>
<a name="ln5776">    stp-&gt;st_wordlen = goodlen;</a>
<a name="ln5777">    stp-&gt;st_score = score;</a>
<a name="ln5778">    stp-&gt;st_altscore = altscore;</a>
<a name="ln5779">    stp-&gt;st_had_bonus = had_bonus;</a>
<a name="ln5780">    stp-&gt;st_orglen = badlen;</a>
<a name="ln5781">    stp-&gt;st_slang = slang;</a>
<a name="ln5782"> </a>
<a name="ln5783">    // If we have too many suggestions now, sort the list and keep</a>
<a name="ln5784">    // the best suggestions.</a>
<a name="ln5785">    if (gap-&gt;ga_len &gt; SUG_MAX_COUNT(su)) {</a>
<a name="ln5786">      if (maxsf) {</a>
<a name="ln5787">        su-&gt;su_sfmaxscore = cleanup_suggestions(gap,</a>
<a name="ln5788">                                                su-&gt;su_sfmaxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5789">      } else {</a>
<a name="ln5790">        su-&gt;su_maxscore = cleanup_suggestions(gap,</a>
<a name="ln5791">                                              su-&gt;su_maxscore, SUG_CLEAN_COUNT(su));</a>
<a name="ln5792">      }</a>
<a name="ln5793">    }</a>
<a name="ln5794">  }</a>
<a name="ln5795">}</a>
<a name="ln5796"> </a>
<a name="ln5797">/// Suggestions may in fact be flagged as errors.  Esp. for banned words and</a>
<a name="ln5798">/// for split words, such as &quot;the the&quot;.  Remove these from the list here.</a>
<a name="ln5799">///</a>
<a name="ln5800">/// @param gap  either su_ga or su_sga</a>
<a name="ln5801">static void check_suggestions(suginfo_T *su, garray_T *gap)</a>
<a name="ln5802">{</a>
<a name="ln5803">  suggest_T *stp;</a>
<a name="ln5804">  char_u longword[MAXWLEN + 1];</a>
<a name="ln5805">  int len;</a>
<a name="ln5806">  hlf_T attr;</a>
<a name="ln5807"> </a>
<a name="ln5808">  if (gap-&gt;ga_len == 0) {</a>
<a name="ln5809">    return;</a>
<a name="ln5810">  }</a>
<a name="ln5811">  stp = &amp;SUG(*gap, 0);</a>
<a name="ln5812">  for (int i = gap-&gt;ga_len - 1; i &gt;= 0; --i) {</a>
<a name="ln5813">    // Need to append what follows to check for &quot;the the&quot;.</a>
<a name="ln5814">    STRLCPY(longword, stp[i].st_word, MAXWLEN + 1);</a>
<a name="ln5815">    len = stp[i].st_wordlen;</a>
<a name="ln5816">    STRLCPY(longword + len, su-&gt;su_badptr + stp[i].st_orglen,</a>
<a name="ln5817">            MAXWLEN - len + 1);</a>
<a name="ln5818">    attr = HLF_COUNT;</a>
<a name="ln5819">    (void)spell_check(curwin, longword, &amp;attr, NULL, false);</a>
<a name="ln5820">    if (attr != HLF_COUNT) {</a>
<a name="ln5821">      // Remove this entry.</a>
<a name="ln5822">      xfree(stp[i].st_word);</a>
<a name="ln5823">      --gap-&gt;ga_len;</a>
<a name="ln5824">      if (i &lt; gap-&gt;ga_len) {</a>
<a name="ln5825">        memmove(stp + i, stp + i + 1,</a>
<a name="ln5826">                sizeof(suggest_T) * (gap-&gt;ga_len - i));</a>
<a name="ln5827">      }</a>
<a name="ln5828">    }</a>
<a name="ln5829">  }</a>
<a name="ln5830">}</a>
<a name="ln5831"> </a>
<a name="ln5832">// Add a word to be banned.</a>
<a name="ln5833">static void add_banned(suginfo_T *su, char_u *word)</a>
<a name="ln5834">{</a>
<a name="ln5835">  char_u *s;</a>
<a name="ln5836">  hash_T hash;</a>
<a name="ln5837">  hashitem_T *hi;</a>
<a name="ln5838"> </a>
<a name="ln5839">  hash = hash_hash(word);</a>
<a name="ln5840">  const size_t word_len = STRLEN(word);</a>
<a name="ln5841">  hi = hash_lookup(&amp;su-&gt;su_banned, (const char *)word, word_len, hash);</a>
<a name="ln5842">  if (HASHITEM_EMPTY(hi)) {</a>
<a name="ln5843">    s = xmemdupz(word, word_len);</a>
<a name="ln5844">    hash_add_item(&amp;su-&gt;su_banned, hi, s, hash);</a>
<a name="ln5845">  }</a>
<a name="ln5846">}</a>
<a name="ln5847"> </a>
<a name="ln5848">// Recompute the score for all suggestions if sound-folding is possible.  This</a>
<a name="ln5849">// is slow, thus only done for the final results.</a>
<a name="ln5850">static void rescore_suggestions(suginfo_T *su)</a>
<a name="ln5851">{</a>
<a name="ln5852">  if (su-&gt;su_sallang != NULL) {</a>
<a name="ln5853">    for (int i = 0; i &lt; su-&gt;su_ga.ga_len; ++i) {</a>
<a name="ln5854">      rescore_one(su, &amp;SUG(su-&gt;su_ga, i));</a>
<a name="ln5855">    }</a>
<a name="ln5856">  }</a>
<a name="ln5857">}</a>
<a name="ln5858"> </a>
<a name="ln5859">// Recompute the score for one suggestion if sound-folding is possible.</a>
<a name="ln5860">static void rescore_one(suginfo_T *su, suggest_T *stp)</a>
<a name="ln5861">{</a>
<a name="ln5862">  slang_T *slang = stp-&gt;st_slang;</a>
<a name="ln5863">  char_u sal_badword[MAXWLEN];</a>
<a name="ln5864">  char_u *p;</a>
<a name="ln5865"> </a>
<a name="ln5866">  // Only rescore suggestions that have no sal score yet and do have a</a>
<a name="ln5867">  // language.</a>
<a name="ln5868">  if (slang != NULL &amp;&amp; !GA_EMPTY(&amp;slang-&gt;sl_sal) &amp;&amp; !stp-&gt;st_had_bonus) {</a>
<a name="ln5869">    if (slang == su-&gt;su_sallang) {</a>
<a name="ln5870">      p = su-&gt;su_sal_badword;</a>
<a name="ln5871">    } else {</a>
<a name="ln5872">      spell_soundfold(slang, su-&gt;su_fbadword, true, sal_badword);</a>
<a name="ln5873">      p = sal_badword;</a>
<a name="ln5874">    }</a>
<a name="ln5875"> </a>
<a name="ln5876">    stp-&gt;st_altscore = stp_sal_score(stp, su, slang, p);</a>
<a name="ln5877">    if (stp-&gt;st_altscore == SCORE_MAXMAX) {</a>
<a name="ln5878">      stp-&gt;st_altscore = SCORE_BIG;</a>
<a name="ln5879">    }</a>
<a name="ln5880">    stp-&gt;st_score = RESCORE(stp-&gt;st_score, stp-&gt;st_altscore);</a>
<a name="ln5881">    stp-&gt;st_had_bonus = true;</a>
<a name="ln5882">  }</a>
<a name="ln5883">}</a>
<a name="ln5884"> </a>
<a name="ln5885">// Function given to qsort() to sort the suggestions on st_score.</a>
<a name="ln5886">// First on &quot;st_score&quot;, then &quot;st_altscore&quot; then alphabetically.</a>
<a name="ln5887">static int sug_compare(const void *s1, const void *s2)</a>
<a name="ln5888">{</a>
<a name="ln5889">  suggest_T *p1 = (suggest_T *)s1;</a>
<a name="ln5890">  suggest_T *p2 = (suggest_T *)s2;</a>
<a name="ln5891">  int n = p1-&gt;st_score - p2-&gt;st_score;</a>
<a name="ln5892"> </a>
<a name="ln5893">  if (n == 0) {</a>
<a name="ln5894">    n = p1-&gt;st_altscore - p2-&gt;st_altscore;</a>
<a name="ln5895">    if (n == 0) {</a>
<a name="ln5896">      n = STRICMP(p1-&gt;st_word, p2-&gt;st_word);</a>
<a name="ln5897">    }</a>
<a name="ln5898">  }</a>
<a name="ln5899">  return n;</a>
<a name="ln5900">}</a>
<a name="ln5901"> </a>
<a name="ln5902">/// Cleanup the suggestions:</a>
<a name="ln5903">/// - Sort on score.</a>
<a name="ln5904">/// - Remove words that won't be displayed.</a>
<a name="ln5905">///</a>
<a name="ln5906">/// @param keep  nr of suggestions to keep</a>
<a name="ln5907">///</a>
<a name="ln5908">/// @return  the maximum score in the list or &quot;maxscore&quot; unmodified.</a>
<a name="ln5909">static int cleanup_suggestions(garray_T *gap, int maxscore, int keep)</a>
<a name="ln5910">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5911">{</a>
<a name="ln5912">  if (gap-&gt;ga_len &gt; 0) {</a>
<a name="ln5913">    // Sort the list.</a>
<a name="ln5914">    qsort(gap-&gt;ga_data, (size_t)gap-&gt;ga_len, sizeof(suggest_T), sug_compare);</a>
<a name="ln5915"> </a>
<a name="ln5916">    // Truncate the list to the number of suggestions that will be displayed.</a>
<a name="ln5917">    if (gap-&gt;ga_len &gt; keep) {</a>
<a name="ln5918">      suggest_T *const stp = &amp;SUG(*gap, 0);</a>
<a name="ln5919"> </a>
<a name="ln5920">      for (int i = keep; i &lt; gap-&gt;ga_len; i++) {</a>
<a name="ln5921">        xfree(stp[i].st_word);</a>
<a name="ln5922">      }</a>
<a name="ln5923">      gap-&gt;ga_len = keep;</a>
<a name="ln5924">      if (keep &gt;= 1) {</a>
<a name="ln5925">        return stp[keep - 1].st_score;</a>
<a name="ln5926">      }</a>
<a name="ln5927">    }</a>
<a name="ln5928">  }</a>
<a name="ln5929">  return maxscore;</a>
<a name="ln5930">}</a>
<a name="ln5931"> </a>
<a name="ln5932">/// Soundfold a string, for soundfold()</a>
<a name="ln5933">///</a>
<a name="ln5934">/// @param[in]  word  Word to soundfold.</a>
<a name="ln5935">///</a>
<a name="ln5936">/// @return [allocated] soundfolded string or NULL in case of error. May return</a>
<a name="ln5937">///                     copy of the input string if soundfolding is not</a>
<a name="ln5938">///                     supported by any of the languages in &amp;spellang.</a>
<a name="ln5939">char *eval_soundfold(const char *const word)</a>
<a name="ln5940">  FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC FUNC_ATTR_NONNULL_ALL</a>
<a name="ln5941">{</a>
<a name="ln5942">  if (curwin-&gt;w_p_spell &amp;&amp; *curwin-&gt;w_s-&gt;b_p_spl != NUL) {</a>
<a name="ln5943">    // Use the sound-folding of the first language that supports it.</a>
<a name="ln5944">    for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; lpi++) {</a>
<a name="ln5945">      langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln5946">      if (!GA_EMPTY(&amp;lp-&gt;lp_slang-&gt;sl_sal)) {</a>
<a name="ln5947">        // soundfold the word</a>
<a name="ln5948">        char_u sound[MAXWLEN];</a>
<a name="ln5949">        spell_soundfold(lp-&gt;lp_slang, (char_u *)word, false, sound);</a>
<a name="ln5950">        return xstrdup((const char *)sound);</a>
<a name="ln5951">      }</a>
<a name="ln5952">    }</a>
<a name="ln5953">  }</a>
<a name="ln5954"> </a>
<a name="ln5955">  // No language with sound folding, return word as-is.</a>
<a name="ln5956">  return xstrdup(word);</a>
<a name="ln5957">}</a>
<a name="ln5958"> </a>
<a name="ln5959">/// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln5960">///</a>
<a name="ln5961">/// There are many ways to turn a word into a sound-a-like representation.  The</a>
<a name="ln5962">/// oldest is Soundex (1918!).   A nice overview can be found in &quot;Approximate</a>
<a name="ln5963">/// swedish name matching - survey and test of different algorithms&quot; by Klas</a>
<a name="ln5964">/// Erikson.</a>
<a name="ln5965">///</a>
<a name="ln5966">/// We support two methods:</a>
<a name="ln5967">/// 1. SOFOFROM/SOFOTO do a simple character mapping.</a>
<a name="ln5968">/// 2. SAL items define a more advanced sound-folding (and much slower).</a>
<a name="ln5969">///</a>
<a name="ln5970">/// @param[in]  slang</a>
<a name="ln5971">/// @param[in]  inword  word to soundfold</a>
<a name="ln5972">/// @param[in]  folded  whether inword is already case-folded</a>
<a name="ln5973">/// @param[in,out]  res  destination for soundfolded word</a>
<a name="ln5974">void spell_soundfold(slang_T *slang, char_u *inword, bool folded, char_u *res)</a>
<a name="ln5975">{</a>
<a name="ln5976">  char_u fword[MAXWLEN];</a>
<a name="ln5977">  char_u *word;</a>
<a name="ln5978"> </a>
<a name="ln5979">  if (slang-&gt;sl_sofo) {</a>
<a name="ln5980">    // SOFOFROM and SOFOTO used</a>
<a name="ln5981">    spell_soundfold_sofo(slang, inword, res);</a>
<a name="ln5982">  } else {</a>
<a name="ln5983">    // SAL items used.  Requires the word to be case-folded.</a>
<a name="ln5984">    if (folded) {</a>
<a name="ln5985">      word = inword;</a>
<a name="ln5986">    } else {</a>
<a name="ln5987">      (void)spell_casefold(curwin, inword, (int)STRLEN(inword), fword, MAXWLEN);</a>
<a name="ln5988">      word = fword;</a>
<a name="ln5989">    }</a>
<a name="ln5990"> </a>
<a name="ln5991">    spell_soundfold_wsal(slang, word, res);</a>
<a name="ln5992">  }</a>
<a name="ln5993">}</a>
<a name="ln5994"> </a>
<a name="ln5995">// Perform sound folding of &quot;inword&quot; into &quot;res&quot; according to SOFOFROM and</a>
<a name="ln5996">// SOFOTO lines.</a>
<a name="ln5997">static void spell_soundfold_sofo(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln5998">{</a>
<a name="ln5999">  int ri = 0;</a>
<a name="ln6000"> </a>
<a name="ln6001">  int prevc = 0;</a>
<a name="ln6002"> </a>
<a name="ln6003">  // The sl_sal_first[] table contains the translation for chars up to</a>
<a name="ln6004">  // 255, sl_sal the rest.</a>
<a name="ln6005">  for (char_u *s = inword; *s != NUL;) {</a>
<a name="ln6006">    int c = mb_cptr2char_adv((const char_u **)&amp;s);</a>
<a name="ln6007">    if (utf_class(c) == 0) {</a>
<a name="ln6008">      c = ' ';</a>
<a name="ln6009">    } else if (c &lt; 256) {</a>
<a name="ln6010">      c = slang-&gt;sl_sal_first[c];</a>
<a name="ln6011">    } else {</a>
<a name="ln6012">      int *ip = ((int **)slang-&gt;sl_sal.ga_data)[c &amp; 0xff];</a>
<a name="ln6013">      if (ip == NULL) {               // empty list, can't match</a>
<a name="ln6014">        c = NUL;</a>
<a name="ln6015">      } else {</a>
<a name="ln6016">        for (;;) {                   // find &quot;c&quot; in the list</a>
<a name="ln6017">          if (*ip == 0) {             // not found</a>
<a name="ln6018">            c = NUL;</a>
<a name="ln6019">            break;</a>
<a name="ln6020">          }</a>
<a name="ln6021">          if (*ip == c) {             // match!</a>
<a name="ln6022">            c = ip[1];</a>
<a name="ln6023">            break;</a>
<a name="ln6024">          }</a>
<a name="ln6025">          ip += 2;</a>
<a name="ln6026">        }</a>
<a name="ln6027">      }</a>
<a name="ln6028">    }</a>
<a name="ln6029"> </a>
<a name="ln6030">    if (c != NUL &amp;&amp; c != prevc) {</a>
<a name="ln6031">      ri += utf_char2bytes(c, (char *)res + ri);</a>
<a name="ln6032">      if (ri + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln6033">        break;</a>
<a name="ln6034">      }</a>
<a name="ln6035">      prevc = c;</a>
<a name="ln6036">    }</a>
<a name="ln6037">  }</a>
<a name="ln6038"> </a>
<a name="ln6039">  res[ri] = NUL;</a>
<a name="ln6040">}</a>
<a name="ln6041"> </a>
<a name="ln6042">// Turn &quot;inword&quot; into its sound-a-like equivalent in &quot;res[MAXWLEN]&quot;.</a>
<a name="ln6043">// Multi-byte version of spell_soundfold().</a>
<a name="ln6044">static void spell_soundfold_wsal(slang_T *slang, char_u *inword, char_u *res)</a>
<a name="ln6045">{</a>
<a name="ln6046">  salitem_T *smp = (salitem_T *)slang-&gt;sl_sal.ga_data;</a>
<a name="ln6047">  int word[MAXWLEN] = { 0 };</a>
<a name="ln6048">  int wres[MAXWLEN] = { 0 };</a>
<a name="ln6049">  int l;</a>
<a name="ln6050">  int *ws;</a>
<a name="ln6051">  int *pf;</a>
<a name="ln6052">  int i, j, z;</a>
<a name="ln6053">  int reslen;</a>
<a name="ln6054">  int n, k = 0;</a>
<a name="ln6055">  int z0;</a>
<a name="ln6056">  int k0;</a>
<a name="ln6057">  int n0;</a>
<a name="ln6058">  int c;</a>
<a name="ln6059">  int pri;</a>
<a name="ln6060">  int p0 = -333;</a>
<a name="ln6061">  int c0;</a>
<a name="ln6062">  bool did_white = false;</a>
<a name="ln6063">  int wordlen;</a>
<a name="ln6064"> </a>
<a name="ln6065">  // Convert the multi-byte string to a wide-character string.</a>
<a name="ln6066">  // Remove accents, if wanted.  We actually remove all non-word characters.</a>
<a name="ln6067">  // But keep white space.</a>
<a name="ln6068">  wordlen = 0;</a>
<a name="ln6069">  for (const char_u *s = inword; *s != NUL;) {</a>
<a name="ln6070">    const char_u *t = s;</a>
<a name="ln6071">    c = mb_cptr2char_adv(&amp;s);</a>
<a name="ln6072">    if (slang-&gt;sl_rem_accents) {</a>
<a name="ln6073">      if (utf_class(c) == 0) {</a>
<a name="ln6074">        if (did_white) {</a>
<a name="ln6075">          continue;</a>
<a name="ln6076">        }</a>
<a name="ln6077">        c = ' ';</a>
<a name="ln6078">        did_white = true;</a>
<a name="ln6079">      } else {</a>
<a name="ln6080">        did_white = false;</a>
<a name="ln6081">        if (!spell_iswordp_nmw(t, curwin)) {</a>
<a name="ln6082">          continue;</a>
<a name="ln6083">        }</a>
<a name="ln6084">      }</a>
<a name="ln6085">    }</a>
<a name="ln6086">    word[wordlen++] = c;</a>
<a name="ln6087">  }</a>
<a name="ln6088">  word[wordlen] = NUL;</a>
<a name="ln6089"> </a>
<a name="ln6090">  // This algorithm comes from Aspell phonet.cpp.</a>
<a name="ln6091">  // Converted from C++ to C.  Added support for multi-byte chars.</a>
<a name="ln6092">  // Changed to keep spaces.</a>
<a name="ln6093">  i = reslen = z = 0;</a>
<a name="ln6094">  while ((c = word[i]) != NUL) {</a>
<a name="ln6095">    // Start with the first rule that has the character in the word.</a>
<a name="ln6096">    n = slang-&gt;sl_sal_first[c &amp; 0xff];</a>
<a name="ln6097">    z0 = 0;</a>
<a name="ln6098"> </a>
<a name="ln6099">    if (n &gt;= 0) {</a>
<a name="ln6100">      // Check all rules for the same index byte.</a>
<a name="ln6101">      // If c is 0x300 need extra check for the end of the array, as</a>
<a name="ln6102">      // (c &amp; 0xff) is NUL.</a>
<a name="ln6103">      for (; ((ws = smp[n].sm_lead_w)[0] &amp; 0xff) == (c &amp; 0xff)</a>
<a name="ln6104">           &amp;&amp; ws[0] != NUL; ++n) {</a>
<a name="ln6105">        // Quickly skip entries that don't match the word.  Most</a>
<a name="ln6106">        // entries are less than three chars, optimize for that.</a>
<a name="ln6107">        if (c != ws[0]) {</a>
<a name="ln6108">          continue;</a>
<a name="ln6109">        }</a>
<a name="ln6110">        k = smp[n].sm_leadlen;</a>
<a name="ln6111">        if (k &gt; 1) {</a>
<a name="ln6112">          if (word[i + 1] != ws[1]) {</a>
<a name="ln6113">            continue;</a>
<a name="ln6114">          }</a>
<a name="ln6115">          if (k &gt; 2) {</a>
<a name="ln6116">            for (j = 2; j &lt; k; ++j) {</a>
<a name="ln6117">              if (word[i + j] != ws[j]) {</a>
<a name="ln6118">                break;</a>
<a name="ln6119">              }</a>
<a name="ln6120">            }</a>
<a name="ln6121">            if (j &lt; k) {</a>
<a name="ln6122">              continue;</a>
<a name="ln6123">            }</a>
<a name="ln6124">          }</a>
<a name="ln6125">        }</a>
<a name="ln6126"> </a>
<a name="ln6127">        if ((pf = smp[n].sm_oneof_w) != NULL) {</a>
<a name="ln6128">          // Check for match with one of the chars in &quot;sm_oneof&quot;.</a>
<a name="ln6129">          while (*pf != NUL &amp;&amp; *pf != word[i + k]) {</a>
<a name="ln6130">            ++pf;</a>
<a name="ln6131">          }</a>
<a name="ln6132">          if (*pf == NUL) {</a>
<a name="ln6133">            continue;</a>
<a name="ln6134">          }</a>
<a name="ln6135">          ++k;</a>
<a name="ln6136">        }</a>
<a name="ln6137">        char_u *s = smp[n].sm_rules;</a>
<a name="ln6138">        pri = 5;            // default priority</a>
<a name="ln6139"> </a>
<a name="ln6140">        p0 = *s;</a>
<a name="ln6141">        k0 = k;</a>
<a name="ln6142">        while (*s == '-' &amp;&amp; k &gt; 1) {</a>
<a name="ln6143">          k--;</a>
<a name="ln6144">          s++;</a>
<a name="ln6145">        }</a>
<a name="ln6146">        if (*s == '&lt;') {</a>
<a name="ln6147">          s++;</a>
<a name="ln6148">        }</a>
<a name="ln6149">        if (ascii_isdigit(*s)) {</a>
<a name="ln6150">          // determine priority</a>
<a name="ln6151">          pri = *s - '0';</a>
<a name="ln6152">          s++;</a>
<a name="ln6153">        }</a>
<a name="ln6154">        if (*s == '^' &amp;&amp; *(s + 1) == '^') {</a>
<a name="ln6155">          s++;</a>
<a name="ln6156">        }</a>
<a name="ln6157"> </a>
<a name="ln6158">        if (*s == NUL</a>
<a name="ln6159">            || (*s == '^'</a>
<a name="ln6160">                &amp;&amp; (i == 0 || !(word[i - 1] == ' '</a>
<a name="ln6161">                                || spell_iswordp_w(word + i - 1, curwin)))</a>
<a name="ln6162">                &amp;&amp; (*(s + 1) != '$'</a>
<a name="ln6163">                    || (!spell_iswordp_w(word + i + k0, curwin))))</a>
<a name="ln6164">            || (*s == '$' &amp;&amp; i &gt; 0</a>
<a name="ln6165">                &amp;&amp; spell_iswordp_w(word + i - 1, curwin)</a>
<a name="ln6166">                &amp;&amp; (!spell_iswordp_w(word + i + k0, curwin)))) {</a>
<a name="ln6167">          // search for followup rules, if:</a>
<a name="ln6168">          // followup and k &gt; 1  and  NO '-' in searchstring</a>
<a name="ln6169">          c0 = word[i + k - 1];</a>
<a name="ln6170">          n0 = slang-&gt;sl_sal_first[c0 &amp; 0xff];</a>
<a name="ln6171"> </a>
<a name="ln6172">          if (slang-&gt;sl_followup &amp;&amp; k &gt; 1 &amp;&amp; n0 &gt;= 0</a>
<a name="ln6173">              &amp;&amp; p0 != '-' &amp;&amp; word[i + k] != NUL) {</a>
<a name="ln6174">            // Test follow-up rule for &quot;word[i + k]&quot;; loop over</a>
<a name="ln6175">            // all entries with the same index byte.</a>
<a name="ln6176">            for (; ((ws = smp[n0].sm_lead_w)[0] &amp; 0xff)</a>
<a name="ln6177">                 == (c0 &amp; 0xff); ++n0) {</a>
<a name="ln6178">              // Quickly skip entries that don't match the word.</a>
<a name="ln6179">              if (c0 != ws[0]) {</a>
<a name="ln6180">                continue;</a>
<a name="ln6181">              }</a>
<a name="ln6182">              k0 = smp[n0].sm_leadlen;</a>
<a name="ln6183">              if (k0 &gt; 1) {</a>
<a name="ln6184">                if (word[i + k] != ws[1]) {</a>
<a name="ln6185">                  continue;</a>
<a name="ln6186">                }</a>
<a name="ln6187">                if (k0 &gt; 2) {</a>
<a name="ln6188">                  pf = word + i + k + 1;</a>
<a name="ln6189">                  for (j = 2; j &lt; k0; ++j) {</a>
<a name="ln6190">                    if (*pf++ != ws[j]) {</a>
<a name="ln6191">                      break;</a>
<a name="ln6192">                    }</a>
<a name="ln6193">                  }</a>
<a name="ln6194">                  if (j &lt; k0) {</a>
<a name="ln6195">                    continue;</a>
<a name="ln6196">                  }</a>
<a name="ln6197">                }</a>
<a name="ln6198">              }</a>
<a name="ln6199">              k0 += k - 1;</a>
<a name="ln6200"> </a>
<a name="ln6201">              if ((pf = smp[n0].sm_oneof_w) != NULL) {</a>
<a name="ln6202">                // Check for match with one of the chars in</a>
<a name="ln6203">                // &quot;sm_oneof&quot;.</a>
<a name="ln6204">                while (*pf != NUL &amp;&amp; *pf != word[i + k0]) {</a>
<a name="ln6205">                  ++pf;</a>
<a name="ln6206">                }</a>
<a name="ln6207">                if (*pf == NUL) {</a>
<a name="ln6208">                  continue;</a>
<a name="ln6209">                }</a>
<a name="ln6210">                ++k0;</a>
<a name="ln6211">              }</a>
<a name="ln6212"> </a>
<a name="ln6213">              p0 = 5;</a>
<a name="ln6214">              s = smp[n0].sm_rules;</a>
<a name="ln6215">              while (*s == '-') {</a>
<a name="ln6216">                // &quot;k0&quot; gets NOT reduced because</a>
<a name="ln6217">                // &quot;if (k0 == k)&quot;</a>
<a name="ln6218">                s++;</a>
<a name="ln6219">              }</a>
<a name="ln6220">              if (*s == '&lt;') {</a>
<a name="ln6221">                s++;</a>
<a name="ln6222">              }</a>
<a name="ln6223">              if (ascii_isdigit(*s)) {</a>
<a name="ln6224">                p0 = *s - '0';</a>
<a name="ln6225">                s++;</a>
<a name="ln6226">              }</a>
<a name="ln6227"> </a>
<a name="ln6228">              if (*s == NUL</a>
<a name="ln6229">                  // *s == '^' cuts</a>
<a name="ln6230">                  || (*s == '$'</a>
<a name="ln6231">                      &amp;&amp; !spell_iswordp_w(word + i + k0,</a>
<a name="ln6232">                                          curwin))) {</a>
<a name="ln6233">                if (k0 == k) {</a>
<a name="ln6234">                  // this is just a piece of the string</a>
<a name="ln6235">                  continue;</a>
<a name="ln6236">                }</a>
<a name="ln6237"> </a>
<a name="ln6238">                if (p0 &lt; pri) {</a>
<a name="ln6239">                  // priority too low</a>
<a name="ln6240">                  continue;</a>
<a name="ln6241">                }</a>
<a name="ln6242">                // rule fits; stop search</a>
<a name="ln6243">                break;</a>
<a name="ln6244">              }</a>
<a name="ln6245">            }</a>
<a name="ln6246"> </a>
<a name="ln6247">            if (p0 &gt;= pri &amp;&amp; (smp[n0].sm_lead_w[0] &amp; 0xff)</a>
<a name="ln6248">                == (c0 &amp; 0xff)) {</a>
<a name="ln6249">              continue;</a>
<a name="ln6250">            }</a>
<a name="ln6251">          }</a>
<a name="ln6252"> </a>
<a name="ln6253">          // replace string</a>
<a name="ln6254">          ws = smp[n].sm_to_w;</a>
<a name="ln6255">          s = smp[n].sm_rules;</a>
<a name="ln6256">          p0 = (vim_strchr((char *)s, '&lt;') != NULL) ? 1 : 0;</a>
<a name="ln6257">          if (p0 == 1 &amp;&amp; z == 0) {</a>
<a name="ln6258">            // rule with '&lt;' is used</a>
<a name="ln6259">            if (reslen &gt; 0 &amp;&amp; ws != NULL &amp;&amp; *ws != NUL</a>
<a name="ln6260">                &amp;&amp; (wres[reslen - 1] == c</a>
<a name="ln6261">                    || wres[reslen - 1] == *ws)) {</a>
<a name="ln6262">              reslen--;</a>
<a name="ln6263">            }</a>
<a name="ln6264">            z0 = 1;</a>
<a name="ln6265">            z = 1;</a>
<a name="ln6266">            k0 = 0;</a>
<a name="ln6267">            if (ws != NULL) {</a>
<a name="ln6268">              while (*ws != NUL &amp;&amp; word[i + k0] != NUL) {</a>
<a name="ln6269">                word[i + k0] = *ws;</a>
<a name="ln6270">                k0++;</a>
<a name="ln6271">                ws++;</a>
<a name="ln6272">              }</a>
<a name="ln6273">            }</a>
<a name="ln6274">            if (k &gt; k0) {</a>
<a name="ln6275">              memmove(word + i + k0, word + i + k,</a>
<a name="ln6276">                      sizeof(int) * (wordlen - (i + k) + 1));</a>
<a name="ln6277">            }</a>
<a name="ln6278"> </a>
<a name="ln6279">            // new &quot;actual letter&quot;</a>
<a name="ln6280">            c = word[i];</a>
<a name="ln6281">          } else {</a>
<a name="ln6282">            // no '&lt;' rule used</a>
<a name="ln6283">            i += k - 1;</a>
<a name="ln6284">            z = 0;</a>
<a name="ln6285">            if (ws != NULL) {</a>
<a name="ln6286">              while (*ws != NUL &amp;&amp; ws[1] != NUL</a>
<a name="ln6287">                     &amp;&amp; reslen &lt; MAXWLEN) {</a>
<a name="ln6288">                if (reslen == 0 || wres[reslen - 1] != *ws) {</a>
<a name="ln6289">                  wres[reslen++] = *ws;</a>
<a name="ln6290">                }</a>
<a name="ln6291">                ws++;</a>
<a name="ln6292">              }</a>
<a name="ln6293">            }</a>
<a name="ln6294">            // new &quot;actual letter&quot;</a>
<a name="ln6295">            if (ws == NULL) {</a>
<a name="ln6296">              c = NUL;</a>
<a name="ln6297">            } else {</a>
<a name="ln6298">              c = *ws;</a>
<a name="ln6299">            }</a>
<a name="ln6300">            if (strstr((char *)s, &quot;^^&quot;) != NULL) {</a>
<a name="ln6301">              if (c != NUL) {</a>
<a name="ln6302">                wres[reslen++] = c;</a>
<a name="ln6303">              }</a>
<a name="ln6304">              memmove(word, word + i + 1,</a>
<a name="ln6305">                      sizeof(int) * (wordlen - (i + 1) + 1));</a>
<a name="ln6306">              i = 0;</a>
<a name="ln6307">              z0 = 1;</a>
<a name="ln6308">            }</a>
<a name="ln6309">          }</a>
<a name="ln6310">          break;</a>
<a name="ln6311">        }</a>
<a name="ln6312">      }</a>
<a name="ln6313">    } else if (ascii_iswhite(c)) {</a>
<a name="ln6314">      c = ' ';</a>
<a name="ln6315">      k = 1;</a>
<a name="ln6316">    }</a>
<a name="ln6317"> </a>
<a name="ln6318">    if (z0 == 0) {</a>
<a name="ln6319">      if (k &amp;&amp; !p0 &amp;&amp; reslen &lt; MAXWLEN &amp;&amp; c != NUL</a>
<a name="ln6320">          &amp;&amp; (!slang-&gt;sl_collapse || reslen == 0</a>
<a name="ln6321">              || wres[reslen - 1] != c)) {</a>
<a name="ln6322">        // condense only double letters</a>
<a name="ln6323">        wres[reslen++] = c;</a>
<a name="ln6324">      }</a>
<a name="ln6325"> </a>
<a name="ln6326">      i++;</a>
<a name="ln6327">      z = 0;</a>
<a name="ln6328">      k = 0;</a>
<a name="ln6329">    }</a>
<a name="ln6330">  }</a>
<a name="ln6331"> </a>
<a name="ln6332">  // Convert wide characters in &quot;wres&quot; to a multi-byte string in &quot;res&quot;.</a>
<a name="ln6333">  l = 0;</a>
<a name="ln6334">  for (n = 0; n &lt; reslen; n++) {</a>
<a name="ln6335">    l += utf_char2bytes(wres[n], (char *)res + l);</a>
<a name="ln6336">    if (l + MB_MAXBYTES &gt; MAXWLEN) {</a>
<a name="ln6337">      break;</a>
<a name="ln6338">    }</a>
<a name="ln6339">  }</a>
<a name="ln6340">  res[l] = NUL;</a>
<a name="ln6341">}</a>
<a name="ln6342"> </a>
<a name="ln6343">/// Compute a score for two sound-a-like words.</a>
<a name="ln6344">/// This permits up to two inserts/deletes/swaps/etc. to keep things fast.</a>
<a name="ln6345">/// Instead of a generic loop we write out the code.  That keeps it fast by</a>
<a name="ln6346">/// avoiding checks that will not be possible.</a>
<a name="ln6347">///</a>
<a name="ln6348">/// @param goodstart  sound-folded good word</a>
<a name="ln6349">/// @param badstart  sound-folded bad word</a>
<a name="ln6350">static int soundalike_score(char_u *goodstart, char_u *badstart)</a>
<a name="ln6351">{</a>
<a name="ln6352">  char_u *goodsound = goodstart;</a>
<a name="ln6353">  char_u *badsound = badstart;</a>
<a name="ln6354">  int goodlen;</a>
<a name="ln6355">  int badlen;</a>
<a name="ln6356">  int n;</a>
<a name="ln6357">  char_u *pl, *ps;</a>
<a name="ln6358">  char_u *pl2, *ps2;</a>
<a name="ln6359">  int score = 0;</a>
<a name="ln6360"> </a>
<a name="ln6361">  // Adding/inserting &quot;*&quot; at the start (word starts with vowel) shouldn't be</a>
<a name="ln6362">  // counted so much, vowels in the middle of the word aren't counted at all.</a>
<a name="ln6363">  if ((*badsound == '*' || *goodsound == '*') &amp;&amp; *badsound != *goodsound) {</a>
<a name="ln6364">    if ((badsound[0] == NUL &amp;&amp; goodsound[1] == NUL)</a>
<a name="ln6365">        || (goodsound[0] == NUL &amp;&amp; badsound[1] == NUL)) {</a>
<a name="ln6366">      // changing word with vowel to word without a sound</a>
<a name="ln6367">      return SCORE_DEL;</a>
<a name="ln6368">    }</a>
<a name="ln6369">    if (badsound[0] == NUL || goodsound[0] == NUL) {</a>
<a name="ln6370">      // more than two changes</a>
<a name="ln6371">      return SCORE_MAXMAX;</a>
<a name="ln6372">    }</a>
<a name="ln6373"> </a>
<a name="ln6374">    if (badsound[1] == goodsound[1]</a>
<a name="ln6375">        || (badsound[1] != NUL</a>
<a name="ln6376">            &amp;&amp; goodsound[1] != NUL</a>
<a name="ln6377">            &amp;&amp; badsound[2] == goodsound[2])) {</a>
<a name="ln6378">      // handle like a substitute</a>
<a name="ln6379">    } else {</a>
<a name="ln6380">      score = 2 * SCORE_DEL / 3;</a>
<a name="ln6381">      if (*badsound == '*') {</a>
<a name="ln6382">        ++badsound;</a>
<a name="ln6383">      } else {</a>
<a name="ln6384">        ++goodsound;</a>
<a name="ln6385">      }</a>
<a name="ln6386">    }</a>
<a name="ln6387">  }</a>
<a name="ln6388"> </a>
<a name="ln6389">  goodlen = (int)STRLEN(goodsound);</a>
<a name="ln6390">  badlen = (int)STRLEN(badsound);</a>
<a name="ln6391"> </a>
<a name="ln6392">  // Return quickly if the lengths are too different to be fixed by two</a>
<a name="ln6393">  // changes.</a>
<a name="ln6394">  n = goodlen - badlen;</a>
<a name="ln6395">  if (n &lt; -2 || n &gt; 2) {</a>
<a name="ln6396">    return SCORE_MAXMAX;</a>
<a name="ln6397">  }</a>
<a name="ln6398"> </a>
<a name="ln6399">  if (n &gt; 0) {</a>
<a name="ln6400">    pl = goodsound;         // goodsound is longest</a>
<a name="ln6401">    ps = badsound;</a>
<a name="ln6402">  } else {</a>
<a name="ln6403">    pl = badsound;          // badsound is longest</a>
<a name="ln6404">    ps = goodsound;</a>
<a name="ln6405">  }</a>
<a name="ln6406"> </a>
<a name="ln6407">  // Skip over the identical part.</a>
<a name="ln6408">  while (*pl == *ps &amp;&amp; *pl != NUL) {</a>
<a name="ln6409">    ++pl;</a>
<a name="ln6410">    ++ps;</a>
<a name="ln6411">  }</a>
<a name="ln6412"> </a>
<a name="ln6413">  switch (n) {</a>
<a name="ln6414">  case -2:</a>
<a name="ln6415">  case 2:</a>
<a name="ln6416">    // Must delete two characters from &quot;pl&quot;.</a>
<a name="ln6417">    ++pl;               // first delete</a>
<a name="ln6418">    while (*pl == *ps) {</a>
<a name="ln6419">      ++pl;</a>
<a name="ln6420">      ++ps;</a>
<a name="ln6421">    }</a>
<a name="ln6422">    // strings must be equal after second delete</a>
<a name="ln6423">    if (STRCMP(pl + 1, ps) == 0) {</a>
<a name="ln6424">      return score + SCORE_DEL * 2;</a>
<a name="ln6425">    }</a>
<a name="ln6426"> </a>
<a name="ln6427">    // Failed to compare.</a>
<a name="ln6428">    break;</a>
<a name="ln6429"> </a>
<a name="ln6430">  case -1:</a>
<a name="ln6431">  case 1:</a>
<a name="ln6432">    // Minimal one delete from &quot;pl&quot; required.</a>
<a name="ln6433"> </a>
<a name="ln6434">    // 1: delete</a>
<a name="ln6435">    pl2 = pl + 1;</a>
<a name="ln6436">    ps2 = ps;</a>
<a name="ln6437">    while (*pl2 == *ps2) {</a>
<a name="ln6438">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln6439">        return score + SCORE_DEL;</a>
<a name="ln6440">      }</a>
<a name="ln6441">      ++pl2;</a>
<a name="ln6442">      ++ps2;</a>
<a name="ln6443">    }</a>
<a name="ln6444"> </a>
<a name="ln6445">    // 2: delete then swap, then rest must be equal</a>
<a name="ln6446">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6447">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln6448">      return score + SCORE_DEL + SCORE_SWAP;</a>
<a name="ln6449">    }</a>
<a name="ln6450"> </a>
<a name="ln6451">    // 3: delete then substitute, then the rest must be equal</a>
<a name="ln6452">    if (STRCMP(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln6453">      return score + SCORE_DEL + SCORE_SUBST;</a>
<a name="ln6454">    }</a>
<a name="ln6455"> </a>
<a name="ln6456">    // 4: first swap then delete</a>
<a name="ln6457">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6458">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6459">      ps2 = ps + 2;</a>
<a name="ln6460">      while (*pl2 == *ps2) {</a>
<a name="ln6461">        ++pl2;</a>
<a name="ln6462">        ++ps2;</a>
<a name="ln6463">      }</a>
<a name="ln6464">      // delete a char and then strings must be equal</a>
<a name="ln6465">      if (STRCMP(pl2 + 1, ps2) == 0) {</a>
<a name="ln6466">        return score + SCORE_SWAP + SCORE_DEL;</a>
<a name="ln6467">      }</a>
<a name="ln6468">    }</a>
<a name="ln6469"> </a>
<a name="ln6470">    // 5: first substitute then delete</a>
<a name="ln6471">    pl2 = pl + 1;                   // substitute, skip one char</a>
<a name="ln6472">    ps2 = ps + 1;</a>
<a name="ln6473">    while (*pl2 == *ps2) {</a>
<a name="ln6474">      ++pl2;</a>
<a name="ln6475">      ++ps2;</a>
<a name="ln6476">    }</a>
<a name="ln6477">    // delete a char and then strings must be equal</a>
<a name="ln6478">    if (STRCMP(pl2 + 1, ps2) == 0) {</a>
<a name="ln6479">      return score + SCORE_SUBST + SCORE_DEL;</a>
<a name="ln6480">    }</a>
<a name="ln6481"> </a>
<a name="ln6482">    // Failed to compare.</a>
<a name="ln6483">    break;</a>
<a name="ln6484"> </a>
<a name="ln6485">  case 0:</a>
<a name="ln6486">    // Lengths are equal, thus changes must result in same length: An</a>
<a name="ln6487">    // insert is only possible in combination with a delete.</a>
<a name="ln6488">    // 1: check if for identical strings</a>
<a name="ln6489">    if (*pl == NUL) {</a>
<a name="ln6490">      return score;</a>
<a name="ln6491">    }</a>
<a name="ln6492"> </a>
<a name="ln6493">    // 2: swap</a>
<a name="ln6494">    if (pl[0] == ps[1] &amp;&amp; pl[1] == ps[0]) {</a>
<a name="ln6495">      pl2 = pl + 2;                 // swap, skip two chars</a>
<a name="ln6496">      ps2 = ps + 2;</a>
<a name="ln6497">      while (*pl2 == *ps2) {</a>
<a name="ln6498">        if (*pl2 == NUL) {              // reached the end</a>
<a name="ln6499">          return score + SCORE_SWAP;</a>
<a name="ln6500">        }</a>
<a name="ln6501">        ++pl2;</a>
<a name="ln6502">        ++ps2;</a>
<a name="ln6503">      }</a>
<a name="ln6504">      // 3: swap and swap again</a>
<a name="ln6505">      if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6506">          &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln6507">        return score + SCORE_SWAP + SCORE_SWAP;</a>
<a name="ln6508">      }</a>
<a name="ln6509"> </a>
<a name="ln6510">      // 4: swap and substitute</a>
<a name="ln6511">      if (STRCMP(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln6512">        return score + SCORE_SWAP + SCORE_SUBST;</a>
<a name="ln6513">      }</a>
<a name="ln6514">    }</a>
<a name="ln6515"> </a>
<a name="ln6516">    // 5: substitute</a>
<a name="ln6517">    pl2 = pl + 1;</a>
<a name="ln6518">    ps2 = ps + 1;</a>
<a name="ln6519">    while (*pl2 == *ps2) {</a>
<a name="ln6520">      if (*pl2 == NUL) {                // reached the end</a>
<a name="ln6521">        return score + SCORE_SUBST;</a>
<a name="ln6522">      }</a>
<a name="ln6523">      ++pl2;</a>
<a name="ln6524">      ++ps2;</a>
<a name="ln6525">    }</a>
<a name="ln6526"> </a>
<a name="ln6527">    // 6: substitute and swap</a>
<a name="ln6528">    if (pl2[0] == ps2[1] &amp;&amp; pl2[1] == ps2[0]</a>
<a name="ln6529">        &amp;&amp; STRCMP(pl2 + 2, ps2 + 2) == 0) {</a>
<a name="ln6530">      return score + SCORE_SUBST + SCORE_SWAP;</a>
<a name="ln6531">    }</a>
<a name="ln6532"> </a>
<a name="ln6533">    // 7: substitute and substitute</a>
<a name="ln6534">    if (STRCMP(pl2 + 1, ps2 + 1) == 0) {</a>
<a name="ln6535">      return score + SCORE_SUBST + SCORE_SUBST;</a>
<a name="ln6536">    }</a>
<a name="ln6537"> </a>
<a name="ln6538">    // 8: insert then delete</a>
<a name="ln6539">    pl2 = pl;</a>
<a name="ln6540">    ps2 = ps + 1;</a>
<a name="ln6541">    while (*pl2 == *ps2) {</a>
<a name="ln6542">      ++pl2;</a>
<a name="ln6543">      ++ps2;</a>
<a name="ln6544">    }</a>
<a name="ln6545">    if (STRCMP(pl2 + 1, ps2) == 0) {</a>
<a name="ln6546">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6547">    }</a>
<a name="ln6548"> </a>
<a name="ln6549">    // 9: delete then insert</a>
<a name="ln6550">    pl2 = pl + 1;</a>
<a name="ln6551">    ps2 = ps;</a>
<a name="ln6552">    while (*pl2 == *ps2) {</a>
<a name="ln6553">      ++pl2;</a>
<a name="ln6554">      ++ps2;</a>
<a name="ln6555">    }</a>
<a name="ln6556">    if (STRCMP(pl2, ps2 + 1) == 0) {</a>
<a name="ln6557">      return score + SCORE_INS + SCORE_DEL;</a>
<a name="ln6558">    }</a>
<a name="ln6559"> </a>
<a name="ln6560">    // Failed to compare.</a>
<a name="ln6561">    break;</a>
<a name="ln6562">  }</a>
<a name="ln6563"> </a>
<a name="ln6564">  return SCORE_MAXMAX;</a>
<a name="ln6565">}</a>
<a name="ln6566"> </a>
<a name="ln6567">// Compute the &quot;edit distance&quot; to turn &quot;badword&quot; into &quot;goodword&quot;.  The less</a>
<a name="ln6568">// deletes/inserts/substitutes/swaps are required the lower the score.</a>
<a name="ln6569">//</a>
<a name="ln6570">// The algorithm is described by Du and Chang, 1992.</a>
<a name="ln6571">// The implementation of the algorithm comes from Aspell editdist.cpp,</a>
<a name="ln6572">// edit_distance().  It has been converted from C++ to C and modified to</a>
<a name="ln6573">// support multi-byte characters.</a>
<a name="ln6574">static int spell_edit_score(slang_T *slang, char_u *badword, char_u *goodword)</a>
<a name="ln6575">{</a>
<a name="ln6576">  int *cnt;</a>
<a name="ln6577">  int j, i;</a>
<a name="ln6578">  int t;</a>
<a name="ln6579">  int bc, gc;</a>
<a name="ln6580">  int pbc, pgc;</a>
<a name="ln6581">  int wbadword[MAXWLEN];</a>
<a name="ln6582">  int wgoodword[MAXWLEN];</a>
<a name="ln6583"> </a>
<a name="ln6584">  // Lengths with NUL.</a>
<a name="ln6585">  int badlen;</a>
<a name="ln6586">  int goodlen;</a>
<a name="ln6587">  {</a>
<a name="ln6588">    // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6589">    // int array for easy access.</a>
<a name="ln6590">    badlen = 0;</a>
<a name="ln6591">    for (const char_u *p = badword; *p != NUL;) {</a>
<a name="ln6592">      wbadword[badlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6593">    }</a>
<a name="ln6594">    wbadword[badlen++] = 0;</a>
<a name="ln6595">    goodlen = 0;</a>
<a name="ln6596">    for (const char_u *p = goodword; *p != NUL;) {</a>
<a name="ln6597">      wgoodword[goodlen++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6598">    }</a>
<a name="ln6599">    wgoodword[goodlen++] = 0;</a>
<a name="ln6600">  }</a>
<a name="ln6601"> </a>
<a name="ln6602">  // We use &quot;cnt&quot; as an array: CNT(badword_idx, goodword_idx).</a>
<a name="ln6603">#define CNT(a, b)   cnt[(a) + (b) * (badlen + 1)]</a>
<a name="ln6604">  cnt = xmalloc(sizeof(int) * (badlen + 1) * (goodlen + 1));</a>
<a name="ln6605"> </a>
<a name="ln6606">  CNT(0, 0) = 0;</a>
<a name="ln6607">  for (j = 1; j &lt;= goodlen; ++j) {</a>
<a name="ln6608">    CNT(0, j) = CNT(0, j - 1) + SCORE_INS;</a>
<a name="ln6609">  }</a>
<a name="ln6610"> </a>
<a name="ln6611">  for (i = 1; i &lt;= badlen; ++i) {</a>
<a name="ln6612">    CNT(i, 0) = CNT(i - 1, 0) + SCORE_DEL;</a>
<a name="ln6613">    for (j = 1; j &lt;= goodlen; j++) {</a>
<a name="ln6614">      bc = wbadword[i - 1];</a>
<a name="ln6615">      gc = wgoodword[j - 1];</a>
<a name="ln6616">      if (bc == gc) {</a>
<a name="ln6617">        CNT(i, j) = CNT(i - 1, j - 1);</a>
<a name="ln6618">      } else {</a>
<a name="ln6619">        // Use a better score when there is only a case difference.</a>
<a name="ln6620">        if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln6621">          CNT(i, j) = SCORE_ICASE + CNT(i - 1, j - 1);</a>
<a name="ln6622">        } else {</a>
<a name="ln6623">          // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6624">          if (slang != NULL</a>
<a name="ln6625">              &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6626">              &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln6627">            CNT(i, j) = SCORE_SIMILAR + CNT(i - 1, j - 1);</a>
<a name="ln6628">          } else {</a>
<a name="ln6629">            CNT(i, j) = SCORE_SUBST + CNT(i - 1, j - 1);</a>
<a name="ln6630">          }</a>
<a name="ln6631">        }</a>
<a name="ln6632"> </a>
<a name="ln6633">        if (i &gt; 1 &amp;&amp; j &gt; 1) {</a>
<a name="ln6634">          pbc = wbadword[i - 2];</a>
<a name="ln6635">          pgc = wgoodword[j - 2];</a>
<a name="ln6636">          if (bc == pgc &amp;&amp; pbc == gc) {</a>
<a name="ln6637">            t = SCORE_SWAP + CNT(i - 2, j - 2);</a>
<a name="ln6638">            if (t &lt; CNT(i, j)) {</a>
<a name="ln6639">              CNT(i, j) = t;</a>
<a name="ln6640">            }</a>
<a name="ln6641">          }</a>
<a name="ln6642">        }</a>
<a name="ln6643">        t = SCORE_DEL + CNT(i - 1, j);</a>
<a name="ln6644">        if (t &lt; CNT(i, j)) {</a>
<a name="ln6645">          CNT(i, j) = t;</a>
<a name="ln6646">        }</a>
<a name="ln6647">        t = SCORE_INS + CNT(i, j - 1);</a>
<a name="ln6648">        if (t &lt; CNT(i, j)) {</a>
<a name="ln6649">          CNT(i, j) = t;</a>
<a name="ln6650">        }</a>
<a name="ln6651">      }</a>
<a name="ln6652">    }</a>
<a name="ln6653">  }</a>
<a name="ln6654"> </a>
<a name="ln6655">  i = CNT(badlen - 1, goodlen - 1);</a>
<a name="ln6656">  xfree(cnt);</a>
<a name="ln6657">  return i;</a>
<a name="ln6658">}</a>
<a name="ln6659"> </a>
<a name="ln6660">// Like spell_edit_score(), but with a limit on the score to make it faster.</a>
<a name="ln6661">// May return SCORE_MAXMAX when the score is higher than &quot;limit&quot;.</a>
<a name="ln6662">//</a>
<a name="ln6663">// This uses a stack for the edits still to be tried.</a>
<a name="ln6664">// The idea comes from Aspell leditdist.cpp.  Rewritten in C and added support</a>
<a name="ln6665">// for multi-byte characters.</a>
<a name="ln6666">static int spell_edit_score_limit(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6667">{</a>
<a name="ln6668">  return spell_edit_score_limit_w(slang, badword, goodword, limit);</a>
<a name="ln6669">}</a>
<a name="ln6670"> </a>
<a name="ln6671">// Multi-byte version of spell_edit_score_limit().</a>
<a name="ln6672">// Keep it in sync with the above!</a>
<a name="ln6673">static int spell_edit_score_limit_w(slang_T *slang, char_u *badword, char_u *goodword, int limit)</a>
<a name="ln6674">{</a>
<a name="ln6675">  limitscore_T stack[10];               // allow for over 3 * 2 edits</a>
<a name="ln6676">  int stackidx;</a>
<a name="ln6677">  int bi, gi;</a>
<a name="ln6678">  int bi2, gi2;</a>
<a name="ln6679">  int bc, gc;</a>
<a name="ln6680">  int score;</a>
<a name="ln6681">  int score_off;</a>
<a name="ln6682">  int minscore;</a>
<a name="ln6683">  int round;</a>
<a name="ln6684">  int wbadword[MAXWLEN];</a>
<a name="ln6685">  int wgoodword[MAXWLEN];</a>
<a name="ln6686"> </a>
<a name="ln6687">  // Get the characters from the multi-byte strings and put them in an</a>
<a name="ln6688">  // int array for easy access.</a>
<a name="ln6689">  bi = 0;</a>
<a name="ln6690">  for (const char_u *p = badword; *p != NUL;) {</a>
<a name="ln6691">    wbadword[bi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6692">  }</a>
<a name="ln6693">  wbadword[bi++] = 0;</a>
<a name="ln6694">  gi = 0;</a>
<a name="ln6695">  for (const char_u *p = goodword; *p != NUL;) {</a>
<a name="ln6696">    wgoodword[gi++] = mb_cptr2char_adv(&amp;p);</a>
<a name="ln6697">  }</a>
<a name="ln6698">  wgoodword[gi++] = 0;</a>
<a name="ln6699"> </a>
<a name="ln6700">  // The idea is to go from start to end over the words.  So long as</a>
<a name="ln6701">  // characters are equal just continue, this always gives the lowest score.</a>
<a name="ln6702">  // When there is a difference try several alternatives.  Each alternative</a>
<a name="ln6703">  // increases &quot;score&quot; for the edit distance.  Some of the alternatives are</a>
<a name="ln6704">  // pushed unto a stack and tried later, some are tried right away.  At the</a>
<a name="ln6705">  // end of the word the score for one alternative is known.  The lowest</a>
<a name="ln6706">  // possible score is stored in &quot;minscore&quot;.</a>
<a name="ln6707">  stackidx = 0;</a>
<a name="ln6708">  bi = 0;</a>
<a name="ln6709">  gi = 0;</a>
<a name="ln6710">  score = 0;</a>
<a name="ln6711">  minscore = limit + 1;</a>
<a name="ln6712"> </a>
<a name="ln6713">  for (;;) {</a>
<a name="ln6714">    // Skip over an equal part, score remains the same.</a>
<a name="ln6715">    for (;;) {</a>
<a name="ln6716">      bc = wbadword[bi];</a>
<a name="ln6717">      gc = wgoodword[gi];</a>
<a name="ln6718"> </a>
<a name="ln6719">      if (bc != gc) {           // stop at a char that's different</a>
<a name="ln6720">        break;</a>
<a name="ln6721">      }</a>
<a name="ln6722">      if (bc == NUL) {          // both words end</a>
<a name="ln6723">        if (score &lt; minscore) {</a>
<a name="ln6724">          minscore = score;</a>
<a name="ln6725">        }</a>
<a name="ln6726">        goto pop;               // do next alternative</a>
<a name="ln6727">      }</a>
<a name="ln6728">      ++bi;</a>
<a name="ln6729">      ++gi;</a>
<a name="ln6730">    }</a>
<a name="ln6731"> </a>
<a name="ln6732">    if (gc == NUL) {      // goodword ends, delete badword chars</a>
<a name="ln6733">      do {</a>
<a name="ln6734">        if ((score += SCORE_DEL) &gt;= minscore) {</a>
<a name="ln6735">          goto pop;                 // do next alternative</a>
<a name="ln6736">        }</a>
<a name="ln6737">      } while (wbadword[++bi] != NUL);</a>
<a name="ln6738">      minscore = score;</a>
<a name="ln6739">    } else if (bc == NUL) {   // badword ends, insert badword chars</a>
<a name="ln6740">      do {</a>
<a name="ln6741">        if ((score += SCORE_INS) &gt;= minscore) {</a>
<a name="ln6742">          goto pop;                 // do next alternative</a>
<a name="ln6743">        }</a>
<a name="ln6744">      } while (wgoodword[++gi] != NUL);</a>
<a name="ln6745">      minscore = score;</a>
<a name="ln6746">    } else {                  // both words continue</a>
<a name="ln6747">      // If not close to the limit, perform a change.  Only try changes</a>
<a name="ln6748">      // that may lead to a lower score than &quot;minscore&quot;.</a>
<a name="ln6749">      // round 0: try deleting a char from badword</a>
<a name="ln6750">      // round 1: try inserting a char in badword</a>
<a name="ln6751">      for (round = 0; round &lt;= 1; ++round) {</a>
<a name="ln6752">        score_off = score + (round == 0 ? SCORE_DEL : SCORE_INS);</a>
<a name="ln6753">        if (score_off &lt; minscore) {</a>
<a name="ln6754">          if (score_off + SCORE_EDIT_MIN &gt;= minscore) {</a>
<a name="ln6755">            // Near the limit, rest of the words must match.  We</a>
<a name="ln6756">            // can check that right now, no need to push an item</a>
<a name="ln6757">            // onto the stack.</a>
<a name="ln6758">            bi2 = bi + 1 - round;</a>
<a name="ln6759">            gi2 = gi + round;</a>
<a name="ln6760">            while (wgoodword[gi2] == wbadword[bi2]) {</a>
<a name="ln6761">              if (wgoodword[gi2] == NUL) {</a>
<a name="ln6762">                minscore = score_off;</a>
<a name="ln6763">                break;</a>
<a name="ln6764">              }</a>
<a name="ln6765">              ++bi2;</a>
<a name="ln6766">              ++gi2;</a>
<a name="ln6767">            }</a>
<a name="ln6768">          } else {</a>
<a name="ln6769">            // try deleting a character from badword later</a>
<a name="ln6770">            stack[stackidx].badi = bi + 1 - round;</a>
<a name="ln6771">            stack[stackidx].goodi = gi + round;</a>
<a name="ln6772">            stack[stackidx].score = score_off;</a>
<a name="ln6773">            ++stackidx;</a>
<a name="ln6774">          }</a>
<a name="ln6775">        }</a>
<a name="ln6776">      }</a>
<a name="ln6777"> </a>
<a name="ln6778">      if (score + SCORE_SWAP &lt; minscore) {</a>
<a name="ln6779">        // If swapping two characters makes a match then the</a>
<a name="ln6780">        // substitution is more expensive, thus there is no need to</a>
<a name="ln6781">        // try both.</a>
<a name="ln6782">        if (gc == wbadword[bi + 1] &amp;&amp; bc == wgoodword[gi + 1]) {</a>
<a name="ln6783">          // Swap two characters, that is: skip them.</a>
<a name="ln6784">          gi += 2;</a>
<a name="ln6785">          bi += 2;</a>
<a name="ln6786">          score += SCORE_SWAP;</a>
<a name="ln6787">          continue;</a>
<a name="ln6788">        }</a>
<a name="ln6789">      }</a>
<a name="ln6790"> </a>
<a name="ln6791">      // Substitute one character for another which is the same</a>
<a name="ln6792">      // thing as deleting a character from both goodword and badword.</a>
<a name="ln6793">      // Use a better score when there is only a case difference.</a>
<a name="ln6794">      if (SPELL_TOFOLD(bc) == SPELL_TOFOLD(gc)) {</a>
<a name="ln6795">        score += SCORE_ICASE;</a>
<a name="ln6796">      } else {</a>
<a name="ln6797">        // For a similar character use SCORE_SIMILAR.</a>
<a name="ln6798">        if (slang != NULL</a>
<a name="ln6799">            &amp;&amp; slang-&gt;sl_has_map</a>
<a name="ln6800">            &amp;&amp; similar_chars(slang, gc, bc)) {</a>
<a name="ln6801">          score += SCORE_SIMILAR;</a>
<a name="ln6802">        } else {</a>
<a name="ln6803">          score += SCORE_SUBST;</a>
<a name="ln6804">        }</a>
<a name="ln6805">      }</a>
<a name="ln6806"> </a>
<a name="ln6807">      if (score &lt; minscore) {</a>
<a name="ln6808">        // Do the substitution.</a>
<a name="ln6809">        ++gi;</a>
<a name="ln6810">        ++bi;</a>
<a name="ln6811">        continue;</a>
<a name="ln6812">      }</a>
<a name="ln6813">    }</a>
<a name="ln6814">pop:</a>
<a name="ln6815">    // Get here to try the next alternative, pop it from the stack.</a>
<a name="ln6816">    if (stackidx == 0) {                // stack is empty, finished</a>
<a name="ln6817">      break;</a>
<a name="ln6818">    }</a>
<a name="ln6819"> </a>
<a name="ln6820">    // pop an item from the stack</a>
<a name="ln6821">    --stackidx;</a>
<a name="ln6822">    gi = stack[stackidx].goodi;</a>
<a name="ln6823">    bi = stack[stackidx].badi;</a>
<a name="ln6824">    score = stack[stackidx].score;</a>
<a name="ln6825">  }</a>
<a name="ln6826"> </a>
<a name="ln6827">  // When the score goes over &quot;limit&quot; it may actually be much higher.</a>
<a name="ln6828">  // Return a very large number to avoid going below the limit when giving a</a>
<a name="ln6829">  // bonus.</a>
<a name="ln6830">  if (minscore &gt; limit) {</a>
<a name="ln6831">    return SCORE_MAXMAX;</a>
<a name="ln6832">  }</a>
<a name="ln6833">  return minscore;</a>
<a name="ln6834">}</a>
<a name="ln6835"> </a>
<a name="ln6836">// &quot;:spellinfo&quot;</a>
<a name="ln6837">void ex_spellinfo(exarg_T *eap)</a>
<a name="ln6838">{</a>
<a name="ln6839">  if (no_spell_checking(curwin)) {</a>
<a name="ln6840">    return;</a>
<a name="ln6841">  }</a>
<a name="ln6842"> </a>
<a name="ln6843">  msg_start();</a>
<a name="ln6844">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len &amp;&amp; !got_int; lpi++) {</a>
<a name="ln6845">    langp_T *const lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6846">    msg_puts(&quot;file: &quot;);</a>
<a name="ln6847">    msg_puts((const char *)lp-&gt;lp_slang-&gt;sl_fname);</a>
<a name="ln6848">    msg_putchar('\n');</a>
<a name="ln6849">    const char *const p = (const char *)lp-&gt;lp_slang-&gt;sl_info;</a>
<a name="ln6850">    if (p != NULL) {</a>
<a name="ln6851">      msg_puts(p);</a>
<a name="ln6852">      msg_putchar('\n');</a>
<a name="ln6853">    }</a>
<a name="ln6854">  }</a>
<a name="ln6855">  msg_end();</a>
<a name="ln6856">}</a>
<a name="ln6857"> </a>
<a name="ln6858">#define DUMPFLAG_KEEPCASE   1   // round 2: keep-case tree</a>
<a name="ln6859">#define DUMPFLAG_COUNT      2   // include word count</a>
<a name="ln6860">#define DUMPFLAG_ICASE      4   // ignore case when finding matches</a>
<a name="ln6861">#define DUMPFLAG_ONECAP     8   // pattern starts with capital</a>
<a name="ln6862">#define DUMPFLAG_ALLCAP     16  // pattern is all capitals</a>
<a name="ln6863"> </a>
<a name="ln6864">// &quot;:spelldump&quot;</a>
<a name="ln6865">void ex_spelldump(exarg_T *eap)</a>
<a name="ln6866">{</a>
<a name="ln6867">  char *spl;</a>
<a name="ln6868">  long dummy;</a>
<a name="ln6869"> </a>
<a name="ln6870">  if (no_spell_checking(curwin)) {</a>
<a name="ln6871">    return;</a>
<a name="ln6872">  }</a>
<a name="ln6873">  get_option_value(&quot;spl&quot;, &amp;dummy, &amp;spl, OPT_LOCAL);</a>
<a name="ln6874"> </a>
<a name="ln6875">  // Create a new empty buffer in a new window.</a>
<a name="ln6876">  do_cmdline_cmd(&quot;new&quot;);</a>
<a name="ln6877"> </a>
<a name="ln6878">  // enable spelling locally in the new window</a>
<a name="ln6879">  set_option_value(&quot;spell&quot;, true, &quot;&quot;, OPT_LOCAL);</a>
<a name="ln6880">  set_option_value(&quot;spl&quot;,  dummy, spl, OPT_LOCAL);</a>
<a name="ln6881">  xfree(spl);</a>
<a name="ln6882"> </a>
<a name="ln6883">  if (!buf_is_empty(curbuf)) {</a>
<a name="ln6884">    return;</a>
<a name="ln6885">  }</a>
<a name="ln6886"> </a>
<a name="ln6887">  spell_dump_compl(NULL, 0, NULL, eap-&gt;forceit ? DUMPFLAG_COUNT : 0);</a>
<a name="ln6888"> </a>
<a name="ln6889">  // Delete the empty line that we started with.</a>
<a name="ln6890">  if (curbuf-&gt;b_ml.ml_line_count &gt; 1) {</a>
<a name="ln6891">    ml_delete(curbuf-&gt;b_ml.ml_line_count, false);</a>
<a name="ln6892">  }</a>
<a name="ln6893">  redraw_later(curwin, NOT_VALID);</a>
<a name="ln6894">}</a>
<a name="ln6895"> </a>
<a name="ln6896">/// Go through all possible words and:</a>
<a name="ln6897">/// 1. When &quot;pat&quot; is NULL: dump a list of all words in the current buffer.</a>
<a name="ln6898">///      &quot;ic&quot; and &quot;dir&quot; are not used.</a>
<a name="ln6899">/// 2. When &quot;pat&quot; is not NULL: add matching words to insert mode completion.</a>
<a name="ln6900">///</a>
<a name="ln6901">/// @param pat  leading part of the word</a>
<a name="ln6902">/// @param ic  ignore case</a>
<a name="ln6903">/// @param dir  direction for adding matches</a>
<a name="ln6904">/// @param dumpflags_arg  DUMPFLAG_*</a>
<a name="ln6905">void spell_dump_compl(char_u *pat, int ic, Direction *dir, int dumpflags_arg)</a>
<a name="ln6906">{</a>
<a name="ln6907">  langp_T *lp;</a>
<a name="ln6908">  slang_T *slang;</a>
<a name="ln6909">  idx_T arridx[MAXWLEN];</a>
<a name="ln6910">  int curi[MAXWLEN];</a>
<a name="ln6911">  char_u word[MAXWLEN];</a>
<a name="ln6912">  int c;</a>
<a name="ln6913">  char_u *byts;</a>
<a name="ln6914">  idx_T *idxs;</a>
<a name="ln6915">  linenr_T lnum = 0;</a>
<a name="ln6916">  int round;</a>
<a name="ln6917">  int depth;</a>
<a name="ln6918">  int n;</a>
<a name="ln6919">  int flags;</a>
<a name="ln6920">  char_u *region_names = NULL;         // region names being used</a>
<a name="ln6921">  bool do_region = true;                    // dump region names and numbers</a>
<a name="ln6922">  char_u *p;</a>
<a name="ln6923">  int dumpflags = dumpflags_arg;</a>
<a name="ln6924">  int patlen;</a>
<a name="ln6925"> </a>
<a name="ln6926">  // When ignoring case or when the pattern starts with capital pass this on</a>
<a name="ln6927">  // to dump_word().</a>
<a name="ln6928">  if (pat != NULL) {</a>
<a name="ln6929">    if (ic) {</a>
<a name="ln6930">      dumpflags |= DUMPFLAG_ICASE;</a>
<a name="ln6931">    } else {</a>
<a name="ln6932">      n = captype(pat, NULL);</a>
<a name="ln6933">      if (n == WF_ONECAP) {</a>
<a name="ln6934">        dumpflags |= DUMPFLAG_ONECAP;</a>
<a name="ln6935">      } else if (n == WF_ALLCAP</a>
<a name="ln6936">                 &amp;&amp; (int)STRLEN(pat) &gt; utfc_ptr2len((char *)pat)) {</a>
<a name="ln6937">        dumpflags |= DUMPFLAG_ALLCAP;</a>
<a name="ln6938">      }</a>
<a name="ln6939">    }</a>
<a name="ln6940">  }</a>
<a name="ln6941"> </a>
<a name="ln6942">  // Find out if we can support regions: All languages must support the same</a>
<a name="ln6943">  // regions or none at all.</a>
<a name="ln6944">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6945">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6946">    p = lp-&gt;lp_slang-&gt;sl_regions;</a>
<a name="ln6947">    if (p[0] != 0) {</a>
<a name="ln6948">      if (region_names == NULL) {           // first language with regions</a>
<a name="ln6949">        region_names = p;</a>
<a name="ln6950">      } else if (STRCMP(region_names, p) != 0) {</a>
<a name="ln6951">        do_region = false;                  // region names are different</a>
<a name="ln6952">        break;</a>
<a name="ln6953">      }</a>
<a name="ln6954">    }</a>
<a name="ln6955">  }</a>
<a name="ln6956"> </a>
<a name="ln6957">  if (do_region &amp;&amp; region_names != NULL) {</a>
<a name="ln6958">    if (pat == NULL) {</a>
<a name="ln6959">      vim_snprintf((char *)IObuff, IOSIZE, &quot;/regions=%s&quot;, region_names);</a>
<a name="ln6960">      ml_append(lnum++, (char *)IObuff, (colnr_T)0, false);</a>
<a name="ln6961">    }</a>
<a name="ln6962">  } else {</a>
<a name="ln6963">    do_region = false;</a>
<a name="ln6964">  }</a>
<a name="ln6965"> </a>
<a name="ln6966">  // Loop over all files loaded for the entries in 'spelllang'.</a>
<a name="ln6967">  for (int lpi = 0; lpi &lt; curwin-&gt;w_s-&gt;b_langp.ga_len; ++lpi) {</a>
<a name="ln6968">    lp = LANGP_ENTRY(curwin-&gt;w_s-&gt;b_langp, lpi);</a>
<a name="ln6969">    slang = lp-&gt;lp_slang;</a>
<a name="ln6970">    if (slang-&gt;sl_fbyts == NULL) {          // reloading failed</a>
<a name="ln6971">      continue;</a>
<a name="ln6972">    }</a>
<a name="ln6973"> </a>
<a name="ln6974">    if (pat == NULL) {</a>
<a name="ln6975">      vim_snprintf((char *)IObuff, IOSIZE, &quot;# file: %s&quot;, slang-&gt;sl_fname);</a>
<a name="ln6976">      ml_append(lnum++, (char *)IObuff, (colnr_T)0, false);</a>
<a name="ln6977">    }</a>
<a name="ln6978"> </a>
<a name="ln6979">    // When matching with a pattern and there are no prefixes only use</a>
<a name="ln6980">    // parts of the tree that match &quot;pat&quot;.</a>
<a name="ln6981">    if (pat != NULL &amp;&amp; slang-&gt;sl_pbyts == NULL) {</a>
<a name="ln6982">      patlen = (int)STRLEN(pat);</a>
<a name="ln6983">    } else {</a>
<a name="ln6984">      patlen = -1;</a>
<a name="ln6985">    }</a>
<a name="ln6986"> </a>
<a name="ln6987">    // round 1: case-folded tree</a>
<a name="ln6988">    // round 2: keep-case tree</a>
<a name="ln6989">    for (round = 1; round &lt;= 2; ++round) {</a>
<a name="ln6990">      if (round == 1) {</a>
<a name="ln6991">        dumpflags &amp;= ~DUMPFLAG_KEEPCASE;</a>
<a name="ln6992">        byts = slang-&gt;sl_fbyts;</a>
<a name="ln6993">        idxs = slang-&gt;sl_fidxs;</a>
<a name="ln6994">      } else {</a>
<a name="ln6995">        dumpflags |= DUMPFLAG_KEEPCASE;</a>
<a name="ln6996">        byts = slang-&gt;sl_kbyts;</a>
<a name="ln6997">        idxs = slang-&gt;sl_kidxs;</a>
<a name="ln6998">      }</a>
<a name="ln6999">      if (byts == NULL) {</a>
<a name="ln7000">        continue;                       // array is empty</a>
<a name="ln7001">      }</a>
<a name="ln7002">      depth = 0;</a>
<a name="ln7003">      arridx[0] = 0;</a>
<a name="ln7004">      curi[0] = 1;</a>
<a name="ln7005">      while (depth &gt;= 0 &amp;&amp; !got_int</a>
<a name="ln7006">             &amp;&amp; (pat == NULL || !compl_interrupted)) {</a>
<a name="ln7007">        if (curi[depth] &gt; byts[arridx[depth]]) {</a>
<a name="ln7008">          // Done all bytes at this node, go up one level.</a>
<a name="ln7009">          --depth;</a>
<a name="ln7010">          line_breakcheck();</a>
<a name="ln7011">          ins_compl_check_keys(50, false);</a>
<a name="ln7012">        } else {</a>
<a name="ln7013">          // Do one more byte at this node.</a>
<a name="ln7014">          n = arridx[depth] + curi[depth];</a>
<a name="ln7015">          ++curi[depth];</a>
<a name="ln7016">          c = byts[n];</a>
<a name="ln7017">          if (c == 0) {</a>
<a name="ln7018">            // End of word, deal with the word.</a>
<a name="ln7019">            // Don't use keep-case words in the fold-case tree,</a>
<a name="ln7020">            // they will appear in the keep-case tree.</a>
<a name="ln7021">            // Only use the word when the region matches.</a>
<a name="ln7022">            flags = (int)idxs[n];</a>
<a name="ln7023">            if ((round == 2 || (flags &amp; WF_KEEPCAP) == 0)</a>
<a name="ln7024">                &amp;&amp; (flags &amp; WF_NEEDCOMP) == 0</a>
<a name="ln7025">                &amp;&amp; (do_region</a>
<a name="ln7026">                    || (flags &amp; WF_REGION) == 0</a>
<a name="ln7027">                    || (((unsigned)flags &gt;&gt; 16)</a>
<a name="ln7028">                        &amp; lp-&gt;lp_region) != 0)) {</a>
<a name="ln7029">              word[depth] = NUL;</a>
<a name="ln7030">              if (!do_region) {</a>
<a name="ln7031">                flags &amp;= ~WF_REGION;</a>
<a name="ln7032">              }</a>
<a name="ln7033"> </a>
<a name="ln7034">              // Dump the basic word if there is no prefix or</a>
<a name="ln7035">              // when it's the first one.</a>
<a name="ln7036">              c = (unsigned)flags &gt;&gt; 24;</a>
<a name="ln7037">              if (c == 0 || curi[depth] == 2) {</a>
<a name="ln7038">                dump_word(slang, word, pat, dir,</a>
<a name="ln7039">                          dumpflags, flags, lnum);</a>
<a name="ln7040">                if (pat == NULL) {</a>
<a name="ln7041">                  ++lnum;</a>
<a name="ln7042">                }</a>
<a name="ln7043">              }</a>
<a name="ln7044"> </a>
<a name="ln7045">              // Apply the prefix, if there is one.</a>
<a name="ln7046">              if (c != 0) {</a>
<a name="ln7047">                lnum = dump_prefixes(slang, word, pat, dir,</a>
<a name="ln7048">                                     dumpflags, flags, lnum);</a>
<a name="ln7049">              }</a>
<a name="ln7050">            }</a>
<a name="ln7051">          } else {</a>
<a name="ln7052">            // Normal char, go one level deeper.</a>
<a name="ln7053">            word[depth++] = c;</a>
<a name="ln7054">            arridx[depth] = idxs[n];</a>
<a name="ln7055">            curi[depth] = 1;</a>
<a name="ln7056"> </a>
<a name="ln7057">            // Check if this character matches with the pattern.</a>
<a name="ln7058">            // If not skip the whole tree below it.</a>
<a name="ln7059">            // Always ignore case here, dump_word() will check</a>
<a name="ln7060">            // proper case later.  This isn't exactly right when</a>
<a name="ln7061">            // length changes for multi-byte characters with</a>
<a name="ln7062">            // ignore case...</a>
<a name="ln7063">            assert(depth &gt;= 0);</a>
<a name="ln7064">            if (depth &lt;= patlen</a>
<a name="ln7065">                &amp;&amp; mb_strnicmp(word, pat, (size_t)depth) != 0) {</a>
<a name="ln7066">              --depth;</a>
<a name="ln7067">            }</a>
<a name="ln7068">          }</a>
<a name="ln7069">        }</a>
<a name="ln7070">      }</a>
<a name="ln7071">    }</a>
<a name="ln7072">  }</a>
<a name="ln7073">}</a>
<a name="ln7074"> </a>
<a name="ln7075">// Dumps one word: apply case modifications and append a line to the buffer.</a>
<a name="ln7076">// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln7077">static void dump_word(slang_T *slang, char_u *word, char_u *pat, Direction *dir, int dumpflags,</a>
<a name="ln7078">                      int wordflags, linenr_T lnum)</a>
<a name="ln7079">{</a>
<a name="ln7080">  bool keepcap = false;</a>
<a name="ln7081">  char_u *p;</a>
<a name="ln7082">  char_u *tw;</a>
<a name="ln7083">  char_u cword[MAXWLEN];</a>
<a name="ln7084">  char_u badword[MAXWLEN + 10];</a>
<a name="ln7085">  int i;</a>
<a name="ln7086">  int flags = wordflags;</a>
<a name="ln7087"> </a>
<a name="ln7088">  if (dumpflags &amp; DUMPFLAG_ONECAP) {</a>
<a name="ln7089">    flags |= WF_ONECAP;</a>
<a name="ln7090">  }</a>
<a name="ln7091">  if (dumpflags &amp; DUMPFLAG_ALLCAP) {</a>
<a name="ln7092">    flags |= WF_ALLCAP;</a>
<a name="ln7093">  }</a>
<a name="ln7094"> </a>
<a name="ln7095">  if ((dumpflags &amp; DUMPFLAG_KEEPCASE) == 0 &amp;&amp; (flags &amp; WF_CAPMASK) != 0) {</a>
<a name="ln7096">    // Need to fix case according to &quot;flags&quot;.</a>
<a name="ln7097">    make_case_word(word, cword, flags);</a>
<a name="ln7098">    p = cword;</a>
<a name="ln7099">  } else {</a>
<a name="ln7100">    p = word;</a>
<a name="ln7101">    if ((dumpflags &amp; DUMPFLAG_KEEPCASE)</a>
<a name="ln7102">        &amp;&amp; ((captype(word, NULL) &amp; WF_KEEPCAP) == 0</a>
<a name="ln7103">            || (flags &amp; WF_FIXCAP) != 0)) {</a>
<a name="ln7104">      keepcap = true;</a>
<a name="ln7105">    }</a>
<a name="ln7106">  }</a>
<a name="ln7107">  tw = p;</a>
<a name="ln7108"> </a>
<a name="ln7109">  if (pat == NULL) {</a>
<a name="ln7110">    // Add flags and regions after a slash.</a>
<a name="ln7111">    if ((flags &amp; (WF_BANNED | WF_RARE | WF_REGION)) || keepcap) {</a>
<a name="ln7112">      STRCPY(badword, p);</a>
<a name="ln7113">      STRCAT(badword, &quot;/&quot;);</a>
<a name="ln7114">      if (keepcap) {</a>
<a name="ln7115">        STRCAT(badword, &quot;=&quot;);</a>
<a name="ln7116">      }</a>
<a name="ln7117">      if (flags &amp; WF_BANNED) {</a>
<a name="ln7118">        STRCAT(badword, &quot;!&quot;);</a>
<a name="ln7119">      } else if (flags &amp; WF_RARE) {</a>
<a name="ln7120">        STRCAT(badword, &quot;?&quot;);</a>
<a name="ln7121">      }</a>
<a name="ln7122">      if (flags &amp; WF_REGION) {</a>
<a name="ln7123">        for (i = 0; i &lt; 7; i++) {</a>
<a name="ln7124">          if (flags &amp; (0x10000 &lt;&lt; i)) {</a>
<a name="ln7125">            const size_t badword_len = STRLEN(badword);</a>
<a name="ln7126">            snprintf((char *)badword + badword_len,</a>
<a name="ln7127">                     sizeof(badword) - badword_len,</a>
<a name="ln7128">                     &quot;%d&quot;, i + 1);</a>
<a name="ln7129">          }</a>
<a name="ln7130">        }</a>
<a name="ln7131">      }</a>
<a name="ln7132">      p = badword;</a>
<a name="ln7133">    }</a>
<a name="ln7134"> </a>
<a name="ln7135">    if (dumpflags &amp; DUMPFLAG_COUNT) {</a>
<a name="ln7136">      hashitem_T *hi;</a>
<a name="ln7137"> </a>
<a name="ln7138">      // Include the word count for &quot;:spelldump!&quot;.</a>
<a name="ln7139">      hi = hash_find(&amp;slang-&gt;sl_wordcount, tw);</a>
<a name="ln7140">      if (!HASHITEM_EMPTY(hi)) {</a>
<a name="ln7141">        vim_snprintf((char *)IObuff, IOSIZE, &quot;%s\t%d&quot;,</a>
<a name="ln7142">                     tw, HI2WC(hi)-&gt;wc_count);</a>
<a name="ln7143">        p = IObuff;</a>
<a name="ln7144">      }</a>
<a name="ln7145">    }</a>
<a name="ln7146"> </a>
<a name="ln7147">    ml_append(lnum, (char *)p, (colnr_T)0, false);</a>
<a name="ln7148">  } else if (((dumpflags &amp; DUMPFLAG_ICASE)</a>
<a name="ln7149">              ? mb_strnicmp(p, pat, STRLEN(pat)) == 0</a>
<a name="ln7150">              : STRNCMP(p, pat, STRLEN(pat)) == 0)</a>
<a name="ln7151">             &amp;&amp; ins_compl_add_infercase(p, (int)STRLEN(p),</a>
<a name="ln7152">                                        p_ic, NULL, *dir, false) == OK) {</a>
<a name="ln7153">    // if dir was BACKWARD then honor it just once</a>
<a name="ln7154">    *dir = FORWARD;</a>
<a name="ln7155">  }</a>
<a name="ln7156">}</a>
<a name="ln7157"> </a>
<a name="ln7158">/// For &quot;:spelldump&quot;: Find matching prefixes for &quot;word&quot;.  Prepend each to</a>
<a name="ln7159">/// &quot;word&quot; and append a line to the buffer.</a>
<a name="ln7160">/// When &quot;lnum&quot; is zero add insert mode completion.</a>
<a name="ln7161">///</a>
<a name="ln7162">/// @param word  case-folded word</a>
<a name="ln7163">/// @param flags  flags with prefix ID</a>
<a name="ln7164">///</a>
<a name="ln7165">/// @return  the updated line number.</a>
<a name="ln7166">static linenr_T dump_prefixes(slang_T *slang, char_u *word, char_u *pat, Direction *dir,</a>
<a name="ln7167">                              int dumpflags, int flags, linenr_T startlnum)</a>
<a name="ln7168">{</a>
<a name="ln7169">  idx_T arridx[MAXWLEN];</a>
<a name="ln7170">  int curi[MAXWLEN];</a>
<a name="ln7171">  char_u prefix[MAXWLEN];</a>
<a name="ln7172">  char_u word_up[MAXWLEN];</a>
<a name="ln7173">  bool has_word_up = false;</a>
<a name="ln7174">  int c;</a>
<a name="ln7175">  char_u *byts;</a>
<a name="ln7176">  idx_T *idxs;</a>
<a name="ln7177">  linenr_T lnum = startlnum;</a>
<a name="ln7178">  int depth;</a>
<a name="ln7179">  int n;</a>
<a name="ln7180">  int len;</a>
<a name="ln7181">  int i;</a>
<a name="ln7182"> </a>
<a name="ln7183">  // If the word starts with a lower-case letter make the word with an</a>
<a name="ln7184">  // upper-case letter in word_up[].</a>
<a name="ln7185">  c = utf_ptr2char((char *)word);</a>
<a name="ln7186">  if (SPELL_TOUPPER(c) != c) {</a>
<a name="ln7187">    onecap_copy(word, word_up, true);</a>
<a name="ln7188">    has_word_up = true;</a>
<a name="ln7189">  }</a>
<a name="ln7190"> </a>
<a name="ln7191">  byts = slang-&gt;sl_pbyts;</a>
<a name="ln7192">  idxs = slang-&gt;sl_pidxs;</a>
<a name="ln7193">  if (byts != NULL) {           // array not is empty</a>
<a name="ln7194">    // Loop over all prefixes, building them byte-by-byte in prefix[].</a>
<a name="ln7195">    // When at the end of a prefix check that it supports &quot;flags&quot;.</a>
<a name="ln7196">    depth = 0;</a>
<a name="ln7197">    arridx[0] = 0;</a>
<a name="ln7198">    curi[0] = 1;</a>
<a name="ln7199">    while (depth &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln7200">      n = arridx[depth];</a>
<a name="ln7201">      len = byts[n];</a>
<a name="ln7202">      if (curi[depth] &gt; len) {</a>
<a name="ln7203">        // Done all bytes at this node, go up one level.</a>
<a name="ln7204">        --depth;</a>
<a name="ln7205">        line_breakcheck();</a>
<a name="ln7206">      } else {</a>
<a name="ln7207">        // Do one more byte at this node.</a>
<a name="ln7208">        n += curi[depth];</a>
<a name="ln7209">        ++curi[depth];</a>
<a name="ln7210">        c = byts[n];</a>
<a name="ln7211">        if (c == 0) {</a>
<a name="ln7212">          // End of prefix, find out how many IDs there are.</a>
<a name="ln7213">          for (i = 1; i &lt; len; ++i) {</a>
<a name="ln7214">            if (byts[n + i] != 0) {</a>
<a name="ln7215">              break;</a>
<a name="ln7216">            }</a>
<a name="ln7217">          }</a>
<a name="ln7218">          curi[depth] += i - 1;</a>
<a name="ln7219"> </a>
<a name="ln7220">          c = valid_word_prefix(i, n, flags, word, slang, false);</a>
<a name="ln7221">          if (c != 0) {</a>
<a name="ln7222">            STRLCPY(prefix + depth, word, MAXWLEN - depth);</a>
<a name="ln7223">            dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln7224">                      (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln7225">                                       : flags, lnum);</a>
<a name="ln7226">            if (lnum != 0) {</a>
<a name="ln7227">              ++lnum;</a>
<a name="ln7228">            }</a>
<a name="ln7229">          }</a>
<a name="ln7230"> </a>
<a name="ln7231">          // Check for prefix that matches the word when the</a>
<a name="ln7232">          // first letter is upper-case, but only if the prefix has</a>
<a name="ln7233">          // a condition.</a>
<a name="ln7234">          if (has_word_up) {</a>
<a name="ln7235">            c = valid_word_prefix(i, n, flags, word_up, slang,</a>
<a name="ln7236">                                  true);</a>
<a name="ln7237">            if (c != 0) {</a>
<a name="ln7238">              STRLCPY(prefix + depth, word_up, MAXWLEN - depth);</a>
<a name="ln7239">              dump_word(slang, prefix, pat, dir, dumpflags,</a>
<a name="ln7240">                        (c &amp; WF_RAREPFX) ? (flags | WF_RARE)</a>
<a name="ln7241">                                         : flags, lnum);</a>
<a name="ln7242">              if (lnum != 0) {</a>
<a name="ln7243">                ++lnum;</a>
<a name="ln7244">              }</a>
<a name="ln7245">            }</a>
<a name="ln7246">          }</a>
<a name="ln7247">        } else {</a>
<a name="ln7248">          // Normal char, go one level deeper.</a>
<a name="ln7249">          prefix[depth++] = c;</a>
<a name="ln7250">          arridx[depth] = idxs[n];</a>
<a name="ln7251">          curi[depth] = 1;</a>
<a name="ln7252">        }</a>
<a name="ln7253">      }</a>
<a name="ln7254">    }</a>
<a name="ln7255">  }</a>
<a name="ln7256"> </a>
<a name="ln7257">  return lnum;</a>
<a name="ln7258">}</a>
<a name="ln7259"> </a>
<a name="ln7260">// Move &quot;p&quot; to the end of word &quot;start&quot;.</a>
<a name="ln7261">// Uses the spell-checking word characters.</a>
<a name="ln7262">char_u *spell_to_word_end(char_u *start, win_T *win)</a>
<a name="ln7263">{</a>
<a name="ln7264">  char_u *p = start;</a>
<a name="ln7265"> </a>
<a name="ln7266">  while (*p != NUL &amp;&amp; spell_iswordp(p, win)) {</a>
<a name="ln7267">    MB_PTR_ADV(p);</a>
<a name="ln7268">  }</a>
<a name="ln7269">  return p;</a>
<a name="ln7270">}</a>
<a name="ln7271"> </a>
<a name="ln7272">// For Insert mode completion CTRL-X s:</a>
<a name="ln7273">// Find start of the word in front of column &quot;startcol&quot;.</a>
<a name="ln7274">// We don't check if it is badly spelled, with completion we can only change</a>
<a name="ln7275">// the word in front of the cursor.</a>
<a name="ln7276">// Returns the column number of the word.</a>
<a name="ln7277">int spell_word_start(int startcol)</a>
<a name="ln7278">{</a>
<a name="ln7279">  char_u *line;</a>
<a name="ln7280">  char_u *p;</a>
<a name="ln7281">  int col = 0;</a>
<a name="ln7282"> </a>
<a name="ln7283">  if (no_spell_checking(curwin)) {</a>
<a name="ln7284">    return startcol;</a>
<a name="ln7285">  }</a>
<a name="ln7286"> </a>
<a name="ln7287">  // Find a word character before &quot;startcol&quot;.</a>
<a name="ln7288">  line = get_cursor_line_ptr();</a>
<a name="ln7289">  for (p = line + startcol; p &gt; line;) {</a>
<a name="ln7290">    MB_PTR_BACK(line, p);</a>
<a name="ln7291">    if (spell_iswordp_nmw(p, curwin)) {</a>
<a name="ln7292">      break;</a>
<a name="ln7293">    }</a>
<a name="ln7294">  }</a>
<a name="ln7295"> </a>
<a name="ln7296">  // Go back to start of the word.</a>
<a name="ln7297">  while (p &gt; line) {</a>
<a name="ln7298">    col = (int)(p - line);</a>
<a name="ln7299">    MB_PTR_BACK(line, p);</a>
<a name="ln7300">    if (!spell_iswordp(p, curwin)) {</a>
<a name="ln7301">      break;</a>
<a name="ln7302">    }</a>
<a name="ln7303">    col = 0;</a>
<a name="ln7304">  }</a>
<a name="ln7305"> </a>
<a name="ln7306">  return col;</a>
<a name="ln7307">}</a>
<a name="ln7308"> </a>
<a name="ln7309">// Need to check for 'spellcapcheck' now, the word is removed before</a>
<a name="ln7310">// expand_spelling() is called.  Therefore the ugly global variable.</a>
<a name="ln7311">static bool spell_expand_need_cap;</a>
<a name="ln7312"> </a>
<a name="ln7313">void spell_expand_check_cap(colnr_T col)</a>
<a name="ln7314">{</a>
<a name="ln7315">  spell_expand_need_cap = check_need_cap(curwin-&gt;w_cursor.lnum, col);</a>
<a name="ln7316">}</a>
<a name="ln7317"> </a>
<a name="ln7318">// Get list of spelling suggestions.</a>
<a name="ln7319">// Used for Insert mode completion CTRL-X ?.</a>
<a name="ln7320">// Returns the number of matches.  The matches are in &quot;matchp[]&quot;, array of</a>
<a name="ln7321">// allocated strings.</a>
<a name="ln7322">int expand_spelling(linenr_T lnum, char_u *pat, char_u ***matchp)</a>
<a name="ln7323">{</a>
<a name="ln7324">  garray_T ga;</a>
<a name="ln7325"> </a>
<a name="ln7326">  spell_suggest_list(&amp;ga, pat, 100, spell_expand_need_cap, true);</a>
<a name="ln7327">  *matchp = ga.ga_data;</a>
<a name="ln7328">  return ga.ga_len;</a>
<a name="ln7329">}</a>

</code></pre>
<div class="balloon" rel="6158"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v781/" target="_blank">V781</a> The value of the 'i' index is checked after it was used. Perhaps there is a mistake in program logic.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

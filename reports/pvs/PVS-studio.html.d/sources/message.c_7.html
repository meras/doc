
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>message.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> * message.c: functions for displaying messages on the command line</a>
<a name="ln6"> */</a>
<a name="ln7"> </a>
<a name="ln8">#include &lt;assert.h&gt;</a>
<a name="ln9">#include &lt;inttypes.h&gt;</a>
<a name="ln10">#include &lt;stdarg.h&gt;</a>
<a name="ln11">#include &lt;stdbool.h&gt;</a>
<a name="ln12">#include &lt;string.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;nvim/api/private/helpers.h&quot;</a>
<a name="ln15">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln16">#include &quot;nvim/assert.h&quot;</a>
<a name="ln17">#include &quot;nvim/charset.h&quot;</a>
<a name="ln18">#include &quot;nvim/eval.h&quot;</a>
<a name="ln19">#include &quot;nvim/ex_docmd.h&quot;</a>
<a name="ln20">#include &quot;nvim/ex_eval.h&quot;</a>
<a name="ln21">#include &quot;nvim/fileio.h&quot;</a>
<a name="ln22">#include &quot;nvim/func_attr.h&quot;</a>
<a name="ln23">#include &quot;nvim/garray.h&quot;</a>
<a name="ln24">#include &quot;nvim/getchar.h&quot;</a>
<a name="ln25">#include &quot;nvim/highlight.h&quot;</a>
<a name="ln26">#include &quot;nvim/input.h&quot;</a>
<a name="ln27">#include &quot;nvim/keycodes.h&quot;</a>
<a name="ln28">#include &quot;nvim/main.h&quot;</a>
<a name="ln29">#include &quot;nvim/mbyte.h&quot;</a>
<a name="ln30">#include &quot;nvim/memory.h&quot;</a>
<a name="ln31">#include &quot;nvim/message.h&quot;</a>
<a name="ln32">#include &quot;nvim/mouse.h&quot;</a>
<a name="ln33">#include &quot;nvim/normal.h&quot;</a>
<a name="ln34">#include &quot;nvim/ops.h&quot;</a>
<a name="ln35">#include &quot;nvim/option.h&quot;</a>
<a name="ln36">#include &quot;nvim/os/input.h&quot;</a>
<a name="ln37">#include &quot;nvim/os/os.h&quot;</a>
<a name="ln38">#include &quot;nvim/os/time.h&quot;</a>
<a name="ln39">#include &quot;nvim/regexp.h&quot;</a>
<a name="ln40">#include &quot;nvim/screen.h&quot;</a>
<a name="ln41">#include &quot;nvim/strings.h&quot;</a>
<a name="ln42">#include &quot;nvim/syntax.h&quot;</a>
<a name="ln43">#include &quot;nvim/ui.h&quot;</a>
<a name="ln44">#include &quot;nvim/ui_compositor.h&quot;</a>
<a name="ln45">#include &quot;nvim/vim.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">/*</a>
<a name="ln48"> * To be able to scroll back at the &quot;more&quot; and &quot;hit-enter&quot; prompts we need to</a>
<a name="ln49"> * store the displayed text and remember where screen lines start.</a>
<a name="ln50"> */</a>
<a name="ln51">typedef struct msgchunk_S msgchunk_T;</a>
<a name="ln52">struct msgchunk_S {</a>
<a name="ln53">  msgchunk_T *sb_next;</a>
<a name="ln54">  msgchunk_T *sb_prev;</a>
<a name="ln55">  char sb_eol;                  // TRUE when line ends after this text</a>
<a name="ln56">  int sb_msg_col;               // column in which text starts</a>
<a name="ln57">  int sb_attr;                  // text attributes</a>
<a name="ln58">  char_u sb_text[1];            // text to be displayed, actually longer</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61">// Magic chars used in confirm dialog strings</a>
<a name="ln62">#define DLG_BUTTON_SEP  '\n'</a>
<a name="ln63">#define DLG_HOTKEY_CHAR '&amp;'</a>
<a name="ln64"> </a>
<a name="ln65">static int confirm_msg_used = FALSE;            // displaying confirm_msg</a>
<a name="ln66">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln67"># include &quot;message.c.generated.h&quot;</a>
<a name="ln68">#endif</a>
<a name="ln69">static char_u *confirm_msg = NULL;            // &quot;:confirm&quot; message</a>
<a name="ln70">static char_u *confirm_msg_tail;              // tail of confirm_msg</a>
<a name="ln71"> </a>
<a name="ln72">MessageHistoryEntry *first_msg_hist = NULL;</a>
<a name="ln73">MessageHistoryEntry *last_msg_hist = NULL;</a>
<a name="ln74">static int msg_hist_len = 0;</a>
<a name="ln75"> </a>
<a name="ln76">static FILE *verbose_fd = NULL;</a>
<a name="ln77">static int verbose_did_open = FALSE;</a>
<a name="ln78"> </a>
<a name="ln79">bool keep_msg_more = false;    // keep_msg was set by msgmore()</a>
<a name="ln80"> </a>
<a name="ln81">/*</a>
<a name="ln82"> * When writing messages to the screen, there are many different situations.</a>
<a name="ln83"> * A number of variables is used to remember the current state:</a>
<a name="ln84"> * msg_didany       true when messages were written since the last time the</a>
<a name="ln85"> *                  user reacted to a prompt.</a>
<a name="ln86"> *                  Reset: After hitting a key for the hit-return prompt,</a>
<a name="ln87"> *                  hitting &lt;CR&gt; for the command line or input().</a>
<a name="ln88"> *                  Set: When any message is written to the screen.</a>
<a name="ln89"> * msg_didout       true when something was written to the current line.</a>
<a name="ln90"> *                  Reset: When advancing to the next line, when the current</a>
<a name="ln91"> *                  text can be overwritten.</a>
<a name="ln92"> *                  Set: When any message is written to the screen.</a>
<a name="ln93"> * msg_nowait       No extra delay for the last drawn message.</a>
<a name="ln94"> *                  Used in normal_cmd() before the mode message is drawn.</a>
<a name="ln95"> * emsg_on_display  There was an error message recently.  Indicates that there</a>
<a name="ln96"> *                  should be a delay before redrawing.</a>
<a name="ln97"> * msg_scroll       The next message should not overwrite the current one.</a>
<a name="ln98"> * msg_scrolled     How many lines the screen has been scrolled (because of</a>
<a name="ln99"> *                  messages).  Used in update_screen() to scroll the screen</a>
<a name="ln100"> *                  back.  Incremented each time the screen scrolls a line.</a>
<a name="ln101"> * msg_scrolled_ign  TRUE when msg_scrolled is non-zero and msg_puts_attr()</a>
<a name="ln102"> *                  writes something without scrolling should not make</a>
<a name="ln103"> *                  need_wait_return to be set.  This is a hack to make &quot;:ts&quot;</a>
<a name="ln104"> *                  work without an extra prompt.</a>
<a name="ln105"> * lines_left       Number of lines available for messages before the</a>
<a name="ln106"> *                  more-prompt is to be given.  -1 when not set.</a>
<a name="ln107"> * need_wait_return true when the hit-return prompt is needed.</a>
<a name="ln108"> *                  Reset: After giving the hit-return prompt, when the user</a>
<a name="ln109"> *                  has answered some other prompt.</a>
<a name="ln110"> *                  Set: When the ruler or typeahead display is overwritten,</a>
<a name="ln111"> *                  scrolling the screen for some message.</a>
<a name="ln112"> * keep_msg         Message to be displayed after redrawing the screen, in</a>
<a name="ln113"> *                  main_loop().</a>
<a name="ln114"> *                  This is an allocated string or NULL when not used.</a>
<a name="ln115"> */</a>
<a name="ln116"> </a>
<a name="ln117">// Extended msg state, currently used for external UIs with ext_messages</a>
<a name="ln118">static const char *msg_ext_kind = NULL;</a>
<a name="ln119">static Array msg_ext_chunks = ARRAY_DICT_INIT;</a>
<a name="ln120">static garray_T msg_ext_last_chunk = GA_INIT(sizeof(char), 40);</a>
<a name="ln121">static sattr_T msg_ext_last_attr = -1;</a>
<a name="ln122">static size_t msg_ext_cur_len = 0;</a>
<a name="ln123"> </a>
<a name="ln124">static bool msg_ext_overwrite = false;  ///&lt; will overwrite last message</a>
<a name="ln125">static int msg_ext_visible = 0;  ///&lt; number of messages currently visible</a>
<a name="ln126"> </a>
<a name="ln127">static bool msg_ext_history_visible = false;</a>
<a name="ln128"> </a>
<a name="ln129">/// Shouldn't clear message after leaving cmdline</a>
<a name="ln130">static bool msg_ext_keep_after_cmdline = false;</a>
<a name="ln131"> </a>
<a name="ln132">static int msg_grid_pos_at_flush = 0;</a>
<a name="ln133">static int msg_grid_scroll_discount = 0;</a>
<a name="ln134"> </a>
<a name="ln135">static void ui_ext_msg_set_pos(int row, bool scrolled)</a>
<a name="ln136">{</a>
<a name="ln137">  char buf[MAX_MCO + 1];</a>
<a name="ln138">  size_t size = utf_char2bytes(curwin-&gt;w_p_fcs_chars.msgsep, buf);</a>
<a name="ln139">  buf[size] = '\0';</a>
<a name="ln140">  ui_call_msg_set_pos(msg_grid.handle, row, scrolled,</a>
<a name="ln141">                      (String){ .data = buf, .size = size });</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">void msg_grid_set_pos(int row, bool scrolled)</a>
<a name="ln145">{</a>
<a name="ln146">  if (!msg_grid.throttled) {</a>
<a name="ln147">    ui_ext_msg_set_pos(row, scrolled);</a>
<a name="ln148">    msg_grid_pos_at_flush = row;</a>
<a name="ln149">  }</a>
<a name="ln150">  msg_grid_pos = row;</a>
<a name="ln151">  if (msg_grid.chars) {</a>
<a name="ln152">    msg_grid_adj.row_offset = -row;</a>
<a name="ln153">  }</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">bool msg_use_grid(void)</a>
<a name="ln157">{</a>
<a name="ln158">  return default_grid.chars &amp;&amp; msg_use_msgsep()</a>
<a name="ln159">         &amp;&amp; !ui_has(kUIMessages);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">void msg_grid_validate(void)</a>
<a name="ln163">{</a>
<a name="ln164">  grid_assign_handle(&amp;msg_grid);</a>
<a name="ln165">  bool should_alloc = msg_use_grid();</a>
<a name="ln166">  if (should_alloc &amp;&amp; (msg_grid.rows != Rows || msg_grid.cols != Columns</a>
<a name="ln167">                       || !msg_grid.chars)) {</a>
<a name="ln168">    // TODO(bfredl): eventually should be set to &quot;invalid&quot;. I e all callers</a>
<a name="ln169">    // will use the grid including clear to EOS if necessary.</a>
<a name="ln170">    grid_alloc(&amp;msg_grid, Rows, Columns, false, true);</a>
<a name="ln171">    msg_grid.zindex = kZIndexMessages;</a>
<a name="ln172"> </a>
<a name="ln173">    xfree(msg_grid.dirty_col);</a>
<a name="ln174">    msg_grid.dirty_col = xcalloc(Rows, sizeof(*msg_grid.dirty_col));</a>
<a name="ln175"> </a>
<a name="ln176">    // Tricky: allow resize while pager is active</a>
<a name="ln177">    int pos = msg_scrolled ? msg_grid_pos : Rows - p_ch;</a>
<a name="ln178">    ui_comp_put_grid(&amp;msg_grid, pos, 0, msg_grid.rows, msg_grid.cols,</a>
<a name="ln179">                     false, true);</a>
<a name="ln180">    ui_call_grid_resize(msg_grid.handle, msg_grid.cols, msg_grid.rows);</a>
<a name="ln181"> </a>
<a name="ln182">    msg_grid.throttled = false;  // don't throttle in 'cmdheight' area</a>
<a name="ln183">    msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln184">    msg_grid.focusable = false;</a>
<a name="ln185">    msg_grid_adj.target = &amp;msg_grid;</a>
<a name="ln186">    if (!msg_scrolled) {</a>
<a name="ln187">      msg_grid_set_pos(Rows - p_ch, false);</a>
<a name="ln188">    }</a>
<a name="ln189">  } else if (!should_alloc &amp;&amp; msg_grid.chars) {</a>
<a name="ln190">    ui_comp_remove_grid(&amp;msg_grid);</a>
<a name="ln191">    grid_free(&amp;msg_grid);</a>
<a name="ln192">    XFREE_CLEAR(msg_grid.dirty_col);</a>
<a name="ln193">    ui_call_grid_destroy(msg_grid.handle);</a>
<a name="ln194">    msg_grid.throttled = false;</a>
<a name="ln195">    msg_grid_adj.row_offset = 0;</a>
<a name="ln196">    msg_grid_adj.target = &amp;default_grid;</a>
<a name="ln197">    redraw_cmdline = true;</a>
<a name="ln198">  } else if (msg_grid.chars &amp;&amp; !msg_scrolled &amp;&amp; msg_grid_pos != Rows - p_ch) {</a>
<a name="ln199">    msg_grid_set_pos(Rows - p_ch, false);</a>
<a name="ln200">  }</a>
<a name="ln201"> </a>
<a name="ln202">  if (msg_grid.chars &amp;&amp; cmdline_row &lt; msg_grid_pos) {</a>
<a name="ln203">    // TODO(bfredl): this should already be the case, but fails in some</a>
<a name="ln204">    // &quot;batched&quot; executions where compute_cmdrow() use stale positions or</a>
<a name="ln205">    // something.</a>
<a name="ln206">    cmdline_row = msg_grid_pos;</a>
<a name="ln207">  }</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">/// Displays the string 's' on the status line</a>
<a name="ln211">/// When terminal not initialized (yet) mch_errmsg(..) is used.</a>
<a name="ln212">///</a>
<a name="ln213">/// @return  TRUE if wait_return not called</a>
<a name="ln214">int msg(char *s)</a>
<a name="ln215">{</a>
<a name="ln216">  return msg_attr_keep(s, 0, false, false);</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">/// Like msg() but keep it silent when 'verbosefile' is set.</a>
<a name="ln220">int verb_msg(char *s)</a>
<a name="ln221">{</a>
<a name="ln222">  verbose_enter();</a>
<a name="ln223">  int n = msg_attr_keep(s, 0, false, false);</a>
<a name="ln224">  verbose_leave();</a>
<a name="ln225"> </a>
<a name="ln226">  return n;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">int msg_attr(const char *s, const int attr)</a>
<a name="ln230">  FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln231">{</a>
<a name="ln232">  return msg_attr_keep(s, attr, false, false);</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/// Similar to msg_outtrans_attr, but support newlines and tabs.</a>
<a name="ln236">void msg_multiline_attr(const char *s, int attr, bool check_int, bool *need_clear)</a>
<a name="ln237">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln238">{</a>
<a name="ln239">  const char *next_spec = s;</a>
<a name="ln240"> </a>
<a name="ln241">  while (next_spec != NULL) {</a>
<a name="ln242">    if (check_int &amp;&amp; got_int) {</a>
<a name="ln243">      return;</a>
<a name="ln244">    }</a>
<a name="ln245">    next_spec = strpbrk(s, &quot;\t\n\r&quot;);</a>
<a name="ln246"> </a>
<a name="ln247">    if (next_spec != NULL) {</a>
<a name="ln248">      // Printing all char that are before the char found by strpbrk</a>
<a name="ln249">      msg_outtrans_len_attr((const char_u *)s, next_spec - s, attr);</a>
<a name="ln250"> </a>
<a name="ln251">      if (*next_spec != TAB &amp;&amp; *need_clear) {</a>
<a name="ln252">        msg_clr_eos();</a>
<a name="ln253">        *need_clear = false;</a>
<a name="ln254">      }</a>
<a name="ln255">      msg_putchar_attr((uint8_t)(*next_spec), attr);</a>
<a name="ln256">      s = next_spec + 1;</a>
<a name="ln257">    }</a>
<a name="ln258">  }</a>
<a name="ln259"> </a>
<a name="ln260">  // Print the rest of the message. We know there is no special</a>
<a name="ln261">  // character because strpbrk returned NULL</a>
<a name="ln262">  if (*s != NUL) {</a>
<a name="ln263">    msg_outtrans_attr((char_u *)s, attr);</a>
<a name="ln264">  }</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/// @param keep set keep_msg if it doesn't scroll</a>
<a name="ln268">bool msg_attr_keep(const char *s, int attr, bool keep, bool multiline)</a>
<a name="ln269">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln270">{</a>
<a name="ln271">  static int entered = 0;</a>
<a name="ln272">  int retval;</a>
<a name="ln273">  char_u *buf = NULL;</a>
<a name="ln274"> </a>
<a name="ln275">  if (keep &amp;&amp; multiline) {</a>
<a name="ln276">    // Not implemented. 'multiline' is only used by nvim-added messages,</a>
<a name="ln277">    // which should avoid 'keep' behavior (just show the message at</a>
<a name="ln278">    // the correct time already).</a>
<a name="ln279">    abort();</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  // Skip messages not match &quot;:filter pattern&quot;.</a>
<a name="ln283">  // Don't filter when there is an error.</a>
<a name="ln284">  if (!emsg_on_display &amp;&amp; message_filtered((char_u *)s)) {</a>
<a name="ln285">    return true;</a>
<a name="ln286">  }</a>
<a name="ln287"> </a>
<a name="ln288">  if (attr == 0) {</a>
<a name="ln289">    set_vim_var_string(VV_STATUSMSG, s, -1);</a>
<a name="ln290">  }</a>
<a name="ln291"> </a>
<a name="ln292">  /*</a>
<a name="ln293">   * It is possible that displaying a messages causes a problem (e.g.,</a>
<a name="ln294">   * when redrawing the window), which causes another message, etc..    To</a>
<a name="ln295">   * break this loop, limit the recursiveness to 3 levels.</a>
<a name="ln296">   */</a>
<a name="ln297">  if (entered &gt;= 3) {</a>
<a name="ln298">    return TRUE;</a>
<a name="ln299">  }</a>
<a name="ln300">  ++entered;</a>
<a name="ln301"> </a>
<a name="ln302">  // Add message to history (unless it's a repeated kept message or a</a>
<a name="ln303">  // truncated message)</a>
<a name="ln304">  if ((const char_u *)s != keep_msg</a>
<a name="ln305">      || (*s != '&lt;'</a>
<a name="ln306">          &amp;&amp; last_msg_hist != NULL</a>
<a name="ln307">          &amp;&amp; last_msg_hist-&gt;msg != NULL</a>
<a name="ln308">          &amp;&amp; STRCMP(s, last_msg_hist-&gt;msg))) {</a>
<a name="ln309">    add_msg_hist(s, -1, attr, multiline);</a>
<a name="ln310">  }</a>
<a name="ln311"> </a>
<a name="ln312">  // Truncate the message if needed.</a>
<a name="ln313">  msg_start();</a>
<a name="ln314">  buf = msg_strtrunc((char_u *)s, FALSE);</a>
<a name="ln315">  if (buf != NULL) {</a>
<a name="ln316">    s = (const char *)buf;</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">  bool need_clear = true;</a>
<a name="ln320">  if (multiline) {</a>
<a name="ln321">    msg_multiline_attr(s, attr, false, &amp;need_clear);</a>
<a name="ln322">  } else {</a>
<a name="ln323">    msg_outtrans_attr((char_u *)s, attr);</a>
<a name="ln324">  }</a>
<a name="ln325">  if (need_clear) {</a>
<a name="ln326">    msg_clr_eos();</a>
<a name="ln327">  }</a>
<a name="ln328">  retval = msg_end();</a>
<a name="ln329"> </a>
<a name="ln330">  if (keep &amp;&amp; retval &amp;&amp; vim_strsize((char_u *)s) &lt; (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln331">    set_keep_msg((char *)s, 0);</a>
<a name="ln332">  }</a>
<a name="ln333"> </a>
<a name="ln334">  need_fileinfo = false;</a>
<a name="ln335"> </a>
<a name="ln336">  xfree(buf);</a>
<a name="ln337">  --entered;</a>
<a name="ln338">  return retval;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">/// Truncate a string such that it can be printed without causing a scroll.</a>
<a name="ln342">///</a>
<a name="ln343">/// @return  an allocated string or NULL when no truncating is done.</a>
<a name="ln344">///</a>
<a name="ln345">/// @param force  always truncate</a>
<a name="ln346">char_u *msg_strtrunc(char_u *s, int force)</a>
<a name="ln347">{</a>
<a name="ln348">  char_u *buf = NULL;</a>
<a name="ln349">  int len;</a>
<a name="ln350">  int room;</a>
<a name="ln351"> </a>
<a name="ln352">  // May truncate message to avoid a hit-return prompt</a>
<a name="ln353">  if ((!msg_scroll &amp;&amp; !need_wait_return &amp;&amp; shortmess(SHM_TRUNCALL)</a>
<a name="ln354">       &amp;&amp; !exmode_active &amp;&amp; msg_silent == 0 &amp;&amp; !ui_has(kUIMessages))</a>
<a name="ln355">      || force) {</a>
<a name="ln356">    len = vim_strsize(s);</a>
<a name="ln357">    if (msg_scrolled != 0) {</a>
<a name="ln358">      // Use all the columns.</a>
<a name="ln359">      room = (Rows - msg_row) * Columns - 1;</a>
<a name="ln360">    } else {</a>
<a name="ln361">      // Use up to 'showcmd' column.</a>
<a name="ln362">      room = (Rows - msg_row - 1) * Columns + sc_col - 1;</a>
<a name="ln363">    }</a>
<a name="ln364">    if (len &gt; room &amp;&amp; room &gt; 0) {</a>
<a name="ln365">      // may have up to 18 bytes per cell (6 per char, up to two</a>
<a name="ln366">      // composing chars)</a>
<a name="ln367">      len = (room + 2) * 18;</a>
<a name="ln368">      buf = xmalloc(len);</a>
<a name="ln369">      trunc_string(s, buf, room, len);</a>
<a name="ln370">    }</a>
<a name="ln371">  }</a>
<a name="ln372">  return buf;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">/// Truncate a string &quot;s&quot; to &quot;buf&quot; with cell width &quot;room&quot;.</a>
<a name="ln376">/// &quot;s&quot; and &quot;buf&quot; may be equal.</a>
<a name="ln377">void trunc_string(char_u *s, char_u *buf, int room_in, int buflen)</a>
<a name="ln378">{</a>
<a name="ln379">  size_t room = room_in - 3;  // &quot;...&quot; takes 3 chars</a>
<a name="ln380">  size_t half;</a>
<a name="ln381">  size_t len = 0;</a>
<a name="ln382">  int e;</a>
<a name="ln383">  int i;</a>
<a name="ln384">  int n;</a>
<a name="ln385"> </a>
<a name="ln386">  if (*s == NUL) {</a>
<a name="ln387">    if (buflen &gt; 0) {</a>
<a name="ln388">      *buf = NUL;</a>
<a name="ln389">    }</a>
<a name="ln390">    return;</a>
<a name="ln391">  }</a>
<a name="ln392"> </a>
<a name="ln393">  if (room_in &lt; 3) {</a>
<a name="ln394">    room = 0;</a>
<a name="ln395">  }</a>
<a name="ln396">  half = room / 2;</a>
<a name="ln397"> </a>
<a name="ln398">  // First part: Start of the string.</a>
<a name="ln399">  for (e = 0; len &lt; half &amp;&amp; e &lt; buflen; ++e) {</a>
<a name="ln400">    if (s[e] == NUL) {</a>
<a name="ln401">      // text fits without truncating!</a>
<a name="ln402">      buf[e] = NUL;</a>
<a name="ln403">      return;</a>
<a name="ln404">    }</a>
<a name="ln405">    n = ptr2cells(s + e);</a>
<a name="ln406">    if (len + n &gt; half) {</a>
<a name="ln407">      break;</a>
<a name="ln408">    }</a>
<a name="ln409">    len += n;</a>
<a name="ln410">    buf[e] = s[e];</a>
<a name="ln411">    for (n = utfc_ptr2len((char *)s + e); --n &gt; 0;) {</a>
<a name="ln412">      if (++e == buflen) {</a>
<a name="ln413">        break;</a>
<a name="ln414">      }</a>
<a name="ln415">      buf[e] = s[e];</a>
<a name="ln416">    }</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  // Last part: End of the string.</a>
<a name="ln420">  half = i = (int)STRLEN(s);</a>
<a name="ln421">  for (;;) {</a>
<a name="ln422">    do {</a>
<a name="ln423">      half = half - utf_head_off(s, s + half - 1) - 1;</a>
<a name="ln424">    } while (half &gt; 0 &amp;&amp; utf_iscomposing(utf_ptr2char((char *)s + half)));</a>
<a name="ln425">    n = ptr2cells(s + half);</a>
<a name="ln426">    if (len + n &gt; room || half == 0) {</a>
<a name="ln427">      break;</a>
<a name="ln428">    }</a>
<a name="ln429">    len += n;</a>
<a name="ln430">    i = half;</a>
<a name="ln431">  }</a>
<a name="ln432"> </a>
<a name="ln433">  if (i &lt;= e + 3) {</a>
<a name="ln434">    // text fits without truncating</a>
<a name="ln435">    if (s != buf) {</a>
<a name="ln436">      len = STRLEN(s);</a>
<a name="ln437">      if (len &gt;= (size_t)buflen) {</a>
<a name="ln438">        len = buflen - 1;</a>
<a name="ln439">      }</a>
<a name="ln440">      len = len - e + 1;</a>
<a name="ln441">      if (len &lt; 1) {</a>
<a name="ln442">        buf[e - 1] = NUL;</a>
<a name="ln443">      } else {</a>
<a name="ln444">        memmove(buf + e, s + e, len);</a>
<a name="ln445">      }</a>
<a name="ln446">    }</a>
<a name="ln447">  } else if (e + 3 &lt; buflen) {</a>
<a name="ln448">    // set the middle and copy the last part</a>
<a name="ln449">    memmove(buf + e, &quot;...&quot;, (size_t)3);</a>
<a name="ln450">    len = STRLEN(s + i) + 1;</a>
<a name="ln451">    if (len &gt;= (size_t)buflen - e - 3) {</a>
<a name="ln452">      len = buflen - e - 3 - 1;</a>
<a name="ln453">    }</a>
<a name="ln454">    memmove(buf + e + 3, s + i, len);</a>
<a name="ln455">    buf[e + 3 + len - 1] = NUL;</a>
<a name="ln456">  } else {</a>
<a name="ln457">    // can't fit in the &quot;...&quot;, just truncate it</a>
<a name="ln458">    buf[e - 1] = NUL;</a>
<a name="ln459">  }</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/*</a>
<a name="ln463"> * Note: Caller of smsg() and smsg_attr() must check the resulting string is</a>
<a name="ln464"> * shorter than IOSIZE!!!</a>
<a name="ln465"> */</a>
<a name="ln466"> </a>
<a name="ln467">int smsg(const char *s, ...)</a>
<a name="ln468">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln469">{</a>
<a name="ln470">  va_list arglist;</a>
<a name="ln471"> </a>
<a name="ln472">  va_start(arglist, s);</a>
<a name="ln473">  vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);</a>
<a name="ln474">  va_end(arglist);</a>
<a name="ln475">  return msg((char *)IObuff);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">int smsg_attr(int attr, const char *s, ...)</a>
<a name="ln479">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln480">{</a>
<a name="ln481">  va_list arglist;</a>
<a name="ln482"> </a>
<a name="ln483">  va_start(arglist, s);</a>
<a name="ln484">  vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);</a>
<a name="ln485">  va_end(arglist);</a>
<a name="ln486">  return msg_attr((const char *)IObuff, attr);</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">int smsg_attr_keep(int attr, const char *s, ...)</a>
<a name="ln490">  FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln491">{</a>
<a name="ln492">  va_list arglist;</a>
<a name="ln493"> </a>
<a name="ln494">  va_start(arglist, s);</a>
<a name="ln495">  vim_vsnprintf((char *)IObuff, IOSIZE, s, arglist);</a>
<a name="ln496">  va_end(arglist);</a>
<a name="ln497">  return msg_attr_keep((const char *)IObuff, attr, true, false);</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">/*</a>
<a name="ln501"> * Remember the last sourcing name/lnum used in an error message, so that it</a>
<a name="ln502"> * isn't printed each time when it didn't change.</a>
<a name="ln503"> */</a>
<a name="ln504">static int last_sourcing_lnum = 0;</a>
<a name="ln505">static char_u *last_sourcing_name = NULL;</a>
<a name="ln506"> </a>
<a name="ln507">/// Reset the last used sourcing name/lnum.  Makes sure it is displayed again</a>
<a name="ln508">/// for the next error message;</a>
<a name="ln509">void reset_last_sourcing(void)</a>
<a name="ln510">{</a>
<a name="ln511">  XFREE_CLEAR(last_sourcing_name);</a>
<a name="ln512">  last_sourcing_lnum = 0;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">/// @return  TRUE if &quot;sourcing_name&quot; differs from &quot;last_sourcing_name&quot;.</a>
<a name="ln516">static int other_sourcing_name(void)</a>
<a name="ln517">{</a>
<a name="ln518">  if (sourcing_name != NULL) {</a>
<a name="ln519">    if (last_sourcing_name != NULL) {</a>
<a name="ln520">      return STRCMP(sourcing_name, last_sourcing_name) != 0;</a>
<a name="ln521">    }</a>
<a name="ln522">    return TRUE;</a>
<a name="ln523">  }</a>
<a name="ln524">  return FALSE;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">/// Get the message about the source, as used for an error message</a>
<a name="ln528">///</a>
<a name="ln529">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln530">///                     message is to be given.</a>
<a name="ln531">static char *get_emsg_source(void)</a>
<a name="ln532">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln533">{</a>
<a name="ln534">  if (sourcing_name != NULL &amp;&amp; other_sourcing_name()) {</a>
<a name="ln535">    const char *const p = _(&quot;Error detected while processing %s:&quot;);</a>
<a name="ln536">    const size_t buf_len = STRLEN(sourcing_name) + strlen(p) + 1;</a>
<a name="ln537">    char *const buf = xmalloc(buf_len);</a>
<a name="ln538">    snprintf(buf, buf_len, p, sourcing_name);</a>
<a name="ln539">    return buf;</a>
<a name="ln540">  }</a>
<a name="ln541">  return NULL;</a>
<a name="ln542">}</a>
<a name="ln543"> </a>
<a name="ln544">/// Get the message about the source lnum, as used for an error message.</a>
<a name="ln545">///</a>
<a name="ln546">/// @return [allocated] String with room for one more character. NULL when no</a>
<a name="ln547">///                     message is to be given.</a>
<a name="ln548">static char *get_emsg_lnum(void)</a>
<a name="ln549">  FUNC_ATTR_MALLOC FUNC_ATTR_WARN_UNUSED_RESULT</a>
<a name="ln550">{</a>
<a name="ln551">  // lnum is 0 when executing a command from the command line</a>
<a name="ln552">  // argument, we don't want a line number then</a>
<a name="ln553">  if (sourcing_name != NULL</a>
<a name="ln554">      &amp;&amp; (other_sourcing_name() || sourcing_lnum != last_sourcing_lnum)</a>
<a name="ln555">      &amp;&amp; sourcing_lnum != 0) {</a>
<a name="ln556">    const char *const p = _(&quot;line %4ld:&quot;);</a>
<a name="ln557">    const size_t buf_len = 20 + strlen(p);</a>
<a name="ln558">    char *const buf = xmalloc(buf_len);</a>
<a name="ln559">    snprintf(buf, buf_len, p, (long)sourcing_lnum);</a>
<a name="ln560">    return buf;</a>
<a name="ln561">  }</a>
<a name="ln562">  return NULL;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">/// Display name and line number for the source of an error.</a>
<a name="ln566">/// Remember the file name and line number, so that for the next error the info</a>
<a name="ln567">/// is only displayed if it changed.</a>
<a name="ln568">void msg_source(int attr)</a>
<a name="ln569">{</a>
<a name="ln570">  no_wait_return++;</a>
<a name="ln571">  char *p = get_emsg_source();</a>
<a name="ln572">  if (p != NULL) {</a>
<a name="ln573">    msg_attr(p, attr);</a>
<a name="ln574">    xfree(p);</a>
<a name="ln575">  }</a>
<a name="ln576">  p = get_emsg_lnum();</a>
<a name="ln577">  if (p != NULL) {</a>
<a name="ln578">    msg_attr(p, HL_ATTR(HLF_N));</a>
<a name="ln579">    xfree(p);</a>
<a name="ln580">    last_sourcing_lnum = sourcing_lnum;      // only once for each line</a>
<a name="ln581">  }</a>
<a name="ln582"> </a>
<a name="ln583">  // remember the last sourcing name printed, also when it's empty</a>
<a name="ln584">  if (sourcing_name == NULL || other_sourcing_name()) {</a>
<a name="ln585">    xfree(last_sourcing_name);</a>
<a name="ln586">    if (sourcing_name == NULL) {</a>
<a name="ln587">      last_sourcing_name = NULL;</a>
<a name="ln588">    } else {</a>
<a name="ln589">      last_sourcing_name = vim_strsave((char_u *)sourcing_name);</a>
<a name="ln590">    }</a>
<a name="ln591">  }</a>
<a name="ln592">  --no_wait_return;</a>
<a name="ln593">}</a>
<a name="ln594"> </a>
<a name="ln595">/// @return  TRUE if not giving error messages right now:</a>
<a name="ln596">///            If &quot;emsg_off&quot; is set: no error messages at the moment.</a>
<a name="ln597">///            If &quot;msg&quot; is in 'debug': do error message but without side effects.</a>
<a name="ln598">///            If &quot;emsg_skip&quot; is set: never do error messages.</a>
<a name="ln599">int emsg_not_now(void)</a>
<a name="ln600">{</a>
<a name="ln601">  if ((emsg_off &gt; 0 &amp;&amp; vim_strchr((char *)p_debug, 'm') == NULL</a>
<a name="ln602">       &amp;&amp; vim_strchr((char *)p_debug, 't') == NULL)</a>
<a name="ln603">      || emsg_skip &gt; 0) {</a>
<a name="ln604">    return TRUE;</a>
<a name="ln605">  }</a>
<a name="ln606">  return FALSE;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609">static bool emsg_multiline(const char *s, bool multiline)</a>
<a name="ln610">{</a>
<a name="ln611">  int attr;</a>
<a name="ln612">  bool ignore = false;</a>
<a name="ln613"> </a>
<a name="ln614">  // Skip this if not giving error messages at the moment.</a>
<a name="ln615">  if (emsg_not_now()) {</a>
<a name="ln616">    return true;</a>
<a name="ln617">  }</a>
<a name="ln618"> </a>
<a name="ln619">  called_emsg = true;</a>
<a name="ln620"> </a>
<a name="ln621">  // If &quot;emsg_severe&quot; is true: When an error exception is to be thrown,</a>
<a name="ln622">  // prefer this message over previous messages for the same command.</a>
<a name="ln623">  bool severe = emsg_severe;</a>
<a name="ln624">  emsg_severe = false;</a>
<a name="ln625"> </a>
<a name="ln626">  if (!emsg_off || vim_strchr((char *)p_debug, 't') != NULL) {</a>
<a name="ln627">    // Cause a throw of an error exception if appropriate.  Don't display</a>
<a name="ln628">    // the error message in this case.  (If no matching catch clause will</a>
<a name="ln629">    // be found, the message will be displayed later on.)  &quot;ignore&quot; is set</a>
<a name="ln630">    // when the message should be ignored completely (used for the</a>
<a name="ln631">    // interrupt message).</a>
<a name="ln632">    if (cause_errthrow(s, severe, &amp;ignore)) {</a>
<a name="ln633">      if (!ignore) {</a>
<a name="ln634">        did_emsg++;</a>
<a name="ln635">      }</a>
<a name="ln636">      return true;</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">    // set &quot;v:errmsg&quot;, also when using &quot;:silent! cmd&quot;</a>
<a name="ln640">    set_vim_var_string(VV_ERRMSG, s, -1);</a>
<a name="ln641"> </a>
<a name="ln642">    /*</a>
<a name="ln643">     * When using &quot;:silent! cmd&quot; ignore error messages.</a>
<a name="ln644">     * But do write it to the redirection file.</a>
<a name="ln645">     */</a>
<a name="ln646">    if (emsg_silent != 0) {</a>
<a name="ln647">      if (!emsg_noredir) {</a>
<a name="ln648">        msg_start();</a>
<a name="ln649">        char *p = get_emsg_source();</a>
<a name="ln650">        if (p != NULL) {</a>
<a name="ln651">          const size_t p_len = strlen(p);</a>
<a name="ln652">          p[p_len] = '\n';</a>
<a name="ln653">          redir_write(p, p_len + 1);</a>
<a name="ln654">          xfree(p);</a>
<a name="ln655">        }</a>
<a name="ln656">        p = get_emsg_lnum();</a>
<a name="ln657">        if (p != NULL) {</a>
<a name="ln658">          const size_t p_len = strlen(p);</a>
<a name="ln659">          p[p_len] = '\n';</a>
<a name="ln660">          redir_write(p, p_len + 1);</a>
<a name="ln661">          xfree(p);</a>
<a name="ln662">        }</a>
<a name="ln663">        redir_write(s, strlen(s));</a>
<a name="ln664">      }</a>
<a name="ln665"> </a>
<a name="ln666">      // Log (silent) errors as debug messages.</a>
<a name="ln667">      if (sourcing_name != NULL &amp;&amp; sourcing_lnum != 0) {</a>
<a name="ln668">        DLOG(&quot;(:silent) %s (%s (line %ld))&quot;,</a>
<a name="ln669">             s, sourcing_name, (long)sourcing_lnum);</a>
<a name="ln670">      } else {</a>
<a name="ln671">        DLOG(&quot;(:silent) %s&quot;, s);</a>
<a name="ln672">      }</a>
<a name="ln673"> </a>
<a name="ln674">      return true;</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">    // Log editor errors as INFO.</a>
<a name="ln678">    if (sourcing_name != NULL &amp;&amp; sourcing_lnum != 0) {</a>
<a name="ln679">      ILOG(&quot;%s (%s (line %ld))&quot;, s, sourcing_name, (long)sourcing_lnum);</a>
<a name="ln680">    } else {</a>
<a name="ln681">      ILOG(&quot;%s&quot;, s);</a>
<a name="ln682">    }</a>
<a name="ln683"> </a>
<a name="ln684">    ex_exitval = 1;</a>
<a name="ln685"> </a>
<a name="ln686">    // Reset msg_silent, an error causes messages to be switched back on.</a>
<a name="ln687">    msg_silent = 0;</a>
<a name="ln688">    cmd_silent = false;</a>
<a name="ln689"> </a>
<a name="ln690">    if (global_busy) {        // break :global command</a>
<a name="ln691">      global_busy++;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    if (p_eb) {</a>
<a name="ln695">      beep_flush();           // also includes flush_buffers()</a>
<a name="ln696">    } else {</a>
<a name="ln697">      flush_buffers(FLUSH_MINIMAL);  // flush internal buffers</a>
<a name="ln698">    }</a>
<a name="ln699">    did_emsg++;               // flag for DoOneCmd()</a>
<a name="ln700">  }</a>
<a name="ln701"> </a>
<a name="ln702">  emsg_on_display = true;     // remember there is an error message</a>
<a name="ln703">  msg_scroll++;               // don't overwrite a previous message</a>
<a name="ln704">  attr = HL_ATTR(HLF_E);      // set highlight mode for error messages</a>
<a name="ln705">  if (msg_scrolled != 0) {</a>
<a name="ln706">    need_wait_return = true;  // needed in case emsg() is called after</a>
<a name="ln707">  }                           // wait_return has reset need_wait_return</a>
<a name="ln708">                              // and a redraw is expected because</a>
<a name="ln709">                              // msg_scrolled is non-zero</a>
<a name="ln710">  if (msg_ext_kind == NULL) {</a>
<a name="ln711">    msg_ext_set_kind(&quot;emsg&quot;);</a>
<a name="ln712">  }</a>
<a name="ln713"> </a>
<a name="ln714">  /*</a>
<a name="ln715">   * Display name and line number for the source of the error.</a>
<a name="ln716">   */</a>
<a name="ln717">  msg_source(attr);</a>
<a name="ln718"> </a>
<a name="ln719">  // Display the error message itself.</a>
<a name="ln720">  msg_nowait = false;  // Wait for this msg.</a>
<a name="ln721">  return msg_attr_keep(s, attr, false, multiline);</a>
<a name="ln722">}</a>
<a name="ln723"> </a>
<a name="ln724">/// emsg() - display an error message</a>
<a name="ln725">///</a>
<a name="ln726">/// Rings the bell, if appropriate, and calls message() to do the real work</a>
<a name="ln727">/// When terminal not initialized (yet) mch_errmsg(..) is used.</a>
<a name="ln728">///</a>
<a name="ln729">/// @return true if wait_return not called</a>
<a name="ln730">bool emsg(const char *s)</a>
<a name="ln731">{</a>
<a name="ln732">  return emsg_multiline(s, false);</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">void emsg_invreg(int name)</a>
<a name="ln736">{</a>
<a name="ln737">  semsg(_(&quot;E354: Invalid register name: '%s'&quot;), transchar(name));</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/// Print an error message with unknown number of arguments</a>
<a name="ln741">bool semsg(const char *const fmt, ...)</a>
<a name="ln742">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln743">{</a>
<a name="ln744">  bool ret;</a>
<a name="ln745"> </a>
<a name="ln746">  va_list ap;</a>
<a name="ln747">  va_start(ap, fmt);</a>
<a name="ln748">  ret = semsgv(fmt, ap);</a>
<a name="ln749">  va_end(ap);</a>
<a name="ln750"> </a>
<a name="ln751">  return ret;</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">#define MULTILINE_BUFSIZE 8192</a>
<a name="ln755"> </a>
<a name="ln756">bool semsg_multiline(const char *const fmt, ...)</a>
<a name="ln757">{</a>
<a name="ln758">  bool ret;</a>
<a name="ln759">  va_list ap;</a>
<a name="ln760"> </a>
<a name="ln761">  static char errbuf[MULTILINE_BUFSIZE];</a>
<a name="ln762">  if (emsg_not_now()) {</a>
<a name="ln763">    return true;</a>
<a name="ln764">  }</a>
<a name="ln765"> </a>
<a name="ln766">  va_start(ap, fmt);</a>
<a name="ln767">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln768">  va_end(ap);</a>
<a name="ln769"> </a>
<a name="ln770">  ret = emsg_multiline(errbuf, true);</a>
<a name="ln771"> </a>
<a name="ln772">  return ret;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">/// Print an error message with unknown number of arguments</a>
<a name="ln776">static bool semsgv(const char *fmt, va_list ap)</a>
<a name="ln777">{</a>
<a name="ln778">  static char errbuf[IOSIZE];</a>
<a name="ln779">  if (emsg_not_now()) {</a>
<a name="ln780">    return true;</a>
<a name="ln781">  }</a>
<a name="ln782"> </a>
<a name="ln783">  vim_vsnprintf(errbuf, sizeof(errbuf), fmt, ap);</a>
<a name="ln784"> </a>
<a name="ln785">  return emsg(errbuf);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">/// Same as emsg(...), but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln789">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln790">/// detected when fuzzing vim.</a>
<a name="ln791">void iemsg(const char *s)</a>
<a name="ln792">{</a>
<a name="ln793">  emsg(s);</a>
<a name="ln794">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln795">  abort();</a>
<a name="ln796">#endif</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">/// Same as semsg(...) but abort on error when ABORT_ON_INTERNAL_ERROR is</a>
<a name="ln800">/// defined. It is used for internal errors only, so that they can be</a>
<a name="ln801">/// detected when fuzzing vim.</a>
<a name="ln802">void siemsg(const char *s, ...)</a>
<a name="ln803">{</a>
<a name="ln804">  va_list ap;</a>
<a name="ln805">  va_start(ap, s);</a>
<a name="ln806">  (void)semsgv(s, ap);</a>
<a name="ln807">  va_end(ap);</a>
<a name="ln808">#ifdef ABORT_ON_INTERNAL_ERROR</a>
<a name="ln809">  abort();</a>
<a name="ln810">#endif</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">/// Give an &quot;Internal error&quot; message.</a>
<a name="ln814">void internal_error(char *where)</a>
<a name="ln815">{</a>
<a name="ln816">  siemsg(_(e_intern2), where);</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">static void msg_semsg_event(void **argv)</a>
<a name="ln820">{</a>
<a name="ln821">  char *s = argv[0];</a>
<a name="ln822">  (void)emsg(s);</a>
<a name="ln823">  xfree(s);</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">void msg_schedule_semsg(const char *const fmt, ...)</a>
<a name="ln827">  FUNC_ATTR_PRINTF(1, 2)</a>
<a name="ln828">{</a>
<a name="ln829">  va_list ap;</a>
<a name="ln830">  va_start(ap, fmt);</a>
<a name="ln831">  vim_vsnprintf((char *)IObuff, IOSIZE, fmt, ap);</a>
<a name="ln832">  va_end(ap);</a>
<a name="ln833"> </a>
<a name="ln834">  char *s = xstrdup((char *)IObuff);</a>
<a name="ln835">  multiqueue_put(main_loop.events, msg_semsg_event, 1, s);</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">/// Like msg(), but truncate to a single line if p_shm contains 't', or when</a>
<a name="ln839">/// &quot;force&quot; is true.  This truncates in another way as for normal messages.</a>
<a name="ln840">/// Careful: The string may be changed by msg_may_trunc()!</a>
<a name="ln841">///</a>
<a name="ln842">/// @return  a pointer to the printed message, if wait_return() not called.</a>
<a name="ln843">char *msg_trunc_attr(char *s, bool force, int attr)</a>
<a name="ln844">{</a>
<a name="ln845">  int n;</a>
<a name="ln846"> </a>
<a name="ln847">  // Add message to history before truncating.</a>
<a name="ln848">  add_msg_hist(s, -1, attr, false);</a>
<a name="ln849"> </a>
<a name="ln850">  char *ts = (char *)msg_may_trunc(force, (char_u *)s);</a>
<a name="ln851"> </a>
<a name="ln852">  msg_hist_off = true;</a>
<a name="ln853">  n = msg_attr(ts, attr);</a>
<a name="ln854">  msg_hist_off = false;</a>
<a name="ln855"> </a>
<a name="ln856">  if (n) {</a>
<a name="ln857">    return ts;</a>
<a name="ln858">  }</a>
<a name="ln859">  return NULL;</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">/// Check if message &quot;s&quot; should be truncated at the start (for filenames).</a>
<a name="ln863">///</a>
<a name="ln864">/// @return  a pointer to where the truncated message starts.</a>
<a name="ln865">///</a>
<a name="ln866">/// @note: May change the message by replacing a character with '&lt;'.</a>
<a name="ln867">char_u *msg_may_trunc(bool force, char_u *s)</a>
<a name="ln868">{</a>
<a name="ln869">  int room;</a>
<a name="ln870"> </a>
<a name="ln871">  room = (Rows - cmdline_row - 1) * Columns + sc_col - 1;</a>
<a name="ln872">  if ((force || (shortmess(SHM_TRUNC) &amp;&amp; !exmode_active))</a>
<a name="ln873">      &amp;&amp; (int)STRLEN(s) - room &gt; 0) {</a>
<a name="ln874">    int size = vim_strsize(s);</a>
<a name="ln875"> </a>
<a name="ln876">    // There may be room anyway when there are multibyte chars.</a>
<a name="ln877">    if (size &lt;= room) {</a>
<a name="ln878">      return s;</a>
<a name="ln879">    }</a>
<a name="ln880">    int n;</a>
<a name="ln881">    for (n = 0; size &gt;= room;) {</a>
<a name="ln882">      size -= utf_ptr2cells((char *)s + n);</a>
<a name="ln883">      n += utfc_ptr2len((char *)s + n);</a>
<a name="ln884">    }</a>
<a name="ln885">    n--;</a>
<a name="ln886">    s += n;</a>
<a name="ln887">    *s = '&lt;';</a>
<a name="ln888">  }</a>
<a name="ln889">  return s;</a>
<a name="ln890">}</a>
<a name="ln891"> </a>
<a name="ln892">void clear_hl_msg(HlMessage *hl_msg)</a>
<a name="ln893">{</a>
<a name="ln894">  for (size_t i = 0; i &lt; kv_size(*hl_msg); i++) {</a>
<a name="ln895">    xfree(kv_A(*hl_msg, i).text.data);</a>
<a name="ln896">  }</a>
<a name="ln897">  kv_destroy(*hl_msg);</a>
<a name="ln898">  *hl_msg = (HlMessage)KV_INITIAL_VALUE;</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">#define LINE_BUFFER_SIZE 4096</a>
<a name="ln902"> </a>
<a name="ln903">void add_hl_msg_hist(HlMessage hl_msg)</a>
<a name="ln904">{</a>
<a name="ln905">  // TODO(notomo): support multi highlighted message history</a>
<a name="ln906">  size_t pos = 0;</a>
<a name="ln907">  char buf[LINE_BUFFER_SIZE];</a>
<a name="ln908">  for (uint32_t i = 0; i &lt; kv_size(hl_msg); i++) {</a>
<a name="ln909">    HlMessageChunk chunk = kv_A(hl_msg, i);</a>
<a name="ln910">    for (uint32_t j = 0; j &lt; chunk.text.size; j++) {</a>
<a name="ln911">      if (pos == LINE_BUFFER_SIZE - 1) {</a>
<a name="ln912">        buf[pos] = NUL;</a>
<a name="ln913">        add_msg_hist((const char *)buf, -1, MSG_HIST, true);</a>
<a name="ln914">        pos = 0;</a>
<a name="ln915">        continue;</a>
<a name="ln916">      }</a>
<a name="ln917">      buf[pos++] = chunk.text.data[j];</a>
<a name="ln918">    }</a>
<a name="ln919">  }</a>
<a name="ln920">  if (pos != 0) {</a>
<a name="ln921">    buf[pos] = NUL;</a>
<a name="ln922">    add_msg_hist((const char *)buf, -1, MSG_HIST, true);</a>
<a name="ln923">  }</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">/// @param[in]  len  Length of s or -1.</a>
<a name="ln927">static void add_msg_hist(const char *s, int len, int attr, bool multiline)</a>
<a name="ln928">{</a>
<a name="ln929">  if (msg_hist_off || msg_silent != 0) {</a>
<a name="ln930">    return;</a>
<a name="ln931">  }</a>
<a name="ln932"> </a>
<a name="ln933">  // Don't let the message history get too big</a>
<a name="ln934">  while (msg_hist_len &gt; MAX_MSG_HIST_LEN) {</a>
<a name="ln935">    (void)delete_first_msg();</a>
<a name="ln936">  }</a>
<a name="ln937"> </a>
<a name="ln938">  // allocate an entry and add the message at the end of the history</a>
<a name="ln939">  struct msg_hist *p = xmalloc(sizeof(struct msg_hist));</a>
<a name="ln940">  if (len &lt; 0) {</a>
<a name="ln941">    len = (int)STRLEN(s);</a>
<a name="ln942">  }</a>
<a name="ln943">  // remove leading and trailing newlines</a>
<a name="ln944">  while (len &gt; 0 &amp;&amp; *s == '\n') {</a>
<a name="ln945">    ++s;</a>
<a name="ln946">    --len;</a>
<a name="ln947">  }</a>
<a name="ln948">  while (len &gt; 0 &amp;&amp; s[len - 1] == '\n') {</a>
<a name="ln949">    len--;</a>
<a name="ln950">  }</a>
<a name="ln951">  p-&gt;msg = (char_u *)xmemdupz(s, (size_t)len);</a>
<a name="ln952">  p-&gt;next = NULL;</a>
<a name="ln953">  p-&gt;attr = attr;</a>
<a name="ln954">  p-&gt;multiline = multiline;</a>
<a name="ln955">  p-&gt;kind = msg_ext_kind;</a>
<a name="ln956">  if (last_msg_hist != NULL) {</a>
<a name="ln957">    last_msg_hist-&gt;next = p;</a>
<a name="ln958">  }</a>
<a name="ln959">  last_msg_hist = p;</a>
<a name="ln960">  if (first_msg_hist == NULL) {</a>
<a name="ln961">    first_msg_hist = last_msg_hist;</a>
<a name="ln962">  }</a>
<a name="ln963">  msg_hist_len++;</a>
<a name="ln964">}</a>
<a name="ln965"> </a>
<a name="ln966">/// Delete the first (oldest) message from the history.</a>
<a name="ln967">///</a>
<a name="ln968">/// @return  FAIL if there are no messages.</a>
<a name="ln969">int delete_first_msg(void)</a>
<a name="ln970">{</a>
<a name="ln971">  struct msg_hist *p;</a>
<a name="ln972"> </a>
<a name="ln973">  if (msg_hist_len &lt;= 0) {</a>
<a name="ln974">    return FAIL;</a>
<a name="ln975">  }</a>
<a name="ln976">  p = first_msg_hist;</a>
<a name="ln977">  first_msg_hist = p-&gt;next;</a>
<a name="ln978">  if (first_msg_hist == NULL) {  // history is becoming empty</a>
<a name="ln979">    assert(msg_hist_len == 1);</a>
<a name="ln980">    last_msg_hist = NULL;</a>
<a name="ln981">  }</a>
<a name="ln982">  xfree(p-&gt;msg);</a>
<a name="ln983">  xfree(p);</a>
<a name="ln984">  --msg_hist_len;</a>
<a name="ln985">  return OK;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/// :messages command implementation</a>
<a name="ln989">void ex_messages(void *const eap_p)</a>
<a name="ln990">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln991">{</a>
<a name="ln992">  const exarg_T *const eap = (const exarg_T *)eap_p;</a>
<a name="ln993">  struct msg_hist *p;</a>
<a name="ln994">  int c = 0;</a>
<a name="ln995"> </a>
<a name="ln996">  if (STRCMP(eap-&gt;arg, &quot;clear&quot;) == 0) {</a>
<a name="ln997">    int keep = eap-&gt;addr_count == 0 ? 0 : eap-&gt;line2;</a>
<a name="ln998"> </a>
<a name="ln999">    while (msg_hist_len &gt; keep) {</a>
<a name="ln1000">      (void)delete_first_msg();</a>
<a name="ln1001">    }</a>
<a name="ln1002">    return;</a>
<a name="ln1003">  }</a>
<a name="ln1004"> </a>
<a name="ln1005">  if (*eap-&gt;arg != NUL) {</a>
<a name="ln1006">    emsg(_(e_invarg));</a>
<a name="ln1007">    return;</a>
<a name="ln1008">  }</a>
<a name="ln1009"> </a>
<a name="ln1010">  p = first_msg_hist;</a>
<a name="ln1011"> </a>
<a name="ln1012">  if (eap-&gt;addr_count != 0) {</a>
<a name="ln1013">    // Count total messages</a>
<a name="ln1014">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1015">      c++;</a>
<a name="ln1016">    }</a>
<a name="ln1017"> </a>
<a name="ln1018">    c -= eap-&gt;line2;</a>
<a name="ln1019"> </a>
<a name="ln1020">    // Skip without number of messages specified</a>
<a name="ln1021">    for (p = first_msg_hist; p != NULL &amp;&amp; !got_int &amp;&amp; c &gt; 0; p = p-&gt;next, c--) {}</a>
<a name="ln1022">  }</a>
<a name="ln1023"> </a>
<a name="ln1024">  // Display what was not skipped.</a>
<a name="ln1025">  if (ui_has(kUIMessages)) {</a>
<a name="ln1026">    if (msg_silent) {</a>
<a name="ln1027">      return;</a>
<a name="ln1028">    }</a>
<a name="ln1029">    Array entries = ARRAY_DICT_INIT;</a>
<a name="ln1030">    for (; p != NULL; p = p-&gt;next) {</a>
<a name="ln1031">      if (p-&gt;msg != NULL &amp;&amp; p-&gt;msg[0] != NUL) {</a>
<a name="ln1032">        Array entry = ARRAY_DICT_INIT;</a>
<a name="ln1033">        ADD(entry, STRING_OBJ(cstr_to_string(p-&gt;kind)));</a>
<a name="ln1034">        Array content_entry = ARRAY_DICT_INIT;</a>
<a name="ln1035">        ADD(content_entry, INTEGER_OBJ(p-&gt;attr));</a>
<a name="ln1036">        ADD(content_entry, STRING_OBJ(cstr_to_string((char *)(p-&gt;msg))));</a>
<a name="ln1037">        Array content = ARRAY_DICT_INIT;</a>
<a name="ln1038">        ADD(content, ARRAY_OBJ(content_entry));</a>
<a name="ln1039">        ADD(entry, ARRAY_OBJ(content));</a>
<a name="ln1040">        ADD(entries, ARRAY_OBJ(entry));</a>
<a name="ln1041">      }</a>
<a name="ln1042">    }</a>
<a name="ln1043">    ui_call_msg_history_show(entries);</a>
<a name="ln1044">    msg_ext_history_visible = true;</a>
<a name="ln1045">    wait_return(false);</a>
<a name="ln1046">  } else {</a>
<a name="ln1047">    msg_hist_off = true;</a>
<a name="ln1048">    for (; p != NULL &amp;&amp; !got_int; p = p-&gt;next) {</a>
<a name="ln1049">      if (p-&gt;msg != NULL) {</a>
<a name="ln1050">        msg_attr_keep((char *)p-&gt;msg, p-&gt;attr, false, p-&gt;multiline);</a>
<a name="ln1051">      }</a>
<a name="ln1052">    }</a>
<a name="ln1053">    msg_hist_off = false;</a>
<a name="ln1054">  }</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">/// Call this after prompting the user.  This will avoid a hit-return message</a>
<a name="ln1058">/// and a delay.</a>
<a name="ln1059">void msg_end_prompt(void)</a>
<a name="ln1060">{</a>
<a name="ln1061">  msg_ext_clear_later();</a>
<a name="ln1062">  need_wait_return = false;</a>
<a name="ln1063">  emsg_on_display = false;</a>
<a name="ln1064">  cmdline_row = msg_row;</a>
<a name="ln1065">  msg_col = 0;</a>
<a name="ln1066">  msg_clr_eos();</a>
<a name="ln1067">  lines_left = -1;</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/// Wait for the user to hit a key (normally Enter)</a>
<a name="ln1071">///</a>
<a name="ln1072">/// @param redraw  if true, redraw the entire screen NOT_VALID</a>
<a name="ln1073">///                if false, do a normal redraw</a>
<a name="ln1074">///                if -1, don't redraw at all</a>
<a name="ln1075">void wait_return(int redraw)</a>
<a name="ln1076">{</a>
<a name="ln1077">  int c;</a>
<a name="ln1078">  int oldState;</a>
<a name="ln1079">  int tmpState;</a>
<a name="ln1080">  int had_got_int;</a>
<a name="ln1081">  FILE *save_scriptout;</a>
<a name="ln1082"> </a>
<a name="ln1083">  if (redraw == true) {</a>
<a name="ln1084">    redraw_all_later(NOT_VALID);</a>
<a name="ln1085">  }</a>
<a name="ln1086"> </a>
<a name="ln1087">  // If using &quot;:silent cmd&quot;, don't wait for a return.  Also don't set</a>
<a name="ln1088">  // need_wait_return to do it later.</a>
<a name="ln1089">  if (msg_silent != 0) {</a>
<a name="ln1090">    return;</a>
<a name="ln1091">  }</a>
<a name="ln1092"> </a>
<a name="ln1093">  if (headless_mode &amp;&amp; !ui_active()) {</a>
<a name="ln1094">    return;</a>
<a name="ln1095">  }</a>
<a name="ln1096"> </a>
<a name="ln1097">  /*</a>
<a name="ln1098">   * When inside vgetc(), we can't wait for a typed character at all.</a>
<a name="ln1099">   * With the global command (and some others) we only need one return at</a>
<a name="ln1100">   * the end. Adjust cmdline_row to avoid the next message overwriting the</a>
<a name="ln1101">   * last one.</a>
<a name="ln1102">   */</a>
<a name="ln1103">  if (vgetc_busy &gt; 0) {</a>
<a name="ln1104">    return;</a>
<a name="ln1105">  }</a>
<a name="ln1106">  need_wait_return = true;</a>
<a name="ln1107">  if (no_wait_return) {</a>
<a name="ln1108">    if (!exmode_active) {</a>
<a name="ln1109">      cmdline_row = msg_row;</a>
<a name="ln1110">    }</a>
<a name="ln1111">    return;</a>
<a name="ln1112">  }</a>
<a name="ln1113"> </a>
<a name="ln1114">  redir_off = true;             // don't redirect this message</a>
<a name="ln1115">  oldState = State;</a>
<a name="ln1116">  if (quit_more) {</a>
<a name="ln1117">    c = CAR;                    // just pretend CR was hit</a>
<a name="ln1118">    quit_more = FALSE;</a>
<a name="ln1119">    got_int = FALSE;</a>
<a name="ln1120">  } else if (exmode_active) {</a>
<a name="ln1121">    msg_puts(&quot; &quot;);              // make sure the cursor is on the right line</a>
<a name="ln1122">    c = CAR;                    // no need for a return in ex mode</a>
<a name="ln1123">    got_int = FALSE;</a>
<a name="ln1124">  } else {</a>
<a name="ln1125">    // Make sure the hit-return prompt is on screen when 'guioptions' was</a>
<a name="ln1126">    // just changed.</a>
<a name="ln1127">    screenalloc();</a>
<a name="ln1128"> </a>
<a name="ln1129">    State = MODE_HITRETURN;</a>
<a name="ln1130">    setmouse();</a>
<a name="ln1131">    cmdline_row = msg_row;</a>
<a name="ln1132">    // Avoid the sequence that the user types &quot;:&quot; at the hit-return prompt</a>
<a name="ln1133">    // to start an Ex command, but the file-changed dialog gets in the</a>
<a name="ln1134">    // way.</a>
<a name="ln1135">    if (need_check_timestamps) {</a>
<a name="ln1136">      check_timestamps(false);</a>
<a name="ln1137">    }</a>
<a name="ln1138"> </a>
<a name="ln1139">    hit_return_msg();</a>
<a name="ln1140"> </a>
<a name="ln1141">    do {</a>
<a name="ln1142">      // Remember &quot;got_int&quot;, if it is set vgetc() probably returns a</a>
<a name="ln1143">      // CTRL-C, but we need to loop then.</a>
<a name="ln1144">      had_got_int = got_int;</a>
<a name="ln1145"> </a>
<a name="ln1146">      // Don't do mappings here, we put the character back in the</a>
<a name="ln1147">      // typeahead buffer.</a>
<a name="ln1148">      no_mapping++;</a>
<a name="ln1149">      allow_keys++;</a>
<a name="ln1150"> </a>
<a name="ln1151">      // Temporarily disable Recording. If Recording is active, the</a>
<a name="ln1152">      // character will be recorded later, since it will be added to the</a>
<a name="ln1153">      // typebuf after the loop</a>
<a name="ln1154">      const int save_reg_recording = reg_recording;</a>
<a name="ln1155">      save_scriptout = scriptout;</a>
<a name="ln1156">      reg_recording = 0;</a>
<a name="ln1157">      scriptout = NULL;</a>
<a name="ln1158">      c = safe_vgetc();</a>
<a name="ln1159">      if (had_got_int &amp;&amp; !global_busy) {</a>
<a name="ln1160">        got_int = false;</a>
<a name="ln1161">      }</a>
<a name="ln1162">      no_mapping--;</a>
<a name="ln1163">      allow_keys--;</a>
<a name="ln1164">      reg_recording = save_reg_recording;</a>
<a name="ln1165">      scriptout = save_scriptout;</a>
<a name="ln1166"> </a>
<a name="ln1167">      /*</a>
<a name="ln1168">       * Allow scrolling back in the messages.</a>
<a name="ln1169">       * Also accept scroll-down commands when messages fill the screen,</a>
<a name="ln1170">       * to avoid that typing one 'j' too many makes the messages</a>
<a name="ln1171">       * disappear.</a>
<a name="ln1172">       */</a>
<a name="ln1173">      if (p_more) {</a>
<a name="ln1174">        if (c == 'b' || c == 'k' || c == 'u' || c == 'g'</a>
<a name="ln1175">            || c == K_UP || c == K_PAGEUP) {</a>
<a name="ln1176">          if (msg_scrolled &gt; Rows) {</a>
<a name="ln1177">            // scroll back to show older messages</a>
<a name="ln1178">            do_more_prompt(c);</a>
<a name="ln1179">          } else {</a>
<a name="ln1180">            msg_didout = false;</a>
<a name="ln1181">            c = K_IGNORE;</a>
<a name="ln1182">            msg_col =</a>
<a name="ln1183">              cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1184">              0;</a>
<a name="ln1185">          }</a>
<a name="ln1186">          if (quit_more) {</a>
<a name="ln1187">            c = CAR;                            // just pretend CR was hit</a>
<a name="ln1188">            quit_more = FALSE;</a>
<a name="ln1189">            got_int = FALSE;</a>
<a name="ln1190">          } else if (c != K_IGNORE) {</a>
<a name="ln1191">            c = K_IGNORE;</a>
<a name="ln1192">            hit_return_msg();</a>
<a name="ln1193">          }</a>
<a name="ln1194">        } else if (msg_scrolled &gt; Rows - 2</a>
<a name="ln1195">                   &amp;&amp; (c == 'j' || c == 'd' || c == 'f'</a>
<a name="ln1196">                       || c == K_DOWN || c == K_PAGEDOWN)) {</a>
<a name="ln1197">          c = K_IGNORE;</a>
<a name="ln1198">        }</a>
<a name="ln1199">      }</a>
<a name="ln1200">    } while ((had_got_int &amp;&amp; c == Ctrl_C)</a>
<a name="ln1201">             || c == K_IGNORE</a>
<a name="ln1202">             || c == K_LEFTDRAG || c == K_LEFTRELEASE</a>
<a name="ln1203">             || c == K_MIDDLEDRAG || c == K_MIDDLERELEASE</a>
<a name="ln1204">             || c == K_RIGHTDRAG || c == K_RIGHTRELEASE</a>
<a name="ln1205">             || c == K_MOUSELEFT || c == K_MOUSERIGHT</a>
<a name="ln1206">             || c == K_MOUSEDOWN || c == K_MOUSEUP</a>
<a name="ln1207">             || c == K_MOUSEMOVE);</a>
<a name="ln1208">    os_breakcheck();</a>
<a name="ln1209">    /*</a>
<a name="ln1210">     * Avoid that the mouse-up event causes visual mode to start.</a>
<a name="ln1211">     */</a>
<a name="ln1212">    if (c == K_LEFTMOUSE || c == K_MIDDLEMOUSE || c == K_RIGHTMOUSE</a>
<a name="ln1213">        || c == K_X1MOUSE || c == K_X2MOUSE) {</a>
<a name="ln1214">      (void)jump_to_mouse(MOUSE_SETPOS, NULL, 0);</a>
<a name="ln1215">    } else if (vim_strchr(&quot;\r\n &quot;, c) == NULL &amp;&amp; c != Ctrl_C) {</a>
<a name="ln1216">      // Put the character back in the typeahead buffer.  Don't use the</a>
<a name="ln1217">      // stuff buffer, because lmaps wouldn't work.</a>
<a name="ln1218">      ins_char_typebuf(vgetc_char, vgetc_mod_mask);</a>
<a name="ln1219">      do_redraw = true;             // need a redraw even though there is</a>
<a name="ln1220">                                    // typeahead</a>
<a name="ln1221">    }</a>
<a name="ln1222">  }</a>
<a name="ln1223">  redir_off = false;</a>
<a name="ln1224"> </a>
<a name="ln1225">  // If the user hits ':', '?' or '/' we get a command line from the next</a>
<a name="ln1226">  // line.</a>
<a name="ln1227">  if (c == ':' || c == '?' || c == '/') {</a>
<a name="ln1228">    if (!exmode_active) {</a>
<a name="ln1229">      cmdline_row = msg_row;</a>
<a name="ln1230">    }</a>
<a name="ln1231">    skip_redraw = true;  // skip redraw once</a>
<a name="ln1232">    do_redraw = false;</a>
<a name="ln1233">    msg_ext_keep_after_cmdline = true;</a>
<a name="ln1234">  }</a>
<a name="ln1235"> </a>
<a name="ln1236">  // If the window size changed set_shellsize() will redraw the screen.</a>
<a name="ln1237">  // Otherwise the screen is only redrawn if 'redraw' is set and no ':'</a>
<a name="ln1238">  // typed.</a>
<a name="ln1239">  tmpState = State;</a>
<a name="ln1240">  State = oldState;                 // restore State before set_shellsize</a>
<a name="ln1241">  setmouse();</a>
<a name="ln1242">  msg_check();</a>
<a name="ln1243">  need_wait_return = false;</a>
<a name="ln1244">  did_wait_return = true;</a>
<a name="ln1245">  emsg_on_display = false;      // can delete error message now</a>
<a name="ln1246">  lines_left = -1;              // reset lines_left at next msg_start()</a>
<a name="ln1247">  reset_last_sourcing();</a>
<a name="ln1248">  if (keep_msg != NULL &amp;&amp; vim_strsize(keep_msg) &gt;=</a>
<a name="ln1249">      (Rows - cmdline_row - 1) * Columns + sc_col) {</a>
<a name="ln1250">    XFREE_CLEAR(keep_msg);          // don't redisplay message, it's too long</a>
<a name="ln1251">  }</a>
<a name="ln1252"> </a>
<a name="ln1253">  if (tmpState == MODE_SETWSIZE) {       // got resize event while in vgetc()</a>
<a name="ln1254">    ui_refresh();</a>
<a name="ln1255">  } else if (!skip_redraw) {</a>
<a name="ln1256">    if (redraw == true || (msg_scrolled != 0 &amp;&amp; redraw != -1)) {</a>
<a name="ln1257">      redraw_later(curwin, VALID);</a>
<a name="ln1258">    }</a>
<a name="ln1259">    if (ui_has(kUIMessages)) {</a>
<a name="ln1260">      msg_ext_clear(true);</a>
<a name="ln1261">    }</a>
<a name="ln1262">  }</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">/// Write the hit-return prompt.</a>
<a name="ln1266">static void hit_return_msg(void)</a>
<a name="ln1267">{</a>
<a name="ln1268">  int save_p_more = p_more;</a>
<a name="ln1269"> </a>
<a name="ln1270">  p_more = false;       // don't want to see this message when scrolling back</a>
<a name="ln1271">  if (msg_didout) {     // start on a new line</a>
<a name="ln1272">    msg_putchar('\n');</a>
<a name="ln1273">  }</a>
<a name="ln1274">  msg_ext_set_kind(&quot;return_prompt&quot;);</a>
<a name="ln1275">  if (got_int) {</a>
<a name="ln1276">    msg_puts(_(&quot;Interrupt: &quot;));</a>
<a name="ln1277">  }</a>
<a name="ln1278"> </a>
<a name="ln1279">  msg_puts_attr(_(&quot;Press ENTER or type command to continue&quot;), HL_ATTR(HLF_R));</a>
<a name="ln1280">  if (!msg_use_printf()) {</a>
<a name="ln1281">    msg_clr_eos();</a>
<a name="ln1282">  }</a>
<a name="ln1283">  p_more = save_p_more;</a>
<a name="ln1284">}</a>
<a name="ln1285"> </a>
<a name="ln1286">/// Set &quot;keep_msg&quot; to &quot;s&quot;.  Free the old value and check for NULL pointer.</a>
<a name="ln1287">void set_keep_msg(char *s, int attr)</a>
<a name="ln1288">{</a>
<a name="ln1289">  xfree(keep_msg);</a>
<a name="ln1290">  if (s != NULL &amp;&amp; msg_silent == 0) {</a>
<a name="ln1291">    keep_msg = vim_strsave((char_u *)s);</a>
<a name="ln1292">  } else {</a>
<a name="ln1293">    keep_msg = NULL;</a>
<a name="ln1294">  }</a>
<a name="ln1295">  keep_msg_more = false;</a>
<a name="ln1296">  keep_msg_attr = attr;</a>
<a name="ln1297">}</a>
<a name="ln1298"> </a>
<a name="ln1299">void msgmore(long n)</a>
<a name="ln1300">{</a>
<a name="ln1301">  long pn;</a>
<a name="ln1302"> </a>
<a name="ln1303">  if (global_busy           // no messages now, wait until global is finished</a>
<a name="ln1304">      || !messaging()) {      // 'lazyredraw' set, don't do messages now</a>
<a name="ln1305">    return;</a>
<a name="ln1306">  }</a>
<a name="ln1307"> </a>
<a name="ln1308">  // We don't want to overwrite another important message, but do overwrite</a>
<a name="ln1309">  // a previous &quot;more lines&quot; or &quot;fewer lines&quot; message, so that &quot;5dd&quot; and</a>
<a name="ln1310">  // then &quot;put&quot; reports the last action.</a>
<a name="ln1311">  if (keep_msg != NULL &amp;&amp; !keep_msg_more) {</a>
<a name="ln1312">    return;</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">  if (n &gt; 0) {</a>
<a name="ln1316">    pn = n;</a>
<a name="ln1317">  } else {</a>
<a name="ln1318">    pn = -n;</a>
<a name="ln1319">  }</a>
<a name="ln1320"> </a>
<a name="ln1321">  if (pn &gt; p_report) {</a>
<a name="ln1322">    if (n &gt; 0) {</a>
<a name="ln1323">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1324">                   NGETTEXT(&quot;%ld more line&quot;, &quot;%ld more lines&quot;, pn),</a>
<a name="ln1325">                   pn);</a>
<a name="ln1326">    } else {</a>
<a name="ln1327">      vim_snprintf(msg_buf, MSG_BUF_LEN,</a>
<a name="ln1328">                   NGETTEXT(&quot;%ld line less&quot;, &quot;%ld fewer lines&quot;, pn),</a>
<a name="ln1329">                   pn);</a>
<a name="ln1330">    }</a>
<a name="ln1331">    if (got_int) {</a>
<a name="ln1332">      xstrlcat(msg_buf, _(&quot; (Interrupted)&quot;), MSG_BUF_LEN);</a>
<a name="ln1333">    }</a>
<a name="ln1334">    if (msg(msg_buf)) {</a>
<a name="ln1335">      set_keep_msg(msg_buf, 0);</a>
<a name="ln1336">      keep_msg_more = true;</a>
<a name="ln1337">    }</a>
<a name="ln1338">  }</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">void msg_ext_set_kind(const char *msg_kind)</a>
<a name="ln1342">{</a>
<a name="ln1343">  // Don't change the label of an existing batch:</a>
<a name="ln1344">  msg_ext_ui_flush();</a>
<a name="ln1345"> </a>
<a name="ln1346">  // TODO(bfredl): would be nice to avoid dynamic scoping, but that would</a>
<a name="ln1347">  // need refactoring the msg_ interface to not be &quot;please pretend nvim is</a>
<a name="ln1348">  // a terminal for a moment&quot;</a>
<a name="ln1349">  msg_ext_kind = msg_kind;</a>
<a name="ln1350">}</a>
<a name="ln1351"> </a>
<a name="ln1352">/// Prepare for outputting characters in the command line.</a>
<a name="ln1353">void msg_start(void)</a>
<a name="ln1354">{</a>
<a name="ln1355">  int did_return = false;</a>
<a name="ln1356"> </a>
<a name="ln1357">  if (!msg_silent) {</a>
<a name="ln1358">    XFREE_CLEAR(keep_msg);              // don't display old message now</a>
<a name="ln1359">    need_fileinfo = false;</a>
<a name="ln1360">  }</a>
<a name="ln1361"> </a>
<a name="ln1362">  if (need_clr_eos) {</a>
<a name="ln1363">    // Halfway an &quot;:echo&quot; command and getting an (error) message: clear</a>
<a name="ln1364">    // any text from the command.</a>
<a name="ln1365">    need_clr_eos = false;</a>
<a name="ln1366">    msg_clr_eos();</a>
<a name="ln1367">  }</a>
<a name="ln1368"> </a>
<a name="ln1369">  if (!msg_scroll &amp;&amp; full_screen) {     // overwrite last message</a>
<a name="ln1370">    msg_row = cmdline_row;</a>
<a name="ln1371">    msg_col =</a>
<a name="ln1372">      cmdmsg_rl ? Columns - 1 :</a>
<a name="ln1373">      0;</a>
<a name="ln1374">  } else if (msg_didout) {                // start message on next line</a>
<a name="ln1375">    msg_putchar('\n');</a>
<a name="ln1376">    did_return = true;</a>
<a name="ln1377">    cmdline_row = msg_row;</a>
<a name="ln1378">  }</a>
<a name="ln1379">  if (!msg_didany || lines_left &lt; 0) {</a>
<a name="ln1380">    msg_starthere();</a>
<a name="ln1381">  }</a>
<a name="ln1382">  if (msg_silent == 0) {</a>
<a name="ln1383">    msg_didout = false;                     // no output on current line yet</a>
<a name="ln1384">  }</a>
<a name="ln1385"> </a>
<a name="ln1386">  if (ui_has(kUIMessages)) {</a>
<a name="ln1387">    msg_ext_ui_flush();</a>
<a name="ln1388">    if (!msg_scroll &amp;&amp; msg_ext_visible) {</a>
<a name="ln1389">      // Will overwrite last message.</a>
<a name="ln1390">      msg_ext_overwrite = true;</a>
<a name="ln1391">    }</a>
<a name="ln1392">  }</a>
<a name="ln1393"> </a>
<a name="ln1394">  // When redirecting, may need to start a new line.</a>
<a name="ln1395">  if (!did_return) {</a>
<a name="ln1396">    redir_write(&quot;\n&quot;, 1);</a>
<a name="ln1397">  }</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">/// Note that the current msg position is where messages start.</a>
<a name="ln1401">void msg_starthere(void)</a>
<a name="ln1402">{</a>
<a name="ln1403">  lines_left = cmdline_row;</a>
<a name="ln1404">  msg_didany = false;</a>
<a name="ln1405">}</a>
<a name="ln1406"> </a>
<a name="ln1407">void msg_putchar(int c)</a>
<a name="ln1408">{</a>
<a name="ln1409">  msg_putchar_attr(c, 0);</a>
<a name="ln1410">}</a>
<a name="ln1411"> </a>
<a name="ln1412">void msg_putchar_attr(int c, int attr)</a>
<a name="ln1413">{</a>
<a name="ln1414">  char_u buf[MB_MAXBYTES + 1];</a>
<a name="ln1415"> </a>
<a name="ln1416">  if (IS_SPECIAL(c)) {</a>
<a name="ln1417">    buf[0] = (char)K_SPECIAL;</a>
<a name="ln1418">    buf[1] = (char)K_SECOND(c);</a>
<a name="ln1419">    buf[2] = (char)K_THIRD(c);</a>
<a name="ln1420">    buf[3] = NUL;</a>
<a name="ln1421">  } else {</a>
<a name="ln1422">    buf[utf_char2bytes(c, (char *)buf)] = NUL;</a>
<a name="ln1423">  }</a>
<a name="ln1424">  msg_puts_attr((const char *)buf, attr);</a>
<a name="ln1425">}</a>
<a name="ln1426"> </a>
<a name="ln1427">void msg_outnum(long n)</a>
<a name="ln1428">{</a>
<a name="ln1429">  char buf[20];</a>
<a name="ln1430"> </a>
<a name="ln1431">  snprintf(buf, sizeof(buf), &quot;%ld&quot;, n);</a>
<a name="ln1432">  msg_puts(buf);</a>
<a name="ln1433">}</a>
<a name="ln1434"> </a>
<a name="ln1435">void msg_home_replace(char_u *fname)</a>
<a name="ln1436">{</a>
<a name="ln1437">  msg_home_replace_attr(fname, 0);</a>
<a name="ln1438">}</a>
<a name="ln1439"> </a>
<a name="ln1440">void msg_home_replace_hl(char_u *fname)</a>
<a name="ln1441">{</a>
<a name="ln1442">  msg_home_replace_attr(fname, HL_ATTR(HLF_D));</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445">static void msg_home_replace_attr(char_u *fname, int attr)</a>
<a name="ln1446">{</a>
<a name="ln1447">  char_u *name;</a>
<a name="ln1448"> </a>
<a name="ln1449">  name = home_replace_save(NULL, fname);</a>
<a name="ln1450">  msg_outtrans_attr(name, attr);</a>
<a name="ln1451">  xfree(name);</a>
<a name="ln1452">}</a>
<a name="ln1453"> </a>
<a name="ln1454">/// Output 'len' characters in 'str' (including NULs) with translation</a>
<a name="ln1455">/// if 'len' is -1, output up to a NUL character.</a>
<a name="ln1456">/// Use attributes 'attr'.</a>
<a name="ln1457">///</a>
<a name="ln1458">/// @return  the number of characters it takes on the screen.</a>
<a name="ln1459">int msg_outtrans(char_u *str)</a>
<a name="ln1460">{</a>
<a name="ln1461">  return msg_outtrans_attr(str, 0);</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">int msg_outtrans_attr(const char_u *str, int attr)</a>
<a name="ln1465">{</a>
<a name="ln1466">  return msg_outtrans_len_attr(str, (int)STRLEN(str), attr);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">int msg_outtrans_len(const char_u *str, int len)</a>
<a name="ln1470">{</a>
<a name="ln1471">  return msg_outtrans_len_attr(str, len, 0);</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">/// Output one character at &quot;p&quot;.</a>
<a name="ln1475">/// Handles multi-byte characters.</a>
<a name="ln1476">///</a>
<a name="ln1477">/// @return  pointer to the next character.</a>
<a name="ln1478">char_u *msg_outtrans_one(char_u *p, int attr)</a>
<a name="ln1479">{</a>
<a name="ln1480">  int l;</a>
<a name="ln1481"> </a>
<a name="ln1482">  if ((l = utfc_ptr2len((char *)p)) &gt; 1) {</a>
<a name="ln1483">    msg_outtrans_len_attr(p, l, attr);</a>
<a name="ln1484">    return p + l;</a>
<a name="ln1485">  }</a>
<a name="ln1486">  msg_puts_attr((const char *)transchar_byte(*p), attr);</a>
<a name="ln1487">  return p + 1;</a>
<a name="ln1488">}</a>
<a name="ln1489"> </a>
<a name="ln1490">int msg_outtrans_len_attr(const char_u *msgstr, int len, int attr)</a>
<a name="ln1491">{</a>
<a name="ln1492">  int retval = 0;</a>
<a name="ln1493">  const char *str = (const char *)msgstr;</a>
<a name="ln1494">  const char *plain_start = (const char *)msgstr;</a>
<a name="ln1495">  char_u *s;</a>
<a name="ln1496">  int mb_l;</a>
<a name="ln1497">  int c;</a>
<a name="ln1498">  int save_got_int = got_int;</a>
<a name="ln1499"> </a>
<a name="ln1500">  // Only quit when got_int was set in here.</a>
<a name="ln1501">  got_int = false;</a>
<a name="ln1502"> </a>
<a name="ln1503">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1504">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1505">    add_msg_hist(str, len, attr, false);</a>
<a name="ln1506">    attr &amp;= ~MSG_HIST;</a>
<a name="ln1507">  }</a>
<a name="ln1508"> </a>
<a name="ln1509">  // If the string starts with a composing character first draw a space on</a>
<a name="ln1510">  // which the composing char can be drawn.</a>
<a name="ln1511">  if (utf_iscomposing(utf_ptr2char((char *)msgstr))) {</a>
<a name="ln1512">    msg_puts_attr(&quot; &quot;, attr);</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515">  /*</a>
<a name="ln1516">   * Go over the string.  Special characters are translated and printed.</a>
<a name="ln1517">   * Normal characters are printed several at a time.</a>
<a name="ln1518">   */</a>
<a name="ln1519">  while (--len &gt;= 0 &amp;&amp; !got_int) {</a>
<a name="ln1520">    // Don't include composing chars after the end.</a>
<a name="ln1521">    mb_l = utfc_ptr2len_len((char_u *)str, len + 1);</a>
<a name="ln1522">    if (mb_l &gt; 1) {</a>
<a name="ln1523">      c = utf_ptr2char(str);</a>
<a name="ln1524">      if (vim_isprintc(c)) {</a>
<a name="ln1525">        // Printable multi-byte char: count the cells.</a>
<a name="ln1526">        retval += utf_ptr2cells(str);</a>
<a name="ln1527">      } else {</a>
<a name="ln1528">        // Unprintable multi-byte char: print the printable chars so</a>
<a name="ln1529">        // far and the translation of the unprintable char.</a>
<a name="ln1530">        if (str &gt; plain_start) {</a>
<a name="ln1531">          msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1532">        }</a>
<a name="ln1533">        plain_start = str + mb_l;</a>
<a name="ln1534">        msg_puts_attr((const char *)transchar(c),</a>
<a name="ln1535">                      (attr == 0 ? HL_ATTR(HLF_8) : attr));</a>
<a name="ln1536">        retval += char2cells(c);</a>
<a name="ln1537">      }</a>
<a name="ln1538">      len -= mb_l - 1;</a>
<a name="ln1539">      str += mb_l;</a>
<a name="ln1540">    } else {</a>
<a name="ln1541">      s = transchar_byte((uint8_t)(*str));</a>
<a name="ln1542">      if (s[1] != NUL) {</a>
<a name="ln1543">        // Unprintable char: print the printable chars so far and the</a>
<a name="ln1544">        // translation of the unprintable char.</a>
<a name="ln1545">        if (str &gt; plain_start) {</a>
<a name="ln1546">          msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1547">        }</a>
<a name="ln1548">        plain_start = str + 1;</a>
<a name="ln1549">        msg_puts_attr((const char *)s, attr == 0 ? HL_ATTR(HLF_8) : attr);</a>
<a name="ln1550">        retval += (int)STRLEN(s);</a>
<a name="ln1551">      } else {</a>
<a name="ln1552">        retval++;</a>
<a name="ln1553">      }</a>
<a name="ln1554">      str++;</a>
<a name="ln1555">    }</a>
<a name="ln1556">  }</a>
<a name="ln1557"> </a>
<a name="ln1558">  if (str &gt; plain_start &amp;&amp; !got_int) {</a>
<a name="ln1559">    // Print the printable chars at the end.</a>
<a name="ln1560">    msg_puts_attr_len(plain_start, str - plain_start, attr);</a>
<a name="ln1561">  }</a>
<a name="ln1562"> </a>
<a name="ln1563">  got_int |= save_got_int;</a>
<a name="ln1564"> </a>
<a name="ln1565">  return retval;</a>
<a name="ln1566">}</a>
<a name="ln1567"> </a>
<a name="ln1568">void msg_make(char_u *arg)</a>
<a name="ln1569">{</a>
<a name="ln1570">  int i;</a>
<a name="ln1571">  static char_u *str = (char_u *)&quot;eeffoc&quot;, *rs = (char_u *)&quot;Plon#dqg#vxjduB&quot;;</a>
<a name="ln1572"> </a>
<a name="ln1573">  arg = (char_u *)skipwhite((char *)arg);</a>
<a name="ln1574">  for (i = 5; *arg &amp;&amp; i &gt;= 0; i--) {</a>
<a name="ln1575">    if (*arg++ != str[i]) {</a>
<a name="ln1576">      break;</a>
<a name="ln1577">    }</a>
<a name="ln1578">  }</a>
<a name="ln1579">  if (i &lt; 0) {</a>
<a name="ln1580">    msg_putchar('\n');</a>
<a name="ln1581">    for (i = 0; rs[i]; ++i) {</a>
<a name="ln1582">      msg_putchar(rs[i] - 3);</a>
<a name="ln1583">    }</a>
<a name="ln1584">  }</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">/// Output the string 'str' up to a NUL character.</a>
<a name="ln1588">/// Return the number of characters it takes on the screen.</a>
<a name="ln1589">///</a>
<a name="ln1590">/// If K_SPECIAL is encountered, then it is taken in conjunction with the</a>
<a name="ln1591">/// following character and shown as &lt;F1&gt;, &lt;S-Up&gt; etc.  Any other character</a>
<a name="ln1592">/// which is not printable shown in &lt;&gt; form.</a>
<a name="ln1593">/// If 'from' is TRUE (lhs of a mapping), a space is shown as &lt;Space&gt;.</a>
<a name="ln1594">/// If a character is displayed in one of these special ways, is also</a>
<a name="ln1595">/// highlighted (its highlight name is '8' in the p_hl variable).</a>
<a name="ln1596">/// Otherwise characters are not highlighted.</a>
<a name="ln1597">/// This function is used to show mappings, where we want to see how to type</a>
<a name="ln1598">/// the character/string -- webb</a>
<a name="ln1599">///</a>
<a name="ln1600">/// @param from  true for LHS of a mapping</a>
<a name="ln1601">/// @param maxlen  screen columns, 0 for unlimited</a>
<a name="ln1602">int msg_outtrans_special(const char_u *strstart, bool from, int maxlen)</a>
<a name="ln1603">{</a>
<a name="ln1604">  if (strstart == NULL) {</a>
<a name="ln1605">    return 0;  // Do nothing.</a>
<a name="ln1606">  }</a>
<a name="ln1607">  const char_u *str = strstart;</a>
<a name="ln1608">  int retval = 0;</a>
<a name="ln1609">  int attr = HL_ATTR(HLF_8);</a>
<a name="ln1610"> </a>
<a name="ln1611">  while (*str != NUL) {</a>
<a name="ln1612">    const char *text;</a>
<a name="ln1613">    // Leading and trailing spaces need to be displayed in &lt;&gt; form.</a>
<a name="ln1614">    if ((str == strstart || str[1] == NUL) &amp;&amp; *str == ' ') {</a>
<a name="ln1615">      text = &quot;&lt;Space&gt;&quot;;</a>
<a name="ln1616">      str++;</a>
<a name="ln1617">    } else {</a>
<a name="ln1618">      text = str2special((const char **)&amp;str, from, false);</a>
<a name="ln1619">    }</a>
<a name="ln1620">    if (text[0] != NUL &amp;&amp; text[1] == NUL) {</a>
<a name="ln1621">      // single-byte character or illegal byte</a>
<a name="ln1622">      text = (char *)transchar_byte((uint8_t)text[0]);</a>
<a name="ln1623">    }</a>
<a name="ln1624">    const int len = vim_strsize((char_u *)text);</a>
<a name="ln1625">    if (maxlen &gt; 0 &amp;&amp; retval + len &gt;= maxlen) {</a>
<a name="ln1626">      break;</a>
<a name="ln1627">    }</a>
<a name="ln1628">    // Highlight special keys</a>
<a name="ln1629">    msg_puts_attr(text, (len &gt; 1</a>
<a name="ln1630">                         &amp;&amp; utfc_ptr2len(text) &lt;= 1</a>
<a name="ln1631">                         ? attr : 0));</a>
<a name="ln1632">    retval += len;</a>
<a name="ln1633">  }</a>
<a name="ln1634">  return retval;</a>
<a name="ln1635">}</a>
<a name="ln1636"> </a>
<a name="ln1637">/// Convert string, replacing key codes with printables</a>
<a name="ln1638">///</a>
<a name="ln1639">/// Used for lhs or rhs of mappings.</a>
<a name="ln1640">///</a>
<a name="ln1641">/// @param[in]  str  String to convert.</a>
<a name="ln1642">/// @param[in]  replace_spaces  Convert spaces into `&lt;Space&gt;`, normally used fo</a>
<a name="ln1643">///                             lhs, but not rhs.</a>
<a name="ln1644">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1645">///</a>
<a name="ln1646">/// @return [allocated] Converted string.</a>
<a name="ln1647">char *str2special_save(const char *const str, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1648">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_MALLOC</a>
<a name="ln1649">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln1650">{</a>
<a name="ln1651">  garray_T ga;</a>
<a name="ln1652">  ga_init(&amp;ga, 1, 40);</a>
<a name="ln1653"> </a>
<a name="ln1654">  const char *p = str;</a>
<a name="ln1655">  while (*p != NUL) {</a>
<a name="ln1656">    ga_concat(&amp;ga, str2special(&amp;p, replace_spaces, replace_lt));</a>
<a name="ln1657">  }</a>
<a name="ln1658">  ga_append(&amp;ga, NUL);</a>
<a name="ln1659">  return (char *)ga.ga_data;</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662">/// Convert character, replacing key with printable representation.</a>
<a name="ln1663">///</a>
<a name="ln1664">/// @param[in,out]  sp  String to convert. Is advanced to the next key code.</a>
<a name="ln1665">/// @param[in]  replace_spaces  Convert spaces into &lt;Space&gt;, normally used for</a>
<a name="ln1666">///                             lhs, but not rhs.</a>
<a name="ln1667">/// @param[in]  replace_lt  Convert `&lt;` into `&lt;lt&gt;`.</a>
<a name="ln1668">///</a>
<a name="ln1669">/// @return Converted key code, in a static buffer. Buffer is always one and the</a>
<a name="ln1670">///         same, so save converted string somewhere before running str2special</a>
<a name="ln1671">///         for the second time.</a>
<a name="ln1672">///         On illegal byte return a string with only that byte.</a>
<a name="ln1673">const char *str2special(const char **const sp, const bool replace_spaces, const bool replace_lt)</a>
<a name="ln1674">  FUNC_ATTR_NONNULL_ALL FUNC_ATTR_WARN_UNUSED_RESULT FUNC_ATTR_NONNULL_RET</a>
<a name="ln1675">{</a>
<a name="ln1676">  static char buf[7];</a>
<a name="ln1677"> </a>
<a name="ln1678">  {</a>
<a name="ln1679">    // Try to un-escape a multi-byte character.  Return the un-escaped</a>
<a name="ln1680">    // string if it is a multi-byte character.</a>
<a name="ln1681">    const char *const p = mb_unescape(sp);</a>
<a name="ln1682">    if (p != NULL) {</a>
<a name="ln1683">      return p;</a>
<a name="ln1684">    }</a>
<a name="ln1685">  }</a>
<a name="ln1686"> </a>
<a name="ln1687">  const char *str = *sp;</a>
<a name="ln1688">  int c = (uint8_t)(*str);</a>
<a name="ln1689">  int modifiers = 0;</a>
<a name="ln1690">  bool special = false;</a>
<a name="ln1691">  if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1692">    if ((uint8_t)str[1] == KS_MODIFIER) {</a>
<a name="ln1693">      modifiers = (uint8_t)str[2];</a>
<a name="ln1694">      str += 3;</a>
<a name="ln1695">      c = (uint8_t)(*str);</a>
<a name="ln1696">    }</a>
<a name="ln1697">    if (c == K_SPECIAL &amp;&amp; str[1] != NUL &amp;&amp; str[2] != NUL) {</a>
<a name="ln1698">      c = TO_SPECIAL((uint8_t)str[1], (uint8_t)str[2]);</a>
<a name="ln1699">      str += 2;</a>
<a name="ln1700">    }</a>
<a name="ln1701">    if (IS_SPECIAL(c) || modifiers) {  // Special key.</a>
<a name="ln1702">      special = true;</a>
<a name="ln1703">    }</a>
<a name="ln1704">  }</a>
<a name="ln1705"> </a>
<a name="ln1706">  if (!IS_SPECIAL(c) &amp;&amp; MB_BYTE2LEN(c) &gt; 1) {</a>
<a name="ln1707">    *sp = str;</a>
<a name="ln1708">    // Try to un-escape a multi-byte character after modifiers.</a>
<a name="ln1709">    const char *p = mb_unescape(sp);</a>
<a name="ln1710">    if (p != NULL) {</a>
<a name="ln1711">      // Since 'special' is true the multi-byte character 'c' will be</a>
<a name="ln1712">      // processed by get_special_key_name().</a>
<a name="ln1713">      c = utf_ptr2char(p);</a>
<a name="ln1714">    } else {</a>
<a name="ln1715">      // illegal byte</a>
<a name="ln1716">      *sp = str + 1;</a>
<a name="ln1717">    }</a>
<a name="ln1718">  } else {</a>
<a name="ln1719">    // single-byte character or illegal byte</a>
<a name="ln1720">    *sp = str + 1;</a>
<a name="ln1721">  }</a>
<a name="ln1722"> </a>
<a name="ln1723">  // Make special keys and C0 control characters in &lt;&gt; form, also &lt;M-Space&gt;.</a>
<a name="ln1724">  if (special</a>
<a name="ln1725">      || c &lt; ' '</a>
<a name="ln1726">      || (replace_spaces &amp;&amp; c == ' ')</a>
<a name="ln1727">      || (replace_lt &amp;&amp; c == '&lt;')) {</a>
<a name="ln1728">    return (const char *)get_special_key_name(c, modifiers);</a>
<a name="ln1729">  }</a>
<a name="ln1730">  buf[0] = (char)c;</a>
<a name="ln1731">  buf[1] = NUL;</a>
<a name="ln1732">  return buf;</a>
<a name="ln1733">}</a>
<a name="ln1734"> </a>
<a name="ln1735">/// Convert string, replacing key codes with printables</a>
<a name="ln1736">///</a>
<a name="ln1737">/// @param[in]  str  String to convert.</a>
<a name="ln1738">/// @param[out]  buf  Buffer to save results to.</a>
<a name="ln1739">/// @param[in]  len  Buffer length.</a>
<a name="ln1740">void str2specialbuf(const char *sp, char *buf, size_t len)</a>
<a name="ln1741">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1742">{</a>
<a name="ln1743">  while (*sp) {</a>
<a name="ln1744">    const char *s = str2special(&amp;sp, false, false);</a>
<a name="ln1745">    const size_t s_len = strlen(s);</a>
<a name="ln1746">    if (len &lt;= s_len) {</a>
<a name="ln1747">      break;</a>
<a name="ln1748">    }</a>
<a name="ln1749">    memcpy(buf, s, s_len);</a>
<a name="ln1750">    buf += s_len;</a>
<a name="ln1751">    len -= s_len;</a>
<a name="ln1752">  }</a>
<a name="ln1753">  *buf = NUL;</a>
<a name="ln1754">}</a>
<a name="ln1755"> </a>
<a name="ln1756">/// print line for :print or :list command</a>
<a name="ln1757">void msg_prt_line(char_u *s, int list)</a>
<a name="ln1758">{</a>
<a name="ln1759">  int c;</a>
<a name="ln1760">  int col = 0;</a>
<a name="ln1761">  int n_extra = 0;</a>
<a name="ln1762">  int c_extra = 0;</a>
<a name="ln1763">  int c_final = 0;</a>
<a name="ln1764">  char_u *p_extra = NULL;  // init to make SASC shut up</a>
<a name="ln1765">  int n;</a>
<a name="ln1766">  int attr = 0;</a>
<a name="ln1767">  char_u *lead = NULL;</a>
<a name="ln1768">  bool in_multispace = false;</a>
<a name="ln1769">  int multispace_pos = 0;</a>
<a name="ln1770">  char_u *trail = NULL;</a>
<a name="ln1771">  int l;</a>
<a name="ln1772"> </a>
<a name="ln1773">  if (curwin-&gt;w_p_list) {</a>
<a name="ln1774">    list = true;</a>
<a name="ln1775">  }</a>
<a name="ln1776"> </a>
<a name="ln1777">  if (list) {</a>
<a name="ln1778">    // find start of trailing whitespace</a>
<a name="ln1779">    if (curwin-&gt;w_p_lcs_chars.trail) {</a>
<a name="ln1780">      trail = s + STRLEN(s);</a>
<a name="ln1781">      while (trail &gt; s &amp;&amp; ascii_iswhite(trail[-1])) {</a>
<a name="ln1782">        trail--;</a>
<a name="ln1783">      }</a>
<a name="ln1784">    }</a>
<a name="ln1785">    // find end of leading whitespace</a>
<a name="ln1786">    if (curwin-&gt;w_p_lcs_chars.lead) {</a>
<a name="ln1787">      lead = s;</a>
<a name="ln1788">      while (ascii_iswhite(lead[0])) {</a>
<a name="ln1789">        lead++;</a>
<a name="ln1790">      }</a>
<a name="ln1791">      // in a line full of spaces all of them are treated as trailing</a>
<a name="ln1792">      if (*lead == NUL) {</a>
<a name="ln1793">        lead = NULL;</a>
<a name="ln1794">      }</a>
<a name="ln1795">    }</a>
<a name="ln1796">  }</a>
<a name="ln1797"> </a>
<a name="ln1798">  // output a space for an empty line, otherwise the line will be overwritten</a>
<a name="ln1799">  if (*s == NUL &amp;&amp; !(list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL)) {</a>
<a name="ln1800">    msg_putchar(' ');</a>
<a name="ln1801">  }</a>
<a name="ln1802"> </a>
<a name="ln1803">  while (!got_int) {</a>
<a name="ln1804">    if (n_extra &gt; 0) {</a>
<a name="ln1805">      n_extra--;</a>
<a name="ln1806">      if (n_extra == 0 &amp;&amp; c_final) {</a>
<a name="ln1807">        c = c_final;</a>
<a name="ln1808">      } else if (c_extra) {</a>
<a name="ln1809">        c = c_extra;</a>
<a name="ln1810">      } else {</a>
<a name="ln1811">        assert(p_extra != NULL);</a>
<a name="ln1812">        c = *p_extra++;</a>
<a name="ln1813">      }</a>
<a name="ln1814">    } else if ((l = utfc_ptr2len((char *)s)) &gt; 1) {</a>
<a name="ln1815">      col += utf_ptr2cells((char *)s);</a>
<a name="ln1816">      char buf[MB_MAXBYTES + 1];</a>
<a name="ln1817">      if (l &gt;= MB_MAXBYTES) {</a>
<a name="ln1818">        xstrlcpy(buf, &quot;?&quot;, sizeof(buf));</a>
<a name="ln1819">      } else if (curwin-&gt;w_p_lcs_chars.nbsp != NUL &amp;&amp; list</a>
<a name="ln1820">                 &amp;&amp; (utf_ptr2char((char *)s) == 160</a>
<a name="ln1821">                     || utf_ptr2char((char *)s) == 0x202f)) {</a>
<a name="ln1822">        utf_char2bytes(curwin-&gt;w_p_lcs_chars.nbsp, buf);</a>
<a name="ln1823">        buf[utfc_ptr2len(buf)] = NUL;</a>
<a name="ln1824">      } else {</a>
<a name="ln1825">        memmove(buf, s, (size_t)l);</a>
<a name="ln1826">        buf[l] = NUL;</a>
<a name="ln1827">      }</a>
<a name="ln1828">      msg_puts(buf);</a>
<a name="ln1829">      s += l;</a>
<a name="ln1830">      continue;</a>
<a name="ln1831">    } else {</a>
<a name="ln1832">      attr = 0;</a>
<a name="ln1833">      c = *s++;</a>
<a name="ln1834">      in_multispace = c == ' ' &amp;&amp; ((col &gt; 0 &amp;&amp; s[-2] == ' ') || *s == ' ');</a>
<a name="ln1835">      if (!in_multispace) {</a>
<a name="ln1836">        multispace_pos = 0;</a>
<a name="ln1837">      }</a>
<a name="ln1838">      if (c == TAB &amp;&amp; (!list || curwin-&gt;w_p_lcs_chars.tab1)) {</a>
<a name="ln1839">        // tab amount depends on current column</a>
<a name="ln1840">        n_extra = tabstop_padding(col,</a>
<a name="ln1841">                                  curbuf-&gt;b_p_ts,</a>
<a name="ln1842">                                  curbuf-&gt;b_p_vts_array) - 1;</a>
<a name="ln1843">        if (!list) {</a>
<a name="ln1844">          c = ' ';</a>
<a name="ln1845">          c_extra = ' ';</a>
<a name="ln1846">          c_final = NUL;</a>
<a name="ln1847">        } else {</a>
<a name="ln1848">          c = (n_extra == 0 &amp;&amp; curwin-&gt;w_p_lcs_chars.tab3)</a>
<a name="ln1849">              ? curwin-&gt;w_p_lcs_chars.tab3</a>
<a name="ln1850">              : curwin-&gt;w_p_lcs_chars.tab1;</a>
<a name="ln1851">          c_extra = curwin-&gt;w_p_lcs_chars.tab2;</a>
<a name="ln1852">          c_final = curwin-&gt;w_p_lcs_chars.tab3;</a>
<a name="ln1853">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1854">        }</a>
<a name="ln1855">      } else if (c == 160 &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.nbsp != NUL) {</a>
<a name="ln1856">        c = curwin-&gt;w_p_lcs_chars.nbsp;</a>
<a name="ln1857">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1858">      } else if (c == NUL &amp;&amp; list &amp;&amp; curwin-&gt;w_p_lcs_chars.eol != NUL) {</a>
<a name="ln1859">        p_extra = (char_u *)&quot;&quot;;</a>
<a name="ln1860">        c_extra = NUL;</a>
<a name="ln1861">        c_final = NUL;</a>
<a name="ln1862">        n_extra = 1;</a>
<a name="ln1863">        c = curwin-&gt;w_p_lcs_chars.eol;</a>
<a name="ln1864">        attr = HL_ATTR(HLF_AT);</a>
<a name="ln1865">        s--;</a>
<a name="ln1866">      } else if (c != NUL &amp;&amp; (n = byte2cells(c)) &gt; 1) {</a>
<a name="ln1867">        n_extra = n - 1;</a>
<a name="ln1868">        p_extra = transchar_byte(c);</a>
<a name="ln1869">        c_extra = NUL;</a>
<a name="ln1870">        c_final = NUL;</a>
<a name="ln1871">        c = *p_extra++;</a>
<a name="ln1872">        // Use special coloring to be able to distinguish &lt;hex&gt; from</a>
<a name="ln1873">        // the same in plain text.</a>
<a name="ln1874">        attr = HL_ATTR(HLF_0);</a>
<a name="ln1875">      } else if (c == ' ') {</a>
<a name="ln1876">        if (lead != NULL &amp;&amp; s &lt;= lead) {</a>
<a name="ln1877">          c = curwin-&gt;w_p_lcs_chars.lead;</a>
<a name="ln1878">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1879">        } else if (trail != NULL &amp;&amp; s &gt; trail) {</a>
<a name="ln1880">          c = curwin-&gt;w_p_lcs_chars.trail;</a>
<a name="ln1881">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1882">        } else if (list &amp;&amp; in_multispace &amp;&amp; curwin-&gt;w_p_lcs_chars.multispace != NULL) {</a>
<a name="ln1883">          c = curwin-&gt;w_p_lcs_chars.multispace[multispace_pos++];</a>
<a name="ln1884">          if (curwin-&gt;w_p_lcs_chars.multispace[multispace_pos] == NUL) {</a>
<a name="ln1885">            multispace_pos = 0;</a>
<a name="ln1886">          }</a>
<a name="ln1887">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1888">        } else if (list &amp;&amp; curwin-&gt;w_p_lcs_chars.space != NUL) {</a>
<a name="ln1889">          c = curwin-&gt;w_p_lcs_chars.space;</a>
<a name="ln1890">          attr = HL_ATTR(HLF_0);</a>
<a name="ln1891">        }</a>
<a name="ln1892">      }</a>
<a name="ln1893">    }</a>
<a name="ln1894"> </a>
<a name="ln1895">    if (c == NUL) {</a>
<a name="ln1896">      break;</a>
<a name="ln1897">    }</a>
<a name="ln1898"> </a>
<a name="ln1899">    msg_putchar_attr(c, attr);</a>
<a name="ln1900">    col++;</a>
<a name="ln1901">  }</a>
<a name="ln1902">  msg_clr_eos();</a>
<a name="ln1903">}</a>
<a name="ln1904"> </a>
<a name="ln1905">/// Use grid_puts() to output one multi-byte character.</a>
<a name="ln1906">///</a>
<a name="ln1907">/// @return  the pointer &quot;s&quot; advanced to the next character.</a>
<a name="ln1908">static char_u *screen_puts_mbyte(char_u *s, int l, int attr)</a>
<a name="ln1909">{</a>
<a name="ln1910">  int cw;</a>
<a name="ln1911">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln1912"> </a>
<a name="ln1913">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln1914">  cw = utf_ptr2cells((char *)s);</a>
<a name="ln1915">  if (cw &gt; 1</a>
<a name="ln1916">      &amp;&amp; (cmdmsg_rl ? msg_col &lt;= 1 : msg_col == Columns - 1)) {</a>
<a name="ln1917">    // Doesn't fit, print a highlighted '&gt;' to fill it up.</a>
<a name="ln1918">    msg_screen_putchar('&gt;', HL_ATTR(HLF_AT));</a>
<a name="ln1919">    return s;</a>
<a name="ln1920">  }</a>
<a name="ln1921"> </a>
<a name="ln1922">  grid_puts_len(&amp;msg_grid_adj, s, l, msg_row, msg_col, attr);</a>
<a name="ln1923">  if (cmdmsg_rl) {</a>
<a name="ln1924">    msg_col -= cw;</a>
<a name="ln1925">    if (msg_col == 0) {</a>
<a name="ln1926">      msg_col = Columns;</a>
<a name="ln1927">      ++msg_row;</a>
<a name="ln1928">    }</a>
<a name="ln1929">  } else {</a>
<a name="ln1930">    msg_col += cw;</a>
<a name="ln1931">    if (msg_col &gt;= Columns) {</a>
<a name="ln1932">      msg_col = 0;</a>
<a name="ln1933">      ++msg_row;</a>
<a name="ln1934">    }</a>
<a name="ln1935">  }</a>
<a name="ln1936">  return s + l;</a>
<a name="ln1937">}</a>
<a name="ln1938"> </a>
<a name="ln1939">/// Output a string to the screen at position msg_row, msg_col.</a>
<a name="ln1940">/// Update msg_row and msg_col for the next message.</a>
<a name="ln1941">void msg_puts(const char *s)</a>
<a name="ln1942">{</a>
<a name="ln1943">  msg_puts_attr(s, 0);</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946">void msg_puts_title(const char *s)</a>
<a name="ln1947">{</a>
<a name="ln1948">  msg_puts_attr(s, HL_ATTR(HLF_T));</a>
<a name="ln1949">}</a>
<a name="ln1950"> </a>
<a name="ln1951">/// Show a message in such a way that it always fits in the line.  Cut out a</a>
<a name="ln1952">/// part in the middle and replace it with &quot;...&quot; when necessary.</a>
<a name="ln1953">/// Does not handle multi-byte characters!</a>
<a name="ln1954">void msg_outtrans_long_attr(char_u *longstr, int attr)</a>
<a name="ln1955">{</a>
<a name="ln1956">  msg_outtrans_long_len_attr(longstr, (int)STRLEN(longstr), attr);</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959">void msg_outtrans_long_len_attr(char_u *longstr, int len, int attr)</a>
<a name="ln1960">{</a>
<a name="ln1961">  int slen = len;</a>
<a name="ln1962">  int room;</a>
<a name="ln1963"> </a>
<a name="ln1964">  room = Columns - msg_col;</a>
<a name="ln1965">  if (len &gt; room &amp;&amp; room &gt;= 20) {</a>
<a name="ln1966">    slen = (room - 3) / 2;</a>
<a name="ln1967">    msg_outtrans_len_attr(longstr, slen, attr);</a>
<a name="ln1968">    msg_puts_attr(&quot;...&quot;, HL_ATTR(HLF_8));</a>
<a name="ln1969">  }</a>
<a name="ln1970">  msg_outtrans_len_attr(longstr + len - slen, slen, attr);</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">/// Basic function for writing a message with highlight attributes.</a>
<a name="ln1974">void msg_puts_attr(const char *const s, const int attr)</a>
<a name="ln1975">{</a>
<a name="ln1976">  msg_puts_attr_len(s, -1, attr);</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979">/// Write a message with highlight attributes</a>
<a name="ln1980">///</a>
<a name="ln1981">/// @param[in]  str  NUL-terminated message string.</a>
<a name="ln1982">/// @param[in]  len  Length of the string or -1.</a>
<a name="ln1983">/// @param[in]  attr  Highlight attribute.</a>
<a name="ln1984">void msg_puts_attr_len(const char *const str, const ptrdiff_t len, int attr)</a>
<a name="ln1985">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln1986">{</a>
<a name="ln1987">  assert(len &lt; 0 || memchr(str, 0, len) == NULL);</a>
<a name="ln1988">  // If redirection is on, also write to the redirection file.</a>
<a name="ln1989">  redir_write(str, len);</a>
<a name="ln1990"> </a>
<a name="ln1991">  // Don't print anything when using &quot;:silent cmd&quot;.</a>
<a name="ln1992">  if (msg_silent != 0) {</a>
<a name="ln1993">    return;</a>
<a name="ln1994">  }</a>
<a name="ln1995"> </a>
<a name="ln1996">  // if MSG_HIST flag set, add message to history</a>
<a name="ln1997">  if (attr &amp; MSG_HIST) {</a>
<a name="ln1998">    add_msg_hist(str, (int)len, attr, false);</a>
<a name="ln1999">    attr &amp;= ~MSG_HIST;</a>
<a name="ln2000">  }</a>
<a name="ln2001"> </a>
<a name="ln2002">  // When writing something to the screen after it has scrolled, requires a</a>
<a name="ln2003">  // wait-return prompt later.  Needed when scrolling, resetting</a>
<a name="ln2004">  // need_wait_return after some prompt, and then outputting something</a>
<a name="ln2005">  // without scrolling</a>
<a name="ln2006">  // Not needed when only using CR to move the cursor.</a>
<a name="ln2007">  bool overflow = false;</a>
<a name="ln2008">  if (ui_has(kUIMessages)) {</a>
<a name="ln2009">    int count = msg_ext_visible + (msg_ext_overwrite ? 0 : 1);</a>
<a name="ln2010">    // TODO(bfredl): possible extension point, let external UI control this</a>
<a name="ln2011">    if (count &gt; 1) {</a>
<a name="ln2012">      overflow = true;</a>
<a name="ln2013">    }</a>
<a name="ln2014">  } else {</a>
<a name="ln2015">    overflow = msg_scrolled != 0;</a>
<a name="ln2016">  }</a>
<a name="ln2017"> </a>
<a name="ln2018">  if (overflow &amp;&amp; !msg_scrolled_ign &amp;&amp; strcmp(str, &quot;\r&quot;) != 0) {</a>
<a name="ln2019">    need_wait_return = true;</a>
<a name="ln2020">  }</a>
<a name="ln2021">  msg_didany = true;  // remember that something was outputted</a>
<a name="ln2022"> </a>
<a name="ln2023">  // If there is no valid screen, use fprintf so we can see error messages.</a>
<a name="ln2024">  // If termcap is not active, we may be writing in an alternate console</a>
<a name="ln2025">  // window, cursor positioning may not work correctly (window size may be</a>
<a name="ln2026">  // different, e.g. for Win32 console) or we just don't know where the</a>
<a name="ln2027">  // cursor is.</a>
<a name="ln2028">  if (msg_use_printf()) {</a>
<a name="ln2029">    int saved_msg_col = msg_col;</a>
<a name="ln2030">    msg_puts_printf(str, len);</a>
<a name="ln2031">    if (headless_mode) {</a>
<a name="ln2032">      msg_col = saved_msg_col;</a>
<a name="ln2033">    }</a>
<a name="ln2034">  }</a>
<a name="ln2035">  if (!msg_use_printf() || (headless_mode &amp;&amp; default_grid.chars)) {</a>
<a name="ln2036">    msg_puts_display((const char_u *)str, len, attr, false);</a>
<a name="ln2037">  }</a>
<a name="ln2038"> </a>
<a name="ln2039">  need_fileinfo = false;</a>
<a name="ln2040">}</a>
<a name="ln2041"> </a>
<a name="ln2042">/// Print a formatted message</a>
<a name="ln2043">///</a>
<a name="ln2044">/// Message printed is limited by #IOSIZE. Must not be used from inside</a>
<a name="ln2045">/// msg_puts_attr().</a>
<a name="ln2046">///</a>
<a name="ln2047">/// @param[in]  attr  Highlight attributes.</a>
<a name="ln2048">/// @param[in]  fmt  Format string.</a>
<a name="ln2049">void msg_printf_attr(const int attr, const char *const fmt, ...)</a>
<a name="ln2050">  FUNC_ATTR_NONNULL_ARG(2) FUNC_ATTR_PRINTF(2, 3)</a>
<a name="ln2051">{</a>
<a name="ln2052">  static char msgbuf[IOSIZE];</a>
<a name="ln2053"> </a>
<a name="ln2054">  va_list ap;</a>
<a name="ln2055">  va_start(ap, fmt);</a>
<a name="ln2056">  const size_t len = vim_vsnprintf(msgbuf, sizeof(msgbuf), fmt, ap);</a>
<a name="ln2057">  va_end(ap);</a>
<a name="ln2058"> </a>
<a name="ln2059">  msg_scroll = true;</a>
<a name="ln2060">  msg_puts_attr_len(msgbuf, (ptrdiff_t)len, attr);</a>
<a name="ln2061">}</a>
<a name="ln2062"> </a>
<a name="ln2063">static void msg_ext_emit_chunk(void)</a>
<a name="ln2064">{</a>
<a name="ln2065">  // Color was changed or a message flushed, end current chunk.</a>
<a name="ln2066">  if (msg_ext_last_attr == -1) {</a>
<a name="ln2067">    return;  // no chunk</a>
<a name="ln2068">  }</a>
<a name="ln2069">  Array chunk = ARRAY_DICT_INIT;</a>
<a name="ln2070">  ADD(chunk, INTEGER_OBJ(msg_ext_last_attr));</a>
<a name="ln2071">  msg_ext_last_attr = -1;</a>
<a name="ln2072">  String text = ga_take_string(&amp;msg_ext_last_chunk);</a>
<a name="ln2073">  ADD(chunk, STRING_OBJ(text));</a>
<a name="ln2074">  ADD(msg_ext_chunks, ARRAY_OBJ(chunk));</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">/// The display part of msg_puts_attr_len().</a>
<a name="ln2078">/// May be called recursively to display scroll-back text.</a>
<a name="ln2079">static void msg_puts_display(const char_u *str, int maxlen, int attr, int recurse)</a>
<a name="ln2080">{</a>
<a name="ln2081">  const char_u *s = str;</a>
<a name="ln2082">  const char_u *t_s = str;  // String from &quot;t_s&quot; to &quot;s&quot; is still todo.</a>
<a name="ln2083">  int t_col = 0;  // Screen cells todo, 0 when &quot;t_s&quot; not used.</a>
<a name="ln2084">  int l;</a>
<a name="ln2085">  int cw;</a>
<a name="ln2086">  const char_u *sb_str = str;</a>
<a name="ln2087">  int sb_col = msg_col;</a>
<a name="ln2088">  int wrap;</a>
<a name="ln2089">  int did_last_char;</a>
<a name="ln2090"> </a>
<a name="ln2091">  did_wait_return = false;</a>
<a name="ln2092"> </a>
<a name="ln2093">  if (ui_has(kUIMessages)) {</a>
<a name="ln2094">    if (attr != msg_ext_last_attr) {</a>
<a name="ln2095">      msg_ext_emit_chunk();</a>
<a name="ln2096">      msg_ext_last_attr = attr;</a>
<a name="ln2097">    }</a>
<a name="ln2098">    // Concat pieces with the same highlight</a>
<a name="ln2099">    size_t len = STRNLEN(str, maxlen);             // -V781</a>
<a name="ln2100">    ga_concat_len(&amp;msg_ext_last_chunk, (char *)str, len);</a>
<a name="ln2101">    msg_ext_cur_len += len;</a>
<a name="ln2102">    return;</a>
<a name="ln2103">  }</a>
<a name="ln2104"> </a>
<a name="ln2105">  msg_grid_validate();</a>
<a name="ln2106"> </a>
<a name="ln2107">  cmdline_was_last_drawn = redrawing_cmdline;</a>
<a name="ln2108"> </a>
<a name="ln2109">  while ((maxlen &lt; 0 || (int)(s - str) &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2110">    // We are at the end of the screen line when:</a>
<a name="ln2111">    // - When outputting a newline.</a>
<a name="ln2112">    // - When outputting a character in the last column.</a>
<a name="ln2113">    if (!recurse &amp;&amp; msg_row &gt;= Rows - 1</a>
<a name="ln2114">        &amp;&amp; (*s == '\n' || (cmdmsg_rl</a>
<a name="ln2115">                           ? (msg_col &lt;= 1</a>
<a name="ln2116">                              || (*s == TAB &amp;&amp; msg_col &lt;= 7)</a>
<a name="ln2117">                              || (utf_ptr2cells((char *)s) &gt; 1</a>
<a name="ln2118">                                  &amp;&amp; msg_col &lt;= 2))</a>
<a name="ln2119">                           : ((*s != '\r' &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2120">                              || (*s == TAB</a>
<a name="ln2121">                                  &amp;&amp; msg_col + t_col &gt;= ((Columns - 1) &amp; ~7))</a>
<a name="ln2122">                              || (utf_ptr2cells((char *)s) &gt; 1</a>
<a name="ln2123">                                  &amp;&amp; msg_col + t_col &gt;= Columns - 2))))) {</a>
<a name="ln2124">      // The screen is scrolled up when at the last row (some terminals</a>
<a name="ln2125">      // scroll automatically, some don't.  To avoid problems we scroll</a>
<a name="ln2126">      // ourselves).</a>
<a name="ln2127">      if (t_col &gt; 0) {</a>
<a name="ln2128">        // output postponed text</a>
<a name="ln2129">        t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2130">      }</a>
<a name="ln2131"> </a>
<a name="ln2132">      // When no more prompt and no more room, truncate here</a>
<a name="ln2133">      if (msg_no_more &amp;&amp; lines_left == 0) {</a>
<a name="ln2134">        break;</a>
<a name="ln2135">      }</a>
<a name="ln2136"> </a>
<a name="ln2137">      // Scroll the screen up one line.</a>
<a name="ln2138">      bool has_last_char = (*s &gt;= ' ' &amp;&amp; !cmdmsg_rl);</a>
<a name="ln2139">      msg_scroll_up(!has_last_char);</a>
<a name="ln2140"> </a>
<a name="ln2141">      msg_row = Rows - 2;</a>
<a name="ln2142">      if (msg_col &gt;= Columns) {         // can happen after screen resize</a>
<a name="ln2143">        msg_col = Columns - 1;</a>
<a name="ln2144">      }</a>
<a name="ln2145"> </a>
<a name="ln2146">      // Display char in last column before showing more-prompt.</a>
<a name="ln2147">      if (has_last_char) {</a>
<a name="ln2148">        if (maxlen &gt;= 0) {</a>
<a name="ln2149">          // Avoid including composing chars after the end.</a>
<a name="ln2150">          l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2151">        } else {</a>
<a name="ln2152">          l = utfc_ptr2len((char *)s);</a>
<a name="ln2153">        }</a>
<a name="ln2154">        s = screen_puts_mbyte((char_u *)s, l, attr);</a>
<a name="ln2155">        did_last_char = true;</a>
<a name="ln2156">      } else {</a>
<a name="ln2157">        did_last_char = false;</a>
<a name="ln2158">      }</a>
<a name="ln2159"> </a>
<a name="ln2160">      // Tricky: if last cell will be written, delay the throttle until</a>
<a name="ln2161">      // after the first scroll. Otherwise we would need to keep track of it.</a>
<a name="ln2162">      if (has_last_char &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2163">        if (!msg_grid.throttled) {</a>
<a name="ln2164">          msg_grid_scroll_discount++;</a>
<a name="ln2165">        }</a>
<a name="ln2166">        msg_grid.throttled = true;</a>
<a name="ln2167">      }</a>
<a name="ln2168"> </a>
<a name="ln2169">      if (p_more) {</a>
<a name="ln2170">        // Store text for scrolling back.</a>
<a name="ln2171">        store_sb_text((char_u **)&amp;sb_str, (char_u *)s, attr, &amp;sb_col, true);</a>
<a name="ln2172">      }</a>
<a name="ln2173"> </a>
<a name="ln2174">      inc_msg_scrolled();</a>
<a name="ln2175">      need_wait_return = true;       // may need wait_return in main()</a>
<a name="ln2176">      redraw_cmdline = true;</a>
<a name="ln2177">      if (cmdline_row &gt; 0 &amp;&amp; !exmode_active) {</a>
<a name="ln2178">        cmdline_row--;</a>
<a name="ln2179">      }</a>
<a name="ln2180"> </a>
<a name="ln2181">      /*</a>
<a name="ln2182">       * If screen is completely filled and 'more' is set then wait</a>
<a name="ln2183">       * for a character.</a>
<a name="ln2184">       */</a>
<a name="ln2185">      if (lines_left &gt; 0) {</a>
<a name="ln2186">        --lines_left;</a>
<a name="ln2187">      }</a>
<a name="ln2188">      if (p_more &amp;&amp; lines_left == 0 &amp;&amp; State != MODE_HITRETURN</a>
<a name="ln2189">          &amp;&amp; !msg_no_more &amp;&amp; !exmode_active) {</a>
<a name="ln2190">        if (do_more_prompt(NUL)) {</a>
<a name="ln2191">          s = confirm_msg_tail;</a>
<a name="ln2192">        }</a>
<a name="ln2193">        if (quit_more) {</a>
<a name="ln2194">          return;</a>
<a name="ln2195">        }</a>
<a name="ln2196">      }</a>
<a name="ln2197"> </a>
<a name="ln2198">      // When we displayed a char in last column need to check if there</a>
<a name="ln2199">      // is still more.</a>
<a name="ln2200">      if (did_last_char) {</a>
<a name="ln2201">        continue;</a>
<a name="ln2202">      }</a>
<a name="ln2203">    }</a>
<a name="ln2204"> </a>
<a name="ln2205">    wrap = *s == '\n'</a>
<a name="ln2206">           || msg_col + t_col &gt;= Columns</a>
<a name="ln2207">           || (utf_ptr2cells((char *)s) &gt; 1</a>
<a name="ln2208">               &amp;&amp; msg_col + t_col &gt;= Columns - 1)</a>
<a name="ln2209">    ;</a>
<a name="ln2210">    if (t_col &gt; 0 &amp;&amp; (wrap || *s == '\r' || *s == '\b'</a>
<a name="ln2211">                      || *s == '\t' || *s == BELL)) {</a>
<a name="ln2212">      // Output any postponed text.</a>
<a name="ln2213">      t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2214">    }</a>
<a name="ln2215"> </a>
<a name="ln2216">    if (wrap &amp;&amp; p_more &amp;&amp; !recurse) {</a>
<a name="ln2217">      // Store text for scrolling back.</a>
<a name="ln2218">      store_sb_text((char_u **)&amp;sb_str, (char_u *)s, attr, &amp;sb_col, true);</a>
<a name="ln2219">    }</a>
<a name="ln2220"> </a>
<a name="ln2221">    if (*s == '\n') {               // go to next line</a>
<a name="ln2222">      msg_didout = false;           // remember that line is empty</a>
<a name="ln2223">      if (cmdmsg_rl) {</a>
<a name="ln2224">        msg_col = Columns - 1;</a>
<a name="ln2225">      } else {</a>
<a name="ln2226">        msg_col = 0;</a>
<a name="ln2227">      }</a>
<a name="ln2228">      if (++msg_row &gt;= Rows) {        // safety check</a>
<a name="ln2229">        msg_row = Rows - 1;</a>
<a name="ln2230">      }</a>
<a name="ln2231">    } else if (*s == '\r') {      // go to column 0</a>
<a name="ln2232">      msg_col = 0;</a>
<a name="ln2233">    } else if (*s == '\b') {      // go to previous char</a>
<a name="ln2234">      if (msg_col) {</a>
<a name="ln2235">        --msg_col;</a>
<a name="ln2236">      }</a>
<a name="ln2237">    } else if (*s == TAB) {       // translate Tab into spaces</a>
<a name="ln2238">      do {</a>
<a name="ln2239">        msg_screen_putchar(' ', attr);</a>
<a name="ln2240">      } while (msg_col &amp; 7);</a>
<a name="ln2241">    } else if (*s == BELL) {  // beep (from &quot;:sh&quot;)</a>
<a name="ln2242">      vim_beep(BO_SH);</a>
<a name="ln2243">    } else if (*s &gt;= 0x20) {  // printable char</a>
<a name="ln2244">      cw = utf_ptr2cells((char *)s);</a>
<a name="ln2245">      if (maxlen &gt;= 0) {</a>
<a name="ln2246">        // avoid including composing chars after the end</a>
<a name="ln2247">        l = utfc_ptr2len_len(s, (int)((str + maxlen) - s));</a>
<a name="ln2248">      } else {</a>
<a name="ln2249">        l = utfc_ptr2len((char *)s);</a>
<a name="ln2250">      }</a>
<a name="ln2251">      // When drawing from right to left or when a double-wide character</a>
<a name="ln2252">      // doesn't fit, draw a single character here.  Otherwise collect</a>
<a name="ln2253">      // characters and draw them all at once later.</a>
<a name="ln2254">      if (cmdmsg_rl || (cw &gt; 1 &amp;&amp; msg_col + t_col &gt;= Columns - 1)) {</a>
<a name="ln2255">        if (l &gt; 1) {</a>
<a name="ln2256">          s = screen_puts_mbyte((char_u *)s, l, attr) - 1;</a>
<a name="ln2257">        } else {</a>
<a name="ln2258">          msg_screen_putchar(*s, attr);</a>
<a name="ln2259">        }</a>
<a name="ln2260">      } else {</a>
<a name="ln2261">        // postpone this character until later</a>
<a name="ln2262">        if (t_col == 0) {</a>
<a name="ln2263">          t_s = s;</a>
<a name="ln2264">        }</a>
<a name="ln2265">        t_col += cw;</a>
<a name="ln2266">        s += l - 1;</a>
<a name="ln2267">      }</a>
<a name="ln2268">    }</a>
<a name="ln2269">    ++s;</a>
<a name="ln2270">  }</a>
<a name="ln2271"> </a>
<a name="ln2272">  // Output any postponed text.</a>
<a name="ln2273">  if (t_col &gt; 0) {</a>
<a name="ln2274">    t_puts(&amp;t_col, t_s, s, attr);</a>
<a name="ln2275">  }</a>
<a name="ln2276">  if (p_more &amp;&amp; !recurse) {</a>
<a name="ln2277">    store_sb_text((char_u **)&amp;sb_str, (char_u *)s, attr, &amp;sb_col, false);</a>
<a name="ln2278">  }</a>
<a name="ln2279"> </a>
<a name="ln2280">  msg_check();</a>
<a name="ln2281">}</a>
<a name="ln2282"> </a>
<a name="ln2283">/// @return  true when &quot;:filter pattern&quot; was used and &quot;msg&quot; does not match</a>
<a name="ln2284">///          &quot;pattern&quot;.</a>
<a name="ln2285">bool message_filtered(char_u *msg)</a>
<a name="ln2286">{</a>
<a name="ln2287">  if (cmdmod.filter_regmatch.regprog == NULL) {</a>
<a name="ln2288">    return false;</a>
<a name="ln2289">  }</a>
<a name="ln2290"> </a>
<a name="ln2291">  bool match = vim_regexec(&amp;cmdmod.filter_regmatch, msg, (colnr_T)0);</a>
<a name="ln2292">  return cmdmod.filter_force ? match : !match;</a>
<a name="ln2293">}</a>
<a name="ln2294"> </a>
<a name="ln2295">/// including horizontal separator</a>
<a name="ln2296">int msg_scrollsize(void)</a>
<a name="ln2297">{</a>
<a name="ln2298">  return msg_scrolled + p_ch + 1;</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">bool msg_use_msgsep(void)</a>
<a name="ln2302">{</a>
<a name="ln2303">  // the full-screen scroll behavior doesn't really make sense with</a>
<a name="ln2304">  // 'ext_multigrid'</a>
<a name="ln2305">  return ((dy_flags &amp; DY_MSGSEP) || ui_has(kUIMultigrid));</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">bool msg_do_throttle(void)</a>
<a name="ln2309">{</a>
<a name="ln2310">  return msg_use_grid() &amp;&amp; !(rdb_flags &amp; RDB_NOTHROTTLE);</a>
<a name="ln2311">}</a>
<a name="ln2312"> </a>
<a name="ln2313">/// Scroll the screen up one line for displaying the next message line.</a>
<a name="ln2314">void msg_scroll_up(bool may_throttle)</a>
<a name="ln2315">{</a>
<a name="ln2316">  if (may_throttle &amp;&amp; msg_do_throttle()) {</a>
<a name="ln2317">    msg_grid.throttled = true;</a>
<a name="ln2318">  }</a>
<a name="ln2319">  msg_did_scroll = true;</a>
<a name="ln2320">  if (msg_use_msgsep()) {</a>
<a name="ln2321">    if (msg_grid_pos &gt; 0) {</a>
<a name="ln2322">      msg_grid_set_pos(msg_grid_pos - 1, true);</a>
<a name="ln2323">    } else {</a>
<a name="ln2324">      grid_del_lines(&amp;msg_grid, 0, 1, msg_grid.rows, 0, msg_grid.cols);</a>
<a name="ln2325">      memmove(msg_grid.dirty_col, msg_grid.dirty_col + 1,</a>
<a name="ln2326">              (msg_grid.rows - 1) * sizeof(*msg_grid.dirty_col));</a>
<a name="ln2327">      msg_grid.dirty_col[msg_grid.rows - 1] = 0;</a>
<a name="ln2328">    }</a>
<a name="ln2329">  } else {</a>
<a name="ln2330">    grid_del_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2331">  }</a>
<a name="ln2332"> </a>
<a name="ln2333">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2334">            HL_ATTR(HLF_MSG));</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">/// Send throttled message output to UI clients</a>
<a name="ln2338">///</a>
<a name="ln2339">/// The way message.c uses the grid_xx family of functions is quite inefficient</a>
<a name="ln2340">/// relative to the &quot;gridline&quot; UI protocol used by TUI and modern clients.</a>
<a name="ln2341">/// For instance scrolling is done one line at a time. By throttling drawing</a>
<a name="ln2342">/// on the message grid, we can coalesce scrolling to a single grid_scroll</a>
<a name="ln2343">/// per screen update.</a>
<a name="ln2344">///</a>
<a name="ln2345">/// NB: The bookkeeping is quite messy, and rests on a bunch of poorly</a>
<a name="ln2346">/// documented assumptions. For instance that the message area always grows</a>
<a name="ln2347">/// while being throttled, messages are only being output on the last line</a>
<a name="ln2348">/// etc.</a>
<a name="ln2349">///</a>
<a name="ln2350">/// Probably message scrollback storage should be reimplemented as a</a>
<a name="ln2351">/// file_buffer, and message scrolling in TUI be reimplemented as a modal</a>
<a name="ln2352">/// floating window. Then we get throttling &quot;for free&quot; using standard</a>
<a name="ln2353">/// redraw_later code paths.</a>
<a name="ln2354">void msg_scroll_flush(void)</a>
<a name="ln2355">{</a>
<a name="ln2356">  if (msg_grid.throttled) {</a>
<a name="ln2357">    msg_grid.throttled = false;</a>
<a name="ln2358">    int pos_delta = msg_grid_pos_at_flush - msg_grid_pos;</a>
<a name="ln2359">    assert(pos_delta &gt;= 0);</a>
<a name="ln2360">    int delta = MIN(msg_scrolled - msg_scrolled_at_flush, msg_grid.rows);</a>
<a name="ln2361"> </a>
<a name="ln2362">    if (pos_delta &gt; 0) {</a>
<a name="ln2363">      ui_ext_msg_set_pos(msg_grid_pos, true);</a>
<a name="ln2364">    }</a>
<a name="ln2365"> </a>
<a name="ln2366">    int to_scroll = delta - pos_delta - msg_grid_scroll_discount;</a>
<a name="ln2367">    assert(to_scroll &gt;= 0);</a>
<a name="ln2368"> </a>
<a name="ln2369">    // TODO(bfredl): msg_grid_pos should be 0 already when starting scrolling</a>
<a name="ln2370">    // but this sometimes fails in &quot;headless&quot; message printing.</a>
<a name="ln2371">    if (to_scroll &gt; 0 &amp;&amp; msg_grid_pos == 0) {</a>
<a name="ln2372">      ui_call_grid_scroll(msg_grid.handle, 0, Rows, 0, Columns, to_scroll, 0);</a>
<a name="ln2373">    }</a>
<a name="ln2374"> </a>
<a name="ln2375">    for (int i = MAX(Rows - MAX(delta, 1), 0); i &lt; Rows; i++) {</a>
<a name="ln2376">      int row = i - msg_grid_pos;</a>
<a name="ln2377">      assert(row &gt;= 0);</a>
<a name="ln2378">      ui_line(&amp;msg_grid, row, 0, msg_grid.dirty_col[row], msg_grid.cols,</a>
<a name="ln2379">              HL_ATTR(HLF_MSG), false);</a>
<a name="ln2380">      msg_grid.dirty_col[row] = 0;</a>
<a name="ln2381">    }</a>
<a name="ln2382">  }</a>
<a name="ln2383">  msg_scrolled_at_flush = msg_scrolled;</a>
<a name="ln2384">  msg_grid_scroll_discount = 0;</a>
<a name="ln2385">  msg_grid_pos_at_flush = msg_grid_pos;</a>
<a name="ln2386">}</a>
<a name="ln2387"> </a>
<a name="ln2388">void msg_reset_scroll(void)</a>
<a name="ln2389">{</a>
<a name="ln2390">  if (ui_has(kUIMessages)) {</a>
<a name="ln2391">    msg_ext_clear(true);</a>
<a name="ln2392">    return;</a>
<a name="ln2393">  }</a>
<a name="ln2394">  // TODO(bfredl): some duplicate logic with update_screen(). Later on</a>
<a name="ln2395">  // we should properly disentangle message clear with full screen redraw.</a>
<a name="ln2396">  if (msg_use_grid()) {</a>
<a name="ln2397">    msg_grid.throttled = false;</a>
<a name="ln2398">    // TODO(bfredl): risk for extra flicker i e with</a>
<a name="ln2399">    // &quot;nvim -o has_swap also_has_swap&quot;</a>
<a name="ln2400">    msg_grid_set_pos(Rows - p_ch, false);</a>
<a name="ln2401">    clear_cmdline = true;</a>
<a name="ln2402">    if (msg_grid.chars) {</a>
<a name="ln2403">      // non-displayed part of msg_grid is considered invalid.</a>
<a name="ln2404">      for (int i = 0; i &lt; MIN(msg_scrollsize(), msg_grid.rows); i++) {</a>
<a name="ln2405">        grid_clear_line(&amp;msg_grid, msg_grid.line_offset[i],</a>
<a name="ln2406">                        msg_grid.cols, false);</a>
<a name="ln2407">      }</a>
<a name="ln2408">    }</a>
<a name="ln2409">  } else {</a>
<a name="ln2410">    redraw_all_later(NOT_VALID);</a>
<a name="ln2411">  }</a>
<a name="ln2412">  msg_scrolled = 0;</a>
<a name="ln2413">  msg_scrolled_at_flush = 0;</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">/// Increment &quot;msg_scrolled&quot;.</a>
<a name="ln2417">static void inc_msg_scrolled(void)</a>
<a name="ln2418">{</a>
<a name="ln2419">  if (*get_vim_var_str(VV_SCROLLSTART) == NUL) {</a>
<a name="ln2420">    char *p = sourcing_name;</a>
<a name="ln2421">    char *tofree = NULL;</a>
<a name="ln2422"> </a>
<a name="ln2423">    // v:scrollstart is empty, set it to the script/function name and line</a>
<a name="ln2424">    // number</a>
<a name="ln2425">    if (p == NULL) {</a>
<a name="ln2426">      p = _(&quot;Unknown&quot;);</a>
<a name="ln2427">    } else {</a>
<a name="ln2428">      size_t len = strlen(p) + 40;</a>
<a name="ln2429">      tofree = xmalloc(len);</a>
<a name="ln2430">      vim_snprintf(tofree, len, _(&quot;%s line %&quot; PRId64),</a>
<a name="ln2431">                   p, (int64_t)sourcing_lnum);</a>
<a name="ln2432">      p = tofree;</a>
<a name="ln2433">    }</a>
<a name="ln2434">    set_vim_var_string(VV_SCROLLSTART, p, -1);</a>
<a name="ln2435">    xfree(tofree);</a>
<a name="ln2436">  }</a>
<a name="ln2437">  msg_scrolled++;</a>
<a name="ln2438">  if (must_redraw &lt; VALID) {</a>
<a name="ln2439">    must_redraw = VALID;</a>
<a name="ln2440">  }</a>
<a name="ln2441">}</a>
<a name="ln2442"> </a>
<a name="ln2443">static msgchunk_T *last_msgchunk = NULL;  // last displayed text</a>
<a name="ln2444"> </a>
<a name="ln2445">typedef enum {</a>
<a name="ln2446">  SB_CLEAR_NONE = 0,</a>
<a name="ln2447">  SB_CLEAR_ALL,</a>
<a name="ln2448">  SB_CLEAR_CMDLINE_BUSY,</a>
<a name="ln2449">  SB_CLEAR_CMDLINE_DONE,</a>
<a name="ln2450">} sb_clear_T;</a>
<a name="ln2451"> </a>
<a name="ln2452">// When to clear text on next msg.</a>
<a name="ln2453">static sb_clear_T do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2454"> </a>
<a name="ln2455">/// Store part of a printed message for displaying when scrolling back.</a>
<a name="ln2456">///</a>
<a name="ln2457">/// @param sb_str  start of string</a>
<a name="ln2458">/// @param s  just after string</a>
<a name="ln2459">/// @param finish  line ends</a>
<a name="ln2460">static void store_sb_text(char_u **sb_str, char_u *s, int attr, int *sb_col, int finish)</a>
<a name="ln2461">{</a>
<a name="ln2462">  msgchunk_T *mp;</a>
<a name="ln2463"> </a>
<a name="ln2464">  if (do_clear_sb_text == SB_CLEAR_ALL</a>
<a name="ln2465">      || do_clear_sb_text == SB_CLEAR_CMDLINE_DONE) {</a>
<a name="ln2466">    clear_sb_text(do_clear_sb_text == SB_CLEAR_ALL);</a>
<a name="ln2467">    do_clear_sb_text = SB_CLEAR_NONE;</a>
<a name="ln2468">  }</a>
<a name="ln2469"> </a>
<a name="ln2470">  if (s &gt; *sb_str) {</a>
<a name="ln2471">    mp = xmalloc((sizeof(msgchunk_T) + (s - *sb_str)));</a>
<a name="ln2472">    mp-&gt;sb_eol = finish;</a>
<a name="ln2473">    mp-&gt;sb_msg_col = *sb_col;</a>
<a name="ln2474">    mp-&gt;sb_attr = attr;</a>
<a name="ln2475">    memcpy(mp-&gt;sb_text, *sb_str, s - *sb_str);</a>
<a name="ln2476">    mp-&gt;sb_text[s - *sb_str] = NUL;</a>
<a name="ln2477"> </a>
<a name="ln2478">    if (last_msgchunk == NULL) {</a>
<a name="ln2479">      last_msgchunk = mp;</a>
<a name="ln2480">      mp-&gt;sb_prev = NULL;</a>
<a name="ln2481">    } else {</a>
<a name="ln2482">      mp-&gt;sb_prev = last_msgchunk;</a>
<a name="ln2483">      last_msgchunk-&gt;sb_next = mp;</a>
<a name="ln2484">      last_msgchunk = mp;</a>
<a name="ln2485">    }</a>
<a name="ln2486">    mp-&gt;sb_next = NULL;</a>
<a name="ln2487">  } else if (finish &amp;&amp; last_msgchunk != NULL) {</a>
<a name="ln2488">    last_msgchunk-&gt;sb_eol = TRUE;</a>
<a name="ln2489">  }</a>
<a name="ln2490"> </a>
<a name="ln2491">  *sb_str = s;</a>
<a name="ln2492">  *sb_col = 0;</a>
<a name="ln2493">}</a>
<a name="ln2494"> </a>
<a name="ln2495">/// Finished showing messages, clear the scroll-back text on the next message.</a>
<a name="ln2496">void may_clear_sb_text(void)</a>
<a name="ln2497">{</a>
<a name="ln2498">  do_clear_sb_text = SB_CLEAR_ALL;</a>
<a name="ln2499">}</a>
<a name="ln2500"> </a>
<a name="ln2501">/// Starting to edit the command line, do not clear messages now.</a>
<a name="ln2502">void sb_text_start_cmdline(void)</a>
<a name="ln2503">{</a>
<a name="ln2504">  do_clear_sb_text = SB_CLEAR_CMDLINE_BUSY;</a>
<a name="ln2505">  msg_sb_eol();</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">/// Ending to edit the command line.  Clear old lines but the last one later.</a>
<a name="ln2509">void sb_text_end_cmdline(void)</a>
<a name="ln2510">{</a>
<a name="ln2511">  do_clear_sb_text = SB_CLEAR_CMDLINE_DONE;</a>
<a name="ln2512">}</a>
<a name="ln2513"> </a>
<a name="ln2514">/// Clear any text remembered for scrolling back.</a>
<a name="ln2515">/// When &quot;all&quot; is FALSE keep the last line.</a>
<a name="ln2516">/// Called when redrawing the screen.</a>
<a name="ln2517">void clear_sb_text(int all)</a>
<a name="ln2518">{</a>
<a name="ln2519">  msgchunk_T *mp;</a>
<a name="ln2520">  msgchunk_T **lastp;</a>
<a name="ln2521"> </a>
<a name="ln2522">  if (all) {</a>
<a name="ln2523">    lastp = &amp;last_msgchunk;</a>
<a name="ln2524">  } else {</a>
<a name="ln2525">    if (last_msgchunk == NULL) {</a>
<a name="ln2526">      return;</a>
<a name="ln2527">    }</a>
<a name="ln2528">    lastp = &amp;last_msgchunk-&gt;sb_prev;</a>
<a name="ln2529">  }</a>
<a name="ln2530"> </a>
<a name="ln2531">  while (*lastp != NULL) {</a>
<a name="ln2532">    mp = (*lastp)-&gt;sb_prev;</a>
<a name="ln2533">    xfree(*lastp);</a>
<a name="ln2534">    *lastp = mp;</a>
<a name="ln2535">  }</a>
<a name="ln2536">}</a>
<a name="ln2537"> </a>
<a name="ln2538">/// &quot;g&lt;&quot; command.</a>
<a name="ln2539">void show_sb_text(void)</a>
<a name="ln2540">{</a>
<a name="ln2541">  msgchunk_T *mp;</a>
<a name="ln2542"> </a>
<a name="ln2543">  // Only show something if there is more than one line, otherwise it looks</a>
<a name="ln2544">  // weird, typing a command without output results in one line.</a>
<a name="ln2545">  mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2546">  if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2547">    vim_beep(BO_MESS);</a>
<a name="ln2548">  } else {</a>
<a name="ln2549">    do_more_prompt('G');</a>
<a name="ln2550">    wait_return(FALSE);</a>
<a name="ln2551">  }</a>
<a name="ln2552">}</a>
<a name="ln2553"> </a>
<a name="ln2554">/// Move to the start of screen line in already displayed text.</a>
<a name="ln2555">static msgchunk_T *msg_sb_start(msgchunk_T *mps)</a>
<a name="ln2556">{</a>
<a name="ln2557">  msgchunk_T *mp = mps;</a>
<a name="ln2558"> </a>
<a name="ln2559">  while (mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL &amp;&amp; !mp-&gt;sb_prev-&gt;sb_eol) {</a>
<a name="ln2560">    mp = mp-&gt;sb_prev;</a>
<a name="ln2561">  }</a>
<a name="ln2562">  return mp;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">/// Mark the last message chunk as finishing the line.</a>
<a name="ln2566">void msg_sb_eol(void)</a>
<a name="ln2567">{</a>
<a name="ln2568">  if (last_msgchunk != NULL) {</a>
<a name="ln2569">    last_msgchunk-&gt;sb_eol = TRUE;</a>
<a name="ln2570">  }</a>
<a name="ln2571">}</a>
<a name="ln2572"> </a>
<a name="ln2573">/// Display a screen line from previously displayed text at row &quot;row&quot;.</a>
<a name="ln2574">///</a>
<a name="ln2575">/// @return  a pointer to the text for the next line (can be NULL).</a>
<a name="ln2576">static msgchunk_T *disp_sb_line(int row, msgchunk_T *smp)</a>
<a name="ln2577">{</a>
<a name="ln2578">  msgchunk_T *mp = smp;</a>
<a name="ln2579">  char_u *p;</a>
<a name="ln2580"> </a>
<a name="ln2581">  for (;;) {</a>
<a name="ln2582">    msg_row = row;</a>
<a name="ln2583">    msg_col = mp-&gt;sb_msg_col;</a>
<a name="ln2584">    p = mp-&gt;sb_text;</a>
<a name="ln2585">    if (*p == '\n') {       // don't display the line break</a>
<a name="ln2586">      ++p;</a>
<a name="ln2587">    }</a>
<a name="ln2588">    msg_puts_display(p, -1, mp-&gt;sb_attr, TRUE);</a>
<a name="ln2589">    if (mp-&gt;sb_eol || mp-&gt;sb_next == NULL) {</a>
<a name="ln2590">      break;</a>
<a name="ln2591">    }</a>
<a name="ln2592">    mp = mp-&gt;sb_next;</a>
<a name="ln2593">  }</a>
<a name="ln2594"> </a>
<a name="ln2595">  return mp-&gt;sb_next;</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">/// Output any postponed text for msg_puts_attr_len().</a>
<a name="ln2599">static void t_puts(int *t_col, const char_u *t_s, const char_u *s, int attr)</a>
<a name="ln2600">{</a>
<a name="ln2601">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2602">  // Output postponed text.</a>
<a name="ln2603">  msg_didout = true;  // Remember that line is not empty.</a>
<a name="ln2604">  grid_puts_len(&amp;msg_grid_adj, (char_u *)t_s, (int)(s - t_s), msg_row, msg_col,</a>
<a name="ln2605">                attr);</a>
<a name="ln2606">  msg_col += *t_col;</a>
<a name="ln2607">  *t_col = 0;</a>
<a name="ln2608">  // If the string starts with a composing character don't increment the</a>
<a name="ln2609">  // column position for it.</a>
<a name="ln2610">  if (utf_iscomposing(utf_ptr2char((char *)t_s))) {</a>
<a name="ln2611">    msg_col--;</a>
<a name="ln2612">  }</a>
<a name="ln2613">  if (msg_col &gt;= Columns) {</a>
<a name="ln2614">    msg_col = 0;</a>
<a name="ln2615">    ++msg_row;</a>
<a name="ln2616">  }</a>
<a name="ln2617">}</a>
<a name="ln2618"> </a>
<a name="ln2619">/// @return  TRUE when messages should be printed to stdout/stderr:</a>
<a name="ln2620">///          - &quot;batch mode&quot; (&quot;silent mode&quot;, -es/-Es)</a>
<a name="ln2621">///          - no UI and not embedded</a>
<a name="ln2622">int msg_use_printf(void)</a>
<a name="ln2623">{</a>
<a name="ln2624">  return !embedded_mode &amp;&amp; !ui_active();</a>
<a name="ln2625">}</a>
<a name="ln2626"> </a>
<a name="ln2627">/// Print a message when there is no valid screen.</a>
<a name="ln2628">static void msg_puts_printf(const char *str, const ptrdiff_t maxlen)</a>
<a name="ln2629">{</a>
<a name="ln2630">  const char *s = str;</a>
<a name="ln2631">  char buf[7];</a>
<a name="ln2632">  char *p;</a>
<a name="ln2633"> </a>
<a name="ln2634">  if (on_print.type != kCallbackNone) {</a>
<a name="ln2635">    typval_T argv[1];</a>
<a name="ln2636">    argv[0].v_type = VAR_STRING;</a>
<a name="ln2637">    argv[0].v_lock = VAR_UNLOCKED;</a>
<a name="ln2638">    argv[0].vval.v_string = (char *)str;</a>
<a name="ln2639">    typval_T rettv = TV_INITIAL_VALUE;</a>
<a name="ln2640">    callback_call(&amp;on_print, 1, argv, &amp;rettv);</a>
<a name="ln2641">    tv_clear(&amp;rettv);</a>
<a name="ln2642">    return;</a>
<a name="ln2643">  }</a>
<a name="ln2644"> </a>
<a name="ln2645">  while ((maxlen &lt; 0 || s - str &lt; maxlen) &amp;&amp; *s != NUL) {</a>
<a name="ln2646">    int len = utf_ptr2len(s);</a>
<a name="ln2647">    if (!(silent_mode &amp;&amp; p_verbose == 0)) {</a>
<a name="ln2648">      // NL --&gt; CR NL translation (for Unix, not for &quot;--version&quot;)</a>
<a name="ln2649">      p = &amp;buf[0];</a>
<a name="ln2650">      if (*s == '\n' &amp;&amp; !info_message) {</a>
<a name="ln2651">        *p++ = '\r';</a>
<a name="ln2652">      }</a>
<a name="ln2653">      memcpy(p, s, len);</a>
<a name="ln2654">      *(p + len) = '\0';</a>
<a name="ln2655">      if (info_message) {</a>
<a name="ln2656">        mch_msg(buf);</a>
<a name="ln2657">      } else {</a>
<a name="ln2658">        mch_errmsg(buf);</a>
<a name="ln2659">      }</a>
<a name="ln2660">    }</a>
<a name="ln2661"> </a>
<a name="ln2662">    int cw = utf_char2cells(utf_ptr2char(s));</a>
<a name="ln2663">    // primitive way to compute the current column</a>
<a name="ln2664">    if (cmdmsg_rl) {</a>
<a name="ln2665">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2666">        msg_col = Columns - 1;</a>
<a name="ln2667">      } else {</a>
<a name="ln2668">        msg_col -= cw;</a>
<a name="ln2669">      }</a>
<a name="ln2670">    } else {</a>
<a name="ln2671">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln2672">        msg_col = 0;</a>
<a name="ln2673">      } else {</a>
<a name="ln2674">        msg_col += cw;</a>
<a name="ln2675">      }</a>
<a name="ln2676">    }</a>
<a name="ln2677">    s += len;</a>
<a name="ln2678">  }</a>
<a name="ln2679">  msg_didout = true;  // assume that line is not empty</a>
<a name="ln2680">}</a>
<a name="ln2681"> </a>
<a name="ln2682">/// Show the more-prompt and handle the user response.</a>
<a name="ln2683">/// This takes care of scrolling back and displaying previously displayed text.</a>
<a name="ln2684">/// When at hit-enter prompt &quot;typed_char&quot; is the already typed character,</a>
<a name="ln2685">/// otherwise it's NUL.</a>
<a name="ln2686">///</a>
<a name="ln2687">/// @return  TRUE when jumping ahead to &quot;confirm_msg_tail&quot;.</a>
<a name="ln2688">static int do_more_prompt(int typed_char)</a>
<a name="ln2689">{</a>
<a name="ln2690">  static bool entered = false;</a>
<a name="ln2691">  int used_typed_char = typed_char;</a>
<a name="ln2692">  int oldState = State;</a>
<a name="ln2693">  int c;</a>
<a name="ln2694">  int retval = FALSE;</a>
<a name="ln2695">  int toscroll;</a>
<a name="ln2696">  bool to_redraw = false;</a>
<a name="ln2697">  msgchunk_T *mp_last = NULL;</a>
<a name="ln2698">  msgchunk_T *mp;</a>
<a name="ln2699">  int i;</a>
<a name="ln2700"> </a>
<a name="ln2701">  // If headless mode is enabled and no input is required, this variable</a>
<a name="ln2702">  // will be true. However If server mode is enabled, the message &quot;--more--&quot;</a>
<a name="ln2703">  // should be displayed.</a>
<a name="ln2704">  bool no_need_more = headless_mode &amp;&amp; !embedded_mode;</a>
<a name="ln2705"> </a>
<a name="ln2706">  // We get called recursively when a timer callback outputs a message. In</a>
<a name="ln2707">  // that case don't show another prompt. Also when at the hit-Enter prompt</a>
<a name="ln2708">  // and nothing was typed.</a>
<a name="ln2709">  if (no_need_more || entered || (State == MODE_HITRETURN &amp;&amp; typed_char == 0)) {</a>
<a name="ln2710">    return false;</a>
<a name="ln2711">  }</a>
<a name="ln2712">  entered = true;</a>
<a name="ln2713"> </a>
<a name="ln2714">  if (typed_char == 'G') {</a>
<a name="ln2715">    // &quot;g&lt;&quot;: Find first line on the last page.</a>
<a name="ln2716">    mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2717">    for (i = 0; i &lt; Rows - 2 &amp;&amp; mp_last != NULL</a>
<a name="ln2718">         &amp;&amp; mp_last-&gt;sb_prev != NULL; ++i) {</a>
<a name="ln2719">      mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2720">    }</a>
<a name="ln2721">  }</a>
<a name="ln2722"> </a>
<a name="ln2723">  State = MODE_ASKMORE;</a>
<a name="ln2724">  setmouse();</a>
<a name="ln2725">  if (typed_char == NUL) {</a>
<a name="ln2726">    msg_moremsg(FALSE);</a>
<a name="ln2727">  }</a>
<a name="ln2728">  for (;;) {</a>
<a name="ln2729">    /*</a>
<a name="ln2730">     * Get a typed character directly from the user.</a>
<a name="ln2731">     */</a>
<a name="ln2732">    if (used_typed_char != NUL) {</a>
<a name="ln2733">      c = used_typed_char;              // was typed at hit-enter prompt</a>
<a name="ln2734">      used_typed_char = NUL;</a>
<a name="ln2735">    } else {</a>
<a name="ln2736">      c = get_keystroke(resize_events);</a>
<a name="ln2737">    }</a>
<a name="ln2738"> </a>
<a name="ln2739">    toscroll = 0;</a>
<a name="ln2740">    switch (c) {</a>
<a name="ln2741">    case BS:                    // scroll one line back</a>
<a name="ln2742">    case K_BS:</a>
<a name="ln2743">    case 'k':</a>
<a name="ln2744">    case K_UP:</a>
<a name="ln2745">      toscroll = -1;</a>
<a name="ln2746">      break;</a>
<a name="ln2747"> </a>
<a name="ln2748">    case CAR:                   // one extra line</a>
<a name="ln2749">    case NL:</a>
<a name="ln2750">    case 'j':</a>
<a name="ln2751">    case K_DOWN:</a>
<a name="ln2752">      toscroll = 1;</a>
<a name="ln2753">      break;</a>
<a name="ln2754"> </a>
<a name="ln2755">    case 'u':                   // Up half a page</a>
<a name="ln2756">      toscroll = -(Rows / 2);</a>
<a name="ln2757">      break;</a>
<a name="ln2758"> </a>
<a name="ln2759">    case 'd':                   // Down half a page</a>
<a name="ln2760">      toscroll = Rows / 2;</a>
<a name="ln2761">      break;</a>
<a name="ln2762"> </a>
<a name="ln2763">    case 'b':                   // one page back</a>
<a name="ln2764">    case K_PAGEUP:</a>
<a name="ln2765">      toscroll = -(Rows - 1);</a>
<a name="ln2766">      break;</a>
<a name="ln2767"> </a>
<a name="ln2768">    case ' ':                   // one extra page</a>
<a name="ln2769">    case 'f':</a>
<a name="ln2770">    case K_PAGEDOWN:</a>
<a name="ln2771">    case K_LEFTMOUSE:</a>
<a name="ln2772">      toscroll = Rows - 1;</a>
<a name="ln2773">      break;</a>
<a name="ln2774"> </a>
<a name="ln2775">    case 'g':                   // all the way back to the start</a>
<a name="ln2776">      toscroll = -999999;</a>
<a name="ln2777">      break;</a>
<a name="ln2778"> </a>
<a name="ln2779">    case 'G':                   // all the way to the end</a>
<a name="ln2780">      toscroll = 999999;</a>
<a name="ln2781">      lines_left = 999999;</a>
<a name="ln2782">      break;</a>
<a name="ln2783"> </a>
<a name="ln2784">    case ':':                   // start new command line</a>
<a name="ln2785">      if (!confirm_msg_used) {</a>
<a name="ln2786">        // Since got_int is set all typeahead will be flushed, but we</a>
<a name="ln2787">        // want to keep this ':', remember that in a special way.</a>
<a name="ln2788">        typeahead_noflush(':');</a>
<a name="ln2789">        cmdline_row = Rows - 1;                 // put ':' on this line</a>
<a name="ln2790">        skip_redraw = true;                     // skip redraw once</a>
<a name="ln2791">        need_wait_return = false;               // don't wait in main()</a>
<a name="ln2792">      }</a>
<a name="ln2793">      FALLTHROUGH;</a>
<a name="ln2794">    case 'q':                   // quit</a>
<a name="ln2795">    case Ctrl_C:</a>
<a name="ln2796">    case ESC:</a>
<a name="ln2797">      if (confirm_msg_used) {</a>
<a name="ln2798">        // Jump to the choices of the dialog.</a>
<a name="ln2799">        retval = TRUE;</a>
<a name="ln2800">      } else {</a>
<a name="ln2801">        got_int = TRUE;</a>
<a name="ln2802">        quit_more = TRUE;</a>
<a name="ln2803">      }</a>
<a name="ln2804">      // When there is some more output (wrapping line) display that</a>
<a name="ln2805">      // without another prompt.</a>
<a name="ln2806">      lines_left = Rows - 1;</a>
<a name="ln2807">      break;</a>
<a name="ln2808"> </a>
<a name="ln2809">    case K_EVENT:</a>
<a name="ln2810">      // only resize_events are processed here</a>
<a name="ln2811">      // Attempt to redraw the screen. sb_text doesn't support reflow</a>
<a name="ln2812">      // so this only really works for vertical resize.</a>
<a name="ln2813">      multiqueue_process_events(resize_events);</a>
<a name="ln2814">      to_redraw = true;</a>
<a name="ln2815">      break;</a>
<a name="ln2816"> </a>
<a name="ln2817">    default:                    // no valid response</a>
<a name="ln2818">      msg_moremsg(TRUE);</a>
<a name="ln2819">      continue;</a>
<a name="ln2820">    }</a>
<a name="ln2821"> </a>
<a name="ln2822">    // code assumes we only do one at a time</a>
<a name="ln2823">    assert((toscroll == 0) || !to_redraw);</a>
<a name="ln2824"> </a>
<a name="ln2825">    if (toscroll != 0 || to_redraw) {</a>
<a name="ln2826">      if (toscroll &lt; 0 || to_redraw) {</a>
<a name="ln2827">        // go to start of last line</a>
<a name="ln2828">        if (mp_last == NULL) {</a>
<a name="ln2829">          mp = msg_sb_start(last_msgchunk);</a>
<a name="ln2830">        } else if (mp_last-&gt;sb_prev != NULL) {</a>
<a name="ln2831">          mp = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2832">        } else {</a>
<a name="ln2833">          mp = NULL;</a>
<a name="ln2834">        }</a>
<a name="ln2835"> </a>
<a name="ln2836">        // go to start of line at top of the screen</a>
<a name="ln2837">        for (i = 0; i &lt; Rows - 2 &amp;&amp; mp != NULL &amp;&amp; mp-&gt;sb_prev != NULL;</a>
<a name="ln2838">             ++i) {</a>
<a name="ln2839">          mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2840">        }</a>
<a name="ln2841"> </a>
<a name="ln2842">        if (mp != NULL &amp;&amp; (mp-&gt;sb_prev != NULL || to_redraw)) {</a>
<a name="ln2843">          // Find line to be displayed at top</a>
<a name="ln2844">          for (i = 0; i &gt; toscroll; i--) {</a>
<a name="ln2845">            if (mp == NULL || mp-&gt;sb_prev == NULL) {</a>
<a name="ln2846">              break;</a>
<a name="ln2847">            }</a>
<a name="ln2848">            mp = msg_sb_start(mp-&gt;sb_prev);</a>
<a name="ln2849">            if (mp_last == NULL) {</a>
<a name="ln2850">              mp_last = msg_sb_start(last_msgchunk);</a>
<a name="ln2851">            } else {</a>
<a name="ln2852">              mp_last = msg_sb_start(mp_last-&gt;sb_prev);</a>
<a name="ln2853">            }</a>
<a name="ln2854">          }</a>
<a name="ln2855"> </a>
<a name="ln2856">          if (toscroll == -1 &amp;&amp; !to_redraw) {</a>
<a name="ln2857">            grid_ins_lines(&amp;msg_grid_adj, 0, 1, Rows, 0, Columns);</a>
<a name="ln2858">            grid_fill(&amp;msg_grid_adj, 0, 1, 0, Columns, ' ', ' ',</a>
<a name="ln2859">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2860">            // display line at top</a>
<a name="ln2861">            (void)disp_sb_line(0, mp);</a>
<a name="ln2862">          } else {</a>
<a name="ln2863">            // redisplay all lines</a>
<a name="ln2864">            // TODO(bfredl): this case is not optimized (though only concerns</a>
<a name="ln2865">            // event fragmentization, not unnecessary scroll events).</a>
<a name="ln2866">            grid_fill(&amp;msg_grid_adj, 0, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2867">                      HL_ATTR(HLF_MSG));</a>
<a name="ln2868">            for (i = 0; mp != NULL &amp;&amp; i &lt; Rows - 1; i++) {</a>
<a name="ln2869">              mp = disp_sb_line(i, mp);</a>
<a name="ln2870">              ++msg_scrolled;</a>
<a name="ln2871">            }</a>
<a name="ln2872">            to_redraw = false;</a>
<a name="ln2873">          }</a>
<a name="ln2874">          toscroll = 0;</a>
<a name="ln2875">        }</a>
<a name="ln2876">      } else {</a>
<a name="ln2877">        // First display any text that we scrolled back.</a>
<a name="ln2878">        while (toscroll &gt; 0 &amp;&amp; mp_last != NULL) {</a>
<a name="ln2879">          if (msg_do_throttle() &amp;&amp; !msg_grid.throttled) {</a>
<a name="ln2880">            // Tricky: we redraw at one line higher than usual. Therefore</a>
<a name="ln2881">            // the non-flushed area is one line larger.</a>
<a name="ln2882">            msg_scrolled_at_flush--;</a>
<a name="ln2883">            msg_grid_scroll_discount++;</a>
<a name="ln2884">          }</a>
<a name="ln2885">          // scroll up, display line at bottom</a>
<a name="ln2886">          msg_scroll_up(true);</a>
<a name="ln2887">          inc_msg_scrolled();</a>
<a name="ln2888">          grid_fill(&amp;msg_grid_adj, Rows - 2, Rows - 1, 0, Columns, ' ', ' ',</a>
<a name="ln2889">                    HL_ATTR(HLF_MSG));</a>
<a name="ln2890">          mp_last = disp_sb_line(Rows - 2, mp_last);</a>
<a name="ln2891">          toscroll--;</a>
<a name="ln2892">        }</a>
<a name="ln2893">      }</a>
<a name="ln2894"> </a>
<a name="ln2895">      if (toscroll &lt;= 0) {</a>
<a name="ln2896">        // displayed the requested text, more prompt again</a>
<a name="ln2897">        grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2898">                  HL_ATTR(HLF_MSG));</a>
<a name="ln2899">        msg_moremsg(false);</a>
<a name="ln2900">        continue;</a>
<a name="ln2901">      }</a>
<a name="ln2902"> </a>
<a name="ln2903">      // display more text, return to caller</a>
<a name="ln2904">      lines_left = toscroll;</a>
<a name="ln2905">    }</a>
<a name="ln2906"> </a>
<a name="ln2907">    break;</a>
<a name="ln2908">  }</a>
<a name="ln2909"> </a>
<a name="ln2910">  // clear the --more-- message</a>
<a name="ln2911">  grid_fill(&amp;msg_grid_adj, Rows - 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln2912">            HL_ATTR(HLF_MSG));</a>
<a name="ln2913">  redraw_cmdline = true;</a>
<a name="ln2914">  clear_cmdline = false;</a>
<a name="ln2915">  mode_displayed = false;</a>
<a name="ln2916"> </a>
<a name="ln2917">  State = oldState;</a>
<a name="ln2918">  setmouse();</a>
<a name="ln2919">  if (quit_more) {</a>
<a name="ln2920">    msg_row = Rows - 1;</a>
<a name="ln2921">    msg_col = 0;</a>
<a name="ln2922">  } else if (cmdmsg_rl) {</a>
<a name="ln2923">    msg_col = Columns - 1;</a>
<a name="ln2924">  }</a>
<a name="ln2925"> </a>
<a name="ln2926">  entered = false;</a>
<a name="ln2927">  return retval;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">#if defined(WIN32)</a>
<a name="ln2931">void mch_errmsg(char *str)</a>
<a name="ln2932">{</a>
<a name="ln2933">  assert(str != NULL);</a>
<a name="ln2934">  wchar_t *utf16str;</a>
<a name="ln2935">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln2936">  if (r != 0) {</a>
<a name="ln2937">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2938">  } else {</a>
<a name="ln2939">    fwprintf(stderr, L&quot;%ls&quot;, utf16str);</a>
<a name="ln2940">    xfree(utf16str);</a>
<a name="ln2941">  }</a>
<a name="ln2942">}</a>
<a name="ln2943"> </a>
<a name="ln2944">/// Give a message.  To be used when the UI is not initialized yet.</a>
<a name="ln2945">void mch_msg(char *str)</a>
<a name="ln2946">{</a>
<a name="ln2947">  assert(str != NULL);</a>
<a name="ln2948">  wchar_t *utf16str;</a>
<a name="ln2949">  int r = utf8_to_utf16(str, -1, &amp;utf16str);</a>
<a name="ln2950">  if (r != 0) {</a>
<a name="ln2951">    fprintf(stderr, &quot;utf8_to_utf16 failed: %d&quot;, r);</a>
<a name="ln2952">  } else {</a>
<a name="ln2953">    wprintf(L&quot;%ls&quot;, utf16str);</a>
<a name="ln2954">    xfree(utf16str);</a>
<a name="ln2955">  }</a>
<a name="ln2956">}</a>
<a name="ln2957">#endif  // WIN32</a>
<a name="ln2958"> </a>
<a name="ln2959">/// Put a character on the screen at the current message position and advance</a>
<a name="ln2960">/// to the next position.  Only for printable ASCII!</a>
<a name="ln2961">static void msg_screen_putchar(int c, int attr)</a>
<a name="ln2962">{</a>
<a name="ln2963">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), attr);</a>
<a name="ln2964">  msg_didout = true;            // remember that line is not empty</a>
<a name="ln2965">  grid_putchar(&amp;msg_grid_adj, c, msg_row, msg_col, attr);</a>
<a name="ln2966">  if (cmdmsg_rl) {</a>
<a name="ln2967">    if (--msg_col == 0) {</a>
<a name="ln2968">      msg_col = Columns;</a>
<a name="ln2969">      ++msg_row;</a>
<a name="ln2970">    }</a>
<a name="ln2971">  } else {</a>
<a name="ln2972">    if (++msg_col &gt;= Columns) {</a>
<a name="ln2973">      msg_col = 0;</a>
<a name="ln2974">      ++msg_row;</a>
<a name="ln2975">    }</a>
<a name="ln2976">  }</a>
<a name="ln2977">}</a>
<a name="ln2978"> </a>
<a name="ln2979">void msg_moremsg(int full)</a>
<a name="ln2980">{</a>
<a name="ln2981">  int attr;</a>
<a name="ln2982">  char_u *s = (char_u *)_(&quot;-- More --&quot;);</a>
<a name="ln2983"> </a>
<a name="ln2984">  attr = hl_combine_attr(HL_ATTR(HLF_MSG), HL_ATTR(HLF_M));</a>
<a name="ln2985">  grid_puts(&amp;msg_grid_adj, s, Rows - 1, 0, attr);</a>
<a name="ln2986">  if (full) {</a>
<a name="ln2987">    grid_puts(&amp;msg_grid_adj, (char_u *)</a>
<a name="ln2988">              _(&quot; SPACE/d/j: screen/page/line down, b/u/k: up, q: quit &quot;),</a>
<a name="ln2989">              Rows - 1, vim_strsize(s), attr);</a>
<a name="ln2990">  }</a>
<a name="ln2991">}</a>
<a name="ln2992"> </a>
<a name="ln2993">/// Repeat the message for the current mode: MODE_ASKMORE, MODE_EXTERNCMD,</a>
<a name="ln2994">/// MODE_CONFIRM or exmode_active.</a>
<a name="ln2995">void repeat_message(void)</a>
<a name="ln2996">{</a>
<a name="ln2997">  if (State == MODE_ASKMORE) {</a>
<a name="ln2998">    msg_moremsg(true);          // display --more-- message again</a>
<a name="ln2999">    msg_row = Rows - 1;</a>
<a name="ln3000">  } else if (State == MODE_CONFIRM) {</a>
<a name="ln3001">    display_confirm_msg();      // display &quot;:confirm&quot; message again</a>
<a name="ln3002">    msg_row = Rows - 1;</a>
<a name="ln3003">  } else if (State == MODE_EXTERNCMD) {</a>
<a name="ln3004">    ui_cursor_goto(msg_row, msg_col);     // put cursor back</a>
<a name="ln3005">  } else if (State == MODE_HITRETURN || State == MODE_SETWSIZE) {</a>
<a name="ln3006">    if (msg_row == Rows - 1) {</a>
<a name="ln3007">      // Avoid drawing the &quot;hit-enter&quot; prompt below the previous one,</a>
<a name="ln3008">      // overwrite it.  Esp. useful when regaining focus and a</a>
<a name="ln3009">      // FocusGained autocmd exists but didn't draw anything.</a>
<a name="ln3010">      msg_didout = false;</a>
<a name="ln3011">      msg_col = 0;</a>
<a name="ln3012">      msg_clr_eos();</a>
<a name="ln3013">    }</a>
<a name="ln3014">    hit_return_msg();</a>
<a name="ln3015">    msg_row = Rows - 1;</a>
<a name="ln3016">  }</a>
<a name="ln3017">}</a>
<a name="ln3018"> </a>
<a name="ln3019">/// Clear from current message position to end of screen.</a>
<a name="ln3020">/// Skip this when &quot;:silent&quot; was used, no need to clear for redirection.</a>
<a name="ln3021">void msg_clr_eos(void)</a>
<a name="ln3022">{</a>
<a name="ln3023">  if (msg_silent == 0) {</a>
<a name="ln3024">    msg_clr_eos_force();</a>
<a name="ln3025">  }</a>
<a name="ln3026">}</a>
<a name="ln3027"> </a>
<a name="ln3028">/// Clear from current message position to end of screen.</a>
<a name="ln3029">/// Note: msg_col is not updated, so we remember the end of the message</a>
<a name="ln3030">/// for msg_check().</a>
<a name="ln3031">void msg_clr_eos_force(void)</a>
<a name="ln3032">{</a>
<a name="ln3033">  if (ui_has(kUIMessages)) {</a>
<a name="ln3034">    return;</a>
<a name="ln3035">  }</a>
<a name="ln3036">  int msg_startcol = (cmdmsg_rl) ? 0 : msg_col;</a>
<a name="ln3037">  int msg_endcol = (cmdmsg_rl) ? msg_col + 1 : Columns;</a>
<a name="ln3038"> </a>
<a name="ln3039">  if (msg_grid.chars &amp;&amp; msg_row &lt; msg_grid_pos) {</a>
<a name="ln3040">    // TODO(bfredl): ugly, this state should already been validated at this</a>
<a name="ln3041">    // point. But msg_clr_eos() is called in a lot of places.</a>
<a name="ln3042">    msg_row = msg_grid_pos;</a>
<a name="ln3043">  }</a>
<a name="ln3044"> </a>
<a name="ln3045">  grid_fill(&amp;msg_grid_adj, msg_row, msg_row + 1, msg_startcol, msg_endcol, ' ',</a>
<a name="ln3046">            ' ', HL_ATTR(HLF_MSG));</a>
<a name="ln3047">  grid_fill(&amp;msg_grid_adj, msg_row + 1, Rows, 0, Columns, ' ', ' ',</a>
<a name="ln3048">            HL_ATTR(HLF_MSG));</a>
<a name="ln3049"> </a>
<a name="ln3050">  redraw_cmdline = true;  // overwritten the command line</a>
<a name="ln3051">  if (msg_row &lt; Rows - 1 || msg_col == (cmdmsg_rl ? Columns : 0)) {</a>
<a name="ln3052">    clear_cmdline = false;  // command line has been cleared</a>
<a name="ln3053">    mode_displayed = false;  // mode cleared or overwritten</a>
<a name="ln3054">  }</a>
<a name="ln3055">}</a>
<a name="ln3056"> </a>
<a name="ln3057">/// Clear the command line.</a>
<a name="ln3058">void msg_clr_cmdline(void)</a>
<a name="ln3059">{</a>
<a name="ln3060">  msg_row = cmdline_row;</a>
<a name="ln3061">  msg_col = 0;</a>
<a name="ln3062">  msg_clr_eos_force();</a>
<a name="ln3063">}</a>
<a name="ln3064"> </a>
<a name="ln3065">/// end putting a message on the screen</a>
<a name="ln3066">/// call wait_return if the message does not fit in the available space</a>
<a name="ln3067">///</a>
<a name="ln3068">/// @return  TRUE if wait_return not called.</a>
<a name="ln3069">int msg_end(void)</a>
<a name="ln3070">{</a>
<a name="ln3071">  /*</a>
<a name="ln3072">   * If the string is larger than the window,</a>
<a name="ln3073">   * or the ruler option is set and we run into it,</a>
<a name="ln3074">   * we have to redraw the window.</a>
<a name="ln3075">   * Do not do this if we are abandoning the file or editing the command line.</a>
<a name="ln3076">   */</a>
<a name="ln3077">  if (!exiting &amp;&amp; need_wait_return &amp;&amp; !(State &amp; MODE_CMDLINE)) {</a>
<a name="ln3078">    wait_return(false);</a>
<a name="ln3079">    return false;</a>
<a name="ln3080">  }</a>
<a name="ln3081"> </a>
<a name="ln3082">  // NOTE: ui_flush() used to be called here. This had to be removed, as it</a>
<a name="ln3083">  // inhibited substantial performance improvements. It is assumed that relevant</a>
<a name="ln3084">  // callers invoke ui_flush() before going into CPU busywork, or restricted</a>
<a name="ln3085">  // event processing after displaying a message to the user.</a>
<a name="ln3086">  msg_ext_ui_flush();</a>
<a name="ln3087">  return true;</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">void msg_ext_ui_flush(void)</a>
<a name="ln3091">{</a>
<a name="ln3092">  if (!ui_has(kUIMessages)) {</a>
<a name="ln3093">    return;</a>
<a name="ln3094">  }</a>
<a name="ln3095"> </a>
<a name="ln3096">  msg_ext_emit_chunk();</a>
<a name="ln3097">  if (msg_ext_chunks.size &gt; 0) {</a>
<a name="ln3098">    ui_call_msg_show(cstr_to_string(msg_ext_kind),</a>
<a name="ln3099">                     msg_ext_chunks, msg_ext_overwrite);</a>
<a name="ln3100">    if (!msg_ext_overwrite) {</a>
<a name="ln3101">      msg_ext_visible++;</a>
<a name="ln3102">    }</a>
<a name="ln3103">    msg_ext_kind = NULL;</a>
<a name="ln3104">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3105">    msg_ext_cur_len = 0;</a>
<a name="ln3106">    msg_ext_overwrite = false;</a>
<a name="ln3107">  }</a>
<a name="ln3108">}</a>
<a name="ln3109"> </a>
<a name="ln3110">void msg_ext_flush_showmode(void)</a>
<a name="ln3111">{</a>
<a name="ln3112">  // Showmode messages doesn't interrupt normal message flow, so we use</a>
<a name="ln3113">  // separate event. Still reuse the same chunking logic, for simplicity.</a>
<a name="ln3114">  if (ui_has(kUIMessages)) {</a>
<a name="ln3115">    msg_ext_emit_chunk();</a>
<a name="ln3116">    ui_call_msg_showmode(msg_ext_chunks);</a>
<a name="ln3117">    msg_ext_chunks = (Array)ARRAY_DICT_INIT;</a>
<a name="ln3118">    msg_ext_cur_len = 0;</a>
<a name="ln3119">  }</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122">void msg_ext_clear(bool force)</a>
<a name="ln3123">{</a>
<a name="ln3124">  if (msg_ext_visible &amp;&amp; (!msg_ext_keep_after_cmdline || force)) {</a>
<a name="ln3125">    ui_call_msg_clear();</a>
<a name="ln3126">    msg_ext_visible = 0;</a>
<a name="ln3127">    msg_ext_overwrite = false;  // nothing to overwrite</a>
<a name="ln3128">  }</a>
<a name="ln3129">  if (msg_ext_history_visible) {</a>
<a name="ln3130">    ui_call_msg_history_clear();</a>
<a name="ln3131">    msg_ext_history_visible = false;</a>
<a name="ln3132">  }</a>
<a name="ln3133"> </a>
<a name="ln3134">  // Only keep once.</a>
<a name="ln3135">  msg_ext_keep_after_cmdline = false;</a>
<a name="ln3136">}</a>
<a name="ln3137"> </a>
<a name="ln3138">void msg_ext_clear_later(void)</a>
<a name="ln3139">{</a>
<a name="ln3140">  if (msg_ext_is_visible()) {</a>
<a name="ln3141">    msg_ext_need_clear = true;</a>
<a name="ln3142">    if (must_redraw &lt; VALID) {</a>
<a name="ln3143">      must_redraw = VALID;</a>
<a name="ln3144">    }</a>
<a name="ln3145">  }</a>
<a name="ln3146">}</a>
<a name="ln3147"> </a>
<a name="ln3148">void msg_ext_check_clear(void)</a>
<a name="ln3149">{</a>
<a name="ln3150">  // Redraw after cmdline or prompt is expected to clear messages.</a>
<a name="ln3151">  if (msg_ext_need_clear) {</a>
<a name="ln3152">    msg_ext_clear(true);</a>
<a name="ln3153">    msg_ext_need_clear = false;</a>
<a name="ln3154">  }</a>
<a name="ln3155">}</a>
<a name="ln3156"> </a>
<a name="ln3157">bool msg_ext_is_visible(void)</a>
<a name="ln3158">{</a>
<a name="ln3159">  return ui_has(kUIMessages) &amp;&amp; msg_ext_visible &gt; 0;</a>
<a name="ln3160">}</a>
<a name="ln3161"> </a>
<a name="ln3162">/// If the written message runs into the shown command or ruler, we have to</a>
<a name="ln3163">/// wait for hit-return and redraw the window later.</a>
<a name="ln3164">void msg_check(void)</a>
<a name="ln3165">{</a>
<a name="ln3166">  if (ui_has(kUIMessages)) {</a>
<a name="ln3167">    return;</a>
<a name="ln3168">  }</a>
<a name="ln3169">  if (msg_row == Rows - 1 &amp;&amp; msg_col &gt;= sc_col) {</a>
<a name="ln3170">    need_wait_return = true;</a>
<a name="ln3171">    redraw_cmdline = true;</a>
<a name="ln3172">  }</a>
<a name="ln3173">}</a>
<a name="ln3174"> </a>
<a name="ln3175">/// May write a string to the redirection file.</a>
<a name="ln3176">///</a>
<a name="ln3177">/// @param maxlen  if -1, write the whole string, otherwise up to &quot;maxlen&quot; bytes.</a>
<a name="ln3178">static void redir_write(const char *const str, const ptrdiff_t maxlen)</a>
<a name="ln3179">{</a>
<a name="ln3180">  const char_u *s = (char_u *)str;</a>
<a name="ln3181">  static int cur_col = 0;</a>
<a name="ln3182"> </a>
<a name="ln3183">  if (maxlen == 0) {</a>
<a name="ln3184">    return;</a>
<a name="ln3185">  }</a>
<a name="ln3186"> </a>
<a name="ln3187">  // Don't do anything for displaying prompts and the like.</a>
<a name="ln3188">  if (redir_off) {</a>
<a name="ln3189">    return;</a>
<a name="ln3190">  }</a>
<a name="ln3191"> </a>
<a name="ln3192">  // If 'verbosefile' is set prepare for writing in that file.</a>
<a name="ln3193">  if (*p_vfile != NUL &amp;&amp; verbose_fd == NULL) {</a>
<a name="ln3194">    verbose_open();</a>
<a name="ln3195">  }</a>
<a name="ln3196"> </a>
<a name="ln3197">  if (redirecting()) {</a>
<a name="ln3198">    // If the string doesn't start with CR or NL, go to msg_col</a>
<a name="ln3199">    if (*s != '\n' &amp;&amp; *s != '\r') {</a>
<a name="ln3200">      while (cur_col &lt; msg_col) {</a>
<a name="ln3201">        if (capture_ga) {</a>
<a name="ln3202">          ga_concat_len(capture_ga, &quot; &quot;, 1);</a>
<a name="ln3203">        }</a>
<a name="ln3204">        if (redir_reg) {</a>
<a name="ln3205">          write_reg_contents(redir_reg, (char_u *)&quot; &quot;, 1, true);</a>
<a name="ln3206">        } else if (redir_vname) {</a>
<a name="ln3207">          var_redir_str(&quot; &quot;, -1);</a>
<a name="ln3208">        } else if (redir_fd != NULL) {</a>
<a name="ln3209">          fputs(&quot; &quot;, redir_fd);</a>
<a name="ln3210">        }</a>
<a name="ln3211">        if (verbose_fd != NULL) {</a>
<a name="ln3212">          fputs(&quot; &quot;, verbose_fd);</a>
<a name="ln3213">        }</a>
<a name="ln3214">        cur_col++;</a>
<a name="ln3215">      }</a>
<a name="ln3216">    }</a>
<a name="ln3217"> </a>
<a name="ln3218">    size_t len = maxlen == -1 ? STRLEN(s) : (size_t)maxlen;</a>
<a name="ln3219">    if (capture_ga) {</a>
<a name="ln3220">      ga_concat_len(capture_ga, str, len);</a>
<a name="ln3221">    }</a>
<a name="ln3222">    if (redir_reg) {</a>
<a name="ln3223">      write_reg_contents(redir_reg, s, len, true);</a>
<a name="ln3224">    }</a>
<a name="ln3225">    if (redir_vname) {</a>
<a name="ln3226">      var_redir_str((char *)s, maxlen);</a>
<a name="ln3227">    }</a>
<a name="ln3228"> </a>
<a name="ln3229">    // Write and adjust the current column.</a>
<a name="ln3230">    while (*s != NUL</a>
<a name="ln3231">           &amp;&amp; (maxlen &lt; 0 || (int)(s - (const char_u *)str) &lt; maxlen)) {</a>
<a name="ln3232">      if (!redir_reg &amp;&amp; !redir_vname &amp;&amp; !capture_ga) {</a>
<a name="ln3233">        if (redir_fd != NULL) {</a>
<a name="ln3234">          putc(*s, redir_fd);</a>
<a name="ln3235">        }</a>
<a name="ln3236">      }</a>
<a name="ln3237">      if (verbose_fd != NULL) {</a>
<a name="ln3238">        putc(*s, verbose_fd);</a>
<a name="ln3239">      }</a>
<a name="ln3240">      if (*s == '\r' || *s == '\n') {</a>
<a name="ln3241">        cur_col = 0;</a>
<a name="ln3242">      } else if (*s == '\t') {</a>
<a name="ln3243">        cur_col += (8 - cur_col % 8);</a>
<a name="ln3244">      } else {</a>
<a name="ln3245">        cur_col++;</a>
<a name="ln3246">      }</a>
<a name="ln3247">      s++;</a>
<a name="ln3248">    }</a>
<a name="ln3249"> </a>
<a name="ln3250">    if (msg_silent != 0) {      // should update msg_col</a>
<a name="ln3251">      msg_col = cur_col;</a>
<a name="ln3252">    }</a>
<a name="ln3253">  }</a>
<a name="ln3254">}</a>
<a name="ln3255"> </a>
<a name="ln3256">int redirecting(void)</a>
<a name="ln3257">{</a>
<a name="ln3258">  return redir_fd != NULL || *p_vfile != NUL</a>
<a name="ln3259">         || redir_reg || redir_vname || capture_ga != NULL;</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262">/// Before giving verbose message.</a>
<a name="ln3263">/// Must always be called paired with verbose_leave()!</a>
<a name="ln3264">void verbose_enter(void)</a>
<a name="ln3265">{</a>
<a name="ln3266">  if (*p_vfile != NUL) {</a>
<a name="ln3267">    ++msg_silent;</a>
<a name="ln3268">  }</a>
<a name="ln3269">}</a>
<a name="ln3270"> </a>
<a name="ln3271">/// After giving verbose message.</a>
<a name="ln3272">/// Must always be called paired with verbose_enter()!</a>
<a name="ln3273">void verbose_leave(void)</a>
<a name="ln3274">{</a>
<a name="ln3275">  if (*p_vfile != NUL) {</a>
<a name="ln3276">    if (--msg_silent &lt; 0) {</a>
<a name="ln3277">      msg_silent = 0;</a>
<a name="ln3278">    }</a>
<a name="ln3279">  }</a>
<a name="ln3280">}</a>
<a name="ln3281"> </a>
<a name="ln3282">/// Like verbose_enter() and set msg_scroll when displaying the message.</a>
<a name="ln3283">void verbose_enter_scroll(void)</a>
<a name="ln3284">{</a>
<a name="ln3285">  if (*p_vfile != NUL) {</a>
<a name="ln3286">    ++msg_silent;</a>
<a name="ln3287">  } else {</a>
<a name="ln3288">    // always scroll up, don't overwrite</a>
<a name="ln3289">    msg_scroll = TRUE;</a>
<a name="ln3290">  }</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">/// Like verbose_leave() and set cmdline_row when displaying the message.</a>
<a name="ln3294">void verbose_leave_scroll(void)</a>
<a name="ln3295">{</a>
<a name="ln3296">  if (*p_vfile != NUL) {</a>
<a name="ln3297">    if (--msg_silent &lt; 0) {</a>
<a name="ln3298">      msg_silent = 0;</a>
<a name="ln3299">    }</a>
<a name="ln3300">  } else {</a>
<a name="ln3301">    cmdline_row = msg_row;</a>
<a name="ln3302">  }</a>
<a name="ln3303">}</a>
<a name="ln3304"> </a>
<a name="ln3305">/// Called when 'verbosefile' is set: stop writing to the file.</a>
<a name="ln3306">void verbose_stop(void)</a>
<a name="ln3307">{</a>
<a name="ln3308">  if (verbose_fd != NULL) {</a>
<a name="ln3309">    fclose(verbose_fd);</a>
<a name="ln3310">    verbose_fd = NULL;</a>
<a name="ln3311">  }</a>
<a name="ln3312">  verbose_did_open = FALSE;</a>
<a name="ln3313">}</a>
<a name="ln3314"> </a>
<a name="ln3315">/// Open the file 'verbosefile'.</a>
<a name="ln3316">///</a>
<a name="ln3317">/// @return  FAIL or OK.</a>
<a name="ln3318">int verbose_open(void)</a>
<a name="ln3319">{</a>
<a name="ln3320">  if (verbose_fd == NULL &amp;&amp; !verbose_did_open) {</a>
<a name="ln3321">    // Only give the error message once.</a>
<a name="ln3322">    verbose_did_open = TRUE;</a>
<a name="ln3323"> </a>
<a name="ln3324">    verbose_fd = os_fopen((char *)p_vfile, &quot;a&quot;);</a>
<a name="ln3325">    if (verbose_fd == NULL) {</a>
<a name="ln3326">      semsg(_(e_notopen), p_vfile);</a>
<a name="ln3327">      return FAIL;</a>
<a name="ln3328">    }</a>
<a name="ln3329">  }</a>
<a name="ln3330">  return OK;</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333">/// Give a warning message (for searching).</a>
<a name="ln3334">/// Use 'w' highlighting and may repeat the message after redrawing</a>
<a name="ln3335">void give_warning(char_u *message, bool hl) FUNC_ATTR_NONNULL_ARG(1)</a>
<a name="ln3336">{</a>
<a name="ln3337">  // Don't do this for &quot;:silent&quot;.</a>
<a name="ln3338">  if (msg_silent != 0) {</a>
<a name="ln3339">    return;</a>
<a name="ln3340">  }</a>
<a name="ln3341"> </a>
<a name="ln3342">  // Don't want a hit-enter prompt here.</a>
<a name="ln3343">  no_wait_return++;</a>
<a name="ln3344"> </a>
<a name="ln3345">  set_vim_var_string(VV_WARNINGMSG, (char *)message, -1);</a>
<a name="ln3346">  XFREE_CLEAR(keep_msg);</a>
<a name="ln3347">  if (hl) {</a>
<a name="ln3348">    keep_msg_attr = HL_ATTR(HLF_W);</a>
<a name="ln3349">  } else {</a>
<a name="ln3350">    keep_msg_attr = 0;</a>
<a name="ln3351">  }</a>
<a name="ln3352"> </a>
<a name="ln3353">  if (msg_ext_kind == NULL) {</a>
<a name="ln3354">    msg_ext_set_kind(&quot;wmsg&quot;);</a>
<a name="ln3355">  }</a>
<a name="ln3356"> </a>
<a name="ln3357">  if (msg_attr((const char *)message, keep_msg_attr) &amp;&amp; msg_scrolled == 0) {</a>
<a name="ln3358">    set_keep_msg((char *)message, keep_msg_attr);</a>
<a name="ln3359">  }</a>
<a name="ln3360">  msg_didout = false;  // Overwrite this message.</a>
<a name="ln3361">  msg_nowait = true;   // Don't wait for this message.</a>
<a name="ln3362">  msg_col = 0;</a>
<a name="ln3363"> </a>
<a name="ln3364">  no_wait_return--;</a>
<a name="ln3365">}</a>
<a name="ln3366"> </a>
<a name="ln3367">void give_warning2(char_u *const message, char_u *const a1, bool hl)</a>
<a name="ln3368">{</a>
<a name="ln3369">  vim_snprintf((char *)IObuff, IOSIZE, (char *)message, a1);</a>
<a name="ln3370">  give_warning(IObuff, hl);</a>
<a name="ln3371">}</a>
<a name="ln3372"> </a>
<a name="ln3373">/// Advance msg cursor to column &quot;col&quot;.</a>
<a name="ln3374">void msg_advance(int col)</a>
<a name="ln3375">{</a>
<a name="ln3376">  if (msg_silent != 0) {        // nothing to advance to</a>
<a name="ln3377">    msg_col = col;              // for redirection, may fill it up later</a>
<a name="ln3378">    return;</a>
<a name="ln3379">  }</a>
<a name="ln3380">  if (ui_has(kUIMessages)) {</a>
<a name="ln3381">    // TODO(bfredl): use byte count as a basic proxy.</a>
<a name="ln3382">    // later on we might add proper support for formatted messages.</a>
<a name="ln3383">    while (msg_ext_cur_len &lt; (size_t)col) {</a>
<a name="ln3384">      msg_putchar(' ');</a>
<a name="ln3385">    }</a>
<a name="ln3386">    return;</a>
<a name="ln3387">  }</a>
<a name="ln3388">  if (col &gt;= Columns) {         // not enough room</a>
<a name="ln3389">    col = Columns - 1;</a>
<a name="ln3390">  }</a>
<a name="ln3391">  if (cmdmsg_rl) {</a>
<a name="ln3392">    while (msg_col &gt; Columns - col) {</a>
<a name="ln3393">      msg_putchar(' ');</a>
<a name="ln3394">    }</a>
<a name="ln3395">  } else {</a>
<a name="ln3396">    while (msg_col &lt; col) {</a>
<a name="ln3397">      msg_putchar(' ');</a>
<a name="ln3398">    }</a>
<a name="ln3399">  }</a>
<a name="ln3400">}</a>
<a name="ln3401"> </a>
<a name="ln3402">/// Used for &quot;confirm()&quot; function, and the :confirm command prefix.</a>
<a name="ln3403">/// Versions which haven't got flexible dialogs yet, and console</a>
<a name="ln3404">/// versions, get this generic handler which uses the command line.</a>
<a name="ln3405">///</a>
<a name="ln3406">/// type  = one of:</a>
<a name="ln3407">///         VIM_QUESTION, VIM_INFO, VIM_WARNING, VIM_ERROR or VIM_GENERIC</a>
<a name="ln3408">/// title = title string (can be NULL for default)</a>
<a name="ln3409">/// (neither used in console dialogs at the moment)</a>
<a name="ln3410">///</a>
<a name="ln3411">/// Format of the &quot;buttons&quot; string:</a>
<a name="ln3412">/// &quot;Button1Name\nButton2Name\nButton3Name&quot;</a>
<a name="ln3413">/// The first button should normally be the default/accept</a>
<a name="ln3414">/// The second button should be the 'Cancel' button</a>
<a name="ln3415">/// Other buttons- use your imagination!</a>
<a name="ln3416">/// A '&amp;' in a button name becomes a shortcut, so each '&amp;' should be before a</a>
<a name="ln3417">/// different letter.</a>
<a name="ln3418">///</a>
<a name="ln3419">/// @param textfiel  IObuff for inputdialog(), NULL otherwise</a>
<a name="ln3420">/// @param ex_cmd  when TRUE pressing : accepts default and starts Ex command</a>
<a name="ln3421">/// @returns 0 if cancelled, otherwise the nth button (1-indexed).</a>
<a name="ln3422">int do_dialog(int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton,</a>
<a name="ln3423">              char_u *textfield, int ex_cmd)</a>
<a name="ln3424">{</a>
<a name="ln3425">  int retval = 0;</a>
<a name="ln3426">  char_u *hotkeys;</a>
<a name="ln3427">  int c;</a>
<a name="ln3428">  int i;</a>
<a name="ln3429"> </a>
<a name="ln3430">  if (silent_mode      // No dialogs in silent mode (&quot;ex -s&quot;)</a>
<a name="ln3431">      || !ui_active()  // Without a UI Nvim waits for input forever.</a>
<a name="ln3432">      ) {</a>
<a name="ln3433">    return dfltbutton;  // return default option</a>
<a name="ln3434">  }</a>
<a name="ln3435"> </a>
<a name="ln3436">  int save_msg_silent = msg_silent;</a>
<a name="ln3437">  int oldState = State;</a>
<a name="ln3438"> </a>
<a name="ln3439">  msg_silent = 0;  // If dialog prompts for input, user needs to see it! #8788</a>
<a name="ln3440">  State = MODE_CONFIRM;</a>
<a name="ln3441">  setmouse();</a>
<a name="ln3442"> </a>
<a name="ln3443">  /*</a>
<a name="ln3444">   * Since we wait for a keypress, don't make the</a>
<a name="ln3445">   * user press RETURN as well afterwards.</a>
<a name="ln3446">   */</a>
<a name="ln3447">  ++no_wait_return;</a>
<a name="ln3448">  hotkeys = msg_show_console_dialog(message, buttons, dfltbutton);</a>
<a name="ln3449"> </a>
<a name="ln3450">  for (;;) {</a>
<a name="ln3451">    // Get a typed character directly from the user.</a>
<a name="ln3452">    c = get_keystroke(NULL);</a>
<a name="ln3453">    switch (c) {</a>
<a name="ln3454">    case CAR:                 // User accepts default option</a>
<a name="ln3455">    case NL:</a>
<a name="ln3456">      retval = dfltbutton;</a>
<a name="ln3457">      break;</a>
<a name="ln3458">    case Ctrl_C:              // User aborts/cancels</a>
<a name="ln3459">    case ESC:</a>
<a name="ln3460">      retval = 0;</a>
<a name="ln3461">      break;</a>
<a name="ln3462">    default:                  // Could be a hotkey?</a>
<a name="ln3463">      if (c &lt; 0) {            // special keys are ignored here</a>
<a name="ln3464">        continue;</a>
<a name="ln3465">      }</a>
<a name="ln3466">      if (c == ':' &amp;&amp; ex_cmd) {</a>
<a name="ln3467">        retval = dfltbutton;</a>
<a name="ln3468">        ins_char_typebuf(':', 0);</a>
<a name="ln3469">        break;</a>
<a name="ln3470">      }</a>
<a name="ln3471"> </a>
<a name="ln3472">      // Make the character lowercase, as chars in &quot;hotkeys&quot; are.</a>
<a name="ln3473">      c = mb_tolower(c);</a>
<a name="ln3474">      retval = 1;</a>
<a name="ln3475">      for (i = 0; hotkeys[i]; i++) {</a>
<a name="ln3476">        if (utf_ptr2char((char *)hotkeys + i) == c) {</a>
<a name="ln3477">          break;</a>
<a name="ln3478">        }</a>
<a name="ln3479">        i += utfc_ptr2len((char *)hotkeys + i) - 1;</a>
<a name="ln3480">        retval++;</a>
<a name="ln3481">      }</a>
<a name="ln3482">      if (hotkeys[i]) {</a>
<a name="ln3483">        break;</a>
<a name="ln3484">      }</a>
<a name="ln3485">      // No hotkey match, so keep waiting</a>
<a name="ln3486">      continue;</a>
<a name="ln3487">    }</a>
<a name="ln3488">    break;</a>
<a name="ln3489">  }</a>
<a name="ln3490"> </a>
<a name="ln3491">  xfree(hotkeys);</a>
<a name="ln3492"> </a>
<a name="ln3493">  msg_silent = save_msg_silent;</a>
<a name="ln3494">  State = oldState;</a>
<a name="ln3495">  setmouse();</a>
<a name="ln3496">  --no_wait_return;</a>
<a name="ln3497">  msg_end_prompt();</a>
<a name="ln3498"> </a>
<a name="ln3499">  return retval;</a>
<a name="ln3500">}</a>
<a name="ln3501"> </a>
<a name="ln3502">/// Copy one character from &quot;*from&quot; to &quot;*to&quot;, taking care of multi-byte</a>
<a name="ln3503">/// characters.  Return the length of the character in bytes.</a>
<a name="ln3504">///</a>
<a name="ln3505">/// @param lowercase  make character lower case</a>
<a name="ln3506">static int copy_char(const char_u *from, char_u *to, bool lowercase)</a>
<a name="ln3507">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln3508">{</a>
<a name="ln3509">  if (lowercase) {</a>
<a name="ln3510">    int c = mb_tolower(utf_ptr2char((char *)from));</a>
<a name="ln3511">    return utf_char2bytes(c, (char *)to);</a>
<a name="ln3512">  }</a>
<a name="ln3513">  int len = utfc_ptr2len((char *)from);</a>
<a name="ln3514">  memmove(to, from, (size_t)len);</a>
<a name="ln3515">  return len;</a>
<a name="ln3516">}</a>
<a name="ln3517"> </a>
<a name="ln3518">#define HAS_HOTKEY_LEN 30</a>
<a name="ln3519">#define HOTK_LEN MB_MAXBYTES</a>
<a name="ln3520"> </a>
<a name="ln3521">/// Allocates memory for dialog string &amp; for storing hotkeys</a>
<a name="ln3522">///</a>
<a name="ln3523">/// Finds the size of memory required for the confirm_msg &amp; for storing hotkeys</a>
<a name="ln3524">/// and then allocates the memory for them.</a>
<a name="ln3525">/// has_hotkey array is also filled-up.</a>
<a name="ln3526">///</a>
<a name="ln3527">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3528">/// @param buttons String containing button names</a>
<a name="ln3529">/// @param[out] has_hotkey An element in this array is set to true if</a>
<a name="ln3530">///                        corresponding button has a hotkey</a>
<a name="ln3531">///</a>
<a name="ln3532">/// @return Pointer to memory allocated for storing hotkeys</a>
<a name="ln3533">static char_u *console_dialog_alloc(const char_u *message, char_u *buttons, bool has_hotkey[])</a>
<a name="ln3534">{</a>
<a name="ln3535">  int lenhotkey = HOTK_LEN;  // count first button</a>
<a name="ln3536">  has_hotkey[0] = false;</a>
<a name="ln3537"> </a>
<a name="ln3538">  // Compute the size of memory to allocate.</a>
<a name="ln3539">  int len = 0;</a>
<a name="ln3540">  int idx = 0;</a>
<a name="ln3541">  char_u *r = buttons;</a>
<a name="ln3542">  while (*r) {</a>
<a name="ln3543">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3544">      len += 3;                         // '\n' -&gt; ', '; 'x' -&gt; '(x)'</a>
<a name="ln3545">      lenhotkey += HOTK_LEN;            // each button needs a hotkey</a>
<a name="ln3546">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3547">        has_hotkey[++idx] = false;</a>
<a name="ln3548">      }</a>
<a name="ln3549">    } else if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3550">      r++;</a>
<a name="ln3551">      len++;                    // '&amp;a' -&gt; '[a]'</a>
<a name="ln3552">      if (idx &lt; HAS_HOTKEY_LEN - 1) {</a>
<a name="ln3553">        has_hotkey[idx] = true;</a>
<a name="ln3554">      }</a>
<a name="ln3555">    }</a>
<a name="ln3556"> </a>
<a name="ln3557">    // Advance to the next character</a>
<a name="ln3558">    MB_PTR_ADV(r);</a>
<a name="ln3559">  }</a>
<a name="ln3560"> </a>
<a name="ln3561">  len += (int)(STRLEN(message)</a>
<a name="ln3562">               + 2                          // for the NL's</a>
<a name="ln3563">               + STRLEN(buttons)</a>
<a name="ln3564">               + 3);                        // for the &quot;: &quot; and NUL</a>
<a name="ln3565">  lenhotkey++;                               // for the NUL</a>
<a name="ln3566"> </a>
<a name="ln3567">  // If no hotkey is specified, first char is used.</a>
<a name="ln3568">  if (!has_hotkey[0]) {</a>
<a name="ln3569">    len += 2;                                // &quot;x&quot; -&gt; &quot;[x]&quot;</a>
<a name="ln3570">  }</a>
<a name="ln3571"> </a>
<a name="ln3572">  // Now allocate space for the strings</a>
<a name="ln3573">  xfree(confirm_msg);</a>
<a name="ln3574">  confirm_msg = xmalloc(len);</a>
<a name="ln3575">  *confirm_msg = NUL;</a>
<a name="ln3576"> </a>
<a name="ln3577">  return xmalloc(lenhotkey);</a>
<a name="ln3578">}</a>
<a name="ln3579"> </a>
<a name="ln3580">/// Format the dialog string, and display it at the bottom of</a>
<a name="ln3581">/// the screen. Return a string of hotkey chars (if defined) for</a>
<a name="ln3582">/// each 'button'. If a button has no hotkey defined, the first character of</a>
<a name="ln3583">/// the button is used.</a>
<a name="ln3584">/// The hotkeys can be multi-byte characters, but without combining chars.</a>
<a name="ln3585">///</a>
<a name="ln3586">/// @return  an allocated string with hotkeys.</a>
<a name="ln3587">static char_u *msg_show_console_dialog(char_u *message, char_u *buttons, int dfltbutton)</a>
<a name="ln3588">  FUNC_ATTR_NONNULL_RET</a>
<a name="ln3589">{</a>
<a name="ln3590">  bool has_hotkey[HAS_HOTKEY_LEN] = { false };</a>
<a name="ln3591">  char_u *hotk = console_dialog_alloc(message, buttons, has_hotkey);</a>
<a name="ln3592"> </a>
<a name="ln3593">  copy_hotkeys_and_msg(message, buttons, dfltbutton, has_hotkey, hotk);</a>
<a name="ln3594"> </a>
<a name="ln3595">  display_confirm_msg();</a>
<a name="ln3596">  return hotk;</a>
<a name="ln3597">}</a>
<a name="ln3598"> </a>
<a name="ln3599">/// Copies hotkeys &amp; dialog message into the memory allocated for it</a>
<a name="ln3600">///</a>
<a name="ln3601">/// @param message Message which will be part of the confirm_msg</a>
<a name="ln3602">/// @param buttons String containing button names</a>
<a name="ln3603">/// @param default_button_idx Number of default button</a>
<a name="ln3604">/// @param has_hotkey An element in this array is true if corresponding button</a>
<a name="ln3605">///                   has a hotkey</a>
<a name="ln3606">/// @param[out] hotkeys_ptr Pointer to the memory location where hotkeys will be copied</a>
<a name="ln3607">static void copy_hotkeys_and_msg(const char_u *message, char_u *buttons, int default_button_idx,</a>
<a name="ln3608">                                 const bool has_hotkey[], char_u *hotkeys_ptr)</a>
<a name="ln3609">{</a>
<a name="ln3610">  *confirm_msg = '\n';</a>
<a name="ln3611">  STRCPY(confirm_msg + 1, message);</a>
<a name="ln3612"> </a>
<a name="ln3613">  char_u *msgp = confirm_msg + 1 + STRLEN(message);</a>
<a name="ln3614"> </a>
<a name="ln3615">  // Define first default hotkey. Keep the hotkey string NUL</a>
<a name="ln3616">  // terminated to avoid reading past the end.</a>
<a name="ln3617">  hotkeys_ptr[copy_char(buttons, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3618"> </a>
<a name="ln3619">  // Remember where the choices start, displaying starts here when</a>
<a name="ln3620">  // &quot;hotkeys_ptr&quot; typed at the more prompt.</a>
<a name="ln3621">  confirm_msg_tail = msgp;</a>
<a name="ln3622">  *msgp++ = '\n';</a>
<a name="ln3623"> </a>
<a name="ln3624">  bool first_hotkey = false;  // Is the first char of button a hotkey</a>
<a name="ln3625">  if (!has_hotkey[0]) {</a>
<a name="ln3626">    first_hotkey = true;     // If no hotkey is specified, first char is used</a>
<a name="ln3627">  }</a>
<a name="ln3628"> </a>
<a name="ln3629">  int idx = 0;</a>
<a name="ln3630">  char_u *r = buttons;</a>
<a name="ln3631">  while (*r) {</a>
<a name="ln3632">    if (*r == DLG_BUTTON_SEP) {</a>
<a name="ln3633">      *msgp++ = ',';</a>
<a name="ln3634">      *msgp++ = ' ';                    // '\n' -&gt; ', '</a>
<a name="ln3635"> </a>
<a name="ln3636">      // Advance to next hotkey and set default hotkey</a>
<a name="ln3637">      hotkeys_ptr += STRLEN(hotkeys_ptr);</a>
<a name="ln3638">      hotkeys_ptr[copy_char(r + 1, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3639"> </a>
<a name="ln3640">      if (default_button_idx) {</a>
<a name="ln3641">        default_button_idx--;</a>
<a name="ln3642">      }</a>
<a name="ln3643"> </a>
<a name="ln3644">      // If no hotkey is specified, first char is used.</a>
<a name="ln3645">      if (idx &lt; HAS_HOTKEY_LEN - 1 &amp;&amp; !has_hotkey[++idx]) {</a>
<a name="ln3646">        first_hotkey = true;</a>
<a name="ln3647">      }</a>
<a name="ln3648">    } else if (*r == DLG_HOTKEY_CHAR || first_hotkey) {</a>
<a name="ln3649">      if (*r == DLG_HOTKEY_CHAR) {</a>
<a name="ln3650">        ++r;</a>
<a name="ln3651">      }</a>
<a name="ln3652"> </a>
<a name="ln3653">      first_hotkey = false;</a>
<a name="ln3654">      if (*r == DLG_HOTKEY_CHAR) {                 // '&amp;&amp;a' -&gt; '&amp;a'</a>
<a name="ln3655">        *msgp++ = *r;</a>
<a name="ln3656">      } else {</a>
<a name="ln3657">        // '&amp;a' -&gt; '[a]'</a>
<a name="ln3658">        *msgp++ = (default_button_idx == 1) ? '[' : '(';</a>
<a name="ln3659">        msgp += copy_char(r, msgp, false);</a>
<a name="ln3660">        *msgp++ = (default_button_idx == 1) ? ']' : ')';</a>
<a name="ln3661"> </a>
<a name="ln3662">        // redefine hotkey</a>
<a name="ln3663">        hotkeys_ptr[copy_char(r, hotkeys_ptr, true)] = NUL;</a>
<a name="ln3664">      }</a>
<a name="ln3665">    } else {</a>
<a name="ln3666">      // everything else copy literally</a>
<a name="ln3667">      msgp += copy_char(r, msgp, false);</a>
<a name="ln3668">    }</a>
<a name="ln3669"> </a>
<a name="ln3670">    // advance to the next character</a>
<a name="ln3671">    MB_PTR_ADV(r);</a>
<a name="ln3672">  }</a>
<a name="ln3673"> </a>
<a name="ln3674">  *msgp++ = ':';</a>
<a name="ln3675">  *msgp++ = ' ';</a>
<a name="ln3676">  *msgp = NUL;</a>
<a name="ln3677">}</a>
<a name="ln3678"> </a>
<a name="ln3679">/// Display the &quot;:confirm&quot; message.  Also called when screen resized.</a>
<a name="ln3680">void display_confirm_msg(void)</a>
<a name="ln3681">{</a>
<a name="ln3682">  // Avoid that 'q' at the more prompt truncates the message here.</a>
<a name="ln3683">  confirm_msg_used++;</a>
<a name="ln3684">  if (confirm_msg != NULL) {</a>
<a name="ln3685">    msg_ext_set_kind(&quot;confirm&quot;);</a>
<a name="ln3686">    msg_puts_attr((const char *)confirm_msg, HL_ATTR(HLF_M));</a>
<a name="ln3687">  }</a>
<a name="ln3688">  confirm_msg_used--;</a>
<a name="ln3689">}</a>
<a name="ln3690"> </a>
<a name="ln3691">int vim_dialog_yesno(int type, char_u *title, char_u *message, int dflt)</a>
<a name="ln3692">{</a>
<a name="ln3693">  if (do_dialog(type,</a>
<a name="ln3694">                title == NULL ? (char_u *)_(&quot;Question&quot;) : title,</a>
<a name="ln3695">                message,</a>
<a name="ln3696">                (char_u *)_(&quot;&amp;Yes\n&amp;No&quot;), dflt, NULL, FALSE) == 1) {</a>
<a name="ln3697">    return VIM_YES;</a>
<a name="ln3698">  }</a>
<a name="ln3699">  return VIM_NO;</a>
<a name="ln3700">}</a>
<a name="ln3701"> </a>
<a name="ln3702">int vim_dialog_yesnocancel(int type, char_u *title, char_u *message, int dflt)</a>
<a name="ln3703">{</a>
<a name="ln3704">  switch (do_dialog(type,</a>
<a name="ln3705">                    title == NULL ? (char_u *)_(&quot;Question&quot;) : title,</a>
<a name="ln3706">                    message,</a>
<a name="ln3707">                    (char_u *)_(&quot;&amp;Yes\n&amp;No\n&amp;Cancel&quot;), dflt, NULL, FALSE)) {</a>
<a name="ln3708">  case 1:</a>
<a name="ln3709">    return VIM_YES;</a>
<a name="ln3710">  case 2:</a>
<a name="ln3711">    return VIM_NO;</a>
<a name="ln3712">  }</a>
<a name="ln3713">  return VIM_CANCEL;</a>
<a name="ln3714">}</a>
<a name="ln3715"> </a>
<a name="ln3716">int vim_dialog_yesnoallcancel(int type, char_u *title, char_u *message, int dflt)</a>
<a name="ln3717">{</a>
<a name="ln3718">  switch (do_dialog(type,</a>
<a name="ln3719">                    title == NULL ? (char_u *)&quot;Question&quot; : title,</a>
<a name="ln3720">                    message,</a>
<a name="ln3721">                    (char_u *)_(&quot;&amp;Yes\n&amp;No\nSave &amp;All\n&amp;Discard All\n&amp;Cancel&quot;),</a>
<a name="ln3722">                    dflt, NULL, FALSE)) {</a>
<a name="ln3723">  case 1:</a>
<a name="ln3724">    return VIM_YES;</a>
<a name="ln3725">  case 2:</a>
<a name="ln3726">    return VIM_NO;</a>
<a name="ln3727">  case 3:</a>
<a name="ln3728">    return VIM_ALL;</a>
<a name="ln3729">  case 4:</a>
<a name="ln3730">    return VIM_DISCARDALL;</a>
<a name="ln3731">  }</a>
<a name="ln3732">  return VIM_CANCEL;</a>
<a name="ln3733">}</a>

</code></pre>
<div class="balloon" rel="1417"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v569/" target="_blank">V569</a> Truncation of constant value -128. The value range of unsigned char type: [0, 255].</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>

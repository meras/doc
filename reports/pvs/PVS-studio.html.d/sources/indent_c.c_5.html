
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>indent_c.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">// This is an open source non-commercial project. Dear PVS-Studio, please check</a>
<a name="ln2">// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln3"> </a>
<a name="ln4">#include &lt;assert.h&gt;</a>
<a name="ln5">#include &lt;inttypes.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;nvim/ascii.h&quot;</a>
<a name="ln8">#include &quot;nvim/charset.h&quot;</a>
<a name="ln9">#include &quot;nvim/cursor.h&quot;</a>
<a name="ln10">#include &quot;nvim/edit.h&quot;</a>
<a name="ln11">#include &quot;nvim/indent.h&quot;</a>
<a name="ln12">#include &quot;nvim/indent_c.h&quot;</a>
<a name="ln13">#include &quot;nvim/mark.h&quot;</a>
<a name="ln14">#include &quot;nvim/memline.h&quot;</a>
<a name="ln15">#include &quot;nvim/memory.h&quot;</a>
<a name="ln16">#include &quot;nvim/option.h&quot;</a>
<a name="ln17">#include &quot;nvim/search.h&quot;</a>
<a name="ln18">#include &quot;nvim/strings.h&quot;</a>
<a name="ln19">#include &quot;nvim/vim.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">// Find result cache for cpp_baseclass</a>
<a name="ln22">typedef struct {</a>
<a name="ln23">  int found;</a>
<a name="ln24">  lpos_T lpos;</a>
<a name="ln25">} cpp_baseclass_cache_T;</a>
<a name="ln26"> </a>
<a name="ln27">#ifdef INCLUDE_GENERATED_DECLARATIONS</a>
<a name="ln28"># include &quot;indent_c.c.generated.h&quot;</a>
<a name="ln29">#endif</a>
<a name="ln30">/*</a>
<a name="ln31"> * Find the start of a comment, not knowing if we are in a comment right now.</a>
<a name="ln32"> * Search starts at w_cursor.lnum and goes backwards.</a>
<a name="ln33"> * Return NULL when not inside a comment.</a>
<a name="ln34"> */</a>
<a name="ln35">static pos_T *ind_find_start_comment(void)  // XXX</a>
<a name="ln36">{</a>
<a name="ln37">  return find_start_comment(curbuf-&gt;b_ind_maxcomment);</a>
<a name="ln38">}</a>
<a name="ln39"> </a>
<a name="ln40">pos_T *find_start_comment(int ind_maxcomment)  // XXX</a>
<a name="ln41">{</a>
<a name="ln42">  pos_T *pos;</a>
<a name="ln43">  int64_t cur_maxcomment = ind_maxcomment;</a>
<a name="ln44"> </a>
<a name="ln45">  for (;;) {</a>
<a name="ln46">    pos = findmatchlimit(NULL, '*', FM_BACKWARD, cur_maxcomment);</a>
<a name="ln47">    if (pos == NULL) {</a>
<a name="ln48">      break;</a>
<a name="ln49">    }</a>
<a name="ln50"> </a>
<a name="ln51">    /*</a>
<a name="ln52">     * Check if the comment start we found is inside a string.</a>
<a name="ln53">     * If it is then restrict the search to below this line and try again.</a>
<a name="ln54">     */</a>
<a name="ln55">    if (!is_pos_in_string(ml_get(pos-&gt;lnum), pos-&gt;col)) {</a>
<a name="ln56">      break;</a>
<a name="ln57">    }</a>
<a name="ln58">    cur_maxcomment = curwin-&gt;w_cursor.lnum - pos-&gt;lnum - 1;</a>
<a name="ln59">    if (cur_maxcomment &lt;= 0) {</a>
<a name="ln60">      pos = NULL;</a>
<a name="ln61">      break;</a>
<a name="ln62">    }</a>
<a name="ln63">  }</a>
<a name="ln64">  return pos;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">/// Find the start of a comment or raw string, not knowing if we are in a</a>
<a name="ln68">/// comment or raw string right now.</a>
<a name="ln69">/// Search starts at w_cursor.lnum and goes backwards.</a>
<a name="ln70">/// If is_raw is given and returns start of raw_string, sets it to true.</a>
<a name="ln71">///</a>
<a name="ln72">/// @returns NULL when not inside a comment or raw string.</a>
<a name="ln73">///</a>
<a name="ln74">/// @note &quot;CORS&quot; -&gt; Comment Or Raw String</a>
<a name="ln75">static pos_T *ind_find_start_CORS(linenr_T *is_raw)</a>
<a name="ln76">{</a>
<a name="ln77">  // XXX</a>
<a name="ln78">  static pos_T comment_pos_copy;</a>
<a name="ln79"> </a>
<a name="ln80">  pos_T *comment_pos = find_start_comment(curbuf-&gt;b_ind_maxcomment);</a>
<a name="ln81">  if (comment_pos != NULL) {</a>
<a name="ln82">    // Need to make a copy of the static pos in findmatchlimit(),</a>
<a name="ln83">    // calling find_start_rawstring() may change it.</a>
<a name="ln84">    comment_pos_copy = *comment_pos;</a>
<a name="ln85">    comment_pos = &amp;comment_pos_copy;</a>
<a name="ln86">  }</a>
<a name="ln87">  pos_T *rs_pos = find_start_rawstring(curbuf-&gt;b_ind_maxcomment);</a>
<a name="ln88"> </a>
<a name="ln89">  // If comment_pos is before rs_pos the raw string is inside the comment.</a>
<a name="ln90">  // If rs_pos is before comment_pos the comment is inside the raw string.</a>
<a name="ln91">  if (comment_pos == NULL || (rs_pos != NULL &amp;&amp; lt(*rs_pos, *comment_pos))) {</a>
<a name="ln92">    if (is_raw != NULL &amp;&amp; rs_pos != NULL) {</a>
<a name="ln93">      *is_raw = rs_pos-&gt;lnum;</a>
<a name="ln94">    }</a>
<a name="ln95">    return rs_pos;</a>
<a name="ln96">  }</a>
<a name="ln97">  return comment_pos;</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">/*</a>
<a name="ln101"> * Find the start of a raw string, not knowing if we are in one right now.</a>
<a name="ln102"> * Search starts at w_cursor.lnum and goes backwards.</a>
<a name="ln103"> * Return NULL when not inside a raw string.</a>
<a name="ln104"> */</a>
<a name="ln105">static pos_T *find_start_rawstring(int ind_maxcomment)  // XXX</a>
<a name="ln106">{</a>
<a name="ln107">  pos_T *pos;</a>
<a name="ln108">  long cur_maxcomment = ind_maxcomment;</a>
<a name="ln109"> </a>
<a name="ln110">  for (;;) {</a>
<a name="ln111">    pos = findmatchlimit(NULL, 'R', FM_BACKWARD, cur_maxcomment);</a>
<a name="ln112">    if (pos == NULL) {</a>
<a name="ln113">      break;</a>
<a name="ln114">    }</a>
<a name="ln115"> </a>
<a name="ln116">    // Check if the raw string start we found is inside a string.</a>
<a name="ln117">    // If it is then restrict the search to below this line and try again.</a>
<a name="ln118">    if (!is_pos_in_string(ml_get(pos-&gt;lnum), pos-&gt;col)) {</a>
<a name="ln119">      break;</a>
<a name="ln120">    }</a>
<a name="ln121">    cur_maxcomment = curwin-&gt;w_cursor.lnum - pos-&gt;lnum - 1;</a>
<a name="ln122">    if (cur_maxcomment &lt;= 0) {</a>
<a name="ln123">      pos = NULL;</a>
<a name="ln124">      break;</a>
<a name="ln125">    }</a>
<a name="ln126">  }</a>
<a name="ln127">  return pos;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">/*</a>
<a name="ln131"> * Skip to the end of a &quot;string&quot; and a 'c' character.</a>
<a name="ln132"> * If there is no string or character, return argument unmodified.</a>
<a name="ln133"> */</a>
<a name="ln134">static const char_u *skip_string(const char_u *p)</a>
<a name="ln135">{</a>
<a name="ln136">  int i;</a>
<a name="ln137"> </a>
<a name="ln138">  /*</a>
<a name="ln139">   * We loop, because strings may be concatenated: &quot;date&quot;&quot;time&quot;.</a>
<a name="ln140">   */</a>
<a name="ln141">  for (;; p++) {</a>
<a name="ln142">    if (p[0] == '\'') {                     // 'c' or '\n' or '\000'</a>
<a name="ln143">      if (p[1] == NUL) {                    // ' at end of line</a>
<a name="ln144">        break;</a>
<a name="ln145">      }</a>
<a name="ln146">      i = 2;</a>
<a name="ln147">      if (p[1] == '\\' &amp;&amp; p[2] != NUL) {    // '\n' or '\000'</a>
<a name="ln148">        i++;</a>
<a name="ln149">        while (ascii_isdigit(p[i - 1])) {   // '\000'</a>
<a name="ln150">          i++;</a>
<a name="ln151">        }</a>
<a name="ln152">      }</a>
<a name="ln153">      if (p[i - 1] != NUL &amp;&amp; p[i] == '\'') {  // check for trailing '</a>
<a name="ln154">        p += i;</a>
<a name="ln155">        continue;</a>
<a name="ln156">      }</a>
<a name="ln157">    } else if (p[0] == '&quot;') {             // start of string</a>
<a name="ln158">      for (++p; p[0]; p++) {</a>
<a name="ln159">        if (p[0] == '\\' &amp;&amp; p[1] != NUL) {</a>
<a name="ln160">          p++;</a>
<a name="ln161">        } else if (p[0] == '&quot;') {         // end of string</a>
<a name="ln162">          break;</a>
<a name="ln163">        }</a>
<a name="ln164">      }</a>
<a name="ln165">      if (p[0] == '&quot;') {</a>
<a name="ln166">        continue;  // continue for another string</a>
<a name="ln167">      }</a>
<a name="ln168">    } else if (p[0] == 'R' &amp;&amp; p[1] == '&quot;') {</a>
<a name="ln169">      // Raw string: R&quot;[delim](...)[delim]&quot;</a>
<a name="ln170">      const char *delim = (char *)p + 2;</a>
<a name="ln171">      const char *paren = vim_strchr((char *)delim, '(');</a>
<a name="ln172"> </a>
<a name="ln173">      if (paren != NULL) {</a>
<a name="ln174">        const ptrdiff_t delim_len = paren - delim;</a>
<a name="ln175"> </a>
<a name="ln176">        for (p += 3; *p; p++) {</a>
<a name="ln177">          if (p[0] == ')' &amp;&amp; STRNCMP(p + 1, delim, delim_len) == 0</a>
<a name="ln178">              &amp;&amp; p[delim_len + 1] == '&quot;') {</a>
<a name="ln179">            p += delim_len + 1;</a>
<a name="ln180">            break;</a>
<a name="ln181">          }</a>
<a name="ln182">        }</a>
<a name="ln183">        if (p[0] == '&quot;') {</a>
<a name="ln184">          continue;  // continue for another string</a>
<a name="ln185">        }</a>
<a name="ln186">      }</a>
<a name="ln187">    }</a>
<a name="ln188">    break;                                  // no string found</a>
<a name="ln189">  }</a>
<a name="ln190">  if (!*p) {</a>
<a name="ln191">    p--;                                    // backup from NUL</a>
<a name="ln192">  }</a>
<a name="ln193">  return p;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">/// @returns true if &quot;line[col]&quot; is inside a C string.</a>
<a name="ln197">int is_pos_in_string(const char_u *line, colnr_T col)</a>
<a name="ln198">{</a>
<a name="ln199">  const char_u *p;</a>
<a name="ln200"> </a>
<a name="ln201">  for (p = line; *p &amp;&amp; (colnr_T)(p - line) &lt; col; p++) {</a>
<a name="ln202">    p = skip_string(p);</a>
<a name="ln203">  }</a>
<a name="ln204">  return !((colnr_T)(p - line) &lt;= col);</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">/*</a>
<a name="ln208"> * Functions for C-indenting.</a>
<a name="ln209"> * Most of this originally comes from Eric Fischer.</a>
<a name="ln210"> */</a>
<a name="ln211">/*</a>
<a name="ln212"> * Below &quot;XXX&quot; means that this function may unlock the current line.</a>
<a name="ln213"> */</a>
<a name="ln214"> </a>
<a name="ln215">/*</a>
<a name="ln216"> * Return true if the string &quot;line&quot; starts with a word from 'cinwords'.</a>
<a name="ln217"> */</a>
<a name="ln218">bool cin_is_cinword(const char_u *line)</a>
<a name="ln219">{</a>
<a name="ln220">  bool retval = false;</a>
<a name="ln221"> </a>
<a name="ln222">  size_t cinw_len = STRLEN(curbuf-&gt;b_p_cinw) + 1;</a>
<a name="ln223">  char_u *cinw_buf = xmalloc(cinw_len);</a>
<a name="ln224">  line = (char_u *)skipwhite((char *)line);</a>
<a name="ln225"> </a>
<a name="ln226">  for (char_u *cinw = curbuf-&gt;b_p_cinw; *cinw;) {</a>
<a name="ln227">    size_t len = copy_option_part(&amp;cinw, cinw_buf, cinw_len, &quot;,&quot;);</a>
<a name="ln228">    if (STRNCMP(line, cinw_buf, len) == 0</a>
<a name="ln229">        &amp;&amp; (!vim_iswordc(line[len]) || !vim_iswordc(line[len - 1]))) {</a>
<a name="ln230">      retval = true;</a>
<a name="ln231">      break;</a>
<a name="ln232">    }</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235">  xfree(cinw_buf);</a>
<a name="ln236"> </a>
<a name="ln237">  return retval;</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">/*</a>
<a name="ln241"> * Skip over white space and C comments within the line.</a>
<a name="ln242"> * Also skip over Perl/shell comments if desired.</a>
<a name="ln243"> */</a>
<a name="ln244">static const char_u *cin_skipcomment(const char_u *s)</a>
<a name="ln245">{</a>
<a name="ln246">  while (*s) {</a>
<a name="ln247">    const char_u *prev_s = s;</a>
<a name="ln248"> </a>
<a name="ln249">    s = (char_u *)skipwhite((char *)s);</a>
<a name="ln250"> </a>
<a name="ln251">    /* Perl/shell # comment comment continues until eol.  Require a space</a>
<a name="ln252">     * before # to avoid recognizing $#array. */</a>
<a name="ln253">    if (curbuf-&gt;b_ind_hash_comment != 0 &amp;&amp; s != prev_s &amp;&amp; *s == '#') {</a>
<a name="ln254">      s += STRLEN(s);</a>
<a name="ln255">      break;</a>
<a name="ln256">    }</a>
<a name="ln257">    if (*s != '/') {</a>
<a name="ln258">      break;</a>
<a name="ln259">    }</a>
<a name="ln260">    s++;</a>
<a name="ln261">    if (*s == '/') {            // slash-slash comment continues till eol</a>
<a name="ln262">      s += STRLEN(s);</a>
<a name="ln263">      break;</a>
<a name="ln264">    }</a>
<a name="ln265">    if (*s != '*') {</a>
<a name="ln266">      break;</a>
<a name="ln267">    }</a>
<a name="ln268">    for (++s; *s; s++) {        // skip slash-star comment</a>
<a name="ln269">      if (s[0] == '*' &amp;&amp; s[1] == '/') {</a>
<a name="ln270">        s += 2;</a>
<a name="ln271">        break;</a>
<a name="ln272">      }</a>
<a name="ln273">    }</a>
<a name="ln274">  }</a>
<a name="ln275">  return s;</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">/*</a>
<a name="ln279"> * Return TRUE if there is no code at *s.  White space and comments are</a>
<a name="ln280"> * not considered code.</a>
<a name="ln281"> */</a>
<a name="ln282">static int cin_nocode(const char_u *s)</a>
<a name="ln283">{</a>
<a name="ln284">  return *cin_skipcomment(s) == NUL;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">/*</a>
<a name="ln288"> * Check previous lines for a &quot;//&quot; line comment, skipping over blank lines.</a>
<a name="ln289"> */</a>
<a name="ln290">static pos_T *find_line_comment(void)  // XXX</a>
<a name="ln291">{</a>
<a name="ln292">  static pos_T pos;</a>
<a name="ln293">  char_u *line;</a>
<a name="ln294">  char_u *p;</a>
<a name="ln295"> </a>
<a name="ln296">  pos = curwin-&gt;w_cursor;</a>
<a name="ln297">  while (--pos.lnum &gt; 0) {</a>
<a name="ln298">    line = ml_get(pos.lnum);</a>
<a name="ln299">    p = (char_u *)skipwhite((char *)line);</a>
<a name="ln300">    if (cin_islinecomment(p)) {</a>
<a name="ln301">      pos.col = (int)(p - line);</a>
<a name="ln302">      return &amp;pos;</a>
<a name="ln303">    }</a>
<a name="ln304">    if (*p != NUL) {</a>
<a name="ln305">      break;</a>
<a name="ln306">    }</a>
<a name="ln307">  }</a>
<a name="ln308">  return NULL;</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">/// Checks if `text` starts with &quot;key:&quot;.</a>
<a name="ln312">static bool cin_has_js_key(const char_u *text)</a>
<a name="ln313">{</a>
<a name="ln314">  const char_u *s = (char_u *)skipwhite((char *)text);</a>
<a name="ln315"> </a>
<a name="ln316">  char_u quote = 0;</a>
<a name="ln317">  if (*s == '\'' || *s == '&quot;') {</a>
<a name="ln318">    // can be 'key': or &quot;key&quot;:</a>
<a name="ln319">    quote = *s;</a>
<a name="ln320">    ++s;</a>
<a name="ln321">  }</a>
<a name="ln322">  if (!vim_isIDc(*s)) {     // need at least one ID character</a>
<a name="ln323">    return false;</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  while (vim_isIDc(*s)) {</a>
<a name="ln327">    ++s;</a>
<a name="ln328">  }</a>
<a name="ln329">  if (*s &amp;&amp; *s == quote) {</a>
<a name="ln330">    ++s;</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  s = cin_skipcomment(s);</a>
<a name="ln334"> </a>
<a name="ln335">  // &quot;::&quot; is not a label, it's C++</a>
<a name="ln336">  return (*s == ':' &amp;&amp; s[1] != ':');</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">/// Checks if string matches &quot;label:&quot;; move to character after ':' if true.</a>
<a name="ln340">/// &quot;*s&quot; must point to the start of the label, if there is one.</a>
<a name="ln341">static bool cin_islabel_skip(const char_u **s)</a>
<a name="ln342">  FUNC_ATTR_NONNULL_ALL</a>
<a name="ln343">{</a>
<a name="ln344">  if (!vim_isIDc(**s)) {            // need at least one ID character</a>
<a name="ln345">    return false;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  while (vim_isIDc(**s)) {</a>
<a name="ln349">    (*s)++;</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  *s = cin_skipcomment(*s);</a>
<a name="ln353"> </a>
<a name="ln354">  // &quot;::&quot; is not a label, it's C++</a>
<a name="ln355">  return **s == ':' &amp;&amp; *++*s != ':';</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">// Recognize a label: &quot;label:&quot;.</a>
<a name="ln359">// Note: curwin-&gt;w_cursor must be where we are looking for the label.</a>
<a name="ln360">bool cin_islabel(void)  // XXX</a>
<a name="ln361">{</a>
<a name="ln362">  const char_u *s = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln363"> </a>
<a name="ln364">  // Exclude &quot;default&quot; from labels, since it should be indented</a>
<a name="ln365">  // like a switch label.  Same for C++ scope declarations.</a>
<a name="ln366">  if (cin_isdefault(s)) {</a>
<a name="ln367">    return false;</a>
<a name="ln368">  }</a>
<a name="ln369">  if (cin_isscopedecl(s)) {</a>
<a name="ln370">    return false;</a>
<a name="ln371">  }</a>
<a name="ln372">  if (!cin_islabel_skip(&amp;s)) {</a>
<a name="ln373">    return false;</a>
<a name="ln374">  }</a>
<a name="ln375"> </a>
<a name="ln376">  /*</a>
<a name="ln377">   * Only accept a label if the previous line is terminated or is a case</a>
<a name="ln378">   * label.</a>
<a name="ln379">   */</a>
<a name="ln380">  pos_T cursor_save;</a>
<a name="ln381">  pos_T *trypos;</a>
<a name="ln382">  const char_u *line;</a>
<a name="ln383"> </a>
<a name="ln384">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln385">  while (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln386">    --curwin-&gt;w_cursor.lnum;</a>
<a name="ln387"> </a>
<a name="ln388">    /*</a>
<a name="ln389">     * If we're in a comment or raw string now, skip to the start of</a>
<a name="ln390">     * it.</a>
<a name="ln391">     */</a>
<a name="ln392">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln393">    if ((trypos = ind_find_start_CORS(NULL)) != NULL) {   // XXX</a>
<a name="ln394">      curwin-&gt;w_cursor = *trypos;</a>
<a name="ln395">    }</a>
<a name="ln396"> </a>
<a name="ln397">    line = get_cursor_line_ptr();</a>
<a name="ln398">    if (cin_ispreproc(line)) {        // ignore #defines, #if, etc.</a>
<a name="ln399">      continue;</a>
<a name="ln400">    }</a>
<a name="ln401">    if (*(line = cin_skipcomment(line)) == NUL) {</a>
<a name="ln402">      continue;</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln406">    if (cin_isterminated(line, TRUE, FALSE)</a>
<a name="ln407">        || cin_isscopedecl(line)</a>
<a name="ln408">        || cin_iscase(line, true)</a>
<a name="ln409">        || (cin_islabel_skip(&amp;line) &amp;&amp; cin_nocode(line))) {</a>
<a name="ln410">      return true;</a>
<a name="ln411">    }</a>
<a name="ln412">    return false;</a>
<a name="ln413">  }</a>
<a name="ln414">  curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln415">  return true;  // label at start of file???</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">/*</a>
<a name="ln419"> * Recognize structure initialization and enumerations:</a>
<a name="ln420"> * &quot;[typedef] [static|public|protected|private] enum&quot;</a>
<a name="ln421"> * &quot;[typedef] [static|public|protected|private] = {&quot;</a>
<a name="ln422"> */</a>
<a name="ln423">static int cin_isinit(void)</a>
<a name="ln424">{</a>
<a name="ln425">  const char_u *s;</a>
<a name="ln426">  static char *skip[] = { &quot;static&quot;, &quot;public&quot;, &quot;protected&quot;, &quot;private&quot; };</a>
<a name="ln427"> </a>
<a name="ln428">  s = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln429"> </a>
<a name="ln430">  if (cin_starts_with(s, &quot;typedef&quot;)) {</a>
<a name="ln431">    s = cin_skipcomment(s + 7);</a>
<a name="ln432">  }</a>
<a name="ln433"> </a>
<a name="ln434">  for (;;) {</a>
<a name="ln435">    int i, l;</a>
<a name="ln436"> </a>
<a name="ln437">    for (i = 0; i &lt; (int)ARRAY_SIZE(skip); ++i) {</a>
<a name="ln438">      l = (int)strlen(skip[i]);</a>
<a name="ln439">      if (cin_starts_with(s, skip[i])) {</a>
<a name="ln440">        s = cin_skipcomment(s + l);</a>
<a name="ln441">        l = 0;</a>
<a name="ln442">        break;</a>
<a name="ln443">      }</a>
<a name="ln444">    }</a>
<a name="ln445">    if (l != 0) {</a>
<a name="ln446">      break;</a>
<a name="ln447">    }</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  if (cin_starts_with(s, &quot;enum&quot;)) {</a>
<a name="ln451">    return true;</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  if (cin_ends_in(s, (char_u *)&quot;=&quot;, (char_u *)&quot;{&quot;)) {</a>
<a name="ln455">    return true;</a>
<a name="ln456">  }</a>
<a name="ln457"> </a>
<a name="ln458">  return FALSE;</a>
<a name="ln459">}</a>
<a name="ln460"> </a>
<a name="ln461">/// Recognize a switch label: &quot;case .*:&quot; or &quot;default:&quot;.</a>
<a name="ln462">///</a>
<a name="ln463">/// @param strict  Allow relaxed check of case statement for JS</a>
<a name="ln464">bool cin_iscase(const char_u *s, bool strict)</a>
<a name="ln465">{</a>
<a name="ln466">  s = cin_skipcomment(s);</a>
<a name="ln467">  if (cin_starts_with(s, &quot;case&quot;)) {</a>
<a name="ln468">    for (s += 4; *s; ++s) {</a>
<a name="ln469">      s = cin_skipcomment(s);</a>
<a name="ln470">      if (*s == NUL) {</a>
<a name="ln471">        break;</a>
<a name="ln472">      }</a>
<a name="ln473">      if (*s == ':') {</a>
<a name="ln474">        if (s[1] == ':') {              // skip over &quot;::&quot; for C++</a>
<a name="ln475">          s++;</a>
<a name="ln476">        } else {</a>
<a name="ln477">          return true;</a>
<a name="ln478">        }</a>
<a name="ln479">      }</a>
<a name="ln480">      if (*s == '\'' &amp;&amp; s[1] &amp;&amp; s[2] == '\'') {</a>
<a name="ln481">        s += 2;                         // skip over ':'</a>
<a name="ln482">      } else if (*s == '/' &amp;&amp; (s[1] == '*' || s[1] == '/')) {</a>
<a name="ln483">        return false;                   // stop at comment</a>
<a name="ln484">      } else if (*s == '&quot;') {</a>
<a name="ln485">        // JS etc.</a>
<a name="ln486">        if (strict) {</a>
<a name="ln487">          return false;                 // stop at string</a>
<a name="ln488">        } else {</a>
<a name="ln489">          return true;</a>
<a name="ln490">        }</a>
<a name="ln491">      }</a>
<a name="ln492">    }</a>
<a name="ln493">    return false;</a>
<a name="ln494">  }</a>
<a name="ln495"> </a>
<a name="ln496">  if (cin_isdefault(s)) {</a>
<a name="ln497">    return true;</a>
<a name="ln498">  }</a>
<a name="ln499">  return false;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">/*</a>
<a name="ln503"> * Recognize a &quot;default&quot; switch label.</a>
<a name="ln504"> */</a>
<a name="ln505">static int cin_isdefault(const char_u *s)</a>
<a name="ln506">{</a>
<a name="ln507">  return STRNCMP(s, &quot;default&quot;, 7) == 0</a>
<a name="ln508">         &amp;&amp; *(s = cin_skipcomment(s + 7)) == ':'</a>
<a name="ln509">         &amp;&amp; s[1] != ':';</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/// Recognize a scope declaration label set in 'cinscopedecls'.</a>
<a name="ln513">bool cin_isscopedecl(const char_u *p)</a>
<a name="ln514">{</a>
<a name="ln515">  const char_u *s = cin_skipcomment(p);</a>
<a name="ln516"> </a>
<a name="ln517">  const size_t cinsd_len = STRLEN(curbuf-&gt;b_p_cinsd) + 1;</a>
<a name="ln518">  char_u *cinsd_buf = xmalloc(cinsd_len);</a>
<a name="ln519"> </a>
<a name="ln520">  bool found = false;</a>
<a name="ln521"> </a>
<a name="ln522">  for (char_u *cinsd = curbuf-&gt;b_p_cinsd; *cinsd;) {</a>
<a name="ln523">    const size_t len = copy_option_part(&amp;cinsd, cinsd_buf, cinsd_len, &quot;,&quot;);</a>
<a name="ln524">    if (STRNCMP(s, cinsd_buf, len) == 0) {</a>
<a name="ln525">      const char_u *skip = cin_skipcomment(s + len);</a>
<a name="ln526">      if (*skip == ':' &amp;&amp; skip[1] != ':') {</a>
<a name="ln527">        found = true;</a>
<a name="ln528">        break;</a>
<a name="ln529">      }</a>
<a name="ln530">    }</a>
<a name="ln531">  }</a>
<a name="ln532"> </a>
<a name="ln533">  xfree(cinsd_buf);</a>
<a name="ln534"> </a>
<a name="ln535">  return found;</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538">// Maximum number of lines to search back for a &quot;namespace&quot; line.</a>
<a name="ln539">#define FIND_NAMESPACE_LIM 20</a>
<a name="ln540"> </a>
<a name="ln541">// Recognize a &quot;namespace&quot; scope declaration.</a>
<a name="ln542">static bool cin_is_cpp_namespace(const char_u *s)</a>
<a name="ln543">{</a>
<a name="ln544">  const char_u *p;</a>
<a name="ln545">  bool has_name = false;</a>
<a name="ln546">  bool has_name_start = false;</a>
<a name="ln547"> </a>
<a name="ln548">  s = cin_skipcomment(s);</a>
<a name="ln549"> </a>
<a name="ln550">  if (STRNCMP(s, &quot;inline&quot;, 6) == 0 &amp;&amp; (s[6] == NUL || !vim_iswordc(s[6]))) {</a>
<a name="ln551">    s = cin_skipcomment((char_u *)skipwhite((char *)s + 6));</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  if (STRNCMP(s, &quot;namespace&quot;, 9) == 0 &amp;&amp; (s[9] == NUL || !vim_iswordc(s[9]))) {</a>
<a name="ln555">    p = cin_skipcomment((char_u *)skipwhite((char *)s + 9));</a>
<a name="ln556">    while (*p != NUL) {</a>
<a name="ln557">      if (ascii_iswhite(*p)) {</a>
<a name="ln558">        has_name = true;         // found end of a name</a>
<a name="ln559">        p = cin_skipcomment((char_u *)skipwhite((char *)p));</a>
<a name="ln560">      } else if (*p == '{') {</a>
<a name="ln561">        break;</a>
<a name="ln562">      } else if (vim_iswordc(*p)) {</a>
<a name="ln563">        has_name_start = true;</a>
<a name="ln564">        if (has_name) {</a>
<a name="ln565">          return false;           // word character after skipping past name</a>
<a name="ln566">        }</a>
<a name="ln567">        p++;</a>
<a name="ln568">      } else if (p[0] == ':' &amp;&amp; p[1] == ':' &amp;&amp; vim_iswordc(p[2])) {</a>
<a name="ln569">        if (!has_name_start || has_name) {</a>
<a name="ln570">          return false;</a>
<a name="ln571">        }</a>
<a name="ln572">        // C++ 17 nested namespace</a>
<a name="ln573">        p += 3;</a>
<a name="ln574">      } else {</a>
<a name="ln575">        return false;</a>
<a name="ln576">      }</a>
<a name="ln577">    }</a>
<a name="ln578">    return true;</a>
<a name="ln579">  }</a>
<a name="ln580">  return false;</a>
<a name="ln581">}</a>
<a name="ln582"> </a>
<a name="ln583">/*</a>
<a name="ln584"> * Return a pointer to the first non-empty non-comment character after a ':'.</a>
<a name="ln585"> * Return NULL if not found.</a>
<a name="ln586"> *        case 234:    a = b;</a>
<a name="ln587"> *                     ^</a>
<a name="ln588"> */</a>
<a name="ln589">static const char_u *after_label(const char_u *l)</a>
<a name="ln590">{</a>
<a name="ln591">  for (; *l; ++l) {</a>
<a name="ln592">    if (*l == ':') {</a>
<a name="ln593">      if (l[1] == ':') {            // skip over &quot;::&quot; for C++</a>
<a name="ln594">        l++;</a>
<a name="ln595">      } else if (!cin_iscase(l + 1, false)) {</a>
<a name="ln596">        break;</a>
<a name="ln597">      }</a>
<a name="ln598">    } else if (*l == '\'' &amp;&amp; l[1] &amp;&amp; l[2] == '\'') {</a>
<a name="ln599">      l += 2;                       // skip over 'x'</a>
<a name="ln600">    }</a>
<a name="ln601">  }</a>
<a name="ln602">  if (*l == NUL) {</a>
<a name="ln603">    return NULL;</a>
<a name="ln604">  }</a>
<a name="ln605">  l = cin_skipcomment(l + 1);</a>
<a name="ln606">  if (*l == NUL) {</a>
<a name="ln607">    return NULL;</a>
<a name="ln608">  }</a>
<a name="ln609">  return l;</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">/*</a>
<a name="ln613"> * Get indent of line &quot;lnum&quot;, skipping a label.</a>
<a name="ln614"> * Return 0 if there is nothing after the label.</a>
<a name="ln615"> */</a>
<a name="ln616">static int get_indent_nolabel(linenr_T lnum)  // XXX</a>
<a name="ln617">{</a>
<a name="ln618">  const char_u *l;</a>
<a name="ln619">  pos_T fp;</a>
<a name="ln620">  colnr_T col;</a>
<a name="ln621">  const char_u *p;</a>
<a name="ln622"> </a>
<a name="ln623">  l = ml_get(lnum);</a>
<a name="ln624">  p = after_label(l);</a>
<a name="ln625">  if (p == NULL) {</a>
<a name="ln626">    return 0;</a>
<a name="ln627">  }</a>
<a name="ln628"> </a>
<a name="ln629">  fp.col = (colnr_T)(p - l);</a>
<a name="ln630">  fp.lnum = lnum;</a>
<a name="ln631">  getvcol(curwin, &amp;fp, &amp;col, NULL, NULL);</a>
<a name="ln632">  return (int)col;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">/*</a>
<a name="ln636"> * Find indent for line &quot;lnum&quot;, ignoring any case or jump label.</a>
<a name="ln637"> * Also return a pointer to the text (after the label) in &quot;pp&quot;.</a>
<a name="ln638"> *   label:     if (asdf &amp;&amp; asdfasdf)</a>
<a name="ln639"> *              ^</a>
<a name="ln640"> */</a>
<a name="ln641">static int skip_label(linenr_T lnum, const char_u **pp)</a>
<a name="ln642">{</a>
<a name="ln643">  const char_u *l;</a>
<a name="ln644">  int amount;</a>
<a name="ln645">  pos_T cursor_save;</a>
<a name="ln646"> </a>
<a name="ln647">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln648">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln649">  l = get_cursor_line_ptr();</a>
<a name="ln650">  // XXX</a>
<a name="ln651">  if (cin_iscase(l, false) || cin_isscopedecl(l) || cin_islabel()) {</a>
<a name="ln652">    amount = get_indent_nolabel(lnum);</a>
<a name="ln653">    l = after_label(get_cursor_line_ptr());</a>
<a name="ln654">    if (l == NULL) {            // just in case</a>
<a name="ln655">      l = get_cursor_line_ptr();</a>
<a name="ln656">    }</a>
<a name="ln657">  } else {</a>
<a name="ln658">    amount = get_indent();</a>
<a name="ln659">    l = get_cursor_line_ptr();</a>
<a name="ln660">  }</a>
<a name="ln661">  *pp = l;</a>
<a name="ln662"> </a>
<a name="ln663">  curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln664">  return amount;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">/*</a>
<a name="ln668"> * Return the indent of the first variable name after a type in a declaration.</a>
<a name="ln669"> *  int     a,                  indent of &quot;a&quot;</a>
<a name="ln670"> *  static struct foo    b,     indent of &quot;b&quot;</a>
<a name="ln671"> *  enum bla    c,              indent of &quot;c&quot;</a>
<a name="ln672"> * Returns zero when it doesn't look like a declaration.</a>
<a name="ln673"> */</a>
<a name="ln674">static int cin_first_id_amount(void)</a>
<a name="ln675">{</a>
<a name="ln676">  char_u *line, *p, *s;</a>
<a name="ln677">  int len;</a>
<a name="ln678">  pos_T fp;</a>
<a name="ln679">  colnr_T col;</a>
<a name="ln680"> </a>
<a name="ln681">  line = get_cursor_line_ptr();</a>
<a name="ln682">  p = (char_u *)skipwhite((char *)line);</a>
<a name="ln683">  len = (int)(skiptowhite(p) - p);</a>
<a name="ln684">  if (len == 6 &amp;&amp; STRNCMP(p, &quot;static&quot;, 6) == 0) {</a>
<a name="ln685">    p = (char_u *)skipwhite((char *)p + 6);</a>
<a name="ln686">    len = (int)(skiptowhite(p) - p);</a>
<a name="ln687">  }</a>
<a name="ln688">  if (len == 6 &amp;&amp; STRNCMP(p, &quot;struct&quot;, 6) == 0) {</a>
<a name="ln689">    p = (char_u *)skipwhite((char *)p + 6);</a>
<a name="ln690">  } else if (len == 4 &amp;&amp; STRNCMP(p, &quot;enum&quot;, 4) == 0) {</a>
<a name="ln691">    p = (char_u *)skipwhite((char *)p + 4);</a>
<a name="ln692">  } else if ((len == 8 &amp;&amp; STRNCMP(p, &quot;unsigned&quot;, 8) == 0)</a>
<a name="ln693">             || (len == 6 &amp;&amp; STRNCMP(p, &quot;signed&quot;, 6) == 0)) {</a>
<a name="ln694">    s = (char_u *)skipwhite((char *)p + len);</a>
<a name="ln695">    if ((STRNCMP(s, &quot;int&quot;, 3) == 0 &amp;&amp; ascii_iswhite(s[3]))</a>
<a name="ln696">        || (STRNCMP(s, &quot;long&quot;, 4) == 0 &amp;&amp; ascii_iswhite(s[4]))</a>
<a name="ln697">        || (STRNCMP(s, &quot;short&quot;, 5) == 0 &amp;&amp; ascii_iswhite(s[5]))</a>
<a name="ln698">        || (STRNCMP(s, &quot;char&quot;, 4) == 0 &amp;&amp; ascii_iswhite(s[4]))) {</a>
<a name="ln699">      p = s;</a>
<a name="ln700">    }</a>
<a name="ln701">  }</a>
<a name="ln702">  for (len = 0; vim_isIDc(p[len]); len++) {}</a>
<a name="ln703">  if (len == 0 || !ascii_iswhite(p[len]) || cin_nocode(p)) {</a>
<a name="ln704">    return 0;</a>
<a name="ln705">  }</a>
<a name="ln706"> </a>
<a name="ln707">  p = (char_u *)skipwhite((char *)p + len);</a>
<a name="ln708">  fp.lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln709">  fp.col = (colnr_T)(p - line);</a>
<a name="ln710">  getvcol(curwin, &amp;fp, &amp;col, NULL, NULL);</a>
<a name="ln711">  return (int)col;</a>
<a name="ln712">}</a>
<a name="ln713"> </a>
<a name="ln714">/*</a>
<a name="ln715"> * Return the indent of the first non-blank after an equal sign.</a>
<a name="ln716"> *       char *foo = &quot;here&quot;;</a>
<a name="ln717"> * Return zero if no (useful) equal sign found.</a>
<a name="ln718"> * Return -1 if the line above &quot;lnum&quot; ends in a backslash.</a>
<a name="ln719"> *      foo = &quot;asdf\</a>
<a name="ln720"> *             asdf\</a>
<a name="ln721"> *             here&quot;;</a>
<a name="ln722"> */</a>
<a name="ln723">static int cin_get_equal_amount(linenr_T lnum)</a>
<a name="ln724">{</a>
<a name="ln725">  const char_u *line;</a>
<a name="ln726">  const char_u *s;</a>
<a name="ln727">  colnr_T col;</a>
<a name="ln728">  pos_T fp;</a>
<a name="ln729"> </a>
<a name="ln730">  if (lnum &gt; 1) {</a>
<a name="ln731">    line = ml_get(lnum - 1);</a>
<a name="ln732">    if (*line != NUL &amp;&amp; line[STRLEN(line) - 1] == '\\') {</a>
<a name="ln733">      return -1;</a>
<a name="ln734">    }</a>
<a name="ln735">  }</a>
<a name="ln736"> </a>
<a name="ln737">  line = s = ml_get(lnum);</a>
<a name="ln738">  while (*s != NUL &amp;&amp; vim_strchr(&quot;=;{}\&quot;'&quot;, *s) == NULL) {</a>
<a name="ln739">    if (cin_iscomment(s)) {     // ignore comments</a>
<a name="ln740">      s = cin_skipcomment(s);</a>
<a name="ln741">    } else {</a>
<a name="ln742">      s++;</a>
<a name="ln743">    }</a>
<a name="ln744">  }</a>
<a name="ln745">  if (*s != '=') {</a>
<a name="ln746">    return 0;</a>
<a name="ln747">  }</a>
<a name="ln748"> </a>
<a name="ln749">  s = (char_u *)skipwhite((char *)s + 1);</a>
<a name="ln750">  if (cin_nocode(s)) {</a>
<a name="ln751">    return 0;</a>
<a name="ln752">  }</a>
<a name="ln753"> </a>
<a name="ln754">  if (*s == '&quot;') {      // nice alignment for continued strings</a>
<a name="ln755">    s++;</a>
<a name="ln756">  }</a>
<a name="ln757"> </a>
<a name="ln758">  fp.lnum = lnum;</a>
<a name="ln759">  fp.col = (colnr_T)(s - line);</a>
<a name="ln760">  getvcol(curwin, &amp;fp, &amp;col, NULL, NULL);</a>
<a name="ln761">  return (int)col;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">/*</a>
<a name="ln765"> * Recognize a preprocessor statement: Any line that starts with '#'.</a>
<a name="ln766"> */</a>
<a name="ln767">static int cin_ispreproc(const char_u *s)</a>
<a name="ln768">{</a>
<a name="ln769">  if (*skipwhite((char *)s) == '#') {</a>
<a name="ln770">    return true;</a>
<a name="ln771">  }</a>
<a name="ln772">  return FALSE;</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">/// Return TRUE if line &quot;*pp&quot; at &quot;*lnump&quot; is a preprocessor statement or a</a>
<a name="ln776">/// continuation line of a preprocessor statement.  Decrease &quot;*lnump&quot; to the</a>
<a name="ln777">/// start and return the line in &quot;*pp&quot;.</a>
<a name="ln778">/// Put the amount of indent in &quot;*amount&quot;.</a>
<a name="ln779">static int cin_ispreproc_cont(const char_u **pp, linenr_T *lnump, int *amount)</a>
<a name="ln780">{</a>
<a name="ln781">  const char_u *line = *pp;</a>
<a name="ln782">  linenr_T lnum = *lnump;</a>
<a name="ln783">  int retval = false;</a>
<a name="ln784">  int candidate_amount = *amount;</a>
<a name="ln785"> </a>
<a name="ln786">  if (*line != NUL &amp;&amp; line[STRLEN(line) - 1] == '\\') {</a>
<a name="ln787">    candidate_amount = get_indent_lnum(lnum);</a>
<a name="ln788">  }</a>
<a name="ln789"> </a>
<a name="ln790">  for (;;) {</a>
<a name="ln791">    if (cin_ispreproc(line)) {</a>
<a name="ln792">      retval = TRUE;</a>
<a name="ln793">      *lnump = lnum;</a>
<a name="ln794">      break;</a>
<a name="ln795">    }</a>
<a name="ln796">    if (lnum == 1) {</a>
<a name="ln797">      break;</a>
<a name="ln798">    }</a>
<a name="ln799">    line = ml_get(--lnum);</a>
<a name="ln800">    if (*line == NUL || line[STRLEN(line) - 1] != '\\') {</a>
<a name="ln801">      break;</a>
<a name="ln802">    }</a>
<a name="ln803">  }</a>
<a name="ln804"> </a>
<a name="ln805">  if (lnum != *lnump) {</a>
<a name="ln806">    *pp = ml_get(*lnump);</a>
<a name="ln807">  }</a>
<a name="ln808">  if (retval) {</a>
<a name="ln809">    *amount = candidate_amount;</a>
<a name="ln810">  }</a>
<a name="ln811">  return retval;</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">/*</a>
<a name="ln815"> * Recognize the start of a C or C++ comment.</a>
<a name="ln816"> */</a>
<a name="ln817">static int cin_iscomment(const char_u *p)</a>
<a name="ln818">{</a>
<a name="ln819">  return p[0] == '/' &amp;&amp; (p[1] == '*' || p[1] == '/');</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/*</a>
<a name="ln823"> * Recognize the start of a &quot;//&quot; comment.</a>
<a name="ln824"> */</a>
<a name="ln825">static int cin_islinecomment(const char_u *p)</a>
<a name="ln826">{</a>
<a name="ln827">  return p[0] == '/' &amp;&amp; p[1] == '/';</a>
<a name="ln828">}</a>
<a name="ln829"> </a>
<a name="ln830">/// Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or</a>
<a name="ln831">/// '}'.</a>
<a name="ln832">/// Don't consider &quot;} else&quot; a terminated line.</a>
<a name="ln833">/// If a line begins with an &quot;else&quot;, only consider it terminated if no unmatched</a>
<a name="ln834">/// opening braces follow (handle &quot;else { foo();&quot; correctly).</a>
<a name="ln835">///</a>
<a name="ln836">/// @param incl_open   include '{' at the end as terminator</a>
<a name="ln837">/// @param incl_comma  recognize a trailing comma</a>
<a name="ln838">///</a>
<a name="ln839">/// @return  the character terminating the line (ending char's have precedence if</a>
<a name="ln840">///          both apply in order to determine initializations).</a>
<a name="ln841">static char_u cin_isterminated(const char_u *s, int incl_open, int incl_comma)</a>
<a name="ln842">{</a>
<a name="ln843">  char_u found_start = 0;</a>
<a name="ln844">  unsigned n_open = 0;</a>
<a name="ln845">  int is_else = FALSE;</a>
<a name="ln846"> </a>
<a name="ln847">  s = cin_skipcomment(s);</a>
<a name="ln848"> </a>
<a name="ln849">  if (*s == '{' || (*s == '}' &amp;&amp; !cin_iselse(s))) {</a>
<a name="ln850">    found_start = *s;</a>
<a name="ln851">  }</a>
<a name="ln852"> </a>
<a name="ln853">  if (!found_start) {</a>
<a name="ln854">    is_else = cin_iselse(s);</a>
<a name="ln855">  }</a>
<a name="ln856"> </a>
<a name="ln857">  while (*s) {</a>
<a name="ln858">    // skip over comments, &quot;&quot; strings and 'c'haracters</a>
<a name="ln859">    s = skip_string(cin_skipcomment(s));</a>
<a name="ln860">    if (*s == '}' &amp;&amp; n_open &gt; 0) {</a>
<a name="ln861">      n_open--;</a>
<a name="ln862">    }</a>
<a name="ln863">    if ((!is_else || n_open == 0)</a>
<a name="ln864">        &amp;&amp; (*s == ';' || *s == '}' || (incl_comma &amp;&amp; *s == ','))</a>
<a name="ln865">        &amp;&amp; cin_nocode(s + 1)) {</a>
<a name="ln866">      return *s;</a>
<a name="ln867">    } else if (*s == '{') {</a>
<a name="ln868">      if (incl_open &amp;&amp; cin_nocode(s + 1)) {</a>
<a name="ln869">        return *s;</a>
<a name="ln870">      } else {</a>
<a name="ln871">        n_open++;</a>
<a name="ln872">      }</a>
<a name="ln873">    }</a>
<a name="ln874"> </a>
<a name="ln875">    if (*s) {</a>
<a name="ln876">      s++;</a>
<a name="ln877">    }</a>
<a name="ln878">  }</a>
<a name="ln879">  return found_start;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">/// Recognizes the basic picture of a function declaration -- it needs to</a>
<a name="ln883">/// have an open paren somewhere and a close paren at the end of the line and</a>
<a name="ln884">/// no semicolons anywhere.</a>
<a name="ln885">/// When a line ends in a comma we continue looking in the next line.</a>
<a name="ln886">///</a>
<a name="ln887">/// @param[in]  sp  Points to a string with the line. When looking at other</a>
<a name="ln888">///                 lines it must be restored to the line. When it's NULL fetch</a>
<a name="ln889">///                 lines here.</a>
<a name="ln890">/// @param[in]  first_lnum Where to start looking.</a>
<a name="ln891">/// @param[in]  min_lnum The line before which we will not be looking.</a>
<a name="ln892">static int cin_isfuncdecl(const char_u **sp, linenr_T first_lnum, linenr_T min_lnum)</a>
<a name="ln893">{</a>
<a name="ln894">  const char_u *s;</a>
<a name="ln895">  linenr_T lnum = first_lnum;</a>
<a name="ln896">  linenr_T save_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln897">  int retval = false;</a>
<a name="ln898">  pos_T *trypos;</a>
<a name="ln899">  int just_started = true;</a>
<a name="ln900"> </a>
<a name="ln901">  if (sp == NULL) {</a>
<a name="ln902">    s = ml_get(lnum);</a>
<a name="ln903">  } else {</a>
<a name="ln904">    s = *sp;</a>
<a name="ln905">  }</a>
<a name="ln906"> </a>
<a name="ln907">  curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln908">  if (find_last_paren(s, '(', ')')</a>
<a name="ln909">      &amp;&amp; (trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln910">    lnum = trypos-&gt;lnum;</a>
<a name="ln911">    if (lnum &lt; min_lnum) {</a>
<a name="ln912">      curwin-&gt;w_cursor.lnum = save_lnum;</a>
<a name="ln913">      return false;</a>
<a name="ln914">    }</a>
<a name="ln915">    s = ml_get(lnum);</a>
<a name="ln916">  }</a>
<a name="ln917"> </a>
<a name="ln918">  curwin-&gt;w_cursor.lnum = save_lnum;</a>
<a name="ln919">  // Ignore line starting with #.</a>
<a name="ln920">  if (cin_ispreproc(s)) {</a>
<a name="ln921">    return false;</a>
<a name="ln922">  }</a>
<a name="ln923"> </a>
<a name="ln924">  while (*s &amp;&amp; *s != '(' &amp;&amp; *s != ';' &amp;&amp; *s != '\'' &amp;&amp; *s != '&quot;') {</a>
<a name="ln925">    // ignore comments</a>
<a name="ln926">    if (cin_iscomment(s)) {</a>
<a name="ln927">      s = cin_skipcomment(s);</a>
<a name="ln928">    } else if (*s == ':') {</a>
<a name="ln929">      if (*(s + 1) == ':') {</a>
<a name="ln930">        s += 2;</a>
<a name="ln931">      } else {</a>
<a name="ln932">        // To avoid a mistake in the following situation:</a>
<a name="ln933">        // A::A(int a, int b)</a>
<a name="ln934">        //     : a(0)  // &lt;--not a function decl</a>
<a name="ln935">        //     , b(0)</a>
<a name="ln936">        // {...</a>
<a name="ln937">        return false;</a>
<a name="ln938">      }</a>
<a name="ln939">    } else {</a>
<a name="ln940">      s++;</a>
<a name="ln941">    }</a>
<a name="ln942">  }</a>
<a name="ln943">  if (*s != '(') {</a>
<a name="ln944">    return false;  // ';', ' or &quot;  before any () or no '('</a>
<a name="ln945">  }</a>
<a name="ln946"> </a>
<a name="ln947">  while (*s &amp;&amp; *s != ';' &amp;&amp; *s != '\'' &amp;&amp; *s != '&quot;') {</a>
<a name="ln948">    if (*s == ')' &amp;&amp; cin_nocode(s + 1)) {</a>
<a name="ln949">      // ')' at the end: may have found a match</a>
<a name="ln950">      // Check for the previous line not to end in a backslash:</a>
<a name="ln951">      //       #if defined(x) &amp;&amp; {backslash}</a>
<a name="ln952">      //           defined(y)</a>
<a name="ln953">      lnum = first_lnum - 1;</a>
<a name="ln954">      s = ml_get(lnum);</a>
<a name="ln955">      if (*s == NUL || s[STRLEN(s) - 1] != '\\') {</a>
<a name="ln956">        retval = true;</a>
<a name="ln957">      }</a>
<a name="ln958">      goto done;</a>
<a name="ln959">    }</a>
<a name="ln960">    if ((*s == ',' &amp;&amp; cin_nocode(s + 1)) || s[1] == NUL || cin_nocode(s)) {</a>
<a name="ln961">      int comma = (*s == ',');</a>
<a name="ln962"> </a>
<a name="ln963">      /* ',' at the end: continue looking in the next line.</a>
<a name="ln964">       * At the end: check for ',' in the next line, for this style:</a>
<a name="ln965">       * func(arg1</a>
<a name="ln966">       *       , arg2) */</a>
<a name="ln967">      for (;;) {</a>
<a name="ln968">        if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln969">          break;</a>
<a name="ln970">        }</a>
<a name="ln971">        s = ml_get(++lnum);</a>
<a name="ln972">        if (!cin_ispreproc(s)) {</a>
<a name="ln973">          break;</a>
<a name="ln974">        }</a>
<a name="ln975">      }</a>
<a name="ln976">      if (lnum &gt;= curbuf-&gt;b_ml.ml_line_count) {</a>
<a name="ln977">        break;</a>
<a name="ln978">      }</a>
<a name="ln979">      // Require a comma at end of the line or a comma or ')' at the</a>
<a name="ln980">      // start of next line.</a>
<a name="ln981">      s = (char_u *)skipwhite((char *)s);</a>
<a name="ln982">      if (!just_started &amp;&amp; (!comma &amp;&amp; *s != ',' &amp;&amp; *s != ')')) {</a>
<a name="ln983">        break;</a>
<a name="ln984">      }</a>
<a name="ln985">      just_started = false;</a>
<a name="ln986">    } else if (cin_iscomment(s)) {      // ignore comments</a>
<a name="ln987">      s = cin_skipcomment(s);</a>
<a name="ln988">    } else {</a>
<a name="ln989">      s++;</a>
<a name="ln990">      just_started = false;</a>
<a name="ln991">    }</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">done:</a>
<a name="ln995">  if (lnum != first_lnum &amp;&amp; sp != NULL) {</a>
<a name="ln996">    *sp = ml_get(first_lnum);</a>
<a name="ln997">  }</a>
<a name="ln998"> </a>
<a name="ln999">  return retval;</a>
<a name="ln1000">}</a>
<a name="ln1001"> </a>
<a name="ln1002">static int cin_isif(const char_u *p)</a>
<a name="ln1003">{</a>
<a name="ln1004">  return STRNCMP(p, &quot;if&quot;, 2) == 0 &amp;&amp; !vim_isIDc(p[2]);</a>
<a name="ln1005">}</a>
<a name="ln1006"> </a>
<a name="ln1007">static int cin_iselse(const char_u *p)</a>
<a name="ln1008">{</a>
<a name="ln1009">  if (*p == '}') {          // accept &quot;} else&quot;</a>
<a name="ln1010">    p = cin_skipcomment(p + 1);</a>
<a name="ln1011">  }</a>
<a name="ln1012">  return STRNCMP(p, &quot;else&quot;, 4) == 0 &amp;&amp; !vim_isIDc(p[4]);</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">static int cin_isdo(const char_u *p)</a>
<a name="ln1016">{</a>
<a name="ln1017">  return STRNCMP(p, &quot;do&quot;, 2) == 0 &amp;&amp; !vim_isIDc(p[2]);</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">/*</a>
<a name="ln1021"> * Check if this is a &quot;while&quot; that should have a matching &quot;do&quot;.</a>
<a name="ln1022"> * We only accept a &quot;while (condition) ;&quot;, with only white space between the</a>
<a name="ln1023"> * ')' and ';'. The condition may be spread over several lines.</a>
<a name="ln1024"> */</a>
<a name="ln1025">static int cin_iswhileofdo(const char_u *p, linenr_T lnum)  // XXX</a>
<a name="ln1026">{</a>
<a name="ln1027">  pos_T cursor_save;</a>
<a name="ln1028">  pos_T *trypos;</a>
<a name="ln1029">  int retval = false;</a>
<a name="ln1030"> </a>
<a name="ln1031">  p = cin_skipcomment(p);</a>
<a name="ln1032">  if (*p == '}') {              // accept &quot;} while (cond);&quot;</a>
<a name="ln1033">    p = cin_skipcomment(p + 1);</a>
<a name="ln1034">  }</a>
<a name="ln1035">  if (cin_starts_with(p, &quot;while&quot;)) {</a>
<a name="ln1036">    cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1037">    curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln1038">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1039">    p = get_cursor_line_ptr();</a>
<a name="ln1040">    while (*p &amp;&amp; *p != 'w') {   // skip any '}', until the 'w' of the &quot;while&quot;</a>
<a name="ln1041">      p++;</a>
<a name="ln1042">      curwin-&gt;w_cursor.col++;</a>
<a name="ln1043">    }</a>
<a name="ln1044">    if ((trypos = findmatchlimit(NULL, 0, 0, curbuf-&gt;b_ind_maxparen)) != NULL</a>
<a name="ln1045">        &amp;&amp; *cin_skipcomment(ml_get_pos(trypos) + 1) == ';') {</a>
<a name="ln1046">      retval = true;</a>
<a name="ln1047">    }</a>
<a name="ln1048">    curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1049">  }</a>
<a name="ln1050">  return retval;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">/*</a>
<a name="ln1054"> * Check whether in &quot;p&quot; there is an &quot;if&quot;, &quot;for&quot; or &quot;while&quot; before &quot;*poffset&quot;.</a>
<a name="ln1055"> * Return 0 if there is none.</a>
<a name="ln1056"> * Otherwise return !0 and update &quot;*poffset&quot; to point to the place where the</a>
<a name="ln1057"> * string was found.</a>
<a name="ln1058"> */</a>
<a name="ln1059">static int cin_is_if_for_while_before_offset(const char_u *line, int *poffset)</a>
<a name="ln1060">{</a>
<a name="ln1061">  int offset = *poffset;</a>
<a name="ln1062"> </a>
<a name="ln1063">  if (offset-- &lt; 2) {</a>
<a name="ln1064">    return 0;</a>
<a name="ln1065">  }</a>
<a name="ln1066">  while (offset &gt; 2 &amp;&amp; ascii_iswhite(line[offset])) {</a>
<a name="ln1067">    offset--;</a>
<a name="ln1068">  }</a>
<a name="ln1069"> </a>
<a name="ln1070">  offset -= 1;</a>
<a name="ln1071">  if (!STRNCMP(line + offset, &quot;if&quot;, 2)) {</a>
<a name="ln1072">    goto probablyFound;</a>
<a name="ln1073">  }</a>
<a name="ln1074"> </a>
<a name="ln1075">  if (offset &gt;= 1) {</a>
<a name="ln1076">    offset -= 1;</a>
<a name="ln1077">    if (!STRNCMP(line + offset, &quot;for&quot;, 3)) {</a>
<a name="ln1078">      goto probablyFound;</a>
<a name="ln1079">    }</a>
<a name="ln1080"> </a>
<a name="ln1081">    if (offset &gt;= 2) {</a>
<a name="ln1082">      offset -= 2;</a>
<a name="ln1083">      if (!STRNCMP(line + offset, &quot;while&quot;, 5)) {</a>
<a name="ln1084">        goto probablyFound;</a>
<a name="ln1085">      }</a>
<a name="ln1086">    }</a>
<a name="ln1087">  }</a>
<a name="ln1088">  return 0;</a>
<a name="ln1089"> </a>
<a name="ln1090">probablyFound:</a>
<a name="ln1091">  if (!offset || !vim_isIDc(line[offset - 1])) {</a>
<a name="ln1092">    *poffset = offset;</a>
<a name="ln1093">    return 1;</a>
<a name="ln1094">  }</a>
<a name="ln1095">  return 0;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">/*</a>
<a name="ln1099"> * Return TRUE if we are at the end of a do-while.</a>
<a name="ln1100"> *    do</a>
<a name="ln1101"> *       nothing;</a>
<a name="ln1102"> *    while (foo</a>
<a name="ln1103"> *             &amp;&amp; bar);  &lt;-- here</a>
<a name="ln1104"> * Adjust the cursor to the line with &quot;while&quot;.</a>
<a name="ln1105"> */</a>
<a name="ln1106">static int cin_iswhileofdo_end(int terminated)</a>
<a name="ln1107">{</a>
<a name="ln1108">  const char_u *line;</a>
<a name="ln1109">  const char_u *p;</a>
<a name="ln1110">  const char_u *s;</a>
<a name="ln1111">  pos_T *trypos;</a>
<a name="ln1112">  int i;</a>
<a name="ln1113"> </a>
<a name="ln1114">  if (terminated != ';') {      // there must be a ';' at the end</a>
<a name="ln1115">    return false;</a>
<a name="ln1116">  }</a>
<a name="ln1117"> </a>
<a name="ln1118">  p = line = get_cursor_line_ptr();</a>
<a name="ln1119">  while (*p != NUL) {</a>
<a name="ln1120">    p = cin_skipcomment(p);</a>
<a name="ln1121">    if (*p == ')') {</a>
<a name="ln1122">      s = (char_u *)skipwhite((char *)p + 1);</a>
<a name="ln1123">      if (*s == ';' &amp;&amp; cin_nocode(s + 1)) {</a>
<a name="ln1124">        /* Found &quot;);&quot; at end of the line, now check there is &quot;while&quot;</a>
<a name="ln1125">         * before the matching '('.  XXX */</a>
<a name="ln1126">        i = (int)(p - line);</a>
<a name="ln1127">        curwin-&gt;w_cursor.col = i;</a>
<a name="ln1128">        trypos = find_match_paren(curbuf-&gt;b_ind_maxparen);</a>
<a name="ln1129">        if (trypos != NULL) {</a>
<a name="ln1130">          s = cin_skipcomment(ml_get(trypos-&gt;lnum));</a>
<a name="ln1131">          if (*s == '}') {                      // accept &quot;} while (cond);&quot;</a>
<a name="ln1132">            s = cin_skipcomment(s + 1);</a>
<a name="ln1133">          }</a>
<a name="ln1134">          if (cin_starts_with(s, &quot;while&quot;)) {</a>
<a name="ln1135">            curwin-&gt;w_cursor.lnum = trypos-&gt;lnum;</a>
<a name="ln1136">            return TRUE;</a>
<a name="ln1137">          }</a>
<a name="ln1138">        }</a>
<a name="ln1139"> </a>
<a name="ln1140">        // Searching may have made &quot;line&quot; invalid, get it again.</a>
<a name="ln1141">        line = get_cursor_line_ptr();</a>
<a name="ln1142">        p = line + i;</a>
<a name="ln1143">      }</a>
<a name="ln1144">    }</a>
<a name="ln1145">    if (*p != NUL) {</a>
<a name="ln1146">      p++;</a>
<a name="ln1147">    }</a>
<a name="ln1148">  }</a>
<a name="ln1149">  return FALSE;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">static int cin_isbreak(const char_u *p)</a>
<a name="ln1153">{</a>
<a name="ln1154">  return STRNCMP(p, &quot;break&quot;, 5) == 0 &amp;&amp; !vim_isIDc(p[5]);</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">/*</a>
<a name="ln1158"> * Find the position of a C++ base-class declaration or</a>
<a name="ln1159"> * constructor-initialization. eg:</a>
<a name="ln1160"> *</a>
<a name="ln1161"> * class MyClass :</a>
<a name="ln1162"> *      baseClass               &lt;-- here</a>
<a name="ln1163"> * class MyClass : public baseClass,</a>
<a name="ln1164"> *      anotherBaseClass        &lt;-- here (should probably lineup ??)</a>
<a name="ln1165"> * MyClass::MyClass(...) :</a>
<a name="ln1166"> *      baseClass(...)          &lt;-- here (constructor-initialization)</a>
<a name="ln1167"> *</a>
<a name="ln1168"> * This is a lot of guessing.  Watch out for &quot;cond ? func() : foo&quot;.</a>
<a name="ln1169"> */</a>
<a name="ln1170">static int cin_is_cpp_baseclass(cpp_baseclass_cache_T *cached)</a>
<a name="ln1171">{</a>
<a name="ln1172">  lpos_T *pos = &amp;cached-&gt;lpos;  // find position</a>
<a name="ln1173">  const char_u *s;</a>
<a name="ln1174">  int class_or_struct, lookfor_ctor_init, cpp_base_class;</a>
<a name="ln1175">  linenr_T lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln1176">  const char_u *line = get_cursor_line_ptr();</a>
<a name="ln1177"> </a>
<a name="ln1178">  if (pos-&gt;lnum &lt;= lnum) {</a>
<a name="ln1179">    return cached-&gt;found;  // Use the cached result</a>
<a name="ln1180">  }</a>
<a name="ln1181"> </a>
<a name="ln1182">  pos-&gt;col = 0;</a>
<a name="ln1183"> </a>
<a name="ln1184">  s = (char_u *)skipwhite((char *)line);</a>
<a name="ln1185">  if (*s == '#') {              // skip #define FOO x ? (x) : x</a>
<a name="ln1186">    return false;</a>
<a name="ln1187">  }</a>
<a name="ln1188">  s = cin_skipcomment(s);</a>
<a name="ln1189">  if (*s == NUL) {</a>
<a name="ln1190">    return false;</a>
<a name="ln1191">  }</a>
<a name="ln1192"> </a>
<a name="ln1193">  cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;</a>
<a name="ln1194"> </a>
<a name="ln1195">  /* Search for a line starting with '#', empty, ending in ';' or containing</a>
<a name="ln1196">   * '{' or '}' and start below it.  This handles the following situations:</a>
<a name="ln1197">   *    a = cond ?</a>
<a name="ln1198">   *          func() :</a>
<a name="ln1199">   *               asdf;</a>
<a name="ln1200">   *    func::foo()</a>
<a name="ln1201">   *          : something</a>
<a name="ln1202">   *    {}</a>
<a name="ln1203">   *    Foo::Foo (int one, int two)</a>
<a name="ln1204">   *            : something(4),</a>
<a name="ln1205">   *            somethingelse(3)</a>
<a name="ln1206">   *    {}</a>
<a name="ln1207">   */</a>
<a name="ln1208">  while (lnum &gt; 1) {</a>
<a name="ln1209">    line = ml_get(lnum - 1);</a>
<a name="ln1210">    s = (char_u *)skipwhite((char *)line);</a>
<a name="ln1211">    if (*s == '#' || *s == NUL) {</a>
<a name="ln1212">      break;</a>
<a name="ln1213">    }</a>
<a name="ln1214">    while (*s != NUL) {</a>
<a name="ln1215">      s = cin_skipcomment(s);</a>
<a name="ln1216">      if (*s == '{' || *s == '}'</a>
<a name="ln1217">          || (*s == ';' &amp;&amp; cin_nocode(s + 1))) {</a>
<a name="ln1218">        break;</a>
<a name="ln1219">      }</a>
<a name="ln1220">      if (*s != NUL) {</a>
<a name="ln1221">        s++;</a>
<a name="ln1222">      }</a>
<a name="ln1223">    }</a>
<a name="ln1224">    if (*s != NUL) {</a>
<a name="ln1225">      break;</a>
<a name="ln1226">    }</a>
<a name="ln1227">    lnum--;</a>
<a name="ln1228">  }</a>
<a name="ln1229"> </a>
<a name="ln1230">  pos-&gt;lnum = lnum;</a>
<a name="ln1231">  line = ml_get(lnum);</a>
<a name="ln1232">  s = line;</a>
<a name="ln1233">  for (;;) {</a>
<a name="ln1234">    if (*s == NUL) {</a>
<a name="ln1235">      if (lnum == curwin-&gt;w_cursor.lnum) {</a>
<a name="ln1236">        break;</a>
<a name="ln1237">      }</a>
<a name="ln1238">      // Continue in the cursor line.</a>
<a name="ln1239">      line = ml_get(++lnum);</a>
<a name="ln1240">      s = line;</a>
<a name="ln1241">    }</a>
<a name="ln1242">    if (s == line) {</a>
<a name="ln1243">      // don't recognize &quot;case (foo):&quot; as a baseclass */</a>
<a name="ln1244">      if (cin_iscase(s, false)) {</a>
<a name="ln1245">        break;</a>
<a name="ln1246">      }</a>
<a name="ln1247">      s = cin_skipcomment(line);</a>
<a name="ln1248">      if (*s == NUL) {</a>
<a name="ln1249">        continue;</a>
<a name="ln1250">      }</a>
<a name="ln1251">    }</a>
<a name="ln1252"> </a>
<a name="ln1253">    if (s[0] == '&quot;' || (s[0] == 'R' &amp;&amp; s[1] == '&quot;')) {</a>
<a name="ln1254">      s = skip_string(s) + 1;</a>
<a name="ln1255">    } else if (s[0] == ':') {</a>
<a name="ln1256">      if (s[1] == ':') {</a>
<a name="ln1257">        /* skip double colon. It can't be a constructor</a>
<a name="ln1258">         * initialization any more */</a>
<a name="ln1259">        lookfor_ctor_init = FALSE;</a>
<a name="ln1260">        s = cin_skipcomment(s + 2);</a>
<a name="ln1261">      } else if (lookfor_ctor_init || class_or_struct) {</a>
<a name="ln1262">        /* we have something found, that looks like the start of</a>
<a name="ln1263">         * cpp-base-class-declaration or constructor-initialization */</a>
<a name="ln1264">        cpp_base_class = true;</a>
<a name="ln1265">        lookfor_ctor_init = class_or_struct = false;</a>
<a name="ln1266">        pos-&gt;col = 0;</a>
<a name="ln1267">        s = cin_skipcomment(s + 1);</a>
<a name="ln1268">      } else {</a>
<a name="ln1269">        s = cin_skipcomment(s + 1);</a>
<a name="ln1270">      }</a>
<a name="ln1271">    } else if ((STRNCMP(s, &quot;class&quot;, 5) == 0 &amp;&amp; !vim_isIDc(s[5]))</a>
<a name="ln1272">               || (STRNCMP(s, &quot;struct&quot;, 6) == 0 &amp;&amp; !vim_isIDc(s[6]))) {</a>
<a name="ln1273">      class_or_struct = TRUE;</a>
<a name="ln1274">      lookfor_ctor_init = FALSE;</a>
<a name="ln1275"> </a>
<a name="ln1276">      if (*s == 'c') {</a>
<a name="ln1277">        s = cin_skipcomment(s + 5);</a>
<a name="ln1278">      } else {</a>
<a name="ln1279">        s = cin_skipcomment(s + 6);</a>
<a name="ln1280">      }</a>
<a name="ln1281">    } else {</a>
<a name="ln1282">      if (s[0] == '{' || s[0] == '}' || s[0] == ';') {</a>
<a name="ln1283">        cpp_base_class = lookfor_ctor_init = class_or_struct = FALSE;</a>
<a name="ln1284">      } else if (s[0] == ')') {</a>
<a name="ln1285">        /* Constructor-initialization is assumed if we come across</a>
<a name="ln1286">         * something like &quot;):&quot; */</a>
<a name="ln1287">        class_or_struct = FALSE;</a>
<a name="ln1288">        lookfor_ctor_init = TRUE;</a>
<a name="ln1289">      } else if (s[0] == '?') {</a>
<a name="ln1290">        // Avoid seeing '() :' after '?' as constructor init.</a>
<a name="ln1291">        return false;</a>
<a name="ln1292">      } else if (!vim_isIDc(s[0])) {</a>
<a name="ln1293">        // if it is not an identifier, we are wrong</a>
<a name="ln1294">        class_or_struct = false;</a>
<a name="ln1295">        lookfor_ctor_init = false;</a>
<a name="ln1296">      } else if (pos-&gt;col == 0) {</a>
<a name="ln1297">        // it can't be a constructor-initialization any more</a>
<a name="ln1298">        lookfor_ctor_init = false;</a>
<a name="ln1299"> </a>
<a name="ln1300">        // the first statement starts here: lineup with this one...</a>
<a name="ln1301">        if (cpp_base_class) {</a>
<a name="ln1302">          pos-&gt;col = (colnr_T)(s - line);</a>
<a name="ln1303">        }</a>
<a name="ln1304">      }</a>
<a name="ln1305"> </a>
<a name="ln1306">      // When the line ends in a comma don't align with it.</a>
<a name="ln1307">      if (lnum == curwin-&gt;w_cursor.lnum &amp;&amp; *s == ',' &amp;&amp; cin_nocode(s + 1)) {</a>
<a name="ln1308">        pos-&gt;col = 0;</a>
<a name="ln1309">      }</a>
<a name="ln1310"> </a>
<a name="ln1311">      s = cin_skipcomment(s + 1);</a>
<a name="ln1312">    }</a>
<a name="ln1313">  }</a>
<a name="ln1314"> </a>
<a name="ln1315">  cached-&gt;found = cpp_base_class;</a>
<a name="ln1316">  if (cpp_base_class) {</a>
<a name="ln1317">    pos-&gt;lnum = lnum;</a>
<a name="ln1318">  }</a>
<a name="ln1319">  return cpp_base_class;</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">static int get_baseclass_amount(int col)</a>
<a name="ln1323">{</a>
<a name="ln1324">  int amount;</a>
<a name="ln1325">  colnr_T vcol;</a>
<a name="ln1326">  pos_T *trypos;</a>
<a name="ln1327"> </a>
<a name="ln1328">  if (col == 0) {</a>
<a name="ln1329">    amount = get_indent();</a>
<a name="ln1330">    if (find_last_paren(get_cursor_line_ptr(), '(', ')')</a>
<a name="ln1331">        &amp;&amp; (trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln1332">      amount = get_indent_lnum(trypos-&gt;lnum);       // XXX</a>
<a name="ln1333">    }</a>
<a name="ln1334">    if (!cin_ends_in(get_cursor_line_ptr(), (char_u *)&quot;,&quot;, NULL)) {</a>
<a name="ln1335">      amount += curbuf-&gt;b_ind_cpp_baseclass;</a>
<a name="ln1336">    }</a>
<a name="ln1337">  } else {</a>
<a name="ln1338">    curwin-&gt;w_cursor.col = col;</a>
<a name="ln1339">    getvcol(curwin, &amp;curwin-&gt;w_cursor, &amp;vcol, NULL, NULL);</a>
<a name="ln1340">    amount = (int)vcol;</a>
<a name="ln1341">  }</a>
<a name="ln1342">  if (amount &lt; curbuf-&gt;b_ind_cpp_baseclass) {</a>
<a name="ln1343">    amount = curbuf-&gt;b_ind_cpp_baseclass;</a>
<a name="ln1344">  }</a>
<a name="ln1345">  return amount;</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">/*</a>
<a name="ln1349"> * Return TRUE if string &quot;s&quot; ends with the string &quot;find&quot;, possibly followed by</a>
<a name="ln1350"> * white space and comments.  Skip strings and comments.</a>
<a name="ln1351"> * Ignore &quot;ignore&quot; after &quot;find&quot; if it's not NULL.</a>
<a name="ln1352"> */</a>
<a name="ln1353">static int cin_ends_in(const char_u *s, const char_u *find, const char_u *ignore)</a>
<a name="ln1354">{</a>
<a name="ln1355">  const char_u *p = s;</a>
<a name="ln1356">  const char_u *r;</a>
<a name="ln1357">  int len = (int)STRLEN(find);</a>
<a name="ln1358"> </a>
<a name="ln1359">  while (*p != NUL) {</a>
<a name="ln1360">    p = cin_skipcomment(p);</a>
<a name="ln1361">    if (STRNCMP(p, find, len) == 0) {</a>
<a name="ln1362">      r = (char_u *)skipwhite((char *)p + len);</a>
<a name="ln1363">      if (ignore != NULL &amp;&amp; STRNCMP(r, ignore, STRLEN(ignore)) == 0) {</a>
<a name="ln1364">        r = (char_u *)skipwhite((char *)r + STRLEN(ignore));</a>
<a name="ln1365">      }</a>
<a name="ln1366">      if (cin_nocode(r)) {</a>
<a name="ln1367">        return true;</a>
<a name="ln1368">      }</a>
<a name="ln1369">    }</a>
<a name="ln1370">    if (*p != NUL) {</a>
<a name="ln1371">      p++;</a>
<a name="ln1372">    }</a>
<a name="ln1373">  }</a>
<a name="ln1374">  return FALSE;</a>
<a name="ln1375">}</a>
<a name="ln1376"> </a>
<a name="ln1377">/*</a>
<a name="ln1378"> * Return TRUE when &quot;s&quot; starts with &quot;word&quot; and then a non-ID character.</a>
<a name="ln1379"> */</a>
<a name="ln1380">static int cin_starts_with(const char_u *s, const char *word)</a>
<a name="ln1381">{</a>
<a name="ln1382">  int l = (int)STRLEN(word);</a>
<a name="ln1383"> </a>
<a name="ln1384">  return STRNCMP(s, word, l) == 0 &amp;&amp; !vim_isIDc(s[l]);</a>
<a name="ln1385">}</a>
<a name="ln1386"> </a>
<a name="ln1387">/// Recognize a `extern &quot;C&quot;` or `extern &quot;C++&quot;` linkage specifications.</a>
<a name="ln1388">static int cin_is_cpp_extern_c(const char_u *s)</a>
<a name="ln1389">{</a>
<a name="ln1390">  const char_u *p;</a>
<a name="ln1391">  int has_string_literal = false;</a>
<a name="ln1392"> </a>
<a name="ln1393">  s = cin_skipcomment(s);</a>
<a name="ln1394">  if (STRNCMP(s, &quot;extern&quot;, 6) == 0 &amp;&amp; (s[6] == NUL || !vim_iswordc(s[6]))) {</a>
<a name="ln1395">    p = cin_skipcomment((char_u *)skipwhite((char *)s + 6));</a>
<a name="ln1396">    while (*p != NUL) {</a>
<a name="ln1397">      if (ascii_iswhite(*p)) {</a>
<a name="ln1398">        p = cin_skipcomment((char_u *)skipwhite((char *)p));</a>
<a name="ln1399">      } else if (*p == '{') {</a>
<a name="ln1400">        break;</a>
<a name="ln1401">      } else if (p[0] == '&quot;' &amp;&amp; p[1] == 'C' &amp;&amp; p[2] == '&quot;') {</a>
<a name="ln1402">        if (has_string_literal) {</a>
<a name="ln1403">          return false;</a>
<a name="ln1404">        }</a>
<a name="ln1405">        has_string_literal = true;</a>
<a name="ln1406">        p += 3;</a>
<a name="ln1407">      } else if (p[0] == '&quot;' &amp;&amp; p[1] == 'C' &amp;&amp; p[2] == '+' &amp;&amp; p[3] == '+'</a>
<a name="ln1408">                 &amp;&amp; p[4] == '&quot;') {</a>
<a name="ln1409">        if (has_string_literal) {</a>
<a name="ln1410">          return false;</a>
<a name="ln1411">        }</a>
<a name="ln1412">        has_string_literal = true;</a>
<a name="ln1413">        p += 5;</a>
<a name="ln1414">      } else {</a>
<a name="ln1415">        return false;</a>
<a name="ln1416">      }</a>
<a name="ln1417">    }</a>
<a name="ln1418">    return has_string_literal ? true : false;</a>
<a name="ln1419">  }</a>
<a name="ln1420">  return false;</a>
<a name="ln1421">}</a>
<a name="ln1422"> </a>
<a name="ln1423">/*</a>
<a name="ln1424"> * Skip strings, chars and comments until at or past &quot;trypos&quot;.</a>
<a name="ln1425"> * Return the column found.</a>
<a name="ln1426"> */</a>
<a name="ln1427">static int cin_skip2pos(pos_T *trypos)</a>
<a name="ln1428">{</a>
<a name="ln1429">  const char_u *line;</a>
<a name="ln1430">  const char_u *p;</a>
<a name="ln1431">  const char_u *new_p;</a>
<a name="ln1432"> </a>
<a name="ln1433">  p = line = ml_get(trypos-&gt;lnum);</a>
<a name="ln1434">  while (*p &amp;&amp; (colnr_T)(p - line) &lt; trypos-&gt;col) {</a>
<a name="ln1435">    if (cin_iscomment(p)) {</a>
<a name="ln1436">      p = cin_skipcomment(p);</a>
<a name="ln1437">    } else {</a>
<a name="ln1438">      new_p = skip_string(p);</a>
<a name="ln1439">      if (new_p == p) {</a>
<a name="ln1440">        p++;</a>
<a name="ln1441">      } else {</a>
<a name="ln1442">        p = new_p;</a>
<a name="ln1443">      }</a>
<a name="ln1444">    }</a>
<a name="ln1445">  }</a>
<a name="ln1446">  return (int)(p - line);</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">/*</a>
<a name="ln1450"> * Find the '{' at the start of the block we are in.</a>
<a name="ln1451"> * Return NULL if no match found.</a>
<a name="ln1452"> * Ignore a '{' that is in a comment, makes indenting the next three lines</a>
<a name="ln1453"> * work. */</a>
<a name="ln1454">// foo()</a>
<a name="ln1455">// {</a>
<a name="ln1456">// }</a>
<a name="ln1457"> </a>
<a name="ln1458">static pos_T *find_start_brace(void)  // XXX</a>
<a name="ln1459">{</a>
<a name="ln1460">  pos_T cursor_save;</a>
<a name="ln1461">  pos_T *trypos;</a>
<a name="ln1462">  pos_T *pos;</a>
<a name="ln1463">  static pos_T pos_copy;</a>
<a name="ln1464"> </a>
<a name="ln1465">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1466">  while ((trypos = findmatchlimit(NULL, '{', FM_BLOCKSTOP, 0)) != NULL) {</a>
<a name="ln1467">    pos_copy = *trypos;         // copy pos_T, next findmatch will change it</a>
<a name="ln1468">    trypos = &amp;pos_copy;</a>
<a name="ln1469">    curwin-&gt;w_cursor = *trypos;</a>
<a name="ln1470">    pos = NULL;</a>
<a name="ln1471">    // ignore the { if it's in a // or / *  * / comment</a>
<a name="ln1472">    if ((colnr_T)cin_skip2pos(trypos) == trypos-&gt;col</a>
<a name="ln1473">        &amp;&amp; (pos = ind_find_start_CORS(NULL)) == NULL) {   // XXX</a>
<a name="ln1474">      break;</a>
<a name="ln1475">    }</a>
<a name="ln1476">    if (pos != NULL) {</a>
<a name="ln1477">      curwin-&gt;w_cursor = *pos;</a>
<a name="ln1478">    }</a>
<a name="ln1479">  }</a>
<a name="ln1480">  curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1481">  return trypos;</a>
<a name="ln1482">}</a>
<a name="ln1483"> </a>
<a name="ln1484">/// Find the matching '(', ignoring it if it is in a comment.</a>
<a name="ln1485">/// @returns NULL or the found match.</a>
<a name="ln1486">static pos_T *find_match_paren(int ind_maxparen)</a>
<a name="ln1487">{</a>
<a name="ln1488">  return find_match_char('(', ind_maxparen);</a>
<a name="ln1489">}</a>
<a name="ln1490"> </a>
<a name="ln1491">static pos_T *find_match_char(char_u c, int ind_maxparen)</a>
<a name="ln1492">{</a>
<a name="ln1493">  pos_T cursor_save;</a>
<a name="ln1494">  pos_T *trypos;</a>
<a name="ln1495">  static pos_T pos_copy;</a>
<a name="ln1496">  int ind_maxp_wk;</a>
<a name="ln1497"> </a>
<a name="ln1498">  cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln1499">  ind_maxp_wk = ind_maxparen;</a>
<a name="ln1500">retry:</a>
<a name="ln1501">  if ((trypos = findmatchlimit(NULL, c, 0, ind_maxp_wk)) != NULL) {</a>
<a name="ln1502">    // check if the ( is in a // comment</a>
<a name="ln1503">    if ((colnr_T)cin_skip2pos(trypos) &gt; trypos-&gt;col) {</a>
<a name="ln1504">      ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos-&gt;lnum);</a>
<a name="ln1505">      if (ind_maxp_wk &gt; 0) {</a>
<a name="ln1506">        curwin-&gt;w_cursor = *trypos;</a>
<a name="ln1507">        curwin-&gt;w_cursor.col = 0;  // XXX</a>
<a name="ln1508">        goto retry;</a>
<a name="ln1509">      }</a>
<a name="ln1510">      trypos = NULL;</a>
<a name="ln1511">    } else {</a>
<a name="ln1512">      pos_T *trypos_wk;</a>
<a name="ln1513"> </a>
<a name="ln1514">      pos_copy = *trypos;           // copy trypos, findmatch will change it</a>
<a name="ln1515">      trypos = &amp;pos_copy;</a>
<a name="ln1516">      curwin-&gt;w_cursor = *trypos;</a>
<a name="ln1517">      if ((trypos_wk = ind_find_start_CORS(NULL)) != NULL) {  // XXX</a>
<a name="ln1518">        ind_maxp_wk = ind_maxparen - (int)(cursor_save.lnum - trypos_wk-&gt;lnum);</a>
<a name="ln1519">        if (ind_maxp_wk &gt; 0) {</a>
<a name="ln1520">          curwin-&gt;w_cursor = *trypos_wk;</a>
<a name="ln1521">          goto retry;</a>
<a name="ln1522">        }</a>
<a name="ln1523">        trypos = NULL;</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526">  }</a>
<a name="ln1527">  curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln1528">  return trypos;</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">/// Find the matching '(', ignoring it if it is in a comment or before an</a>
<a name="ln1532">/// unmatched {.</a>
<a name="ln1533">/// @returns NULL or the found match.</a>
<a name="ln1534">static pos_T *find_match_paren_after_brace(int ind_maxparen)</a>
<a name="ln1535">{</a>
<a name="ln1536">  pos_T *trypos = find_match_paren(ind_maxparen);</a>
<a name="ln1537">  if (trypos == NULL) {</a>
<a name="ln1538">    return NULL;</a>
<a name="ln1539">  }</a>
<a name="ln1540"> </a>
<a name="ln1541">  pos_T *tryposBrace = find_start_brace();</a>
<a name="ln1542">  // If both an unmatched '(' and '{' is found.  Ignore the '('</a>
<a name="ln1543">  // position if the '{' is further down.</a>
<a name="ln1544">  if (tryposBrace != NULL</a>
<a name="ln1545">      &amp;&amp; (trypos-&gt;lnum != tryposBrace-&gt;lnum</a>
<a name="ln1546">          ? trypos-&gt;lnum &lt; tryposBrace-&gt;lnum</a>
<a name="ln1547">          : trypos-&gt;col &lt; tryposBrace-&gt;col)) {</a>
<a name="ln1548">    trypos = NULL;</a>
<a name="ln1549">  }</a>
<a name="ln1550">  return trypos;</a>
<a name="ln1551">}</a>
<a name="ln1552"> </a>
<a name="ln1553">/*</a>
<a name="ln1554"> * Return ind_maxparen corrected for the difference in line number between the</a>
<a name="ln1555"> * cursor position and &quot;startpos&quot;.  This makes sure that searching for a</a>
<a name="ln1556"> * matching paren above the cursor line doesn't find a match because of</a>
<a name="ln1557"> * looking a few lines further.</a>
<a name="ln1558"> */</a>
<a name="ln1559">static int corr_ind_maxparen(pos_T *startpos)</a>
<a name="ln1560">{</a>
<a name="ln1561">  long n = (long)startpos-&gt;lnum - (long)curwin-&gt;w_cursor.lnum;</a>
<a name="ln1562"> </a>
<a name="ln1563">  if (n &gt; 0 &amp;&amp; n &lt; curbuf-&gt;b_ind_maxparen / 2) {</a>
<a name="ln1564">    return curbuf-&gt;b_ind_maxparen - (int)n;</a>
<a name="ln1565">  }</a>
<a name="ln1566">  return curbuf-&gt;b_ind_maxparen;</a>
<a name="ln1567">}</a>
<a name="ln1568"> </a>
<a name="ln1569">/*</a>
<a name="ln1570"> * Set w_cursor.col to the column number of the last unmatched ')' or '{' in</a>
<a name="ln1571"> * line &quot;l&quot;.  &quot;l&quot; must point to the start of the line.</a>
<a name="ln1572"> */</a>
<a name="ln1573">static int find_last_paren(const char_u *l, int start, int end)</a>
<a name="ln1574">{</a>
<a name="ln1575">  int i;</a>
<a name="ln1576">  int retval = FALSE;</a>
<a name="ln1577">  int open_count = 0;</a>
<a name="ln1578"> </a>
<a name="ln1579">  curwin-&gt;w_cursor.col = 0;                 // default is start of line</a>
<a name="ln1580"> </a>
<a name="ln1581">  for (i = 0; l[i] != NUL; i++) {</a>
<a name="ln1582">    i = (int)(cin_skipcomment(l + i) - l);     // ignore parens in comments</a>
<a name="ln1583">    i = (int)(skip_string(l + i) - l);        // ignore parens in quotes</a>
<a name="ln1584">    if (l[i] == start) {</a>
<a name="ln1585">      open_count++;</a>
<a name="ln1586">    } else if (l[i] == end) {</a>
<a name="ln1587">      if (open_count &gt; 0) {</a>
<a name="ln1588">        open_count--;</a>
<a name="ln1589">      } else {</a>
<a name="ln1590">        curwin-&gt;w_cursor.col = i;</a>
<a name="ln1591">        retval = TRUE;</a>
<a name="ln1592">      }</a>
<a name="ln1593">    }</a>
<a name="ln1594">  }</a>
<a name="ln1595">  return retval;</a>
<a name="ln1596">}</a>
<a name="ln1597"> </a>
<a name="ln1598">/*</a>
<a name="ln1599"> * Parse 'cinoptions' and set the values in &quot;curbuf&quot;.</a>
<a name="ln1600"> * Must be called when 'cinoptions', 'shiftwidth' and/or 'tabstop' changes.</a>
<a name="ln1601"> */</a>
<a name="ln1602">void parse_cino(buf_T *buf)</a>
<a name="ln1603">{</a>
<a name="ln1604">  char_u *p;</a>
<a name="ln1605">  char_u *l;</a>
<a name="ln1606">  int divider;</a>
<a name="ln1607">  int fraction = 0;</a>
<a name="ln1608">  int sw = get_sw_value(buf);</a>
<a name="ln1609"> </a>
<a name="ln1610">  /*</a>
<a name="ln1611">   * Set the default values.</a>
<a name="ln1612">   */</a>
<a name="ln1613">  /* Spaces from a block's opening brace the prevailing indent for that</a>
<a name="ln1614">   * block should be. */</a>
<a name="ln1615">  buf-&gt;b_ind_level = sw;</a>
<a name="ln1616"> </a>
<a name="ln1617">  /* Spaces from the edge of the line an open brace that's at the end of a</a>
<a name="ln1618">   * line is imagined to be. */</a>
<a name="ln1619">  buf-&gt;b_ind_open_imag = 0;</a>
<a name="ln1620"> </a>
<a name="ln1621">  /* Spaces from the prevailing indent for a line that is not preceded by</a>
<a name="ln1622">   * an opening brace. */</a>
<a name="ln1623">  buf-&gt;b_ind_no_brace = 0;</a>
<a name="ln1624"> </a>
<a name="ln1625">  // Column where the first { of a function should be located }.</a>
<a name="ln1626">  buf-&gt;b_ind_first_open = 0;</a>
<a name="ln1627"> </a>
<a name="ln1628">  /* Spaces from the prevailing indent a leftmost open brace should be</a>
<a name="ln1629">   * located. */</a>
<a name="ln1630">  buf-&gt;b_ind_open_extra = 0;</a>
<a name="ln1631"> </a>
<a name="ln1632">  /* Spaces from the matching open brace (real location for one at the left</a>
<a name="ln1633">   * edge; imaginary location from one that ends a line) the matching close</a>
<a name="ln1634">   * brace should be located. */</a>
<a name="ln1635">  buf-&gt;b_ind_close_extra = 0;</a>
<a name="ln1636"> </a>
<a name="ln1637">  /* Spaces from the edge of the line an open brace sitting in the leftmost</a>
<a name="ln1638">   * column is imagined to be. */</a>
<a name="ln1639">  buf-&gt;b_ind_open_left_imag = 0;</a>
<a name="ln1640"> </a>
<a name="ln1641">  /* Spaces jump labels should be shifted to the left if N is non-negative,</a>
<a name="ln1642">   * otherwise the jump label will be put to column 1. */</a>
<a name="ln1643">  buf-&gt;b_ind_jump_label = -1;</a>
<a name="ln1644"> </a>
<a name="ln1645">  // Spaces from the switch() indent a &quot;case xx&quot; label should be located.</a>
<a name="ln1646">  buf-&gt;b_ind_case = sw;</a>
<a name="ln1647"> </a>
<a name="ln1648">  // Spaces from the &quot;case xx:&quot; code after a switch() should be located.</a>
<a name="ln1649">  buf-&gt;b_ind_case_code = sw;</a>
<a name="ln1650"> </a>
<a name="ln1651">  // Lineup break at end of case in switch() with case label.</a>
<a name="ln1652">  buf-&gt;b_ind_case_break = 0;</a>
<a name="ln1653"> </a>
<a name="ln1654">  /* Spaces from the class declaration indent a scope declaration label</a>
<a name="ln1655">   * should be located. */</a>
<a name="ln1656">  buf-&gt;b_ind_scopedecl = sw;</a>
<a name="ln1657"> </a>
<a name="ln1658">  // Spaces from the scope declaration label code should be located.</a>
<a name="ln1659">  buf-&gt;b_ind_scopedecl_code = sw;</a>
<a name="ln1660"> </a>
<a name="ln1661">  // Amount K&amp;R-style parameters should be indented.</a>
<a name="ln1662">  buf-&gt;b_ind_param = sw;</a>
<a name="ln1663"> </a>
<a name="ln1664">  // Amount a function type spec should be indented.</a>
<a name="ln1665">  buf-&gt;b_ind_func_type = sw;</a>
<a name="ln1666"> </a>
<a name="ln1667">  /* Amount a cpp base class declaration or constructor initialization</a>
<a name="ln1668">   * should be indented. */</a>
<a name="ln1669">  buf-&gt;b_ind_cpp_baseclass = sw;</a>
<a name="ln1670"> </a>
<a name="ln1671">  /* additional spaces beyond the prevailing indent a continuation line</a>
<a name="ln1672">   * should be located. */</a>
<a name="ln1673">  buf-&gt;b_ind_continuation = sw;</a>
<a name="ln1674"> </a>
<a name="ln1675">  // Spaces from the indent of the line with an unclosed parentheses.</a>
<a name="ln1676">  buf-&gt;b_ind_unclosed = sw * 2;</a>
<a name="ln1677"> </a>
<a name="ln1678">  /* Spaces from the indent of the line with an unclosed parentheses, which</a>
<a name="ln1679">   * itself is also unclosed. */</a>
<a name="ln1680">  buf-&gt;b_ind_unclosed2 = sw;</a>
<a name="ln1681"> </a>
<a name="ln1682">  // Suppress ignoring spaces from the indent of a line starting with an</a>
<a name="ln1683">  // unclosed parenthesis.</a>
<a name="ln1684">  buf-&gt;b_ind_unclosed_noignore = 0;</a>
<a name="ln1685"> </a>
<a name="ln1686">  /* If the opening paren is the last nonwhite character on the line, and</a>
<a name="ln1687">   * b_ind_unclosed_wrapped is nonzero, use this indent relative to the outer</a>
<a name="ln1688">   * context (for very long lines). */</a>
<a name="ln1689">  buf-&gt;b_ind_unclosed_wrapped = 0;</a>
<a name="ln1690"> </a>
<a name="ln1691">  /* Suppress ignoring white space when lining up with the character after</a>
<a name="ln1692">   * an unclosed parentheses. */</a>
<a name="ln1693">  buf-&gt;b_ind_unclosed_whiteok = 0;</a>
<a name="ln1694"> </a>
<a name="ln1695">  // Indent a closing parenthesis under the line start of the matching</a>
<a name="ln1696">  // opening parenthesis.</a>
<a name="ln1697">  buf-&gt;b_ind_matching_paren = 0;</a>
<a name="ln1698"> </a>
<a name="ln1699">  // Indent a closing parenthesis under the previous line.</a>
<a name="ln1700">  buf-&gt;b_ind_paren_prev = 0;</a>
<a name="ln1701"> </a>
<a name="ln1702">  // Extra indent for comments.</a>
<a name="ln1703">  buf-&gt;b_ind_comment = 0;</a>
<a name="ln1704"> </a>
<a name="ln1705">  // Spaces from the comment opener when there is nothing after it.</a>
<a name="ln1706">  buf-&gt;b_ind_in_comment = 3;</a>
<a name="ln1707"> </a>
<a name="ln1708">  /* Boolean: if non-zero, use b_ind_in_comment even if there is something</a>
<a name="ln1709">   * after the comment opener. */</a>
<a name="ln1710">  buf-&gt;b_ind_in_comment2 = 0;</a>
<a name="ln1711"> </a>
<a name="ln1712">  // Max lines to search for an open paren.</a>
<a name="ln1713">  buf-&gt;b_ind_maxparen = 20;</a>
<a name="ln1714"> </a>
<a name="ln1715">  // Max lines to search for an open comment.</a>
<a name="ln1716">  buf-&gt;b_ind_maxcomment = 70;</a>
<a name="ln1717"> </a>
<a name="ln1718">  // Handle braces for java code.</a>
<a name="ln1719">  buf-&gt;b_ind_java = 0;</a>
<a name="ln1720"> </a>
<a name="ln1721">  // Not to confuse JS object properties with labels.</a>
<a name="ln1722">  buf-&gt;b_ind_js = 0;</a>
<a name="ln1723"> </a>
<a name="ln1724">  // Handle blocked cases correctly.</a>
<a name="ln1725">  buf-&gt;b_ind_keep_case_label = 0;</a>
<a name="ln1726"> </a>
<a name="ln1727">  // Handle C++ namespace.</a>
<a name="ln1728">  buf-&gt;b_ind_cpp_namespace = 0;</a>
<a name="ln1729"> </a>
<a name="ln1730">  /* Handle continuation lines containing conditions of if(), for() and</a>
<a name="ln1731">   * while(). */</a>
<a name="ln1732">  buf-&gt;b_ind_if_for_while = 0;</a>
<a name="ln1733"> </a>
<a name="ln1734">  // indentation for # comments</a>
<a name="ln1735">  buf-&gt;b_ind_hash_comment = 0;</a>
<a name="ln1736"> </a>
<a name="ln1737">  // Handle C++ extern &quot;C&quot; or &quot;C++&quot;</a>
<a name="ln1738">  buf-&gt;b_ind_cpp_extern_c = 0;</a>
<a name="ln1739"> </a>
<a name="ln1740">  // Handle C #pragma directives</a>
<a name="ln1741">  buf-&gt;b_ind_pragma = 0;</a>
<a name="ln1742"> </a>
<a name="ln1743">  for (p = buf-&gt;b_p_cino; *p;) {</a>
<a name="ln1744">    l = p++;</a>
<a name="ln1745">    if (*p == '-') {</a>
<a name="ln1746">      p++;</a>
<a name="ln1747">    }</a>
<a name="ln1748">    char_u *digits_start = p;   // remember where the digits start</a>
<a name="ln1749">    int n = getdigits_int(&amp;p, true, 0);</a>
<a name="ln1750">    divider = 0;</a>
<a name="ln1751">    if (*p == '.') {        // &quot;.5s&quot; means a fraction.</a>
<a name="ln1752">      fraction = atoi((char *)++p);</a>
<a name="ln1753">      while (ascii_isdigit(*p)) {</a>
<a name="ln1754">        p++;</a>
<a name="ln1755">        if (divider) {</a>
<a name="ln1756">          divider *= 10;</a>
<a name="ln1757">        } else {</a>
<a name="ln1758">          divider = 10;</a>
<a name="ln1759">        }</a>
<a name="ln1760">      }</a>
<a name="ln1761">    }</a>
<a name="ln1762">    if (*p == 's') {        // &quot;2s&quot; means two times 'shiftwidth'.</a>
<a name="ln1763">      if (p == digits_start) {</a>
<a name="ln1764">        n = sw;             // just &quot;s&quot; is one 'shiftwidth'.</a>
<a name="ln1765">      } else {</a>
<a name="ln1766">        n *= sw;</a>
<a name="ln1767">        if (divider) {</a>
<a name="ln1768">          n += (sw * fraction + divider / 2) / divider;</a>
<a name="ln1769">        }</a>
<a name="ln1770">      }</a>
<a name="ln1771">      ++p;</a>
<a name="ln1772">    }</a>
<a name="ln1773">    if (l[1] == '-') {</a>
<a name="ln1774">      n = -n;</a>
<a name="ln1775">    }</a>
<a name="ln1776"> </a>
<a name="ln1777">    /* When adding an entry here, also update the default 'cinoptions' in</a>
<a name="ln1778">     * doc/indent.txt, and add explanation for it! */</a>
<a name="ln1779">    switch (*l) {</a>
<a name="ln1780">    case '&gt;':</a>
<a name="ln1781">      buf-&gt;b_ind_level = n;</a>
<a name="ln1782">      break;</a>
<a name="ln1783">    case 'e':</a>
<a name="ln1784">      buf-&gt;b_ind_open_imag = n;</a>
<a name="ln1785">      break;</a>
<a name="ln1786">    case 'n':</a>
<a name="ln1787">      buf-&gt;b_ind_no_brace = n;</a>
<a name="ln1788">      break;</a>
<a name="ln1789">    case 'f':</a>
<a name="ln1790">      buf-&gt;b_ind_first_open = n;</a>
<a name="ln1791">      break;</a>
<a name="ln1792">    case '{':</a>
<a name="ln1793">      buf-&gt;b_ind_open_extra = n;</a>
<a name="ln1794">      break;</a>
<a name="ln1795">    case '}':</a>
<a name="ln1796">      buf-&gt;b_ind_close_extra = n;</a>
<a name="ln1797">      break;</a>
<a name="ln1798">    case '^':</a>
<a name="ln1799">      buf-&gt;b_ind_open_left_imag = n;</a>
<a name="ln1800">      break;</a>
<a name="ln1801">    case 'L':</a>
<a name="ln1802">      buf-&gt;b_ind_jump_label = n;</a>
<a name="ln1803">      break;</a>
<a name="ln1804">    case ':':</a>
<a name="ln1805">      buf-&gt;b_ind_case = n;</a>
<a name="ln1806">      break;</a>
<a name="ln1807">    case '=':</a>
<a name="ln1808">      buf-&gt;b_ind_case_code = n;</a>
<a name="ln1809">      break;</a>
<a name="ln1810">    case 'b':</a>
<a name="ln1811">      buf-&gt;b_ind_case_break = n;</a>
<a name="ln1812">      break;</a>
<a name="ln1813">    case 'p':</a>
<a name="ln1814">      buf-&gt;b_ind_param = n;</a>
<a name="ln1815">      break;</a>
<a name="ln1816">    case 't':</a>
<a name="ln1817">      buf-&gt;b_ind_func_type = n;</a>
<a name="ln1818">      break;</a>
<a name="ln1819">    case '/':</a>
<a name="ln1820">      buf-&gt;b_ind_comment = n;</a>
<a name="ln1821">      break;</a>
<a name="ln1822">    case 'c':</a>
<a name="ln1823">      buf-&gt;b_ind_in_comment = n;</a>
<a name="ln1824">      break;</a>
<a name="ln1825">    case 'C':</a>
<a name="ln1826">      buf-&gt;b_ind_in_comment2 = n;</a>
<a name="ln1827">      break;</a>
<a name="ln1828">    case 'i':</a>
<a name="ln1829">      buf-&gt;b_ind_cpp_baseclass = n;</a>
<a name="ln1830">      break;</a>
<a name="ln1831">    case '+':</a>
<a name="ln1832">      buf-&gt;b_ind_continuation = n;</a>
<a name="ln1833">      break;</a>
<a name="ln1834">    case '(':</a>
<a name="ln1835">      buf-&gt;b_ind_unclosed = n;</a>
<a name="ln1836">      break;</a>
<a name="ln1837">    case 'u':</a>
<a name="ln1838">      buf-&gt;b_ind_unclosed2 = n;</a>
<a name="ln1839">      break;</a>
<a name="ln1840">    case 'U':</a>
<a name="ln1841">      buf-&gt;b_ind_unclosed_noignore = n;</a>
<a name="ln1842">      break;</a>
<a name="ln1843">    case 'W':</a>
<a name="ln1844">      buf-&gt;b_ind_unclosed_wrapped = n;</a>
<a name="ln1845">      break;</a>
<a name="ln1846">    case 'w':</a>
<a name="ln1847">      buf-&gt;b_ind_unclosed_whiteok = n;</a>
<a name="ln1848">      break;</a>
<a name="ln1849">    case 'm':</a>
<a name="ln1850">      buf-&gt;b_ind_matching_paren = n;</a>
<a name="ln1851">      break;</a>
<a name="ln1852">    case 'M':</a>
<a name="ln1853">      buf-&gt;b_ind_paren_prev = n;</a>
<a name="ln1854">      break;</a>
<a name="ln1855">    case ')':</a>
<a name="ln1856">      buf-&gt;b_ind_maxparen = n;</a>
<a name="ln1857">      break;</a>
<a name="ln1858">    case '*':</a>
<a name="ln1859">      buf-&gt;b_ind_maxcomment = n;</a>
<a name="ln1860">      break;</a>
<a name="ln1861">    case 'g':</a>
<a name="ln1862">      buf-&gt;b_ind_scopedecl = n;</a>
<a name="ln1863">      break;</a>
<a name="ln1864">    case 'h':</a>
<a name="ln1865">      buf-&gt;b_ind_scopedecl_code = n;</a>
<a name="ln1866">      break;</a>
<a name="ln1867">    case 'j':</a>
<a name="ln1868">      buf-&gt;b_ind_java = n;</a>
<a name="ln1869">      break;</a>
<a name="ln1870">    case 'J':</a>
<a name="ln1871">      buf-&gt;b_ind_js = n;</a>
<a name="ln1872">      break;</a>
<a name="ln1873">    case 'l':</a>
<a name="ln1874">      buf-&gt;b_ind_keep_case_label = n;</a>
<a name="ln1875">      break;</a>
<a name="ln1876">    case '#':</a>
<a name="ln1877">      buf-&gt;b_ind_hash_comment = n;</a>
<a name="ln1878">      break;</a>
<a name="ln1879">    case 'N':</a>
<a name="ln1880">      buf-&gt;b_ind_cpp_namespace = n;</a>
<a name="ln1881">      break;</a>
<a name="ln1882">    case 'k':</a>
<a name="ln1883">      buf-&gt;b_ind_if_for_while = n;</a>
<a name="ln1884">      break;</a>
<a name="ln1885">    case 'E':</a>
<a name="ln1886">      buf-&gt;b_ind_cpp_extern_c = n;</a>
<a name="ln1887">      break;</a>
<a name="ln1888">    case 'P':</a>
<a name="ln1889">      buf-&gt;b_ind_pragma = n;</a>
<a name="ln1890">      break;</a>
<a name="ln1891">    }</a>
<a name="ln1892">    if (*p == ',') {</a>
<a name="ln1893">      p++;</a>
<a name="ln1894">    }</a>
<a name="ln1895">  }</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">/*</a>
<a name="ln1899"> * Return the desired indent for C code.</a>
<a name="ln1900"> * Return -1 if the indent should be left alone (inside a raw string).</a>
<a name="ln1901"> */</a>
<a name="ln1902">int get_c_indent(void)</a>
<a name="ln1903">{</a>
<a name="ln1904">  pos_T cur_curpos;</a>
<a name="ln1905">  int amount;</a>
<a name="ln1906">  int scope_amount;</a>
<a name="ln1907">  int cur_amount = MAXCOL;</a>
<a name="ln1908">  colnr_T col;</a>
<a name="ln1909">  char_u *theline;</a>
<a name="ln1910">  char_u *linecopy;</a>
<a name="ln1911">  pos_T *trypos;</a>
<a name="ln1912">  pos_T *comment_pos;</a>
<a name="ln1913">  pos_T *tryposBrace = NULL;</a>
<a name="ln1914">  pos_T tryposCopy;</a>
<a name="ln1915">  pos_T our_paren_pos;</a>
<a name="ln1916">  char_u *start;</a>
<a name="ln1917">  int start_brace;</a>
<a name="ln1918">#define BRACE_IN_COL0           1           // '{' is in column 0</a>
<a name="ln1919">#define BRACE_AT_START          2           // '{' is at start of line</a>
<a name="ln1920">#define BRACE_AT_END            3           // '{' is at end of line</a>
<a name="ln1921">  linenr_T ourscope;</a>
<a name="ln1922">  const char_u *l;</a>
<a name="ln1923">  const char_u *look;</a>
<a name="ln1924">  char_u terminated;</a>
<a name="ln1925">  int lookfor;</a>
<a name="ln1926">#define LOOKFOR_INITIAL         0</a>
<a name="ln1927">#define LOOKFOR_IF              1</a>
<a name="ln1928">#define LOOKFOR_DO              2</a>
<a name="ln1929">#define LOOKFOR_CASE            3</a>
<a name="ln1930">#define LOOKFOR_ANY             4</a>
<a name="ln1931">#define LOOKFOR_TERM            5</a>
<a name="ln1932">#define LOOKFOR_UNTERM          6</a>
<a name="ln1933">#define LOOKFOR_SCOPEDECL       7</a>
<a name="ln1934">#define LOOKFOR_NOBREAK         8</a>
<a name="ln1935">#define LOOKFOR_CPP_BASECLASS   9</a>
<a name="ln1936">#define LOOKFOR_ENUM_OR_INIT    10</a>
<a name="ln1937">#define LOOKFOR_JS_KEY          11</a>
<a name="ln1938">#define LOOKFOR_COMMA           12</a>
<a name="ln1939"> </a>
<a name="ln1940">  int whilelevel;</a>
<a name="ln1941">  linenr_T lnum;</a>
<a name="ln1942">  int n;</a>
<a name="ln1943">  int lookfor_break;</a>
<a name="ln1944">  bool lookfor_cpp_namespace = false;</a>
<a name="ln1945">  int cont_amount = 0;              // amount for continuation line</a>
<a name="ln1946">  int original_line_islabel;</a>
<a name="ln1947">  int added_to_amount = 0;</a>
<a name="ln1948">  linenr_T raw_string_start = 0;</a>
<a name="ln1949">  cpp_baseclass_cache_T cache_cpp_baseclass = { false, { MAXLNUM, 0 } };</a>
<a name="ln1950"> </a>
<a name="ln1951">  // make a copy, value is changed below</a>
<a name="ln1952">  int ind_continuation = curbuf-&gt;b_ind_continuation;</a>
<a name="ln1953"> </a>
<a name="ln1954">  // remember where the cursor was when we started</a>
<a name="ln1955">  cur_curpos = curwin-&gt;w_cursor;</a>
<a name="ln1956"> </a>
<a name="ln1957">  // if we are at line 1 zero indent is fine, right?</a>
<a name="ln1958">  if (cur_curpos.lnum == 1) {</a>
<a name="ln1959">    return 0;</a>
<a name="ln1960">  }</a>
<a name="ln1961"> </a>
<a name="ln1962">  /* Get a copy of the current contents of the line.</a>
<a name="ln1963">   * This is required, because only the most recent line obtained with</a>
<a name="ln1964">   * ml_get is valid! */</a>
<a name="ln1965">  linecopy = vim_strsave(ml_get(cur_curpos.lnum));</a>
<a name="ln1966"> </a>
<a name="ln1967">  /*</a>
<a name="ln1968">   * In insert mode and the cursor is on a ')' truncate the line at the</a>
<a name="ln1969">   * cursor position.  We don't want to line up with the matching '(' when</a>
<a name="ln1970">   * inserting new stuff.</a>
<a name="ln1971">   * For unknown reasons the cursor might be past the end of the line, thus</a>
<a name="ln1972">   * check for that.</a>
<a name="ln1973">   */</a>
<a name="ln1974">  if ((State &amp; MODE_INSERT)</a>
<a name="ln1975">      &amp;&amp; curwin-&gt;w_cursor.col &lt; (colnr_T)STRLEN(linecopy)</a>
<a name="ln1976">      &amp;&amp; linecopy[curwin-&gt;w_cursor.col] == ')') {</a>
<a name="ln1977">    linecopy[curwin-&gt;w_cursor.col] = NUL;</a>
<a name="ln1978">  }</a>
<a name="ln1979"> </a>
<a name="ln1980">  theline = (char_u *)skipwhite((char *)linecopy);</a>
<a name="ln1981"> </a>
<a name="ln1982">  // move the cursor to the start of the line</a>
<a name="ln1983"> </a>
<a name="ln1984">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln1985"> </a>
<a name="ln1986">  original_line_islabel = cin_islabel();    // XXX</a>
<a name="ln1987"> </a>
<a name="ln1988">  /*</a>
<a name="ln1989">   * If we are inside a raw string don't change the indent.</a>
<a name="ln1990">   * Ignore a raw string inside a comment.</a>
<a name="ln1991">   */</a>
<a name="ln1992">  comment_pos = ind_find_start_comment();</a>
<a name="ln1993">  if (comment_pos != NULL) {</a>
<a name="ln1994">    // findmatchlimit() static pos is overwritten, make a copy</a>
<a name="ln1995">    tryposCopy = *comment_pos;</a>
<a name="ln1996">    comment_pos = &amp;tryposCopy;</a>
<a name="ln1997">  }</a>
<a name="ln1998">  trypos = find_start_rawstring(curbuf-&gt;b_ind_maxcomment);</a>
<a name="ln1999">  if (trypos != NULL &amp;&amp; (comment_pos == NULL || lt(*trypos, *comment_pos))) {</a>
<a name="ln2000">    amount = -1;</a>
<a name="ln2001">    goto laterend;</a>
<a name="ln2002">  }</a>
<a name="ln2003"> </a>
<a name="ln2004">  // #defines and so on go at the left when included in 'cinkeys',</a>
<a name="ln2005">  // exluding pragmas when customized in 'cinoptions'</a>
<a name="ln2006">  if (*theline == '#' &amp;&amp; (*linecopy == '#' || in_cinkeys('#', ' ', true))) {</a>
<a name="ln2007">    const char_u *const directive = (char_u *)skipwhite((char *)theline + 1);</a>
<a name="ln2008">    if (curbuf-&gt;b_ind_pragma == 0 || STRNCMP(directive, &quot;pragma&quot;, 6) != 0) {</a>
<a name="ln2009">      amount = curbuf-&gt;b_ind_hash_comment;</a>
<a name="ln2010">      goto theend;</a>
<a name="ln2011">    }</a>
<a name="ln2012">  }</a>
<a name="ln2013"> </a>
<a name="ln2014">  // Is it a non-case label? Then that goes at the left margin too unless:</a>
<a name="ln2015">  //  - JS flag is set.</a>
<a name="ln2016">  //  - 'L' item has a positive value.</a>
<a name="ln2017">  if (original_line_islabel &amp;&amp; !curbuf-&gt;b_ind_js &amp;&amp; curbuf-&gt;b_ind_jump_label &lt; 0) {</a>
<a name="ln2018">    amount = 0;</a>
<a name="ln2019">    goto theend;</a>
<a name="ln2020">  }</a>
<a name="ln2021">  /*</a>
<a name="ln2022">   * If we're inside a &quot;//&quot; comment and there is a &quot;//&quot; comment in a</a>
<a name="ln2023">   * previous line, lineup with that one.</a>
<a name="ln2024">   */</a>
<a name="ln2025">  if (cin_islinecomment(theline)) {</a>
<a name="ln2026">    pos_T linecomment_pos;</a>
<a name="ln2027"> </a>
<a name="ln2028">    trypos = find_line_comment();  // XXX</a>
<a name="ln2029">    if (trypos == NULL &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln2030">      // There may be a statement before the comment, search from the end</a>
<a name="ln2031">      // of the line for a comment start.</a>
<a name="ln2032">      linecomment_pos.col = check_linecomment(ml_get(curwin-&gt;w_cursor.lnum - 1));</a>
<a name="ln2033">      if (linecomment_pos.col != MAXCOL) {</a>
<a name="ln2034">        trypos = &amp;linecomment_pos;</a>
<a name="ln2035">        trypos-&gt;lnum = curwin-&gt;w_cursor.lnum - 1;</a>
<a name="ln2036">      }</a>
<a name="ln2037">    }</a>
<a name="ln2038">    if (trypos != NULL) {</a>
<a name="ln2039">      // find how indented the line beginning the comment is</a>
<a name="ln2040">      getvcol(curwin, trypos, &amp;col, NULL, NULL);</a>
<a name="ln2041">      amount = col;</a>
<a name="ln2042">      goto theend;</a>
<a name="ln2043">    }</a>
<a name="ln2044">  }</a>
<a name="ln2045">  /*</a>
<a name="ln2046">   * If we're inside a comment and not looking at the start of the</a>
<a name="ln2047">   * comment, try using the 'comments' option.</a>
<a name="ln2048">   */</a>
<a name="ln2049">  if (!cin_iscomment(theline) &amp;&amp; comment_pos != NULL) {  // XXX</a>
<a name="ln2050">    int lead_start_len = 2;</a>
<a name="ln2051">    int lead_middle_len = 1;</a>
<a name="ln2052">    char_u lead_start[COM_MAX_LEN];             // start-comment string</a>
<a name="ln2053">    char_u lead_middle[COM_MAX_LEN];            // middle-comment string</a>
<a name="ln2054">    char_u lead_end[COM_MAX_LEN];               // end-comment string</a>
<a name="ln2055">    char_u *p;</a>
<a name="ln2056">    int start_align = 0;</a>
<a name="ln2057">    int start_off = 0;</a>
<a name="ln2058">    int done = FALSE;</a>
<a name="ln2059"> </a>
<a name="ln2060">    // find how indented the line beginning the comment is</a>
<a name="ln2061">    getvcol(curwin, comment_pos, &amp;col, NULL, NULL);</a>
<a name="ln2062">    amount = col;</a>
<a name="ln2063">    *lead_start = NUL;</a>
<a name="ln2064">    *lead_middle = NUL;</a>
<a name="ln2065"> </a>
<a name="ln2066">    p = curbuf-&gt;b_p_com;</a>
<a name="ln2067">    while (*p != NUL) {</a>
<a name="ln2068">      int align = 0;</a>
<a name="ln2069">      int off = 0;</a>
<a name="ln2070">      int what = 0;</a>
<a name="ln2071"> </a>
<a name="ln2072">      while (*p != NUL &amp;&amp; *p != ':') {</a>
<a name="ln2073">        if (*p == COM_START || *p == COM_END || *p == COM_MIDDLE) {</a>
<a name="ln2074">          what = *p++;</a>
<a name="ln2075">        } else if (*p == COM_LEFT || *p == COM_RIGHT) {</a>
<a name="ln2076">          align = *p++;</a>
<a name="ln2077">        } else if (ascii_isdigit(*p) || *p == '-') {</a>
<a name="ln2078">          off = getdigits_int(&amp;p, true, 0);</a>
<a name="ln2079">        } else {</a>
<a name="ln2080">          p++;</a>
<a name="ln2081">        }</a>
<a name="ln2082">      }</a>
<a name="ln2083"> </a>
<a name="ln2084">      if (*p == ':') {</a>
<a name="ln2085">        p++;</a>
<a name="ln2086">      }</a>
<a name="ln2087">      (void)copy_option_part(&amp;p, lead_end, COM_MAX_LEN, &quot;,&quot;);</a>
<a name="ln2088">      if (what == COM_START) {</a>
<a name="ln2089">        STRCPY(lead_start, lead_end);</a>
<a name="ln2090">        lead_start_len = (int)STRLEN(lead_start);</a>
<a name="ln2091">        start_off = off;</a>
<a name="ln2092">        start_align = align;</a>
<a name="ln2093">      } else if (what == COM_MIDDLE) {</a>
<a name="ln2094">        STRCPY(lead_middle, lead_end);</a>
<a name="ln2095">        lead_middle_len = (int)STRLEN(lead_middle);</a>
<a name="ln2096">      } else if (what == COM_END) {</a>
<a name="ln2097">        /* If our line starts with the middle comment string, line it</a>
<a name="ln2098">         * up with the comment opener per the 'comments' option. */</a>
<a name="ln2099">        if (STRNCMP(theline, lead_middle, lead_middle_len) == 0</a>
<a name="ln2100">            &amp;&amp; STRNCMP(theline, lead_end, STRLEN(lead_end)) != 0) {</a>
<a name="ln2101">          done = TRUE;</a>
<a name="ln2102">          if (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln2103">            /* If the start comment string matches in the previous</a>
<a name="ln2104">             * line, use the indent of that line plus offset.  If</a>
<a name="ln2105">             * the middle comment string matches in the previous</a>
<a name="ln2106">             * line, use the indent of that line.  XXX */</a>
<a name="ln2107">            look = (char_u *)skipwhite((char *)ml_get(curwin-&gt;w_cursor.lnum - 1));</a>
<a name="ln2108">            if (STRNCMP(look, lead_start, lead_start_len) == 0) {</a>
<a name="ln2109">              amount = get_indent_lnum(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln2110">            } else if (STRNCMP(look, lead_middle, lead_middle_len) == 0) {</a>
<a name="ln2111">              amount = get_indent_lnum(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln2112">              break;</a>
<a name="ln2113">            } else if (STRNCMP(ml_get(comment_pos-&gt;lnum) + comment_pos-&gt;col,</a>
<a name="ln2114">                               lead_start, lead_start_len) != 0) {</a>
<a name="ln2115">              // If the start comment string doesn't match with the</a>
<a name="ln2116">              // start of the comment, skip this entry. XXX</a>
<a name="ln2117">              continue;</a>
<a name="ln2118">            }</a>
<a name="ln2119">          }</a>
<a name="ln2120">          if (start_off != 0) {</a>
<a name="ln2121">            amount += start_off;</a>
<a name="ln2122">          } else if (start_align == COM_RIGHT) {</a>
<a name="ln2123">            amount += vim_strsize(lead_start)</a>
<a name="ln2124">                      - vim_strsize(lead_middle);</a>
<a name="ln2125">          }</a>
<a name="ln2126">          break;</a>
<a name="ln2127">        }</a>
<a name="ln2128"> </a>
<a name="ln2129">        /* If our line starts with the end comment string, line it up</a>
<a name="ln2130">         * with the middle comment */</a>
<a name="ln2131">        if (STRNCMP(theline, lead_middle, lead_middle_len) != 0</a>
<a name="ln2132">            &amp;&amp; STRNCMP(theline, lead_end, STRLEN(lead_end)) == 0) {</a>
<a name="ln2133">          amount = get_indent_lnum(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln2134">          // XXX</a>
<a name="ln2135">          if (off != 0) {</a>
<a name="ln2136">            amount += off;</a>
<a name="ln2137">          } else if (align == COM_RIGHT) {</a>
<a name="ln2138">            amount += vim_strsize(lead_start) - vim_strsize(lead_middle);</a>
<a name="ln2139">          }</a>
<a name="ln2140">          done = true;</a>
<a name="ln2141">          break;</a>
<a name="ln2142">        }</a>
<a name="ln2143">      }</a>
<a name="ln2144">    }</a>
<a name="ln2145"> </a>
<a name="ln2146">    /* If our line starts with an asterisk, line up with the</a>
<a name="ln2147">     * asterisk in the comment opener; otherwise, line up</a>
<a name="ln2148">     * with the first character of the comment text.</a>
<a name="ln2149">     */</a>
<a name="ln2150">    if (done) {</a>
<a name="ln2151">      // skip</a>
<a name="ln2152">    } else if (theline[0] == '*') {</a>
<a name="ln2153">      amount += 1;</a>
<a name="ln2154">    } else {</a>
<a name="ln2155">      // If we are more than one line away from the comment opener, take</a>
<a name="ln2156">      // the indent of the previous non-empty line.  If 'cino' has &quot;CO&quot;</a>
<a name="ln2157">      // and we are just below the comment opener and there are any</a>
<a name="ln2158">      // white characters after it line up with the text after it;</a>
<a name="ln2159">      // otherwise, add the amount specified by &quot;c&quot; in 'cino'</a>
<a name="ln2160">      amount = -1;</a>
<a name="ln2161">      for (lnum = cur_curpos.lnum - 1; lnum &gt; comment_pos-&gt;lnum; lnum--) {</a>
<a name="ln2162">        if (linewhite(lnum)) {                      // skip blank lines</a>
<a name="ln2163">          continue;</a>
<a name="ln2164">        }</a>
<a name="ln2165">        amount = get_indent_lnum(lnum);             // XXX</a>
<a name="ln2166">        break;</a>
<a name="ln2167">      }</a>
<a name="ln2168">      if (amount == -1) {                           // use the comment opener</a>
<a name="ln2169">        if (!curbuf-&gt;b_ind_in_comment2) {</a>
<a name="ln2170">          start = ml_get(comment_pos-&gt;lnum);</a>
<a name="ln2171">          look = start + comment_pos-&gt;col + 2;  // skip / and *</a>
<a name="ln2172">          if (*look != NUL) {                   // if something after it</a>
<a name="ln2173">            comment_pos-&gt;col = (colnr_T)((char_u *)skipwhite((char *)look) - start);</a>
<a name="ln2174">          }</a>
<a name="ln2175">        }</a>
<a name="ln2176">        getvcol(curwin, comment_pos, &amp;col, NULL, NULL);</a>
<a name="ln2177">        amount = col;</a>
<a name="ln2178">        if (curbuf-&gt;b_ind_in_comment2 || *look == NUL) {</a>
<a name="ln2179">          amount += curbuf-&gt;b_ind_in_comment;</a>
<a name="ln2180">        }</a>
<a name="ln2181">      }</a>
<a name="ln2182">    }</a>
<a name="ln2183">    goto theend;</a>
<a name="ln2184">  }</a>
<a name="ln2185">  // Are we looking at a ']' that has a match?</a>
<a name="ln2186">  if (*skipwhite((char *)theline) == ']'</a>
<a name="ln2187">      &amp;&amp; (trypos = find_match_char('[', curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln2188">    // align with the line containing the '['.</a>
<a name="ln2189">    amount = get_indent_lnum(trypos-&gt;lnum);</a>
<a name="ln2190">    goto theend;</a>
<a name="ln2191">  }</a>
<a name="ln2192">  // Are we inside parentheses or braces?</a>
<a name="ln2193">  // XXX</a>
<a name="ln2194">  if (((trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL</a>
<a name="ln2195">       &amp;&amp; curbuf-&gt;b_ind_java == 0)</a>
<a name="ln2196">      || (tryposBrace = find_start_brace()) != NULL</a>
<a name="ln2197">      || trypos != NULL) {</a>
<a name="ln2198">    if (trypos != NULL &amp;&amp; tryposBrace != NULL) {</a>
<a name="ln2199">      /* Both an unmatched '(' and '{' is found.  Use the one which is</a>
<a name="ln2200">       * closer to the current cursor position, set the other to NULL. */</a>
<a name="ln2201">      if (trypos-&gt;lnum != tryposBrace-&gt;lnum</a>
<a name="ln2202">          ? trypos-&gt;lnum &lt; tryposBrace-&gt;lnum</a>
<a name="ln2203">          : trypos-&gt;col &lt; tryposBrace-&gt;col) {</a>
<a name="ln2204">        trypos = NULL;</a>
<a name="ln2205">      } else {</a>
<a name="ln2206">        tryposBrace = NULL;</a>
<a name="ln2207">      }</a>
<a name="ln2208">    }</a>
<a name="ln2209"> </a>
<a name="ln2210">    if (trypos != NULL) {</a>
<a name="ln2211">      our_paren_pos = *trypos;</a>
<a name="ln2212">      /*</a>
<a name="ln2213">       * If the matching paren is more than one line away, use the indent of</a>
<a name="ln2214">       * a previous non-empty line that matches the same paren.</a>
<a name="ln2215">       */</a>
<a name="ln2216">      if (theline[0] == ')' &amp;&amp; curbuf-&gt;b_ind_paren_prev) {</a>
<a name="ln2217">        // Line up with the start of the matching paren line.</a>
<a name="ln2218">        amount = get_indent_lnum(curwin-&gt;w_cursor.lnum - 1);      // XXX</a>
<a name="ln2219">      } else {</a>
<a name="ln2220">        amount = -1;</a>
<a name="ln2221">        for (lnum = cur_curpos.lnum - 1; lnum &gt; our_paren_pos.lnum; lnum--) {</a>
<a name="ln2222">          l = (char_u *)skipwhite((char *)ml_get(lnum));</a>
<a name="ln2223">          if (cin_nocode(l)) {                   // skip comment lines</a>
<a name="ln2224">            continue;</a>
<a name="ln2225">          }</a>
<a name="ln2226">          if (cin_ispreproc_cont(&amp;l, &amp;lnum, &amp;amount)) {</a>
<a name="ln2227">            continue;                           // ignore #define, #if, etc.</a>
<a name="ln2228">          }</a>
<a name="ln2229">          curwin-&gt;w_cursor.lnum = lnum;</a>
<a name="ln2230"> </a>
<a name="ln2231">          // Skip a comment or raw string. XXX</a>
<a name="ln2232">          if ((trypos = ind_find_start_CORS(NULL)) != NULL) {</a>
<a name="ln2233">            lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2234">            continue;</a>
<a name="ln2235">          }</a>
<a name="ln2236"> </a>
<a name="ln2237">          // XXX</a>
<a name="ln2238">          if ((trypos = find_match_paren(corr_ind_maxparen(&amp;cur_curpos))) != NULL</a>
<a name="ln2239">              &amp;&amp; trypos-&gt;lnum == our_paren_pos.lnum</a>
<a name="ln2240">              &amp;&amp; trypos-&gt;col == our_paren_pos.col) {</a>
<a name="ln2241">            amount = get_indent_lnum(lnum);             // XXX</a>
<a name="ln2242"> </a>
<a name="ln2243">            if (theline[0] == ')') {</a>
<a name="ln2244">              if (our_paren_pos.lnum != lnum</a>
<a name="ln2245">                  &amp;&amp; cur_amount &gt; amount) {</a>
<a name="ln2246">                cur_amount = amount;</a>
<a name="ln2247">              }</a>
<a name="ln2248">              amount = -1;</a>
<a name="ln2249">            }</a>
<a name="ln2250">            break;</a>
<a name="ln2251">          }</a>
<a name="ln2252">        }</a>
<a name="ln2253">      }</a>
<a name="ln2254"> </a>
<a name="ln2255">      /*</a>
<a name="ln2256">       * Line up with line where the matching paren is. XXX</a>
<a name="ln2257">       * If the line starts with a '(' or the indent for unclosed</a>
<a name="ln2258">       * parentheses is zero, line up with the unclosed parentheses.</a>
<a name="ln2259">       */</a>
<a name="ln2260">      if (amount == -1) {</a>
<a name="ln2261">        int ignore_paren_col = 0;</a>
<a name="ln2262">        int is_if_for_while = 0;</a>
<a name="ln2263"> </a>
<a name="ln2264">        if (curbuf-&gt;b_ind_if_for_while) {</a>
<a name="ln2265">          /* Look for the outermost opening parenthesis on this line</a>
<a name="ln2266">           * and check whether it belongs to an &quot;if&quot;, &quot;for&quot; or &quot;while&quot;. */</a>
<a name="ln2267"> </a>
<a name="ln2268">          pos_T cursor_save = curwin-&gt;w_cursor;</a>
<a name="ln2269">          pos_T outermost;</a>
<a name="ln2270">          char_u *line;</a>
<a name="ln2271"> </a>
<a name="ln2272">          trypos = &amp;our_paren_pos;</a>
<a name="ln2273">          do {</a>
<a name="ln2274">            outermost = *trypos;</a>
<a name="ln2275">            curwin-&gt;w_cursor.lnum = outermost.lnum;</a>
<a name="ln2276">            curwin-&gt;w_cursor.col = outermost.col;</a>
<a name="ln2277"> </a>
<a name="ln2278">            trypos = find_match_paren(curbuf-&gt;b_ind_maxparen);</a>
<a name="ln2279">          } while (trypos &amp;&amp; trypos-&gt;lnum == outermost.lnum);</a>
<a name="ln2280"> </a>
<a name="ln2281">          curwin-&gt;w_cursor = cursor_save;</a>
<a name="ln2282"> </a>
<a name="ln2283">          line = ml_get(outermost.lnum);</a>
<a name="ln2284"> </a>
<a name="ln2285">          is_if_for_while =</a>
<a name="ln2286">            cin_is_if_for_while_before_offset(line, &amp;outermost.col);</a>
<a name="ln2287">        }</a>
<a name="ln2288"> </a>
<a name="ln2289">        amount = skip_label(our_paren_pos.lnum, &amp;look);</a>
<a name="ln2290">        look = (char_u *)skipwhite((char *)look);</a>
<a name="ln2291">        if (*look == '(') {</a>
<a name="ln2292">          linenr_T save_lnum = curwin-&gt;w_cursor.lnum;</a>
<a name="ln2293">          char_u *line;</a>
<a name="ln2294">          int look_col;</a>
<a name="ln2295"> </a>
<a name="ln2296">          /* Ignore a '(' in front of the line that has a match before</a>
<a name="ln2297">           * our matching '('. */</a>
<a name="ln2298">          curwin-&gt;w_cursor.lnum = our_paren_pos.lnum;</a>
<a name="ln2299">          line = get_cursor_line_ptr();</a>
<a name="ln2300">          look_col = (int)(look - line);</a>
<a name="ln2301">          curwin-&gt;w_cursor.col = look_col + 1;</a>
<a name="ln2302">          if ((trypos = findmatchlimit(NULL, ')', 0,</a>
<a name="ln2303">                                       curbuf-&gt;b_ind_maxparen))</a>
<a name="ln2304">              != NULL</a>
<a name="ln2305">              &amp;&amp; trypos-&gt;lnum == our_paren_pos.lnum</a>
<a name="ln2306">              &amp;&amp; trypos-&gt;col &lt; our_paren_pos.col) {</a>
<a name="ln2307">            ignore_paren_col = trypos-&gt;col + 1;</a>
<a name="ln2308">          }</a>
<a name="ln2309"> </a>
<a name="ln2310">          curwin-&gt;w_cursor.lnum = save_lnum;</a>
<a name="ln2311">          look = ml_get(our_paren_pos.lnum) + look_col;</a>
<a name="ln2312">        }</a>
<a name="ln2313">        if (theline[0] == ')' || (curbuf-&gt;b_ind_unclosed == 0</a>
<a name="ln2314">                                  &amp;&amp; is_if_for_while == 0)</a>
<a name="ln2315">            || (!curbuf-&gt;b_ind_unclosed_noignore &amp;&amp; *look == '('</a>
<a name="ln2316">                &amp;&amp; ignore_paren_col == 0)) {</a>
<a name="ln2317">          /*</a>
<a name="ln2318">           * If we're looking at a close paren, line up right there;</a>
<a name="ln2319">           * otherwise, line up with the next (non-white) character.</a>
<a name="ln2320">           * When b_ind_unclosed_wrapped is set and the matching paren is</a>
<a name="ln2321">           * the last nonwhite character of the line, use either the</a>
<a name="ln2322">           * indent of the current line or the indentation of the next</a>
<a name="ln2323">           * outer paren and add b_ind_unclosed_wrapped (for very long</a>
<a name="ln2324">           * lines).</a>
<a name="ln2325">           */</a>
<a name="ln2326">          if (theline[0] != ')') {</a>
<a name="ln2327">            cur_amount = MAXCOL;</a>
<a name="ln2328">            l = ml_get(our_paren_pos.lnum);</a>
<a name="ln2329">            if (curbuf-&gt;b_ind_unclosed_wrapped</a>
<a name="ln2330">                &amp;&amp; cin_ends_in(l, (char_u *)&quot;(&quot;, NULL)) {</a>
<a name="ln2331">              /* look for opening unmatched paren, indent one level</a>
<a name="ln2332">               * for each additional level */</a>
<a name="ln2333">              n = 1;</a>
<a name="ln2334">              for (col = 0; col &lt; our_paren_pos.col; ++col) {</a>
<a name="ln2335">                switch (l[col]) {</a>
<a name="ln2336">                case '(':</a>
<a name="ln2337">                case '{':</a>
<a name="ln2338">                  n++;</a>
<a name="ln2339">                  break;</a>
<a name="ln2340"> </a>
<a name="ln2341">                case ')':</a>
<a name="ln2342">                case '}':</a>
<a name="ln2343">                  if (n &gt; 1) {</a>
<a name="ln2344">                    n--;</a>
<a name="ln2345">                  }</a>
<a name="ln2346">                  break;</a>
<a name="ln2347">                }</a>
<a name="ln2348">              }</a>
<a name="ln2349"> </a>
<a name="ln2350">              our_paren_pos.col = 0;</a>
<a name="ln2351">              amount += n * curbuf-&gt;b_ind_unclosed_wrapped;</a>
<a name="ln2352">            } else if (curbuf-&gt;b_ind_unclosed_whiteok) {</a>
<a name="ln2353">              our_paren_pos.col++;</a>
<a name="ln2354">            } else {</a>
<a name="ln2355">              col = our_paren_pos.col + 1;</a>
<a name="ln2356">              while (ascii_iswhite(l[col])) {</a>
<a name="ln2357">                col++;</a>
<a name="ln2358">              }</a>
<a name="ln2359">              if (l[col] != NUL) {              // In case of trailing space</a>
<a name="ln2360">                our_paren_pos.col = col;</a>
<a name="ln2361">              } else {</a>
<a name="ln2362">                our_paren_pos.col++;</a>
<a name="ln2363">              }</a>
<a name="ln2364">            }</a>
<a name="ln2365">          }</a>
<a name="ln2366"> </a>
<a name="ln2367">          /*</a>
<a name="ln2368">           * Find how indented the paren is, or the character after it</a>
<a name="ln2369">           * if we did the above &quot;if&quot;.</a>
<a name="ln2370">           */</a>
<a name="ln2371">          if (our_paren_pos.col &gt; 0) {</a>
<a name="ln2372">            getvcol(curwin, &amp;our_paren_pos, &amp;col, NULL, NULL);</a>
<a name="ln2373">            if (cur_amount &gt; (int)col) {</a>
<a name="ln2374">              cur_amount = col;</a>
<a name="ln2375">            }</a>
<a name="ln2376">          }</a>
<a name="ln2377">        }</a>
<a name="ln2378"> </a>
<a name="ln2379">        if (theline[0] == ')' &amp;&amp; curbuf-&gt;b_ind_matching_paren) {</a>
<a name="ln2380">          // Line up with the start of the matching paren line.</a>
<a name="ln2381">        } else if ((curbuf-&gt;b_ind_unclosed == 0 &amp;&amp; is_if_for_while == 0)</a>
<a name="ln2382">                   || (!curbuf-&gt;b_ind_unclosed_noignore</a>
<a name="ln2383">                       &amp;&amp; *look == '(' &amp;&amp; ignore_paren_col == 0)) {</a>
<a name="ln2384">          if (cur_amount != MAXCOL) {</a>
<a name="ln2385">            amount = cur_amount;</a>
<a name="ln2386">          }</a>
<a name="ln2387">        } else {</a>
<a name="ln2388">          /* Add b_ind_unclosed2 for each '(' before our matching one,</a>
<a name="ln2389">           * but ignore (void) before the line (ignore_paren_col). */</a>
<a name="ln2390">          col = our_paren_pos.col;</a>
<a name="ln2391">          while ((int)our_paren_pos.col &gt; ignore_paren_col) {</a>
<a name="ln2392">            --our_paren_pos.col;</a>
<a name="ln2393">            switch (*ml_get_pos(&amp;our_paren_pos)) {</a>
<a name="ln2394">            case '(':</a>
<a name="ln2395">              amount += curbuf-&gt;b_ind_unclosed2;</a>
<a name="ln2396">              col = our_paren_pos.col;</a>
<a name="ln2397">              break;</a>
<a name="ln2398">            case ')':</a>
<a name="ln2399">              amount -= curbuf-&gt;b_ind_unclosed2;</a>
<a name="ln2400">              col = MAXCOL;</a>
<a name="ln2401">              break;</a>
<a name="ln2402">            }</a>
<a name="ln2403">          }</a>
<a name="ln2404"> </a>
<a name="ln2405">          /* Use b_ind_unclosed once, when the first '(' is not inside</a>
<a name="ln2406">           * braces */</a>
<a name="ln2407">          if (col == MAXCOL) {</a>
<a name="ln2408">            amount += curbuf-&gt;b_ind_unclosed;</a>
<a name="ln2409">          } else {</a>
<a name="ln2410">            curwin-&gt;w_cursor.lnum = our_paren_pos.lnum;</a>
<a name="ln2411">            curwin-&gt;w_cursor.col = col;</a>
<a name="ln2412">            if (find_match_paren_after_brace(curbuf-&gt;b_ind_maxparen)) {</a>
<a name="ln2413">              amount += curbuf-&gt;b_ind_unclosed2;</a>
<a name="ln2414">            } else {</a>
<a name="ln2415">              if (is_if_for_while) {</a>
<a name="ln2416">                amount += curbuf-&gt;b_ind_if_for_while;</a>
<a name="ln2417">              } else {</a>
<a name="ln2418">                amount += curbuf-&gt;b_ind_unclosed;</a>
<a name="ln2419">              }</a>
<a name="ln2420">            }</a>
<a name="ln2421">          }</a>
<a name="ln2422">          /*</a>
<a name="ln2423">           * For a line starting with ')' use the minimum of the two</a>
<a name="ln2424">           * positions, to avoid giving it more indent than the previous</a>
<a name="ln2425">           * lines:</a>
<a name="ln2426">           *  func_long_name(               if (x</a>
<a name="ln2427">           *    arg                                 &amp;&amp; yy</a>
<a name="ln2428">           *    )         ^ not here           )    ^ not here</a>
<a name="ln2429">           */</a>
<a name="ln2430">          if (cur_amount &lt; amount) {</a>
<a name="ln2431">            amount = cur_amount;</a>
<a name="ln2432">          }</a>
<a name="ln2433">        }</a>
<a name="ln2434">      }</a>
<a name="ln2435"> </a>
<a name="ln2436">      // add extra indent for a comment</a>
<a name="ln2437">      if (cin_iscomment(theline)) {</a>
<a name="ln2438">        amount += curbuf-&gt;b_ind_comment;</a>
<a name="ln2439">      }</a>
<a name="ln2440">    } else {</a>
<a name="ln2441">      // We are inside braces, there is a { before this line at the position</a>
<a name="ln2442">      // stored in tryposBrace.</a>
<a name="ln2443">      // Make a copy of tryposBrace, it may point to pos_copy inside</a>
<a name="ln2444">      // find_start_brace(), which may be changed somewhere.</a>
<a name="ln2445">      tryposCopy = *tryposBrace;</a>
<a name="ln2446">      tryposBrace = &amp;tryposCopy;</a>
<a name="ln2447">      trypos = tryposBrace;</a>
<a name="ln2448">      ourscope = trypos-&gt;lnum;</a>
<a name="ln2449">      start = ml_get(ourscope);</a>
<a name="ln2450"> </a>
<a name="ln2451">      /*</a>
<a name="ln2452">       * Now figure out how indented the line is in general.</a>
<a name="ln2453">       * If the brace was at the start of the line, we use that;</a>
<a name="ln2454">       * otherwise, check out the indentation of the line as</a>
<a name="ln2455">       * a whole and then add the &quot;imaginary indent&quot; to that.</a>
<a name="ln2456">       */</a>
<a name="ln2457">      look = (char_u *)skipwhite((char *)start);</a>
<a name="ln2458">      if (*look == '{') {</a>
<a name="ln2459">        getvcol(curwin, trypos, &amp;col, NULL, NULL);</a>
<a name="ln2460">        amount = col;</a>
<a name="ln2461">        if (*start == '{') {</a>
<a name="ln2462">          start_brace = BRACE_IN_COL0;</a>
<a name="ln2463">        } else {</a>
<a name="ln2464">          start_brace = BRACE_AT_START;</a>
<a name="ln2465">        }</a>
<a name="ln2466">      } else {</a>
<a name="ln2467">        // That opening brace might have been on a continuation</a>
<a name="ln2468">        // line.  If so, find the start of the line.</a>
<a name="ln2469">        curwin-&gt;w_cursor.lnum = ourscope;</a>
<a name="ln2470"> </a>
<a name="ln2471">        // Position the cursor over the rightmost paren, so that</a>
<a name="ln2472">        // matching it will take us back to the start of the line.</a>
<a name="ln2473">        lnum = ourscope;</a>
<a name="ln2474">        if (find_last_paren(start, '(', ')')</a>
<a name="ln2475">            &amp;&amp; (trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln2476">          lnum = trypos-&gt;lnum;</a>
<a name="ln2477">        }</a>
<a name="ln2478"> </a>
<a name="ln2479">        // It could have been something like</a>
<a name="ln2480">        //         case 1: if (asdf &amp;&amp;</a>
<a name="ln2481">        //                      ldfd) {</a>
<a name="ln2482">        //                  }</a>
<a name="ln2483">        if ((curbuf-&gt;b_ind_js || curbuf-&gt;b_ind_keep_case_label)</a>
<a name="ln2484">            &amp;&amp; cin_iscase((char_u *)skipwhite((char *)get_cursor_line_ptr()), false)) {</a>
<a name="ln2485">          amount = get_indent();</a>
<a name="ln2486">        } else if (curbuf-&gt;b_ind_js) {</a>
<a name="ln2487">          amount = get_indent_lnum(lnum);</a>
<a name="ln2488">        } else {</a>
<a name="ln2489">          amount = skip_label(lnum, &amp;l);</a>
<a name="ln2490">        }</a>
<a name="ln2491"> </a>
<a name="ln2492">        start_brace = BRACE_AT_END;</a>
<a name="ln2493">      }</a>
<a name="ln2494"> </a>
<a name="ln2495">      // For Javascript check if the line starts with &quot;key:&quot;.</a>
<a name="ln2496">      bool js_cur_has_key = curbuf-&gt;b_ind_js ? cin_has_js_key(theline) : false;</a>
<a name="ln2497"> </a>
<a name="ln2498">      // If we're looking at a closing brace, that's where</a>
<a name="ln2499">      // we want to be.  Otherwise, add the amount of room</a>
<a name="ln2500">      // that an indent is supposed to be.</a>
<a name="ln2501">      if (theline[0] == '}') {</a>
<a name="ln2502">        /*</a>
<a name="ln2503">         * they may want closing braces to line up with something</a>
<a name="ln2504">         * other than the open brace.  indulge them, if so.</a>
<a name="ln2505">         */</a>
<a name="ln2506">        amount += curbuf-&gt;b_ind_close_extra;</a>
<a name="ln2507">      } else {</a>
<a name="ln2508">        /*</a>
<a name="ln2509">         * If we're looking at an &quot;else&quot;, try to find an &quot;if&quot;</a>
<a name="ln2510">         * to match it with.</a>
<a name="ln2511">         * If we're looking at a &quot;while&quot;, try to find a &quot;do&quot;</a>
<a name="ln2512">         * to match it with.</a>
<a name="ln2513">         */</a>
<a name="ln2514">        lookfor = LOOKFOR_INITIAL;</a>
<a name="ln2515">        if (cin_iselse(theline)) {</a>
<a name="ln2516">          lookfor = LOOKFOR_IF;</a>
<a name="ln2517">        } else if (cin_iswhileofdo(theline, cur_curpos.lnum)) {   // XXX</a>
<a name="ln2518">          lookfor = LOOKFOR_DO;</a>
<a name="ln2519">        }</a>
<a name="ln2520">        if (lookfor != LOOKFOR_INITIAL) {</a>
<a name="ln2521">          curwin-&gt;w_cursor.lnum = cur_curpos.lnum;</a>
<a name="ln2522">          if (find_match(lookfor, ourscope) == OK) {</a>
<a name="ln2523">            amount = get_indent();              // XXX</a>
<a name="ln2524">            goto theend;</a>
<a name="ln2525">          }</a>
<a name="ln2526">        }</a>
<a name="ln2527"> </a>
<a name="ln2528">        /*</a>
<a name="ln2529">         * We get here if we are not on an &quot;while-of-do&quot; or &quot;else&quot; (or</a>
<a name="ln2530">         * failed to find a matching &quot;if&quot;).</a>
<a name="ln2531">         * Search backwards for something to line up with.</a>
<a name="ln2532">         * First set amount for when we don't find anything.</a>
<a name="ln2533">         */</a>
<a name="ln2534"> </a>
<a name="ln2535">        /*</a>
<a name="ln2536">         * if the '{' is  _really_ at the left margin, use the imaginary</a>
<a name="ln2537">         * location of a left-margin brace.  Otherwise, correct the</a>
<a name="ln2538">         * location for b_ind_open_extra.</a>
<a name="ln2539">         */</a>
<a name="ln2540"> </a>
<a name="ln2541">        if (start_brace == BRACE_IN_COL0) {     // '{' is in column 0</a>
<a name="ln2542">          amount = curbuf-&gt;b_ind_open_left_imag;</a>
<a name="ln2543">          lookfor_cpp_namespace = true;</a>
<a name="ln2544">        } else if (start_brace == BRACE_AT_START</a>
<a name="ln2545">                   &amp;&amp; lookfor_cpp_namespace) {  // '{' is at start</a>
<a name="ln2546">          lookfor_cpp_namespace = true;</a>
<a name="ln2547">        } else {</a>
<a name="ln2548">          if (start_brace == BRACE_AT_END) {    // '{' is at end of line</a>
<a name="ln2549">            amount += curbuf-&gt;b_ind_open_imag;</a>
<a name="ln2550"> </a>
<a name="ln2551">            l = (char_u *)skipwhite((char *)get_cursor_line_ptr());</a>
<a name="ln2552">            if (cin_is_cpp_namespace(l)) {</a>
<a name="ln2553">              amount += curbuf-&gt;b_ind_cpp_namespace;</a>
<a name="ln2554">            } else if (cin_is_cpp_extern_c(l)) {</a>
<a name="ln2555">              amount += curbuf-&gt;b_ind_cpp_extern_c;</a>
<a name="ln2556">            }</a>
<a name="ln2557">          } else {</a>
<a name="ln2558">            // Compensate for adding b_ind_open_extra later.</a>
<a name="ln2559">            amount -= curbuf-&gt;b_ind_open_extra;</a>
<a name="ln2560">            if (amount &lt; 0) {</a>
<a name="ln2561">              amount = 0;</a>
<a name="ln2562">            }</a>
<a name="ln2563">          }</a>
<a name="ln2564">        }</a>
<a name="ln2565"> </a>
<a name="ln2566">        lookfor_break = FALSE;</a>
<a name="ln2567"> </a>
<a name="ln2568">        if (cin_iscase(theline, false)) {       // it's a switch() label</a>
<a name="ln2569">          lookfor = LOOKFOR_CASE;       // find a previous switch() label</a>
<a name="ln2570">          amount += curbuf-&gt;b_ind_case;</a>
<a name="ln2571">        } else if (cin_isscopedecl(theline)) {  // private:, ...</a>
<a name="ln2572">          lookfor = LOOKFOR_SCOPEDECL;          // class decl is this block</a>
<a name="ln2573">          amount += curbuf-&gt;b_ind_scopedecl;</a>
<a name="ln2574">        } else {</a>
<a name="ln2575">          if (curbuf-&gt;b_ind_case_break &amp;&amp; cin_isbreak(theline)) {</a>
<a name="ln2576">            // break; ...</a>
<a name="ln2577">            lookfor_break = true;</a>
<a name="ln2578">          }</a>
<a name="ln2579"> </a>
<a name="ln2580">          lookfor = LOOKFOR_INITIAL;</a>
<a name="ln2581">          // b_ind_level from start of block</a>
<a name="ln2582">          amount += curbuf-&gt;b_ind_level;</a>
<a name="ln2583">        }</a>
<a name="ln2584">        scope_amount = amount;</a>
<a name="ln2585">        whilelevel = 0;</a>
<a name="ln2586"> </a>
<a name="ln2587">        // Search backwards.  If we find something we recognize, line up</a>
<a name="ln2588">        // with that.</a>
<a name="ln2589">        //</a>
<a name="ln2590">        // If we're looking at an open brace, indent</a>
<a name="ln2591">        // the usual amount relative to the conditional</a>
<a name="ln2592">        // that opens the block.</a>
<a name="ln2593">        curwin-&gt;w_cursor = cur_curpos;</a>
<a name="ln2594">        for (;;) {</a>
<a name="ln2595">          curwin-&gt;w_cursor.lnum--;</a>
<a name="ln2596">          curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2597"> </a>
<a name="ln2598">          /*</a>
<a name="ln2599">           * If we went all the way back to the start of our scope, line</a>
<a name="ln2600">           * up with it.</a>
<a name="ln2601">           */</a>
<a name="ln2602">          if (curwin-&gt;w_cursor.lnum &lt;= ourscope) {</a>
<a name="ln2603">            // We reached end of scope:</a>
<a name="ln2604">            // If looking for a enum or structure initialization</a>
<a name="ln2605">            // go further back:</a>
<a name="ln2606">            // If it is an initializer (enum xxx or xxx =), then</a>
<a name="ln2607">            // don't add ind_continuation, otherwise it is a variable</a>
<a name="ln2608">            // declaration:</a>
<a name="ln2609">            // int x,</a>
<a name="ln2610">            //     here; &lt;-- add ind_continuation</a>
<a name="ln2611">            if (lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln2612">              if (curwin-&gt;w_cursor.lnum == 0</a>
<a name="ln2613">                  || curwin-&gt;w_cursor.lnum</a>
<a name="ln2614">                  &lt; ourscope - curbuf-&gt;b_ind_maxparen) {</a>
<a name="ln2615">                /* nothing found (abuse curbuf-&gt;b_ind_maxparen as</a>
<a name="ln2616">                 * limit) assume terminated line (i.e. a variable</a>
<a name="ln2617">                 * initialization) */</a>
<a name="ln2618">                if (cont_amount &gt; 0) {</a>
<a name="ln2619">                  amount = cont_amount;</a>
<a name="ln2620">                } else if (!curbuf-&gt;b_ind_js) {</a>
<a name="ln2621">                  amount += ind_continuation;</a>
<a name="ln2622">                }</a>
<a name="ln2623">                break;</a>
<a name="ln2624">              }</a>
<a name="ln2625"> </a>
<a name="ln2626">              l = get_cursor_line_ptr();</a>
<a name="ln2627"> </a>
<a name="ln2628">              /*</a>
<a name="ln2629">               * If we're in a comment or raw string now, skip to</a>
<a name="ln2630">               * the start of it.</a>
<a name="ln2631">               */</a>
<a name="ln2632">              trypos = ind_find_start_CORS(NULL);</a>
<a name="ln2633">              if (trypos != NULL) {</a>
<a name="ln2634">                curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2635">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2636">                continue;</a>
<a name="ln2637">              }</a>
<a name="ln2638"> </a>
<a name="ln2639">              //</a>
<a name="ln2640">              // Skip preprocessor directives and blank lines.</a>
<a name="ln2641">              //</a>
<a name="ln2642">              if (cin_ispreproc_cont(&amp;l, &amp;curwin-&gt;w_cursor.lnum, &amp;amount)) {</a>
<a name="ln2643">                continue;</a>
<a name="ln2644">              }</a>
<a name="ln2645"> </a>
<a name="ln2646">              if (cin_nocode(l)) {</a>
<a name="ln2647">                continue;</a>
<a name="ln2648">              }</a>
<a name="ln2649"> </a>
<a name="ln2650">              terminated = cin_isterminated(l, FALSE, TRUE);</a>
<a name="ln2651"> </a>
<a name="ln2652">              /*</a>
<a name="ln2653">               * If we are at top level and the line looks like a</a>
<a name="ln2654">               * function declaration, we are done</a>
<a name="ln2655">               * (it's a variable declaration).</a>
<a name="ln2656">               */</a>
<a name="ln2657">              if (start_brace != BRACE_IN_COL0</a>
<a name="ln2658">                  || !cin_isfuncdecl(&amp;l, curwin-&gt;w_cursor.lnum, 0)) {</a>
<a name="ln2659">                /* if the line is terminated with another ','</a>
<a name="ln2660">                 * it is a continued variable initialization.</a>
<a name="ln2661">                 * don't add extra indent.</a>
<a name="ln2662">                 * TODO: does not work, if  a function</a>
<a name="ln2663">                 * declaration is split over multiple lines:</a>
<a name="ln2664">                 * cin_isfuncdecl returns FALSE then.</a>
<a name="ln2665">                 */</a>
<a name="ln2666">                if (terminated == ',') {</a>
<a name="ln2667">                  break;</a>
<a name="ln2668">                }</a>
<a name="ln2669"> </a>
<a name="ln2670">                /* if it is an enum declaration or an assignment,</a>
<a name="ln2671">                 * we are done.</a>
<a name="ln2672">                 */</a>
<a name="ln2673">                if (terminated != ';' &amp;&amp; cin_isinit()) {</a>
<a name="ln2674">                  break;</a>
<a name="ln2675">                }</a>
<a name="ln2676"> </a>
<a name="ln2677">                // nothing useful found</a>
<a name="ln2678">                if (terminated == 0 || terminated == '{') {</a>
<a name="ln2679">                  continue;</a>
<a name="ln2680">                }</a>
<a name="ln2681">              }</a>
<a name="ln2682"> </a>
<a name="ln2683">              if (terminated != ';') {</a>
<a name="ln2684">                // Skip parens and braces. Position the cursor</a>
<a name="ln2685">                // over the rightmost paren, so that matching it</a>
<a name="ln2686">                // will take us back to the start of the line.</a>
<a name="ln2687">                // XXX</a>
<a name="ln2688">                trypos = NULL;</a>
<a name="ln2689">                if (find_last_paren(l, '(', ')')) {</a>
<a name="ln2690">                  trypos = find_match_paren(curbuf-&gt;b_ind_maxparen);</a>
<a name="ln2691">                }</a>
<a name="ln2692"> </a>
<a name="ln2693">                if (trypos == NULL &amp;&amp; find_last_paren(l, '{', '}')) {</a>
<a name="ln2694">                  trypos = find_start_brace();</a>
<a name="ln2695">                }</a>
<a name="ln2696"> </a>
<a name="ln2697">                if (trypos != NULL) {</a>
<a name="ln2698">                  curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2699">                  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2700">                  continue;</a>
<a name="ln2701">                }</a>
<a name="ln2702">              }</a>
<a name="ln2703"> </a>
<a name="ln2704">              /* it's a variable declaration, add indentation</a>
<a name="ln2705">               * like in</a>
<a name="ln2706">               * int a,</a>
<a name="ln2707">               *    b;</a>
<a name="ln2708">               */</a>
<a name="ln2709">              if (cont_amount &gt; 0) {</a>
<a name="ln2710">                amount = cont_amount;</a>
<a name="ln2711">              } else {</a>
<a name="ln2712">                amount += ind_continuation;</a>
<a name="ln2713">              }</a>
<a name="ln2714">            } else if (lookfor == LOOKFOR_UNTERM) {</a>
<a name="ln2715">              if (cont_amount &gt; 0) {</a>
<a name="ln2716">                amount = cont_amount;</a>
<a name="ln2717">              } else {</a>
<a name="ln2718">                amount += ind_continuation;</a>
<a name="ln2719">              }</a>
<a name="ln2720">            } else {</a>
<a name="ln2721">              if (lookfor != LOOKFOR_TERM</a>
<a name="ln2722">                  &amp;&amp; lookfor != LOOKFOR_CPP_BASECLASS</a>
<a name="ln2723">                  &amp;&amp; lookfor != LOOKFOR_COMMA) {</a>
<a name="ln2724">                amount = scope_amount;</a>
<a name="ln2725">                if (theline[0] == '{') {</a>
<a name="ln2726">                  amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln2727">                  added_to_amount = curbuf-&gt;b_ind_open_extra;</a>
<a name="ln2728">                }</a>
<a name="ln2729">              }</a>
<a name="ln2730"> </a>
<a name="ln2731">              if (lookfor_cpp_namespace) {</a>
<a name="ln2732">                /*</a>
<a name="ln2733">                 * Looking for C++ namespace, need to look further</a>
<a name="ln2734">                 * back.</a>
<a name="ln2735">                 */</a>
<a name="ln2736">                if (curwin-&gt;w_cursor.lnum == ourscope) {</a>
<a name="ln2737">                  continue;</a>
<a name="ln2738">                }</a>
<a name="ln2739"> </a>
<a name="ln2740">                if (curwin-&gt;w_cursor.lnum == 0</a>
<a name="ln2741">                    || curwin-&gt;w_cursor.lnum</a>
<a name="ln2742">                    &lt; ourscope - FIND_NAMESPACE_LIM) {</a>
<a name="ln2743">                  break;</a>
<a name="ln2744">                }</a>
<a name="ln2745"> </a>
<a name="ln2746">                l = get_cursor_line_ptr();</a>
<a name="ln2747"> </a>
<a name="ln2748">                /* If we're in a comment or raw string now, skip</a>
<a name="ln2749">                 * to the start of it. */</a>
<a name="ln2750">                trypos = ind_find_start_CORS(NULL);</a>
<a name="ln2751">                if (trypos != NULL) {</a>
<a name="ln2752">                  curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2753">                  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2754">                  continue;</a>
<a name="ln2755">                }</a>
<a name="ln2756"> </a>
<a name="ln2757">                // Skip preprocessor directives and blank lines.</a>
<a name="ln2758">                if (cin_ispreproc_cont(&amp;l, &amp;curwin-&gt;w_cursor.lnum, &amp;amount)) {</a>
<a name="ln2759">                  continue;</a>
<a name="ln2760">                }</a>
<a name="ln2761"> </a>
<a name="ln2762">                // Finally the actual check for &quot;namespace&quot;.</a>
<a name="ln2763">                if (cin_is_cpp_namespace(l)) {</a>
<a name="ln2764">                  amount += curbuf-&gt;b_ind_cpp_namespace</a>
<a name="ln2765">                            - added_to_amount;</a>
<a name="ln2766">                  break;</a>
<a name="ln2767">                } else if (cin_is_cpp_extern_c(l)) {</a>
<a name="ln2768">                  amount += curbuf-&gt;b_ind_cpp_extern_c - added_to_amount;</a>
<a name="ln2769">                  break;</a>
<a name="ln2770">                }</a>
<a name="ln2771"> </a>
<a name="ln2772">                if (cin_nocode(l)) {</a>
<a name="ln2773">                  continue;</a>
<a name="ln2774">                }</a>
<a name="ln2775">              }</a>
<a name="ln2776">            }</a>
<a name="ln2777">            break;</a>
<a name="ln2778">          }</a>
<a name="ln2779"> </a>
<a name="ln2780">          // If we're in a comment or raw string now, skip to the start</a>
<a name="ln2781">          // of it.</a>
<a name="ln2782">          // XXX</a>
<a name="ln2783">          if ((trypos = ind_find_start_CORS(&amp;raw_string_start)) != NULL) {</a>
<a name="ln2784">            curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2785">            curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2786">            continue;</a>
<a name="ln2787">          }</a>
<a name="ln2788"> </a>
<a name="ln2789">          l = get_cursor_line_ptr();</a>
<a name="ln2790"> </a>
<a name="ln2791">          /*</a>
<a name="ln2792">           * If this is a switch() label, may line up relative to that.</a>
<a name="ln2793">           * If this is a C++ scope declaration, do the same.</a>
<a name="ln2794">           */</a>
<a name="ln2795">          bool iscase = cin_iscase(l, false);</a>
<a name="ln2796">          if (iscase || cin_isscopedecl(l)) {</a>
<a name="ln2797">            /* we are only looking for cpp base class</a>
<a name="ln2798">             * declaration/initialization any longer */</a>
<a name="ln2799">            if (lookfor == LOOKFOR_CPP_BASECLASS) {</a>
<a name="ln2800">              break;</a>
<a name="ln2801">            }</a>
<a name="ln2802"> </a>
<a name="ln2803">            /* When looking for a &quot;do&quot; we are not interested in</a>
<a name="ln2804">             * labels. */</a>
<a name="ln2805">            if (whilelevel &gt; 0) {</a>
<a name="ln2806">              continue;</a>
<a name="ln2807">            }</a>
<a name="ln2808"> </a>
<a name="ln2809">            //  case xx:</a>
<a name="ln2810">            //      c = 99 +        &lt;- this indent plus continuation</a>
<a name="ln2811">            // -&gt;          here;</a>
<a name="ln2812">            if (lookfor == LOOKFOR_UNTERM || lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln2813">              if (cont_amount &gt; 0) {</a>
<a name="ln2814">                amount = cont_amount;</a>
<a name="ln2815">              } else {</a>
<a name="ln2816">                amount += ind_continuation;</a>
<a name="ln2817">              }</a>
<a name="ln2818">              break;</a>
<a name="ln2819">            }</a>
<a name="ln2820"> </a>
<a name="ln2821">            // case xx: &lt;- line up with this case</a>
<a name="ln2822">            //     x = 333;</a>
<a name="ln2823">            // case yy:</a>
<a name="ln2824">            if ((iscase &amp;&amp; lookfor == LOOKFOR_CASE)</a>
<a name="ln2825">                || (iscase &amp;&amp; lookfor_break)</a>
<a name="ln2826">                || (!iscase &amp;&amp; lookfor == LOOKFOR_SCOPEDECL)) {</a>
<a name="ln2827">              // Check that this case label is not for another</a>
<a name="ln2828">              // switch()</a>
<a name="ln2829">              // XXX</a>
<a name="ln2830">              if ((trypos = find_start_brace()) == NULL</a>
<a name="ln2831">                  || trypos-&gt;lnum == ourscope) {</a>
<a name="ln2832">                amount = get_indent();                  // XXX</a>
<a name="ln2833">                break;</a>
<a name="ln2834">              }</a>
<a name="ln2835">              continue;</a>
<a name="ln2836">            }</a>
<a name="ln2837"> </a>
<a name="ln2838">            n = get_indent_nolabel(curwin-&gt;w_cursor.lnum);          // XXX</a>
<a name="ln2839"> </a>
<a name="ln2840">            //   case xx: if (cond)         &lt;- line up with this if</a>
<a name="ln2841">            //                y = y + 1;</a>
<a name="ln2842">            // -&gt;         s = 99;</a>
<a name="ln2843">            //</a>
<a name="ln2844">            //   case xx:</a>
<a name="ln2845">            //       if (cond)          &lt;- line up with this line</a>
<a name="ln2846">            //           y = y + 1;</a>
<a name="ln2847">            // -&gt;    s = 99;</a>
<a name="ln2848">            if (lookfor == LOOKFOR_TERM) {</a>
<a name="ln2849">              if (n) {</a>
<a name="ln2850">                amount = n;</a>
<a name="ln2851">              }</a>
<a name="ln2852"> </a>
<a name="ln2853">              if (!lookfor_break) {</a>
<a name="ln2854">                break;</a>
<a name="ln2855">              }</a>
<a name="ln2856">            }</a>
<a name="ln2857"> </a>
<a name="ln2858">            //   case xx: x = x + 1;        &lt;- line up with this x</a>
<a name="ln2859">            // -&gt;         y = y + 1;</a>
<a name="ln2860">            //</a>
<a name="ln2861">            //   case xx: if (cond)         &lt;- line up with this if</a>
<a name="ln2862">            // -&gt;              y = y + 1;</a>
<a name="ln2863">            if (n) {</a>
<a name="ln2864">              amount = n;</a>
<a name="ln2865">              l = after_label(get_cursor_line_ptr());</a>
<a name="ln2866">              if (l != NULL &amp;&amp; cin_is_cinword(l)) {</a>
<a name="ln2867">                if (theline[0] == '{') {</a>
<a name="ln2868">                  amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln2869">                } else {</a>
<a name="ln2870">                  amount += curbuf-&gt;b_ind_level</a>
<a name="ln2871">                            + curbuf-&gt;b_ind_no_brace;</a>
<a name="ln2872">                }</a>
<a name="ln2873">              }</a>
<a name="ln2874">              break;</a>
<a name="ln2875">            }</a>
<a name="ln2876"> </a>
<a name="ln2877">            /*</a>
<a name="ln2878">             * Try to get the indent of a statement before the switch</a>
<a name="ln2879">             * label.  If nothing is found, line up relative to the</a>
<a name="ln2880">             * switch label.</a>
<a name="ln2881">             *      break;              &lt;- may line up with this line</a>
<a name="ln2882">             *   case xx:</a>
<a name="ln2883">             * -&gt;   y = 1;</a>
<a name="ln2884">             */</a>
<a name="ln2885">            scope_amount = get_indent() + (iscase            // XXX</a>
<a name="ln2886">                                           ? curbuf-&gt;b_ind_case_code</a>
<a name="ln2887">                                           : curbuf-&gt;b_ind_scopedecl_code);</a>
<a name="ln2888">            lookfor = curbuf-&gt;b_ind_case_break</a>
<a name="ln2889">                      ? LOOKFOR_NOBREAK : LOOKFOR_ANY;</a>
<a name="ln2890">            continue;</a>
<a name="ln2891">          }</a>
<a name="ln2892"> </a>
<a name="ln2893">          /*</a>
<a name="ln2894">           * Looking for a switch() label or C++ scope declaration,</a>
<a name="ln2895">           * ignore other lines, skip {}-blocks.</a>
<a name="ln2896">           */</a>
<a name="ln2897">          if (lookfor == LOOKFOR_CASE || lookfor == LOOKFOR_SCOPEDECL) {</a>
<a name="ln2898">            if (find_last_paren(l, '{', '}')</a>
<a name="ln2899">                &amp;&amp; (trypos = find_start_brace()) != NULL) {</a>
<a name="ln2900">              curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln2901">              curwin-&gt;w_cursor.col = 0;</a>
<a name="ln2902">            }</a>
<a name="ln2903">            continue;</a>
<a name="ln2904">          }</a>
<a name="ln2905"> </a>
<a name="ln2906">          /*</a>
<a name="ln2907">           * Ignore jump labels with nothing after them.</a>
<a name="ln2908">           */</a>
<a name="ln2909">          if (!curbuf-&gt;b_ind_js &amp;&amp; cin_islabel()) {</a>
<a name="ln2910">            l = after_label(get_cursor_line_ptr());</a>
<a name="ln2911">            if (l == NULL || cin_nocode(l)) {</a>
<a name="ln2912">              continue;</a>
<a name="ln2913">            }</a>
<a name="ln2914">          }</a>
<a name="ln2915"> </a>
<a name="ln2916">          /*</a>
<a name="ln2917">           * Ignore #defines, #if, etc.</a>
<a name="ln2918">           * Ignore comment and empty lines.</a>
<a name="ln2919">           * (need to get the line again, cin_islabel() may have</a>
<a name="ln2920">           * unlocked it)</a>
<a name="ln2921">           */</a>
<a name="ln2922">          l = get_cursor_line_ptr();</a>
<a name="ln2923">          if (cin_ispreproc_cont(&amp;l, &amp;curwin-&gt;w_cursor.lnum, &amp;amount)</a>
<a name="ln2924">              || cin_nocode(l)) {</a>
<a name="ln2925">            continue;</a>
<a name="ln2926">          }</a>
<a name="ln2927"> </a>
<a name="ln2928">          // Are we at the start of a cpp base class declaration or</a>
<a name="ln2929">          // constructor initialization?</a>
<a name="ln2930">          // XXX</a>
<a name="ln2931">          n = 0;</a>
<a name="ln2932">          if (lookfor != LOOKFOR_TERM &amp;&amp; curbuf-&gt;b_ind_cpp_baseclass &gt; 0) {</a>
<a name="ln2933">            n = cin_is_cpp_baseclass(&amp;cache_cpp_baseclass);</a>
<a name="ln2934">            l = get_cursor_line_ptr();</a>
<a name="ln2935">          }</a>
<a name="ln2936">          if (n) {</a>
<a name="ln2937">            if (lookfor == LOOKFOR_UNTERM) {</a>
<a name="ln2938">              if (cont_amount &gt; 0) {</a>
<a name="ln2939">                amount = cont_amount;</a>
<a name="ln2940">              } else {</a>
<a name="ln2941">                amount += ind_continuation;</a>
<a name="ln2942">              }</a>
<a name="ln2943">            } else if (theline[0] == '{') {</a>
<a name="ln2944">              // Need to find start of the declaration.</a>
<a name="ln2945">              lookfor = LOOKFOR_UNTERM;</a>
<a name="ln2946">              ind_continuation = 0;</a>
<a name="ln2947">              continue;</a>
<a name="ln2948">            } else {</a>
<a name="ln2949">              // XXX</a>
<a name="ln2950">              amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);</a>
<a name="ln2951">            }</a>
<a name="ln2952">            break;</a>
<a name="ln2953">          } else if (lookfor == LOOKFOR_CPP_BASECLASS) {</a>
<a name="ln2954">            /* only look, whether there is a cpp base class</a>
<a name="ln2955">             * declaration or initialization before the opening brace.</a>
<a name="ln2956">             */</a>
<a name="ln2957">            if (cin_isterminated(l, true, false)) {</a>
<a name="ln2958">              break;</a>
<a name="ln2959">            } else {</a>
<a name="ln2960">              continue;</a>
<a name="ln2961">            }</a>
<a name="ln2962">          }</a>
<a name="ln2963"> </a>
<a name="ln2964">          /*</a>
<a name="ln2965">           * What happens next depends on the line being terminated.</a>
<a name="ln2966">           * If terminated with a ',' only consider it terminating if</a>
<a name="ln2967">           * there is another unterminated statement behind, eg:</a>
<a name="ln2968">           *   123,</a>
<a name="ln2969">           *   sizeof</a>
<a name="ln2970">           *      here</a>
<a name="ln2971">           * Otherwise check whether it is an enumeration or structure</a>
<a name="ln2972">           * initialisation (not indented) or a variable declaration</a>
<a name="ln2973">           * (indented).</a>
<a name="ln2974">           */</a>
<a name="ln2975">          terminated = cin_isterminated(l, FALSE, TRUE);</a>
<a name="ln2976"> </a>
<a name="ln2977">          if (js_cur_has_key) {</a>
<a name="ln2978">            js_cur_has_key = false;  // only check the first line</a>
<a name="ln2979">            if (curbuf-&gt;b_ind_js &amp;&amp; terminated == ',') {</a>
<a name="ln2980">              // For Javascript we might be inside an object:</a>
<a name="ln2981">              //   key: something,  &lt;- align with this</a>
<a name="ln2982">              //   key: something</a>
<a name="ln2983">              // or:</a>
<a name="ln2984">              //   key: something +  &lt;- align with this</a>
<a name="ln2985">              //       something,</a>
<a name="ln2986">              //   key: something</a>
<a name="ln2987">              lookfor = LOOKFOR_JS_KEY;</a>
<a name="ln2988">            }</a>
<a name="ln2989">          }</a>
<a name="ln2990">          if (lookfor == LOOKFOR_JS_KEY &amp;&amp; cin_has_js_key(l)) {</a>
<a name="ln2991">            amount = get_indent();</a>
<a name="ln2992">            break;</a>
<a name="ln2993">          }</a>
<a name="ln2994">          if (lookfor == LOOKFOR_COMMA) {</a>
<a name="ln2995">            if (tryposBrace != NULL &amp;&amp; tryposBrace-&gt;lnum</a>
<a name="ln2996">                &gt;= curwin-&gt;w_cursor.lnum) {</a>
<a name="ln2997">              break;</a>
<a name="ln2998">            }</a>
<a name="ln2999">            if (terminated == ',') {</a>
<a name="ln3000">              // Line below current line is the one that starts a</a>
<a name="ln3001">              // (possibly broken) line ending in a comma.</a>
<a name="ln3002">              break;</a>
<a name="ln3003">            } else {</a>
<a name="ln3004">              amount = get_indent();</a>
<a name="ln3005">              if (curwin-&gt;w_cursor.lnum - 1 == ourscope) {</a>
<a name="ln3006">                // line above is start of the scope, thus current</a>
<a name="ln3007">                // line is the one that stars a (possibly broken)</a>
<a name="ln3008">                // line ending in a comma.</a>
<a name="ln3009">                break;</a>
<a name="ln3010">              }</a>
<a name="ln3011">            }</a>
<a name="ln3012">          }</a>
<a name="ln3013"> </a>
<a name="ln3014">          if (terminated == 0 || (lookfor != LOOKFOR_UNTERM</a>
<a name="ln3015">                                  &amp;&amp; terminated == ',')) {</a>
<a name="ln3016">            if (lookfor != LOOKFOR_ENUM_OR_INIT</a>
<a name="ln3017">                &amp;&amp; (*skipwhite((char *)l) == '[' || l[STRLEN(l) - 1] == '[')) {</a>
<a name="ln3018">              amount += ind_continuation;</a>
<a name="ln3019">            }</a>
<a name="ln3020">            // If we're in the middle of a paren thing, Go back to the line</a>
<a name="ln3021">            // that starts it so we can get the right prevailing indent</a>
<a name="ln3022">            //     if ( foo &amp;&amp;</a>
<a name="ln3023">            //              bar )</a>
<a name="ln3024"> </a>
<a name="ln3025">            // Position the cursor over the rightmost paren, so that</a>
<a name="ln3026">            // matching it will take us back to the start of the line.</a>
<a name="ln3027">            // Ignore a match before the start of the block.</a>
<a name="ln3028">            (void)find_last_paren(l, '(', ')');</a>
<a name="ln3029">            trypos = find_match_paren(corr_ind_maxparen(&amp;cur_curpos));</a>
<a name="ln3030">            if (trypos != NULL &amp;&amp; (trypos-&gt;lnum &lt; tryposBrace-&gt;lnum</a>
<a name="ln3031">                                   || (trypos-&gt;lnum == tryposBrace-&gt;lnum</a>
<a name="ln3032">                                       &amp;&amp; trypos-&gt;col &lt; tryposBrace-&gt;col))) {</a>
<a name="ln3033">              trypos = NULL;</a>
<a name="ln3034">            }</a>
<a name="ln3035"> </a>
<a name="ln3036">            // If we are looking for ',', we also look for matching</a>
<a name="ln3037">            // braces.</a>
<a name="ln3038">            if (trypos == NULL &amp;&amp; terminated == ','</a>
<a name="ln3039">                &amp;&amp; find_last_paren(l, '{', '}')) {</a>
<a name="ln3040">              trypos = find_start_brace();</a>
<a name="ln3041">            }</a>
<a name="ln3042"> </a>
<a name="ln3043">            if (trypos != NULL) {</a>
<a name="ln3044">              /*</a>
<a name="ln3045">               * Check if we are on a case label now.  This is</a>
<a name="ln3046">               * handled above.</a>
<a name="ln3047">               *     case xx:  if ( asdf &amp;&amp;</a>
<a name="ln3048">               *                        asdf)</a>
<a name="ln3049">               */</a>
<a name="ln3050">              curwin-&gt;w_cursor = *trypos;</a>
<a name="ln3051">              l = get_cursor_line_ptr();</a>
<a name="ln3052">              if (cin_iscase(l, false) || cin_isscopedecl(l)) {</a>
<a name="ln3053">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3054">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3055">                continue;</a>
<a name="ln3056">              }</a>
<a name="ln3057">            }</a>
<a name="ln3058"> </a>
<a name="ln3059">            /*</a>
<a name="ln3060">             * Skip over continuation lines to find the one to get the</a>
<a name="ln3061">             * indent from</a>
<a name="ln3062">             * char *usethis = &quot;bla\</a>
<a name="ln3063">             *           bla&quot;,</a>
<a name="ln3064">             *      here;</a>
<a name="ln3065">             */</a>
<a name="ln3066">            if (terminated == ',') {</a>
<a name="ln3067">              while (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln3068">                l = ml_get(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln3069">                if (*l == NUL || l[STRLEN(l) - 1] != '\\') {</a>
<a name="ln3070">                  break;</a>
<a name="ln3071">                }</a>
<a name="ln3072">                curwin-&gt;w_cursor.lnum--;</a>
<a name="ln3073">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3074">              }</a>
<a name="ln3075">            }</a>
<a name="ln3076"> </a>
<a name="ln3077">            /*</a>
<a name="ln3078">             * Get indent and pointer to text for current line,</a>
<a name="ln3079">             * ignoring any jump label.     XXX</a>
<a name="ln3080">             */</a>
<a name="ln3081">            if (curbuf-&gt;b_ind_js) {</a>
<a name="ln3082">              cur_amount = get_indent();</a>
<a name="ln3083">            } else {</a>
<a name="ln3084">              cur_amount = skip_label(curwin-&gt;w_cursor.lnum, &amp;l);</a>
<a name="ln3085">            }</a>
<a name="ln3086">            /*</a>
<a name="ln3087">             * If this is just above the line we are indenting, and it</a>
<a name="ln3088">             * starts with a '{', line it up with this line.</a>
<a name="ln3089">             *          while (not)</a>
<a name="ln3090">             * -&gt;       {</a>
<a name="ln3091">             *          }</a>
<a name="ln3092">             */</a>
<a name="ln3093">            if (terminated != ',' &amp;&amp; lookfor != LOOKFOR_TERM</a>
<a name="ln3094">                &amp;&amp; theline[0] == '{') {</a>
<a name="ln3095">              amount = cur_amount;</a>
<a name="ln3096">              /*</a>
<a name="ln3097">               * Only add b_ind_open_extra when the current line</a>
<a name="ln3098">               * doesn't start with a '{', which must have a match</a>
<a name="ln3099">               * in the same line (scope is the same).  Probably:</a>
<a name="ln3100">               *        { 1, 2 },</a>
<a name="ln3101">               * -&gt;     { 3, 4 }</a>
<a name="ln3102">               */</a>
<a name="ln3103">              if (*skipwhite((char *)l) != '{') {</a>
<a name="ln3104">                amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln3105">              }</a>
<a name="ln3106"> </a>
<a name="ln3107">              if (curbuf-&gt;b_ind_cpp_baseclass &amp;&amp; !curbuf-&gt;b_ind_js) {</a>
<a name="ln3108">                /* have to look back, whether it is a cpp base</a>
<a name="ln3109">                 * class declaration or initialization */</a>
<a name="ln3110">                lookfor = LOOKFOR_CPP_BASECLASS;</a>
<a name="ln3111">                continue;</a>
<a name="ln3112">              }</a>
<a name="ln3113">              break;</a>
<a name="ln3114">            }</a>
<a name="ln3115"> </a>
<a name="ln3116">            /*</a>
<a name="ln3117">             * Check if we are after an &quot;if&quot;, &quot;while&quot;, etc.</a>
<a name="ln3118">             * Also allow &quot;   } else&quot;.</a>
<a name="ln3119">             */</a>
<a name="ln3120">            if (cin_is_cinword(l) || cin_iselse((char_u *)skipwhite((char *)l))) {</a>
<a name="ln3121">              // Found an unterminated line after an if (), line up</a>
<a name="ln3122">              // with the last one.</a>
<a name="ln3123">              //   if (cond)</a>
<a name="ln3124">              //             100 +</a>
<a name="ln3125">              // -&gt;              here;</a>
<a name="ln3126">              if (lookfor == LOOKFOR_UNTERM</a>
<a name="ln3127">                  || lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln3128">                if (cont_amount &gt; 0) {</a>
<a name="ln3129">                  amount = cont_amount;</a>
<a name="ln3130">                } else {</a>
<a name="ln3131">                  amount += ind_continuation;</a>
<a name="ln3132">                }</a>
<a name="ln3133">                break;</a>
<a name="ln3134">              }</a>
<a name="ln3135"> </a>
<a name="ln3136">              /*</a>
<a name="ln3137">               * If this is just above the line we are indenting, we</a>
<a name="ln3138">               * are finished.</a>
<a name="ln3139">               *            while (not)</a>
<a name="ln3140">               * -&gt;             here;</a>
<a name="ln3141">               * Otherwise this indent can be used when the line</a>
<a name="ln3142">               * before this is terminated.</a>
<a name="ln3143">               *        yyy;</a>
<a name="ln3144">               *        if (stat)</a>
<a name="ln3145">               *            while (not)</a>
<a name="ln3146">               *                xxx;</a>
<a name="ln3147">               * -&gt;     here;</a>
<a name="ln3148">               */</a>
<a name="ln3149">              amount = cur_amount;</a>
<a name="ln3150">              if (theline[0] == '{') {</a>
<a name="ln3151">                amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln3152">              }</a>
<a name="ln3153">              if (lookfor != LOOKFOR_TERM) {</a>
<a name="ln3154">                amount += curbuf-&gt;b_ind_level</a>
<a name="ln3155">                          + curbuf-&gt;b_ind_no_brace;</a>
<a name="ln3156">                break;</a>
<a name="ln3157">              }</a>
<a name="ln3158"> </a>
<a name="ln3159">              /*</a>
<a name="ln3160">               * Special trick: when expecting the while () after a</a>
<a name="ln3161">               * do, line up with the while()</a>
<a name="ln3162">               *     do</a>
<a name="ln3163">               *            x = 1;</a>
<a name="ln3164">               * -&gt;  here</a>
<a name="ln3165">               */</a>
<a name="ln3166">              l = (char_u *)skipwhite((char *)get_cursor_line_ptr());</a>
<a name="ln3167">              if (cin_isdo(l)) {</a>
<a name="ln3168">                if (whilelevel == 0) {</a>
<a name="ln3169">                  break;</a>
<a name="ln3170">                }</a>
<a name="ln3171">                whilelevel--;</a>
<a name="ln3172">              }</a>
<a name="ln3173"> </a>
<a name="ln3174">              /*</a>
<a name="ln3175">               * When searching for a terminated line, don't use the</a>
<a name="ln3176">               * one between the &quot;if&quot; and the matching &quot;else&quot;.</a>
<a name="ln3177">               * Need to use the scope of this &quot;else&quot;.  XXX</a>
<a name="ln3178">               * If whilelevel != 0 continue looking for a &quot;do {&quot;.</a>
<a name="ln3179">               */</a>
<a name="ln3180">              if (cin_iselse(l) &amp;&amp; whilelevel == 0) {</a>
<a name="ln3181">                /* If we're looking at &quot;} else&quot;, let's make sure we</a>
<a name="ln3182">                 * find the opening brace of the enclosing scope,</a>
<a name="ln3183">                 * not the one from &quot;if () {&quot;. */</a>
<a name="ln3184">                if (*l == '}') {</a>
<a name="ln3185">                  curwin-&gt;w_cursor.col =</a>
<a name="ln3186">                    (colnr_T)(l - get_cursor_line_ptr()) + 1;</a>
<a name="ln3187">                }</a>
<a name="ln3188"> </a>
<a name="ln3189">                if ((trypos = find_start_brace()) == NULL</a>
<a name="ln3190">                    || find_match(LOOKFOR_IF, trypos-&gt;lnum)</a>
<a name="ln3191">                    == FAIL) {</a>
<a name="ln3192">                  break;</a>
<a name="ln3193">                }</a>
<a name="ln3194">              }</a>
<a name="ln3195">            }</a>
<a name="ln3196">            /*</a>
<a name="ln3197">             * If we're below an unterminated line that is not an</a>
<a name="ln3198">             * &quot;if&quot; or something, we may line up with this line or</a>
<a name="ln3199">             * add something for a continuation line, depending on</a>
<a name="ln3200">             * the line before this one.</a>
<a name="ln3201">             */</a>
<a name="ln3202">            else {</a>
<a name="ln3203">              /*</a>
<a name="ln3204">               * Found two unterminated lines on a row, line up with</a>
<a name="ln3205">               * the last one.</a>
<a name="ln3206">               *   c = 99 +</a>
<a name="ln3207">               *            100 +</a>
<a name="ln3208">               * -&gt;         here;</a>
<a name="ln3209">               */</a>
<a name="ln3210">              if (lookfor == LOOKFOR_UNTERM) {</a>
<a name="ln3211">                // When line ends in a comma add extra indent</a>
<a name="ln3212">                if (terminated == ',') {</a>
<a name="ln3213">                  amount += ind_continuation;</a>
<a name="ln3214">                }</a>
<a name="ln3215">                break;</a>
<a name="ln3216">              }</a>
<a name="ln3217"> </a>
<a name="ln3218">              if (lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln3219">                /* Found two lines ending in ',', lineup with the</a>
<a name="ln3220">                 * lowest one, but check for cpp base class</a>
<a name="ln3221">                 * declaration/initialization, if it is an</a>
<a name="ln3222">                 * opening brace or we are looking just for</a>
<a name="ln3223">                 * enumerations/initializations. */</a>
<a name="ln3224">                if (terminated == ',') {</a>
<a name="ln3225">                  if (curbuf-&gt;b_ind_cpp_baseclass == 0) {</a>
<a name="ln3226">                    break;</a>
<a name="ln3227">                  }</a>
<a name="ln3228"> </a>
<a name="ln3229">                  lookfor = LOOKFOR_CPP_BASECLASS;</a>
<a name="ln3230">                  continue;</a>
<a name="ln3231">                }</a>
<a name="ln3232"> </a>
<a name="ln3233">                // Ignore unterminated lines in between, but</a>
<a name="ln3234">                // reduce indent.</a>
<a name="ln3235">                if (amount &gt; cur_amount) {</a>
<a name="ln3236">                  amount = cur_amount;</a>
<a name="ln3237">                }</a>
<a name="ln3238">              } else {</a>
<a name="ln3239">                // Found first unterminated line on a row, may</a>
<a name="ln3240">                // line up with this line, remember its indent</a>
<a name="ln3241">                //          100 +  //  NOLINT(whitespace/tab)</a>
<a name="ln3242">                // -&gt;       here;  //  NOLINT(whitespace/tab)</a>
<a name="ln3243">                l = get_cursor_line_ptr();</a>
<a name="ln3244">                amount = cur_amount;</a>
<a name="ln3245"> </a>
<a name="ln3246">                n = (int)STRLEN(l);</a>
<a name="ln3247">                if (terminated == ','</a>
<a name="ln3248">                    &amp;&amp; (*skipwhite((char *)l) == ']'</a>
<a name="ln3249">                        || (n &gt;= 2 &amp;&amp; l[n - 2] == ']'))) {</a>
<a name="ln3250">                  break;</a>
<a name="ln3251">                }</a>
<a name="ln3252"> </a>
<a name="ln3253">                // If previous line ends in ',', check whether we</a>
<a name="ln3254">                // are in an initialization or enum</a>
<a name="ln3255">                // struct xxx =</a>
<a name="ln3256">                // {</a>
<a name="ln3257">                //      sizeof a,</a>
<a name="ln3258">                //      124 };</a>
<a name="ln3259">                // or a normal possible continuation line.</a>
<a name="ln3260">                // but only, of no other statement has been found</a>
<a name="ln3261">                // yet.</a>
<a name="ln3262">                if (lookfor == LOOKFOR_INITIAL &amp;&amp; terminated == ',') {</a>
<a name="ln3263">                  if (curbuf-&gt;b_ind_js) {</a>
<a name="ln3264">                    // Search for a line ending in a comma</a>
<a name="ln3265">                    // and line up with the line below it</a>
<a name="ln3266">                    // (could be the current line).</a>
<a name="ln3267">                    // some = [</a>
<a name="ln3268">                    //     1,     &lt;- line up here</a>
<a name="ln3269">                    //     2,</a>
<a name="ln3270">                    // some = [</a>
<a name="ln3271">                    //     3 +    &lt;- line up here</a>
<a name="ln3272">                    //       4 *</a>
<a name="ln3273">                    //        5,</a>
<a name="ln3274">                    //     6,</a>
<a name="ln3275">                    if (cin_iscomment((char_u *)skipwhite((char *)l))) {</a>
<a name="ln3276">                      break;</a>
<a name="ln3277">                    }</a>
<a name="ln3278">                    lookfor = LOOKFOR_COMMA;</a>
<a name="ln3279">                    trypos = find_match_char('[', curbuf-&gt;b_ind_maxparen);</a>
<a name="ln3280">                    if (trypos != NULL) {</a>
<a name="ln3281">                      if (trypos-&gt;lnum == curwin-&gt;w_cursor.lnum - 1) {</a>
<a name="ln3282">                        // Current line is first inside</a>
<a name="ln3283">                        // [], line up with it.</a>
<a name="ln3284">                        break;</a>
<a name="ln3285">                      }</a>
<a name="ln3286">                      ourscope = trypos-&gt;lnum;</a>
<a name="ln3287">                    }</a>
<a name="ln3288">                  } else {</a>
<a name="ln3289">                    lookfor = LOOKFOR_ENUM_OR_INIT;</a>
<a name="ln3290">                    cont_amount = cin_first_id_amount();</a>
<a name="ln3291">                  }</a>
<a name="ln3292">                } else {</a>
<a name="ln3293">                  if (lookfor == LOOKFOR_INITIAL</a>
<a name="ln3294">                      &amp;&amp; *l != NUL</a>
<a name="ln3295">                      &amp;&amp; l[STRLEN(l) - 1] == '\\') {</a>
<a name="ln3296">                    // XXX</a>
<a name="ln3297">                    cont_amount = cin_get_equal_amount(curwin-&gt;w_cursor.lnum);</a>
<a name="ln3298">                  }</a>
<a name="ln3299">                  if (lookfor != LOOKFOR_TERM</a>
<a name="ln3300">                      &amp;&amp; lookfor != LOOKFOR_JS_KEY</a>
<a name="ln3301">                      &amp;&amp; lookfor != LOOKFOR_COMMA</a>
<a name="ln3302">                      &amp;&amp; raw_string_start != curwin-&gt;w_cursor.lnum) {</a>
<a name="ln3303">                    lookfor = LOOKFOR_UNTERM;</a>
<a name="ln3304">                  }</a>
<a name="ln3305">                }</a>
<a name="ln3306">              }</a>
<a name="ln3307">            }</a>
<a name="ln3308">          }</a>
<a name="ln3309">          /*</a>
<a name="ln3310">           * Check if we are after a while (cond);</a>
<a name="ln3311">           * If so: Ignore until the matching &quot;do&quot;.</a>
<a name="ln3312">           */</a>
<a name="ln3313">          else if (cin_iswhileofdo_end(terminated)) {  // XXX</a>
<a name="ln3314">            /*</a>
<a name="ln3315">             * Found an unterminated line after a while ();, line up</a>
<a name="ln3316">             * with the last one.</a>
<a name="ln3317">             *      while (cond);</a>
<a name="ln3318">             *      100 +               &lt;- line up with this one</a>
<a name="ln3319">             * -&gt;           here;</a>
<a name="ln3320">             */</a>
<a name="ln3321">            if (lookfor == LOOKFOR_UNTERM</a>
<a name="ln3322">                || lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln3323">              if (cont_amount &gt; 0) {</a>
<a name="ln3324">                amount = cont_amount;</a>
<a name="ln3325">              } else {</a>
<a name="ln3326">                amount += ind_continuation;</a>
<a name="ln3327">              }</a>
<a name="ln3328">              break;</a>
<a name="ln3329">            }</a>
<a name="ln3330"> </a>
<a name="ln3331">            if (whilelevel == 0) {</a>
<a name="ln3332">              lookfor = LOOKFOR_TERM;</a>
<a name="ln3333">              amount = get_indent();                // XXX</a>
<a name="ln3334">              if (theline[0] == '{') {</a>
<a name="ln3335">                amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln3336">              }</a>
<a name="ln3337">            }</a>
<a name="ln3338">            ++whilelevel;</a>
<a name="ln3339">          }</a>
<a name="ln3340">          /*</a>
<a name="ln3341">           * We are after a &quot;normal&quot; statement.</a>
<a name="ln3342">           * If we had another statement we can stop now and use the</a>
<a name="ln3343">           * indent of that other statement.</a>
<a name="ln3344">           * Otherwise the indent of the current statement may be used,</a>
<a name="ln3345">           * search backwards for the next &quot;normal&quot; statement.</a>
<a name="ln3346">           */</a>
<a name="ln3347">          else {</a>
<a name="ln3348">            /*</a>
<a name="ln3349">             * Skip single break line, if before a switch label. It</a>
<a name="ln3350">             * may be lined up with the case label.</a>
<a name="ln3351">             */</a>
<a name="ln3352">            if (lookfor == LOOKFOR_NOBREAK</a>
<a name="ln3353">                &amp;&amp; cin_isbreak((char_u *)skipwhite((char *)get_cursor_line_ptr()))) {</a>
<a name="ln3354">              lookfor = LOOKFOR_ANY;</a>
<a name="ln3355">              continue;</a>
<a name="ln3356">            }</a>
<a name="ln3357"> </a>
<a name="ln3358">            /*</a>
<a name="ln3359">             * Handle &quot;do {&quot; line.</a>
<a name="ln3360">             */</a>
<a name="ln3361">            if (whilelevel &gt; 0) {</a>
<a name="ln3362">              l = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln3363">              if (cin_isdo(l)) {</a>
<a name="ln3364">                amount = get_indent();                  // XXX</a>
<a name="ln3365">                whilelevel--;</a>
<a name="ln3366">                continue;</a>
<a name="ln3367">              }</a>
<a name="ln3368">            }</a>
<a name="ln3369"> </a>
<a name="ln3370">            /*</a>
<a name="ln3371">             * Found a terminated line above an unterminated line. Add</a>
<a name="ln3372">             * the amount for a continuation line.</a>
<a name="ln3373">             *   x = 1;</a>
<a name="ln3374">             *   y = foo +</a>
<a name="ln3375">             * -&gt;       here;</a>
<a name="ln3376">             * or</a>
<a name="ln3377">             *   int x = 1;</a>
<a name="ln3378">             *   int foo,</a>
<a name="ln3379">             * -&gt;       here;</a>
<a name="ln3380">             */</a>
<a name="ln3381">            if (lookfor == LOOKFOR_UNTERM</a>
<a name="ln3382">                || lookfor == LOOKFOR_ENUM_OR_INIT) {</a>
<a name="ln3383">              if (cont_amount &gt; 0) {</a>
<a name="ln3384">                amount = cont_amount;</a>
<a name="ln3385">              } else {</a>
<a name="ln3386">                amount += ind_continuation;</a>
<a name="ln3387">              }</a>
<a name="ln3388">              break;</a>
<a name="ln3389">            }</a>
<a name="ln3390"> </a>
<a name="ln3391">            /*</a>
<a name="ln3392">             * Found a terminated line above a terminated line or &quot;if&quot;</a>
<a name="ln3393">             * etc. line. Use the amount of the line below us.</a>
<a name="ln3394">             *   x = 1;                         x = 1;</a>
<a name="ln3395">             *   if (asdf)                  y = 2;</a>
<a name="ln3396">             *       while (asdf)         -&gt;here;</a>
<a name="ln3397">             *          here;</a>
<a name="ln3398">             * -&gt;foo;</a>
<a name="ln3399">             */</a>
<a name="ln3400">            if (lookfor == LOOKFOR_TERM) {</a>
<a name="ln3401">              if (!lookfor_break &amp;&amp; whilelevel == 0) {</a>
<a name="ln3402">                break;</a>
<a name="ln3403">              }</a>
<a name="ln3404">            }</a>
<a name="ln3405">            /*</a>
<a name="ln3406">             * First line above the one we're indenting is terminated.</a>
<a name="ln3407">             * To know what needs to be done look further backward for</a>
<a name="ln3408">             * a terminated line.</a>
<a name="ln3409">             */</a>
<a name="ln3410">            else {</a>
<a name="ln3411">              /*</a>
<a name="ln3412">               * position the cursor over the rightmost paren, so</a>
<a name="ln3413">               * that matching it will take us back to the start of</a>
<a name="ln3414">               * the line.  Helps for:</a>
<a name="ln3415">               *     func(asdr,</a>
<a name="ln3416">               *              asdfasdf);</a>
<a name="ln3417">               *     here;</a>
<a name="ln3418">               */</a>
<a name="ln3419">term_again:</a>
<a name="ln3420">              l = get_cursor_line_ptr();</a>
<a name="ln3421">              if (find_last_paren(l, '(', ')')</a>
<a name="ln3422">                  &amp;&amp; (trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln3423">                // Check if we are on a case label now.  This is</a>
<a name="ln3424">                // handled above.</a>
<a name="ln3425">                //         case xx:  if ( asdf &amp;&amp;</a>
<a name="ln3426">                //                          asdf)</a>
<a name="ln3427">                curwin-&gt;w_cursor = *trypos;</a>
<a name="ln3428">                l = get_cursor_line_ptr();</a>
<a name="ln3429">                if (cin_iscase(l, false) || cin_isscopedecl(l)) {</a>
<a name="ln3430">                  curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3431">                  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3432">                  continue;</a>
<a name="ln3433">                }</a>
<a name="ln3434">              }</a>
<a name="ln3435"> </a>
<a name="ln3436">              /* When aligning with the case statement, don't align</a>
<a name="ln3437">               * with a statement after it.</a>
<a name="ln3438">               *  case 1: {   &lt;-- don't use this { position</a>
<a name="ln3439">               *        stat;</a>
<a name="ln3440">               *  }</a>
<a name="ln3441">               *  case 2:</a>
<a name="ln3442">               *        stat;</a>
<a name="ln3443">               * }</a>
<a name="ln3444">               */</a>
<a name="ln3445">              iscase = curbuf-&gt;b_ind_keep_case_label &amp;&amp; cin_iscase(l, false);</a>
<a name="ln3446"> </a>
<a name="ln3447">              /*</a>
<a name="ln3448">               * Get indent and pointer to text for current line,</a>
<a name="ln3449">               * ignoring any jump label.</a>
<a name="ln3450">               */</a>
<a name="ln3451">              amount = skip_label(curwin-&gt;w_cursor.lnum, &amp;l);</a>
<a name="ln3452"> </a>
<a name="ln3453">              if (theline[0] == '{') {</a>
<a name="ln3454">                amount += curbuf-&gt;b_ind_open_extra;</a>
<a name="ln3455">              }</a>
<a name="ln3456">              // See remark above: &quot;Only add b_ind_open_extra..&quot;</a>
<a name="ln3457">              l = (char_u *)skipwhite((char *)l);</a>
<a name="ln3458">              if (*l == '{') {</a>
<a name="ln3459">                amount -= curbuf-&gt;b_ind_open_extra;</a>
<a name="ln3460">              }</a>
<a name="ln3461">              lookfor = iscase ? LOOKFOR_ANY : LOOKFOR_TERM;</a>
<a name="ln3462"> </a>
<a name="ln3463">              /*</a>
<a name="ln3464">               * When a terminated line starts with &quot;else&quot; skip to</a>
<a name="ln3465">               * the matching &quot;if&quot;:</a>
<a name="ln3466">               *       else 3;</a>
<a name="ln3467">               *             indent this;</a>
<a name="ln3468">               * Need to use the scope of this &quot;else&quot;.  XXX</a>
<a name="ln3469">               * If whilelevel != 0 continue looking for a &quot;do {&quot;.</a>
<a name="ln3470">               */</a>
<a name="ln3471">              if (lookfor == LOOKFOR_TERM</a>
<a name="ln3472">                  &amp;&amp; *l != '}'</a>
<a name="ln3473">                  &amp;&amp; cin_iselse(l)</a>
<a name="ln3474">                  &amp;&amp; whilelevel == 0) {</a>
<a name="ln3475">                if ((trypos = find_start_brace()) == NULL</a>
<a name="ln3476">                    || find_match(LOOKFOR_IF, trypos-&gt;lnum)</a>
<a name="ln3477">                    == FAIL) {</a>
<a name="ln3478">                  break;</a>
<a name="ln3479">                }</a>
<a name="ln3480">                continue;</a>
<a name="ln3481">              }</a>
<a name="ln3482"> </a>
<a name="ln3483">              /*</a>
<a name="ln3484">               * If we're at the end of a block, skip to the start of</a>
<a name="ln3485">               * that block.</a>
<a name="ln3486">               */</a>
<a name="ln3487">              l = get_cursor_line_ptr();</a>
<a name="ln3488">              if (find_last_paren(l, '{', '}')           // XXX</a>
<a name="ln3489">                  &amp;&amp; (trypos = find_start_brace()) != NULL) {</a>
<a name="ln3490">                curwin-&gt;w_cursor = *trypos;</a>
<a name="ln3491">                // if not &quot;else {&quot; check for terminated again</a>
<a name="ln3492">                // but skip block for &quot;} else {&quot;</a>
<a name="ln3493">                l = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln3494">                if (*l == '}' || !cin_iselse(l)) {</a>
<a name="ln3495">                  goto term_again;</a>
<a name="ln3496">                }</a>
<a name="ln3497">                curwin-&gt;w_cursor.lnum++;</a>
<a name="ln3498">                curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3499">              }</a>
<a name="ln3500">            }</a>
<a name="ln3501">          }</a>
<a name="ln3502">        }</a>
<a name="ln3503">      }</a>
<a name="ln3504">    }</a>
<a name="ln3505"> </a>
<a name="ln3506">    // add extra indent for a comment</a>
<a name="ln3507">    if (cin_iscomment(theline)) {</a>
<a name="ln3508">      amount += curbuf-&gt;b_ind_comment;</a>
<a name="ln3509">    }</a>
<a name="ln3510">    // subtract extra left-shift for jump labels</a>
<a name="ln3511">    if (curbuf-&gt;b_ind_jump_label &gt; 0 &amp;&amp; original_line_islabel) {</a>
<a name="ln3512">      amount -= curbuf-&gt;b_ind_jump_label;</a>
<a name="ln3513">    }</a>
<a name="ln3514"> </a>
<a name="ln3515">    goto theend;</a>
<a name="ln3516">  }</a>
<a name="ln3517"> </a>
<a name="ln3518">  // Ok -- we're not inside any sort of structure at all!</a>
<a name="ln3519">  //</a>
<a name="ln3520">  // this means we're at the top level, and everything should</a>
<a name="ln3521">  // basically just match where the previous line is, except</a>
<a name="ln3522">  // for the lines immediately following a function declaration,</a>
<a name="ln3523">  // which are K&amp;R-style parameters and need to be indented.</a>
<a name="ln3524"> </a>
<a name="ln3525">  // if our line starts with an open brace, forget about any</a>
<a name="ln3526">  // prevailing indent and make sure it looks like the start</a>
<a name="ln3527">  // of a function</a>
<a name="ln3528"> </a>
<a name="ln3529">  if (theline[0] == '{') {</a>
<a name="ln3530">    amount = curbuf-&gt;b_ind_first_open;</a>
<a name="ln3531">    goto theend;</a>
<a name="ln3532">  }</a>
<a name="ln3533">  /*</a>
<a name="ln3534">   * If the NEXT line is a function declaration, the current</a>
<a name="ln3535">   * line needs to be indented as a function type spec.</a>
<a name="ln3536">   * Don't do this if the current line looks like a comment or if the</a>
<a name="ln3537">   * current line is terminated, ie. ends in ';', or if the current line</a>
<a name="ln3538">   * contains { or }: &quot;void f() {\n if (1)&quot;</a>
<a name="ln3539">   */</a>
<a name="ln3540">  if (cur_curpos.lnum &lt; curbuf-&gt;b_ml.ml_line_count</a>
<a name="ln3541">      &amp;&amp; !cin_nocode(theline)</a>
<a name="ln3542">      &amp;&amp; vim_strchr((char *)theline, '{') == NULL</a>
<a name="ln3543">      &amp;&amp; vim_strchr((char *)theline, '}') == NULL</a>
<a name="ln3544">      &amp;&amp; !cin_ends_in(theline, (char_u *)&quot;:&quot;, NULL)</a>
<a name="ln3545">      &amp;&amp; !cin_ends_in(theline, (char_u *)&quot;,&quot;, NULL)</a>
<a name="ln3546">      &amp;&amp; cin_isfuncdecl(NULL, cur_curpos.lnum + 1, cur_curpos.lnum + 1)</a>
<a name="ln3547">      &amp;&amp; !cin_isterminated(theline, false, true)) {</a>
<a name="ln3548">    amount = curbuf-&gt;b_ind_func_type;</a>
<a name="ln3549">    goto theend;</a>
<a name="ln3550">  }</a>
<a name="ln3551"> </a>
<a name="ln3552">  // search backwards until we find something we recognize</a>
<a name="ln3553">  amount = 0;</a>
<a name="ln3554">  curwin-&gt;w_cursor = cur_curpos;</a>
<a name="ln3555">  while (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln3556">    curwin-&gt;w_cursor.lnum--;</a>
<a name="ln3557">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3558"> </a>
<a name="ln3559">    l = get_cursor_line_ptr();</a>
<a name="ln3560"> </a>
<a name="ln3561">    // If we're in a comment or raw string now, skip to the start</a>
<a name="ln3562">    // of it.</a>
<a name="ln3563">    // XXX</a>
<a name="ln3564">    if ((trypos = ind_find_start_CORS(NULL)) != NULL) {</a>
<a name="ln3565">      curwin-&gt;w_cursor.lnum = trypos-&gt;lnum + 1;</a>
<a name="ln3566">      curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3567">      continue;</a>
<a name="ln3568">    }</a>
<a name="ln3569"> </a>
<a name="ln3570">    // Are we at the start of a cpp base class declaration or</a>
<a name="ln3571">    // constructor initialization?  XXX</a>
<a name="ln3572">    n = 0;</a>
<a name="ln3573">    if (curbuf-&gt;b_ind_cpp_baseclass != 0 &amp;&amp; theline[0] != '{') {</a>
<a name="ln3574">      n = cin_is_cpp_baseclass(&amp;cache_cpp_baseclass);</a>
<a name="ln3575">      l = get_cursor_line_ptr();</a>
<a name="ln3576">    }</a>
<a name="ln3577">    if (n) {</a>
<a name="ln3578">      // XXX</a>
<a name="ln3579">      amount = get_baseclass_amount(cache_cpp_baseclass.lpos.col);</a>
<a name="ln3580">      break;</a>
<a name="ln3581">    }</a>
<a name="ln3582"> </a>
<a name="ln3583">    //</a>
<a name="ln3584">    // Skip preprocessor directives and blank lines.</a>
<a name="ln3585">    //</a>
<a name="ln3586">    if (cin_ispreproc_cont(&amp;l, &amp;curwin-&gt;w_cursor.lnum, &amp;amount)) {</a>
<a name="ln3587">      continue;</a>
<a name="ln3588">    }</a>
<a name="ln3589"> </a>
<a name="ln3590">    if (cin_nocode(l)) {</a>
<a name="ln3591">      continue;</a>
<a name="ln3592">    }</a>
<a name="ln3593"> </a>
<a name="ln3594">    /*</a>
<a name="ln3595">     * If the previous line ends in ',', use one level of</a>
<a name="ln3596">     * indentation:</a>
<a name="ln3597">     * int foo,</a>
<a name="ln3598">     *     bar;</a>
<a name="ln3599">     * do this before checking for '}' in case of eg.</a>
<a name="ln3600">     * enum foobar</a>
<a name="ln3601">     * {</a>
<a name="ln3602">     *   ...</a>
<a name="ln3603">     * } foo,</a>
<a name="ln3604">     *   bar;</a>
<a name="ln3605">     */</a>
<a name="ln3606">    if (cin_ends_in(l, (char_u *)&quot;,&quot;, NULL)</a>
<a name="ln3607">        || (*l != NUL &amp;&amp; (n = l[STRLEN(l) - 1]) == '\\')) {</a>
<a name="ln3608">      // take us back to opening paren</a>
<a name="ln3609">      if (find_last_paren(l, '(', ')')</a>
<a name="ln3610">          &amp;&amp; (trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln3611">        curwin-&gt;w_cursor = *trypos;</a>
<a name="ln3612">      }</a>
<a name="ln3613"> </a>
<a name="ln3614">      /* For a line ending in ',' that is a continuation line go</a>
<a name="ln3615">       * back to the first line with a backslash:</a>
<a name="ln3616">       * char *foo = &quot;bla\</a>
<a name="ln3617">       *                 bla&quot;,</a>
<a name="ln3618">       *      here;</a>
<a name="ln3619">       */</a>
<a name="ln3620">      while (n == 0 &amp;&amp; curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln3621">        l = ml_get(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln3622">        if (*l == NUL || l[STRLEN(l) - 1] != '\\') {</a>
<a name="ln3623">          break;</a>
<a name="ln3624">        }</a>
<a name="ln3625">        curwin-&gt;w_cursor.lnum--;</a>
<a name="ln3626">        curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3627">      }</a>
<a name="ln3628"> </a>
<a name="ln3629">      amount = get_indent();                    // XXX</a>
<a name="ln3630"> </a>
<a name="ln3631">      if (amount == 0) {</a>
<a name="ln3632">        amount = cin_first_id_amount();</a>
<a name="ln3633">      }</a>
<a name="ln3634">      if (amount == 0) {</a>
<a name="ln3635">        amount = ind_continuation;</a>
<a name="ln3636">      }</a>
<a name="ln3637">      break;</a>
<a name="ln3638">    }</a>
<a name="ln3639"> </a>
<a name="ln3640">    /*</a>
<a name="ln3641">     * If the line looks like a function declaration, and we're</a>
<a name="ln3642">     * not in a comment, put it the left margin.</a>
<a name="ln3643">     */</a>
<a name="ln3644">    if (cin_isfuncdecl(NULL, cur_curpos.lnum, 0)) {        // XXX</a>
<a name="ln3645">      break;</a>
<a name="ln3646">    }</a>
<a name="ln3647">    l = get_cursor_line_ptr();</a>
<a name="ln3648"> </a>
<a name="ln3649">    /*</a>
<a name="ln3650">     * Finding the closing '}' of a previous function.  Put</a>
<a name="ln3651">     * current line at the left margin.  For when 'cino' has &quot;fs&quot;.</a>
<a name="ln3652">     */</a>
<a name="ln3653">    if (*skipwhite((char *)l) == '}') {</a>
<a name="ln3654">      break;</a>
<a name="ln3655">    }</a>
<a name="ln3656"> </a>
<a name="ln3657">    //                      (matching {)</a>
<a name="ln3658">    // If the previous line ends on '};' (maybe followed by</a>
<a name="ln3659">    // comments) align at column 0.  For example:</a>
<a name="ln3660">    // char *string_array[] = { &quot;foo&quot;,</a>
<a name="ln3661">    //     / * x * / &quot;b};ar&quot; }; / * foobar * /</a>
<a name="ln3662">    if (cin_ends_in(l, (char_u *)&quot;};&quot;, NULL)) {</a>
<a name="ln3663">      break;</a>
<a name="ln3664">    }</a>
<a name="ln3665"> </a>
<a name="ln3666">    // If the previous line ends on '[' we are probably in an</a>
<a name="ln3667">    // array constant:</a>
<a name="ln3668">    // something = [</a>
<a name="ln3669">    //     234,  &lt;- extra indent</a>
<a name="ln3670">    if (cin_ends_in(l, (char_u *)&quot;[&quot;, NULL)) {</a>
<a name="ln3671">      amount = get_indent() + ind_continuation;</a>
<a name="ln3672">      break;</a>
<a name="ln3673">    }</a>
<a name="ln3674"> </a>
<a name="ln3675">    /*</a>
<a name="ln3676">     * Find a line only has a semicolon that belongs to a previous</a>
<a name="ln3677">     * line ending in '}', e.g. before an #endif.  Don't increase</a>
<a name="ln3678">     * indent then.</a>
<a name="ln3679">     */</a>
<a name="ln3680">    if (*(look = (char_u *)skipwhite((char *)l)) == ';' &amp;&amp; cin_nocode(look + 1)) {</a>
<a name="ln3681">      pos_T curpos_save = curwin-&gt;w_cursor;</a>
<a name="ln3682"> </a>
<a name="ln3683">      while (curwin-&gt;w_cursor.lnum &gt; 1) {</a>
<a name="ln3684">        look = ml_get(--curwin-&gt;w_cursor.lnum);</a>
<a name="ln3685">        if (!(cin_nocode(look)</a>
<a name="ln3686">              || cin_ispreproc_cont(&amp;look, &amp;curwin-&gt;w_cursor.lnum, &amp;amount))) {</a>
<a name="ln3687">          break;</a>
<a name="ln3688">        }</a>
<a name="ln3689">      }</a>
<a name="ln3690">      if (curwin-&gt;w_cursor.lnum &gt; 0</a>
<a name="ln3691">          &amp;&amp; cin_ends_in(look, (char_u *)&quot;}&quot;, NULL)) {</a>
<a name="ln3692">        break;</a>
<a name="ln3693">      }</a>
<a name="ln3694"> </a>
<a name="ln3695">      curwin-&gt;w_cursor = curpos_save;</a>
<a name="ln3696">    }</a>
<a name="ln3697"> </a>
<a name="ln3698">    /*</a>
<a name="ln3699">     * If the PREVIOUS line is a function declaration, the current</a>
<a name="ln3700">     * line (and the ones that follow) needs to be indented as</a>
<a name="ln3701">     * parameters.</a>
<a name="ln3702">     */</a>
<a name="ln3703">    if (cin_isfuncdecl(&amp;l, curwin-&gt;w_cursor.lnum, 0)) {</a>
<a name="ln3704">      amount = curbuf-&gt;b_ind_param;</a>
<a name="ln3705">      break;</a>
<a name="ln3706">    }</a>
<a name="ln3707"> </a>
<a name="ln3708">    /*</a>
<a name="ln3709">     * If the previous line ends in ';' and the line before the</a>
<a name="ln3710">     * previous line ends in ',' or '\', ident to column zero:</a>
<a name="ln3711">     * int foo,</a>
<a name="ln3712">     *     bar;</a>
<a name="ln3713">     * indent_to_0 here;</a>
<a name="ln3714">     */</a>
<a name="ln3715">    if (cin_ends_in(l, (char_u *)&quot;;&quot;, NULL)) {</a>
<a name="ln3716">      l = ml_get(curwin-&gt;w_cursor.lnum - 1);</a>
<a name="ln3717">      if (cin_ends_in(l, (char_u *)&quot;,&quot;, NULL)</a>
<a name="ln3718">          || (*l != NUL &amp;&amp; l[STRLEN(l) - 1] == '\\')) {</a>
<a name="ln3719">        break;</a>
<a name="ln3720">      }</a>
<a name="ln3721">      l = get_cursor_line_ptr();</a>
<a name="ln3722">    }</a>
<a name="ln3723"> </a>
<a name="ln3724">    /*</a>
<a name="ln3725">     * Doesn't look like anything interesting -- so just</a>
<a name="ln3726">     * use the indent of this line.</a>
<a name="ln3727">     *</a>
<a name="ln3728">     * Position the cursor over the rightmost paren, so that</a>
<a name="ln3729">     * matching it will take us back to the start of the line.</a>
<a name="ln3730">     */</a>
<a name="ln3731">    (void)find_last_paren(l, '(', ')');</a>
<a name="ln3732"> </a>
<a name="ln3733">    if ((trypos = find_match_paren(curbuf-&gt;b_ind_maxparen)) != NULL) {</a>
<a name="ln3734">      curwin-&gt;w_cursor = *trypos;</a>
<a name="ln3735">    }</a>
<a name="ln3736">    amount = get_indent();              // XXX</a>
<a name="ln3737">    break;</a>
<a name="ln3738">  }</a>
<a name="ln3739"> </a>
<a name="ln3740">  // add extra indent for a comment</a>
<a name="ln3741">  if (cin_iscomment(theline)) {</a>
<a name="ln3742">    amount += curbuf-&gt;b_ind_comment;</a>
<a name="ln3743">  }</a>
<a name="ln3744"> </a>
<a name="ln3745">  // add extra indent if the previous line ended in a backslash:</a>
<a name="ln3746">  //          &quot;asdfasdf{backslash}</a>
<a name="ln3747">  //              here&quot;;</a>
<a name="ln3748">  //        char *foo = &quot;asdf{backslash}</a>
<a name="ln3749">  //                     here&quot;;</a>
<a name="ln3750">  if (cur_curpos.lnum &gt; 1) {</a>
<a name="ln3751">    l = ml_get(cur_curpos.lnum - 1);</a>
<a name="ln3752">    if (*l != NUL &amp;&amp; l[STRLEN(l) - 1] == '\\') {</a>
<a name="ln3753">      cur_amount = cin_get_equal_amount(cur_curpos.lnum - 1);</a>
<a name="ln3754">      if (cur_amount &gt; 0) {</a>
<a name="ln3755">        amount = cur_amount;</a>
<a name="ln3756">      } else if (cur_amount == 0) {</a>
<a name="ln3757">        amount += ind_continuation;</a>
<a name="ln3758">      }</a>
<a name="ln3759">    }</a>
<a name="ln3760">  }</a>
<a name="ln3761"> </a>
<a name="ln3762">theend:</a>
<a name="ln3763">  if (amount &lt; 0) {</a>
<a name="ln3764">    amount = 0;</a>
<a name="ln3765">  }</a>
<a name="ln3766"> </a>
<a name="ln3767">laterend:</a>
<a name="ln3768">  // put the cursor back where it belongs</a>
<a name="ln3769">  curwin-&gt;w_cursor = cur_curpos;</a>
<a name="ln3770"> </a>
<a name="ln3771">  xfree(linecopy);</a>
<a name="ln3772"> </a>
<a name="ln3773">  return amount;</a>
<a name="ln3774">}</a>
<a name="ln3775"> </a>
<a name="ln3776">static int find_match(int lookfor, linenr_T ourscope)</a>
<a name="ln3777">{</a>
<a name="ln3778">  const char_u *look;</a>
<a name="ln3779">  pos_T *theirscope;</a>
<a name="ln3780">  const char_u *mightbeif;</a>
<a name="ln3781">  int elselevel;</a>
<a name="ln3782">  int whilelevel;</a>
<a name="ln3783"> </a>
<a name="ln3784">  if (lookfor == LOOKFOR_IF) {</a>
<a name="ln3785">    elselevel = 1;</a>
<a name="ln3786">    whilelevel = 0;</a>
<a name="ln3787">  } else {</a>
<a name="ln3788">    elselevel = 0;</a>
<a name="ln3789">    whilelevel = 1;</a>
<a name="ln3790">  }</a>
<a name="ln3791"> </a>
<a name="ln3792">  curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3793"> </a>
<a name="ln3794">  while (curwin-&gt;w_cursor.lnum &gt; ourscope + 1) {</a>
<a name="ln3795">    curwin-&gt;w_cursor.lnum--;</a>
<a name="ln3796">    curwin-&gt;w_cursor.col = 0;</a>
<a name="ln3797"> </a>
<a name="ln3798">    look = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln3799">    if (!cin_iselse(look)</a>
<a name="ln3800">        &amp;&amp; !cin_isif(look)</a>
<a name="ln3801">        &amp;&amp; !cin_isdo(look)                                   // XXX</a>
<a name="ln3802">        &amp;&amp; !cin_iswhileofdo(look, curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln3803">      continue;</a>
<a name="ln3804">    }</a>
<a name="ln3805"> </a>
<a name="ln3806">    /*</a>
<a name="ln3807">     * if we've gone outside the braces entirely,</a>
<a name="ln3808">     * we must be out of scope...</a>
<a name="ln3809">     */</a>
<a name="ln3810">    theirscope = find_start_brace();        // XXX</a>
<a name="ln3811">    if (theirscope == NULL) {</a>
<a name="ln3812">      break;</a>
<a name="ln3813">    }</a>
<a name="ln3814"> </a>
<a name="ln3815">    /*</a>
<a name="ln3816">     * and if the brace enclosing this is further</a>
<a name="ln3817">     * back than the one enclosing the else, we're</a>
<a name="ln3818">     * out of luck too.</a>
<a name="ln3819">     */</a>
<a name="ln3820">    if (theirscope-&gt;lnum &lt; ourscope) {</a>
<a name="ln3821">      break;</a>
<a name="ln3822">    }</a>
<a name="ln3823"> </a>
<a name="ln3824">    /*</a>
<a name="ln3825">     * and if they're enclosed in a *deeper* brace,</a>
<a name="ln3826">     * then we can ignore it because it's in a</a>
<a name="ln3827">     * different scope...</a>
<a name="ln3828">     */</a>
<a name="ln3829">    if (theirscope-&gt;lnum &gt; ourscope) {</a>
<a name="ln3830">      continue;</a>
<a name="ln3831">    }</a>
<a name="ln3832"> </a>
<a name="ln3833">    /*</a>
<a name="ln3834">     * if it was an &quot;else&quot; (that's not an &quot;else if&quot;)</a>
<a name="ln3835">     * then we need to go back to another if, so</a>
<a name="ln3836">     * increment elselevel</a>
<a name="ln3837">     */</a>
<a name="ln3838">    look = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln3839">    if (cin_iselse(look)) {</a>
<a name="ln3840">      mightbeif = cin_skipcomment(look + 4);</a>
<a name="ln3841">      if (!cin_isif(mightbeif)) {</a>
<a name="ln3842">        elselevel++;  // NOLINT(readability/braces)</a>
<a name="ln3843">      }</a>
<a name="ln3844">      continue;</a>
<a name="ln3845">    }</a>
<a name="ln3846"> </a>
<a name="ln3847">    /*</a>
<a name="ln3848">     * if it was a &quot;while&quot; then we need to go back to</a>
<a name="ln3849">     * another &quot;do&quot;, so increment whilelevel.  XXX</a>
<a name="ln3850">     */</a>
<a name="ln3851">    if (cin_iswhileofdo(look, curwin-&gt;w_cursor.lnum)) {</a>
<a name="ln3852">      ++whilelevel;</a>
<a name="ln3853">      continue;</a>
<a name="ln3854">    }</a>
<a name="ln3855"> </a>
<a name="ln3856">    // If it's an &quot;if&quot; decrement elselevel</a>
<a name="ln3857">    look = cin_skipcomment(get_cursor_line_ptr());</a>
<a name="ln3858">    if (cin_isif(look)) {</a>
<a name="ln3859">      elselevel--;</a>
<a name="ln3860">      /*</a>
<a name="ln3861">       * When looking for an &quot;if&quot; ignore &quot;while&quot;s that</a>
<a name="ln3862">       * get in the way.</a>
<a name="ln3863">       */</a>
<a name="ln3864">      if (elselevel == 0 &amp;&amp; lookfor == LOOKFOR_IF) {</a>
<a name="ln3865">        whilelevel = 0;</a>
<a name="ln3866">      }</a>
<a name="ln3867">    }</a>
<a name="ln3868"> </a>
<a name="ln3869">    // If it's a &quot;do&quot; decrement whilelevel</a>
<a name="ln3870">    if (cin_isdo(look)) {</a>
<a name="ln3871">      whilelevel--;</a>
<a name="ln3872">    }</a>
<a name="ln3873"> </a>
<a name="ln3874">    /*</a>
<a name="ln3875">     * if we've used up all the elses, then</a>
<a name="ln3876">     * this must be the if that we want!</a>
<a name="ln3877">     * match the indent level of that if.</a>
<a name="ln3878">     */</a>
<a name="ln3879">    if (elselevel &lt;= 0 &amp;&amp; whilelevel &lt;= 0) {</a>
<a name="ln3880">      return OK;</a>
<a name="ln3881">    }</a>
<a name="ln3882">  }</a>
<a name="ln3883">  return FAIL;</a>
<a name="ln3884">}</a>
<a name="ln3885"> </a>
<a name="ln3886">/*</a>
<a name="ln3887"> * Do C or expression indenting on the current line.</a>
<a name="ln3888"> */</a>
<a name="ln3889">void do_c_expr_indent(void)</a>
<a name="ln3890">{</a>
<a name="ln3891">  if (*curbuf-&gt;b_p_inde != NUL) {</a>
<a name="ln3892">    fixthisline(get_expr_indent);</a>
<a name="ln3893">  } else {</a>
<a name="ln3894">    fixthisline(get_c_indent);</a>
<a name="ln3895">  }</a>
<a name="ln3896">}</a>

</code></pre>
<div class="balloon" rel="3573"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: theline[0] != '{'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
